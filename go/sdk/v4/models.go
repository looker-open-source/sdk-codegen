/*

MIT License

Copyright (c) 2023 Looker Data Sciences, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

/*

407 API models: 258 Spec, 67 Request, 60 Write, 22 Enum
*/

// NOTE: Do not edit this file generated by Looker SDK Codegen for API v4

package v4

import (
	"github.com/looker-open-source/sdk-codegen/go/rtl"
	"time"
)

type AccessToken struct {
	AccessToken  *string `json:"access_token,omitempty"`  // Access Token used for API calls
	TokenType    *string `json:"token_type,omitempty"`    // Type of Token
	ExpiresIn    *int64  `json:"expires_in,omitempty"`    // Number of seconds before the token expires
	RefreshToken *string `json:"refresh_token,omitempty"` // Refresh token which can be used to obtain a new access token
}

type Alert struct {
	AppliedDashboardFilters   *[]AlertAppliedDashboardFilter `json:"applied_dashboard_filters,omitempty"` // Filters coming from the dashboard that are applied. Example `[{ "filter_title": "Name", "field_name": "distribution_centers.name", "filter_value": "Los Angeles CA" }]`
	ComparisonType            ComparisonType                 `json:"comparison_type"`                     // This property informs the check what kind of comparison we are performing. Only certain condition types are valid for time series alerts. For details, refer to [Setting Alert Conditions](https://cloud.google.com/looker/docs/sharing-and-publishing/creating-alerts#setting_alert_conditions) Valid values are: "EQUAL_TO", "GREATER_THAN", "GREATER_THAN_OR_EQUAL_TO", "LESS_THAN", "LESS_THAN_OR_EQUAL_TO", "INCREASES_BY", "DECREASES_BY", "CHANGES_BY".
	Cron                      string                         `json:"cron"`                                // Vixie-Style crontab specification when to run. At minimum, it has to be longer than 15 minute intervals
	CustomUrlBase             *string                        `json:"custom_url_base,omitempty"`           // Domain for the custom url selected by the alert creator from the admin defined domain allowlist
	CustomUrlParams           *string                        `json:"custom_url_params,omitempty"`         // Parameters and path for the custom url defined by the alert creator
	CustomUrlLabel            *string                        `json:"custom_url_label,omitempty"`          // Label for the custom url defined by the alert creator
	ShowCustomUrl             *bool                          `json:"show_custom_url,omitempty"`           // Boolean to determine if the custom url should be used
	CustomTitle               *string                        `json:"custom_title,omitempty"`              // An optional, user-defined title for the alert
	DashboardElementId        *string                        `json:"dashboard_element_id,omitempty"`      // ID of the dashboard element associated with the alert. Refer to [dashboard_element()](#!/Dashboard/DashboardElement)
	Description               *string                        `json:"description,omitempty"`               // An optional description for the alert. This supplements the title
	Destinations              []AlertDestination             `json:"destinations"`                        // Array of destinations to send alerts to. Must be the same type of destination. Example `[{ "destination_type": "EMAIL", "email_address": "test@test.com" }]`
	Field                     AlertField                     `json:"field"`
	Followed                  *bool                          `json:"followed,omitempty"`                    // Whether or not the user follows this alert.
	Followable                *bool                          `json:"followable,omitempty"`                  // Whether or not the alert is followable
	Id                        *string                        `json:"id,omitempty"`                          // ID of the alert
	IsDisabled                *bool                          `json:"is_disabled,omitempty"`                 // Whether or not the alert is disabled
	DisabledReason            *string                        `json:"disabled_reason,omitempty"`             // Reason for disabling alert
	IsPublic                  *bool                          `json:"is_public,omitempty"`                   // Whether or not the alert is public
	InvestigativeContentType  *InvestigativeContentType      `json:"investigative_content_type,omitempty"`  // The type of the investigative content Valid values are: "dashboard".
	InvestigativeContentId    *string                        `json:"investigative_content_id,omitempty"`    // The ID of the investigative content. For dashboards, this will be the dashboard ID
	InvestigativeContentTitle *string                        `json:"investigative_content_title,omitempty"` // The title of the investigative content.
	LookmlDashboardId         *string                        `json:"lookml_dashboard_id,omitempty"`         // ID of the LookML dashboard associated with the alert
	LookmlLinkId              *string                        `json:"lookml_link_id,omitempty"`              // ID of the LookML dashboard element associated with the alert
	OwnerId                   string                         `json:"owner_id"`                              // User id of alert owner
	OwnerDisplayName          *string                        `json:"owner_display_name,omitempty"`          // Alert owner's display name
	Threshold                 float64                        `json:"threshold"`                             // Value of the alert threshold
	TimeSeriesConditionState  *AlertConditionState           `json:"time_series_condition_state,omitempty"`
}

type AlertAppliedDashboardFilter struct {
	FilterTitle       string  `json:"filter_title"`                 // Field Title. Refer to `DashboardFilter.title` in [DashboardFilter](#!/types/DashboardFilter). Example `Name`
	FieldName         string  `json:"field_name"`                   // Field Name. Refer to `DashboardFilter.dimension` in [DashboardFilter](#!/types/DashboardFilter). Example `distribution_centers.name`
	FilterValue       string  `json:"filter_value"`                 // Field Value. [Filter Expressions](https://cloud.google.com/looker/docs/reference/filter-expressions). Example `Los Angeles CA`
	FilterDescription *string `json:"filter_description,omitempty"` // Human Readable Filter Description. This may be null or auto-generated. Example `is Los Angeles CA`
}

type AlertConditionState struct {
	PreviousTimeSeriesId *string `json:"previous_time_series_id,omitempty"` // (Write-Only) The second latest time string the alert has seen.
	LatestTimeSeriesId   *string `json:"latest_time_series_id,omitempty"`   // (Write-Only) Latest time string the alert has seen.
}

type AlertDestination struct {
	DestinationType         DestinationType `json:"destination_type"`                      // Type of destination that the alert will be sent to Valid values are: "EMAIL", "ACTION_HUB".
	EmailAddress            *string         `json:"email_address,omitempty"`               // Email address for the 'email' type
	ActionHubIntegrationId  *string         `json:"action_hub_integration_id,omitempty"`   // Action hub integration id for the 'action_hub' type. [Integration](#!/types/Integration)
	ActionHubFormParamsJson *string         `json:"action_hub_form_params_json,omitempty"` // Action hub form params json for the 'action_hub' type [IntegrationParam](#!/types/IntegrationParam)
}

type AlertField struct {
	Title  string              `json:"title"`            // Field's title. Usually auto-generated to reflect field name and its filters
	Name   string              `json:"name"`             // Field's name. Has the format `<view>.<field>` Refer to [docs](https://cloud.google.com/looker/docs/sharing-and-publishing/creating-alerts) for more details
	Filter *[]AlertFieldFilter `json:"filter,omitempty"` // (Optional / Advance Use) List of fields filter. This further restricts the alert to certain dashboard element's field values. This can be used on top of dashboard filters `applied_dashboard_filters`. To keep thing simple, it's suggested to just use dashboard filters. Example: `{ 'title': '12 Number on Hand', 'name': 'inventory_items.number_on_hand', 'filter': [{ 'field_name': 'inventory_items.id', 'field_value': 12, 'filter_value': null }] }`
}

type AlertFieldFilter struct {
	FieldName   string      `json:"field_name"`             // Field Name. Has format `<view>.<field>`
	FieldValue  interface{} `json:"field_value"`            // Field Value. Depends on the type of field - numeric or string. For [location](https://cloud.google.com/looker/docs/reference/field-reference/dimension-type-reference#location) type, it's a list of floats. Example `[1.0, 56.0]`
	FilterValue *string     `json:"filter_value,omitempty"` // Filter Value. Usually null except for [location](https://cloud.google.com/looker/docs/reference/field-reference/dimension-type-reference#location) type. It'll be a string of lat,long ie `'1.0,56.0'`
}

type AlertNotifications struct {
	NotificationId   *string        `json:"notification_id,omitempty"`    // ID of the notification
	AlertConditionId *string        `json:"alert_condition_id,omitempty"` // ID of the alert
	UserId           *string        `json:"user_id,omitempty"`            // ID of the user
	IsRead           *bool          `json:"is_read,omitempty"`            // Read state of the notification
	FieldValue       *float64       `json:"field_value,omitempty"`        // The value of the field on which the alert condition is set
	ThresholdValue   *float64       `json:"threshold_value,omitempty"`    // The value of the threshold which triggers the alert notification
	RanAt            *string        `json:"ran_at,omitempty"`             // The time at which the alert query ran
	Alert            *MobilePayload `json:"alert,omitempty"`
}

type AlertPatch struct {
	OwnerId        *string  `json:"owner_id,omitempty"`        // New owner ID of the alert
	IsDisabled     *bool    `json:"is_disabled,omitempty"`     // Set alert enabled or disabled
	DisabledReason *string  `json:"disabled_reason,omitempty"` // The reason this alert is disabled
	IsPublic       *bool    `json:"is_public,omitempty"`       // Set alert public or private
	Threshold      *float64 `json:"threshold,omitempty"`       // New threshold value
}

type Align string

const Align_Left Align = "left"
const Align_Right Align = "right"

type ApiSession struct {
	Can         *map[string]bool `json:"can,omitempty"`          // Operations the current user is able to perform on this object
	WorkspaceId *string          `json:"workspace_id,omitempty"` // The id of active workspace for this session
	SudoUserId  *string          `json:"sudo_user_id,omitempty"` // The id of the actual user in the case when this session represents one user sudo'ing as another
}

type ApiVersion struct {
	LookerReleaseVersion *string              `json:"looker_release_version,omitempty"` // Current Looker release version number
	CurrentVersion       *ApiVersionElement   `json:"current_version,omitempty"`
	SupportedVersions    *[]ApiVersionElement `json:"supported_versions,omitempty"` // Array of versions supported by this Looker instance
	ApiServerUrl         *string              `json:"api_server_url,omitempty"`     // API server base url
	WebServerUrl         *string              `json:"web_server_url,omitempty"`     // Web server base url
}

type ApiVersionElement struct {
	Version     *string `json:"version,omitempty"`      // Version number as it appears in '/api/xxx/' urls
	FullVersion *string `json:"full_version,omitempty"` // Full version number including minor version
	Status      *string `json:"status,omitempty"`       // Status of this version
	SwaggerUrl  *string `json:"swagger_url,omitempty"`  // Url for swagger.json for this version
}

type Artifact struct {
	Key             string    `json:"key"`                    // Key of value to store. Namespace + Key must be unique.
	Value           string    `json:"value"`                  // Value to store.
	ContentType     *string   `json:"content_type,omitempty"` // MIME type of content. This can only be used to override content that is detected as text/plain. Needed to set application/json content types, which are analyzed as plain text.
	Version         *int64    `json:"version,omitempty"`      // Version number of the stored value. The version must be provided for any updates to an existing artifact.
	Namespace       string    `json:"namespace"`              // Artifact storage namespace.
	CreatedAt       time.Time `json:"created_at"`             // Timestamp when this artifact was created.
	UpdatedAt       time.Time `json:"updated_at"`             // Timestamp when this artifact was updated.
	ValueSize       int64     `json:"value_size"`             // Size (in bytes) of the stored value.
	CreatedByUserid string    `json:"created_by_userid"`      // User id of the artifact creator.
	UpdatedByUserid string    `json:"updated_by_userid"`      // User id of the artifact updater.
}

type ArtifactNamespace struct {
	Namespace string `json:"namespace"` // Artifact storage namespace.
	Count     int64  `json:"count"`     // The number of artifacts stored in the namespace.
}

type ArtifactUsage struct {
	MaxSize int64 `json:"max_size"` // The configured maximum size in bytes of the entire artifact store.
	Usage   int64 `json:"usage"`    // The currently used storage size in bytes of the entire artifact store.
}

type BackupConfiguration struct {
	Can                  *map[string]bool `json:"can,omitempty"`                     // Operations the current user is able to perform on this object
	Type                 *string          `json:"type,omitempty"`                    // Type of backup: looker-s3 or custom-s3
	CustomS3Bucket       *string          `json:"custom_s3_bucket,omitempty"`        // Name of bucket for custom-s3 backups
	CustomS3BucketRegion *string          `json:"custom_s3_bucket_region,omitempty"` // Name of region where the bucket is located
	CustomS3Key          *string          `json:"custom_s3_key,omitempty"`           // (Write-Only) AWS S3 key used for custom-s3 backups
	CustomS3Secret       *string          `json:"custom_s3_secret,omitempty"`        // (Write-Only) AWS S3 secret used for custom-s3 backups
	Url                  *string          `json:"url,omitempty"`                     // Link to get this item
}

type Board struct {
	Can               *map[string]bool `json:"can,omitempty"`                 // Operations the current user is able to perform on this object
	ContentMetadataId *string          `json:"content_metadata_id,omitempty"` // Id of associated content_metadata record
	CreatedAt         *time.Time       `json:"created_at,omitempty"`          // Date of board creation
	DeletedAt         *time.Time       `json:"deleted_at,omitempty"`          // Date of board deletion
	Description       *string          `json:"description,omitempty"`         // Description of the board
	BoardSections     *[]BoardSection  `json:"board_sections,omitempty"`      // Sections of the board
	Id                *string          `json:"id,omitempty"`                  // Unique Id
	SectionOrder      *[]string        `json:"section_order,omitempty"`       // ids of the board sections in the order they should be displayed
	Title             *string          `json:"title,omitempty"`               // Title of the board
	UpdatedAt         *time.Time       `json:"updated_at,omitempty"`          // Date of last board update
	UserId            *string          `json:"user_id,omitempty"`             // User id of board creator
	PrimaryHomepage   *bool            `json:"primary_homepage,omitempty"`    // Whether the board is the primary homepage or not
}

type BoardItem struct {
	Can                   *map[string]bool `json:"can,omitempty"`                      // Operations the current user is able to perform on this object
	ContentCreatedBy      *string          `json:"content_created_by,omitempty"`       // Name of user who created the content this item is based on
	ContentFavoriteId     *string          `json:"content_favorite_id,omitempty"`      // Content favorite id associated with the item this content is based on
	ContentMetadataId     *string          `json:"content_metadata_id,omitempty"`      // Content metadata id associated with the item this content is based on
	ContentUpdatedAt      *string          `json:"content_updated_at,omitempty"`       // Last time the content that this item is based on was updated
	CustomDescription     *string          `json:"custom_description,omitempty"`       // Custom description entered by the user, if present
	CustomTitle           *string          `json:"custom_title,omitempty"`             // Custom title entered by the user, if present
	CustomUrl             *string          `json:"custom_url,omitempty"`               // Custom url entered by the user, if present
	DashboardId           *string          `json:"dashboard_id,omitempty"`             // Dashboard to base this item on
	Description           *string          `json:"description,omitempty"`              // The actual description for display
	FavoriteCount         *int64           `json:"favorite_count,omitempty"`           // Number of times content has been favorited, if present
	BoardSectionId        *string          `json:"board_section_id,omitempty"`         // Associated Board Section
	Id                    *string          `json:"id,omitempty"`                       // Unique Id
	ImageUrl              *string          `json:"image_url,omitempty"`                // The actual image_url for display
	Location              *string          `json:"location,omitempty"`                 // The container folder name of the content
	LookId                *string          `json:"look_id,omitempty"`                  // Look to base this item on
	LookmlDashboardId     *string          `json:"lookml_dashboard_id,omitempty"`      // LookML Dashboard to base this item on
	Order                 *int64           `json:"order,omitempty"`                    // An arbitrary integer representing the sort order within the section
	Title                 *string          `json:"title,omitempty"`                    // The actual title for display
	Url                   *string          `json:"url,omitempty"`                      // Relative url for the associated content
	UseCustomDescription  *bool            `json:"use_custom_description,omitempty"`   // Whether the custom description should be used instead of the content description, if the item is associated with content
	UseCustomTitle        *bool            `json:"use_custom_title,omitempty"`         // Whether the custom title should be used instead of the content title, if the item is associated with content
	UseCustomUrl          *bool            `json:"use_custom_url,omitempty"`           // Whether the custom url should be used instead of the content url, if the item is associated with content
	ViewCount             *int64           `json:"view_count,omitempty"`               // Number of times content has been viewed, if present
	CustomImageDataBase64 *string          `json:"custom_image_data_base64,omitempty"` // (Write-Only) base64 encoded image data
	CustomImageUrl        *string          `json:"custom_image_url,omitempty"`         // Custom image_url entered by the user, if present
	UseCustomImage        *bool            `json:"use_custom_image,omitempty"`         // Whether the custom image should be used instead of the content image, if the item is associated with content
}

type BoardSection struct {
	Can              *map[string]bool `json:"can,omitempty"`                // Operations the current user is able to perform on this object
	CreatedAt        *time.Time       `json:"created_at,omitempty"`         // Time at which this section was created.
	DeletedAt        *time.Time       `json:"deleted_at,omitempty"`         // Time at which this section was deleted.
	Description      *string          `json:"description,omitempty"`        // Description of the content found in this section.
	BoardId          *string          `json:"board_id,omitempty"`           // Id reference to parent board
	BoardItems       *[]BoardItem     `json:"board_items,omitempty"`        // Items in the board section
	Id               *string          `json:"id,omitempty"`                 // Unique Id
	ItemOrder        *[]string        `json:"item_order,omitempty"`         // ids of the board items in the order they should be displayed
	VisibleItemOrder *[]string        `json:"visible_item_order,omitempty"` // ids of the homepage items the user can see in the order they should be displayed
	Title            *string          `json:"title,omitempty"`              // Name of row
	UpdatedAt        *time.Time       `json:"updated_at,omitempty"`         // Time at which this section was last updated.
}

type Category string

const Category_Parameter Category = "parameter"
const Category_Filter Category = "filter"
const Category_Measure Category = "measure"
const Category_Dimension Category = "dimension"

type ColorCollection struct {
	Id                  *string              `json:"id,omitempty"`                  // Unique Id
	Label               *string              `json:"label,omitempty"`               // Label of color collection
	CategoricalPalettes *[]DiscretePalette   `json:"categoricalPalettes,omitempty"` // Array of categorical palette definitions
	SequentialPalettes  *[]ContinuousPalette `json:"sequentialPalettes,omitempty"`  // Array of discrete palette definitions
	DivergingPalettes   *[]ContinuousPalette `json:"divergingPalettes,omitempty"`   // Array of diverging palette definitions
}

type ColorStop struct {
	Color  *string `json:"color,omitempty"`  // CSS color string
	Offset *int64  `json:"offset,omitempty"` // Offset in continuous palette (0 to 100)
}

type ColumnSearch struct {
	SchemaName *string `json:"schema_name,omitempty"` // Name of schema containing the table
	TableName  *string `json:"table_name,omitempty"`  // Name of table containing the column
	ColumnName *string `json:"column_name,omitempty"` // Name of column
	DataType   *string `json:"data_type,omitempty"`   // Column data type
}

type ComparisonType string

const ComparisonType_EQUAL_TO ComparisonType = "EQUAL_TO"
const ComparisonType_GREATER_THAN ComparisonType = "GREATER_THAN"
const ComparisonType_GREATER_THAN_OR_EQUAL_TO ComparisonType = "GREATER_THAN_OR_EQUAL_TO"
const ComparisonType_LESS_THAN ComparisonType = "LESS_THAN"
const ComparisonType_LESS_THAN_OR_EQUAL_TO ComparisonType = "LESS_THAN_OR_EQUAL_TO"
const ComparisonType_INCREASES_BY ComparisonType = "INCREASES_BY"
const ComparisonType_DECREASES_BY ComparisonType = "DECREASES_BY"
const ComparisonType_CHANGES_BY ComparisonType = "CHANGES_BY"

type ConnectionFeatures struct {
	DialectName             *string `json:"dialect_name,omitempty"`              // Name of the dialect for this connection
	CostEstimate            *bool   `json:"cost_estimate,omitempty"`             // True for cost estimating support
	MultipleDatabases       *bool   `json:"multiple_databases,omitempty"`        // True for multiple database support
	ColumnSearch            *bool   `json:"column_search,omitempty"`             // True for cost estimating support
	PersistentTableIndexes  *bool   `json:"persistent_table_indexes,omitempty"`  // True for secondary index support
	PersistentDerivedTables *bool   `json:"persistent_derived_tables,omitempty"` // True for persistent derived table support
	Turtles                 *bool   `json:"turtles,omitempty"`                   // True for turtles support
	Percentile              *bool   `json:"percentile,omitempty"`                // True for percentile support
	DistinctPercentile      *bool   `json:"distinct_percentile,omitempty"`       // True for distinct percentile support
	StableViews             *bool   `json:"stable_views,omitempty"`              // True for stable views support
	Milliseconds            *bool   `json:"milliseconds,omitempty"`              // True for millisecond support
	Microseconds            *bool   `json:"microseconds,omitempty"`              // True for microsecond support
	Subtotals               *bool   `json:"subtotals,omitempty"`                 // True for subtotal support
	Location                *bool   `json:"location,omitempty"`                  // True for geographic location support
	Timezone                *bool   `json:"timezone,omitempty"`                  // True for timezone conversion in query support
	ConnectionPooling       *bool   `json:"connection_pooling,omitempty"`        // True for connection pooling support
}

type ContentFavorite struct {
	Id                *string        `json:"id,omitempty"`                  // Unique Id
	UserId            *string        `json:"user_id,omitempty"`             // User Id which owns this ContentFavorite
	ContentMetadataId *string        `json:"content_metadata_id,omitempty"` // Content Metadata Id associated with this ContentFavorite
	LookId            *string        `json:"look_id,omitempty"`             // Id of a look
	DashboardId       *string        `json:"dashboard_id,omitempty"`        // Id of a dashboard
	Look              *LookBasic     `json:"look,omitempty"`
	Dashboard         *DashboardBase `json:"dashboard,omitempty"`
	BoardId           *string        `json:"board_id,omitempty"` // Id of a board
}

type ContentMeta struct {
	Can          *map[string]bool `json:"can,omitempty"`           // Operations the current user is able to perform on this object
	Id           *string          `json:"id,omitempty"`            // Unique Id
	Name         *string          `json:"name,omitempty"`          // Name or title of underlying content
	ParentId     *string          `json:"parent_id,omitempty"`     // Id of Parent Content
	DashboardId  *string          `json:"dashboard_id,omitempty"`  // Id of associated dashboard when content_type is "dashboard"
	LookId       *string          `json:"look_id,omitempty"`       // Id of associated look when content_type is "look"
	FolderId     *string          `json:"folder_id,omitempty"`     // Id of associated folder when content_type is "space"
	ContentType  *string          `json:"content_type,omitempty"`  // Content Type ("dashboard", "look", or "folder")
	Inherits     *bool            `json:"inherits,omitempty"`      // Whether content inherits its access levels from parent
	InheritingId *string          `json:"inheriting_id,omitempty"` // Id of Inherited Content
	Slug         *string          `json:"slug,omitempty"`          // Content Slug
}

// WARNING: no writeable properties found for POST, PUT, or PATCH
type ContentMetaGroupUser struct {
	Can               *map[string]bool `json:"can,omitempty"`                 // Operations the current user is able to perform on this object
	Id                *string          `json:"id,omitempty"`                  // Unique Id
	ContentMetadataId *string          `json:"content_metadata_id,omitempty"` // Id of associated Content Metadata
	PermissionType    *PermissionType  `json:"permission_type,omitempty"`     // Type of permission: "view" or "edit" Valid values are: "view", "edit".
	GroupId           *string          `json:"group_id,omitempty"`            // ID of associated group
	UserId            *string          `json:"user_id,omitempty"`             // ID of associated user
}

type ContentSearch struct {
	Can             *map[string]bool `json:"can,omitempty"`              // Operations the current user is able to perform on this object
	ContentId       *string          `json:"content_id,omitempty"`       // Primary id associated with the content
	Type            *string          `json:"type,omitempty"`             // Type of content
	Title           *string          `json:"title,omitempty"`            // Content title
	Description     *string          `json:"description,omitempty"`      // Content description
	FolderId        *string          `json:"folder_id,omitempty"`        // Id of the folder where the content is saved
	FolderName      *string          `json:"folder_name,omitempty"`      // Name of the folder where the content is saved
	ViewCount       *int64           `json:"view_count,omitempty"`       // Number of times the content has been viewed
	PreferredViewer *string          `json:"preferred_viewer,omitempty"` // Preferred way of viewing the content (only applies to dashboards)
}

type ContentValidation struct {
	ContentWithErrors               *[]ContentValidatorError `json:"content_with_errors,omitempty"`                // A list of content errors
	ComputationTime                 *float32                 `json:"computation_time,omitempty"`                   // Duration of content validation in seconds
	TotalLooksValidated             *int64                   `json:"total_looks_validated,omitempty"`              // The number of looks validated
	TotalDashboardElementsValidated *int64                   `json:"total_dashboard_elements_validated,omitempty"` // The number of dashboard elements validated
	TotalDashboardFiltersValidated  *int64                   `json:"total_dashboard_filters_validated,omitempty"`  // The number of dashboard filters validated
	TotalScheduledPlansValidated    *int64                   `json:"total_scheduled_plans_validated,omitempty"`    // The number of scheduled plans validated
	TotalAlertsValidated            *int64                   `json:"total_alerts_validated,omitempty"`             // The number of alerts validated
	TotalExploresValidated          *int64                   `json:"total_explores_validated,omitempty"`           // The number of explores used across all content validated
}

type ContentValidationAlert struct {
	Id                *string `json:"id,omitempty"`                  // ID of the alert
	LookmlDashboardId *string `json:"lookml_dashboard_id,omitempty"` // ID of the LookML dashboard associated with the alert
	LookmlLinkId      *string `json:"lookml_link_id,omitempty"`      // ID of the LookML dashboard element associated with the alert
	CustomUrlBase     *string `json:"custom_url_base,omitempty"`     // Domain for the custom url selected by the alert creator from the admin defined domain allowlist
	CustomUrlParams   *string `json:"custom_url_params,omitempty"`   // Parameters and path for the custom url defined by the alert creator
	CustomUrlLabel    *string `json:"custom_url_label,omitempty"`    // Label for the custom url defined by the alert creator
	ShowCustomUrl     *bool   `json:"show_custom_url,omitempty"`     // Boolean to determine if the custom url should be used
	CustomTitle       *string `json:"custom_title,omitempty"`        // An optional, user-defined title for the alert
}

type ContentValidationDashboard struct {
	Description *string                  `json:"description,omitempty"` // Description
	Id          *string                  `json:"id,omitempty"`          // Unique Id
	Folder      *ContentValidationFolder `json:"folder,omitempty"`
	Title       *string                  `json:"title,omitempty"` // Dashboard Title
	Url         *string                  `json:"url,omitempty"`   // Relative URL of the dashboard
}

type ContentValidationDashboardElement struct {
	BodyText        *string `json:"body_text,omitempty"`         // Text tile body text
	DashboardId     *string `json:"dashboard_id,omitempty"`      // Id of Dashboard
	Id              *string `json:"id,omitempty"`                // Unique Id
	LookId          *string `json:"look_id,omitempty"`           // Id Of Look
	NoteDisplay     *string `json:"note_display,omitempty"`      // Note Display
	NoteState       *string `json:"note_state,omitempty"`        // Note State
	NoteText        *string `json:"note_text,omitempty"`         // Note Text
	NoteTextAsHtml  *string `json:"note_text_as_html,omitempty"` // Note Text as Html
	QueryId         *string `json:"query_id,omitempty"`          // Id Of Query
	SubtitleText    *string `json:"subtitle_text,omitempty"`     // Text tile subtitle text
	Title           *string `json:"title,omitempty"`             // Title of dashboard element
	TitleHidden     *bool   `json:"title_hidden,omitempty"`      // Whether title is hidden
	TitleText       *string `json:"title_text,omitempty"`        // Text tile title
	Type            *string `json:"type,omitempty"`              // Type
	RichContentJson *string `json:"rich_content_json,omitempty"` // JSON with all the properties required for rich editor and buttons elements
	ExtensionId     *string `json:"extension_id,omitempty"`      // Extension ID
}

type ContentValidationDashboardFilter struct {
	Id           *string `json:"id,omitempty"`            // Unique Id
	DashboardId  *string `json:"dashboard_id,omitempty"`  // Id of Dashboard
	Name         *string `json:"name,omitempty"`          // Name of filter
	Title        *string `json:"title,omitempty"`         // Title of filter
	Type         *string `json:"type,omitempty"`          // Type of filter: one of date, number, string, or field
	DefaultValue *string `json:"default_value,omitempty"` // Default value of filter
	Model        *string `json:"model,omitempty"`         // Model of filter (required if type = field)
	Explore      *string `json:"explore,omitempty"`       // Explore of filter (required if type = field)
	Dimension    *string `json:"dimension,omitempty"`     // Dimension of filter (required if type = field)
}

type ContentValidationError struct {
	Message     *string `json:"message,omitempty"`      // Error message
	FieldName   *string `json:"field_name,omitempty"`   // Name of the field involved in the error
	ModelName   *string `json:"model_name,omitempty"`   // Name of the model involved in the error
	ExploreName *string `json:"explore_name,omitempty"` // Name of the explore involved in the error
	Removable   *bool   `json:"removable,omitempty"`    // Whether this validation error is removable
}

type ContentValidationFolder struct {
	Name string  `json:"name"`         // Unique Name
	Id   *string `json:"id,omitempty"` // Unique Id
}

type ContentValidationLook struct {
	Id       *string                  `json:"id,omitempty"`        // Unique Id
	Title    *string                  `json:"title,omitempty"`     // Look Title
	ShortUrl *string                  `json:"short_url,omitempty"` // Short Url
	Folder   *ContentValidationFolder `json:"folder,omitempty"`
}

type ContentValidationLookMLDashboard struct {
	Id      *string `json:"id,omitempty"`       // ID of the LookML Dashboard
	Title   *string `json:"title,omitempty"`    // Title of the LookML Dashboard
	SpaceId *string `json:"space_id,omitempty"` // ID of Space
}

type ContentValidationLookMLDashboardElement struct {
	LookmlLinkId *string `json:"lookml_link_id,omitempty"` // Link ID of the LookML Dashboard Element
	Title        *string `json:"title,omitempty"`          // Title of the LookML Dashboard Element
}

type ContentValidationScheduledPlan struct {
	Name   *string `json:"name,omitempty"`    // Name of this scheduled plan
	LookId *string `json:"look_id,omitempty"` // Id of a look
	Id     *string `json:"id,omitempty"`      // Unique Id
}

type ContentValidatorError struct {
	Look                   *ContentValidationLook                   `json:"look,omitempty"`
	Dashboard              *ContentValidationDashboard              `json:"dashboard,omitempty"`
	DashboardElement       *ContentValidationDashboardElement       `json:"dashboard_element,omitempty"`
	DashboardFilter        *ContentValidationDashboardFilter        `json:"dashboard_filter,omitempty"`
	ScheduledPlan          *ContentValidationScheduledPlan          `json:"scheduled_plan,omitempty"`
	Alert                  *ContentValidationAlert                  `json:"alert,omitempty"`
	LookmlDashboard        *ContentValidationLookMLDashboard        `json:"lookml_dashboard,omitempty"`
	LookmlDashboardElement *ContentValidationLookMLDashboardElement `json:"lookml_dashboard_element,omitempty"`
	Errors                 *[]ContentValidationError                `json:"errors,omitempty"` // A list of errors found for this piece of content
	Id                     *string                                  `json:"id,omitempty"`     // An id unique to this piece of content for this validation run
}

type ContentView struct {
	Can               *map[string]bool `json:"can,omitempty"`                 // Operations the current user is able to perform on this object
	Id                *string          `json:"id,omitempty"`                  // Unique Id
	LookId            *string          `json:"look_id,omitempty"`             // Id of viewed Look
	DashboardId       *string          `json:"dashboard_id,omitempty"`        // Id of the viewed Dashboard
	Title             *string          `json:"title,omitempty"`               // Name or title of underlying content
	ContentMetadataId *string          `json:"content_metadata_id,omitempty"` // Content metadata id of the Look or Dashboard
	UserId            *string          `json:"user_id,omitempty"`             // Id of user content was viewed by
	GroupId           *string          `json:"group_id,omitempty"`            // Id of group content was viewed by
	ViewCount         *int64           `json:"view_count,omitempty"`          // Number of times piece of content was viewed
	FavoriteCount     *int64           `json:"favorite_count,omitempty"`      // Number of times piece of content was favorited
	LastViewedAt      *string          `json:"last_viewed_at,omitempty"`      // Date the piece of content was last viewed
	StartOfWeekDate   *string          `json:"start_of_week_date,omitempty"`  // Week start date for the view and favorite count during that given week
}

type ContinuousPalette struct {
	Id    *string      `json:"id,omitempty"`    // Unique identity string
	Label *string      `json:"label,omitempty"` // Label for palette
	Type  *string      `json:"type,omitempty"`  // Type of palette
	Stops *[]ColorStop `json:"stops,omitempty"` // Array of ColorStops in the palette
}

type CostEstimate struct {
	Cost     *int64  `json:"cost,omitempty"`      // Cost of SQL statement
	CacheHit *bool   `json:"cache_hit,omitempty"` // Does the result come from the cache?
	CostUnit *string `json:"cost_unit,omitempty"` // Cost measurement size
	Message  *string `json:"message,omitempty"`   // Human-friendly message
}

// WARNING: no writeable properties found for POST, PUT, or PATCH
type CreateCostEstimate struct {
	Sql *string `json:"sql,omitempty"` // SQL statement to estimate
}

type CreateCredentialsApi3 struct {
	Can          *map[string]bool `json:"can,omitempty"`           // Operations the current user is able to perform on this object
	Id           *string          `json:"id,omitempty"`            // Unique Id
	ClientId     *string          `json:"client_id,omitempty"`     // API key client_id
	CreatedAt    *string          `json:"created_at,omitempty"`    // Timestamp for the creation of this credential
	IsDisabled   *bool            `json:"is_disabled,omitempty"`   // Has this credential been disabled?
	Type         *string          `json:"type,omitempty"`          // Short name for the type of this kind of credential
	ClientSecret *string          `json:"client_secret,omitempty"` // API key client_secret
	Url          *string          `json:"url,omitempty"`           // Link to get this item
}

type CreateDashboardFilter struct {
	Id                  *string                 `json:"id,omitempty"`                    // Unique Id
	DashboardId         string                  `json:"dashboard_id"`                    // Id of Dashboard
	Name                string                  `json:"name"`                            // Name of filter
	Title               string                  `json:"title"`                           // Title of filter
	Type                string                  `json:"type"`                            // Type of filter: one of date, number, string, or field
	DefaultValue        *string                 `json:"default_value,omitempty"`         // Default value of filter
	Model               *string                 `json:"model,omitempty"`                 // Model of filter (required if type = field)
	Explore             *string                 `json:"explore,omitempty"`               // Explore of filter (required if type = field)
	Dimension           *string                 `json:"dimension,omitempty"`             // Dimension of filter (required if type = field)
	Field               *map[string]interface{} `json:"field,omitempty"`                 // Field information
	Row                 *int64                  `json:"row,omitempty"`                   // Display order of this filter relative to other filters
	ListensToFilters    *[]string               `json:"listens_to_filters,omitempty"`    // Array of listeners for faceted filters
	AllowMultipleValues *bool                   `json:"allow_multiple_values,omitempty"` // Whether the filter allows multiple filter values (deprecated in the latest version of dashboards)
	Required            *bool                   `json:"required,omitempty"`              // Whether the filter requires a value to run the dashboard
	UiConfig            *map[string]interface{} `json:"ui_config,omitempty"`             // The visual configuration for this filter. Used to set up how the UI for this filter should appear.
}

type CreateDashboardRenderTask struct {
	DashboardFilters *string `json:"dashboard_filters,omitempty"` // Filter values to apply to the dashboard queries, in URL query format
	DashboardStyle   *string `json:"dashboard_style,omitempty"`   // Dashboard layout style: single_column or tiled
}

type CreateEmbedUserRequest struct {
	ExternalUserId string `json:"external_user_id"`
}

type CreateFolder struct {
	Name     string `json:"name"`      // Unique Name
	ParentId string `json:"parent_id"` // Id of Parent. If the parent id is null, this is a root-level entry
}

type CreateOAuthApplicationUserStateRequest struct {
	UserId                string     `json:"user_id"`
	OauthApplicationId    string     `json:"oauth_application_id"`
	AccessToken           string     `json:"access_token"`
	AccessTokenExpiresAt  time.Time  `json:"access_token_expires_at"`
	RefreshToken          *string    `json:"refresh_token,omitempty"`
	RefreshTokenExpiresAt *time.Time `json:"refresh_token_expires_at,omitempty"`
}

type CreateOAuthApplicationUserStateResponse struct {
	UserId             string `json:"user_id"`              // User Id
	OauthApplicationId string `json:"oauth_application_id"` // OAuth Application ID
}

type CreateQueryTask struct {
	Can          *map[string]bool `json:"can,omitempty"`          // Operations the current user is able to perform on this object
	QueryId      string           `json:"query_id"`               // Id of query to run
	ResultFormat ResultFormat     `json:"result_format"`          // Desired async query result format. Valid values are: "inline_json", "json", "json_detail", "json_fe", "json_bi", "csv", "html", "md", "txt", "xlsx", "gsxml", "sql".
	Source       *string          `json:"source,omitempty"`       // Source of query task
	Deferred     *bool            `json:"deferred,omitempty"`     // Create the task but defer execution
	LookId       *string          `json:"look_id,omitempty"`      // Id of look associated with query.
	DashboardId  *string          `json:"dashboard_id,omitempty"` // Id of dashboard associated with query.
}

type CredentialsApi3 struct {
	Can        *map[string]bool `json:"can,omitempty"`         // Operations the current user is able to perform on this object
	Id         *string          `json:"id,omitempty"`          // Unique Id
	ClientId   *string          `json:"client_id,omitempty"`   // API key client_id
	CreatedAt  *string          `json:"created_at,omitempty"`  // Timestamp for the creation of this credential
	IsDisabled *bool            `json:"is_disabled,omitempty"` // Has this credential been disabled?
	Type       *string          `json:"type,omitempty"`        // Short name for the type of this kind of credential
	Url        *string          `json:"url,omitempty"`         // Link to get this item
}

type CredentialsEmail struct {
	Can                            *map[string]bool `json:"can,omitempty"`                                 // Operations the current user is able to perform on this object
	CreatedAt                      *string          `json:"created_at,omitempty"`                          // Timestamp for the creation of this credential
	Email                          *string          `json:"email,omitempty"`                               // EMail address used for user login
	ForcedPasswordResetAtNextLogin *bool            `json:"forced_password_reset_at_next_login,omitempty"` // Force the user to change their password upon their next login
	UserId                         *string          `json:"user_id,omitempty"`                             // Unique Id of the user
	IsDisabled                     *bool            `json:"is_disabled,omitempty"`                         // Has this credential been disabled?
	LoggedInAt                     *string          `json:"logged_in_at,omitempty"`                        // Timestamp for most recent login using credential
	PasswordResetUrl               *string          `json:"password_reset_url,omitempty"`                  // Url with one-time use secret token that the user can use to reset password
	AccountSetupUrl                *string          `json:"account_setup_url,omitempty"`                   // Url with one-time use secret token that the user can use to setup account
	Type                           *string          `json:"type,omitempty"`                                // Short name for the type of this kind of credential
	Url                            *string          `json:"url,omitempty"`                                 // Link to get this item
	UserUrl                        *string          `json:"user_url,omitempty"`                            // Link to get this user
}

type CredentialsEmailSearch struct {
	Can                            *map[string]bool `json:"can,omitempty"`                                 // Operations the current user is able to perform on this object
	CreatedAt                      *string          `json:"created_at,omitempty"`                          // Timestamp for the creation of this credential
	Email                          *string          `json:"email,omitempty"`                               // EMail address used for user login
	ForcedPasswordResetAtNextLogin *bool            `json:"forced_password_reset_at_next_login,omitempty"` // Force the user to change their password upon their next login
	UserId                         *string          `json:"user_id,omitempty"`                             // Unique Id of the user
	IsDisabled                     *bool            `json:"is_disabled,omitempty"`                         // Has this credential been disabled?
	LoggedInAt                     *string          `json:"logged_in_at,omitempty"`                        // Timestamp for most recent login using credential
	PasswordResetUrl               *string          `json:"password_reset_url,omitempty"`                  // Url with one-time use secret token that the user can use to reset password
	AccountSetupUrl                *string          `json:"account_setup_url,omitempty"`                   // Url with one-time use secret token that the user can use to setup account
	Type                           *string          `json:"type,omitempty"`                                // Short name for the type of this kind of credential
	Url                            *string          `json:"url,omitempty"`                                 // Link to get this item
	UserUrl                        *string          `json:"user_url,omitempty"`                            // Link to get this user
}

type CredentialsEmbed struct {
	Can             *map[string]bool `json:"can,omitempty"`               // Operations the current user is able to perform on this object
	CreatedAt       *string          `json:"created_at,omitempty"`        // Timestamp for the creation of this credential
	ExternalGroupId *string          `json:"external_group_id,omitempty"` // Embedder's id for a group to which this user was added during the most recent login
	ExternalUserId  *string          `json:"external_user_id,omitempty"`  // Embedder's unique id for the user
	Id              *string          `json:"id,omitempty"`                // Unique Id
	IsDisabled      *bool            `json:"is_disabled,omitempty"`       // Has this credential been disabled?
	LoggedInAt      *string          `json:"logged_in_at,omitempty"`      // Timestamp for most recent login using credential
	Type            *string          `json:"type,omitempty"`              // Short name for the type of this kind of credential
	Url             *string          `json:"url,omitempty"`               // Link to get this item
}

type CredentialsGoogle struct {
	Can          *map[string]bool `json:"can,omitempty"`            // Operations the current user is able to perform on this object
	CreatedAt    *string          `json:"created_at,omitempty"`     // Timestamp for the creation of this credential
	Domain       *string          `json:"domain,omitempty"`         // Google domain
	Email        *string          `json:"email,omitempty"`          // EMail address
	GoogleUserId *string          `json:"google_user_id,omitempty"` // Google's Unique ID for this user
	IsDisabled   *bool            `json:"is_disabled,omitempty"`    // Has this credential been disabled?
	LoggedInAt   *string          `json:"logged_in_at,omitempty"`   // Timestamp for most recent login using credential
	Type         *string          `json:"type,omitempty"`           // Short name for the type of this kind of credential
	Url          *string          `json:"url,omitempty"`            // Link to get this item
}

type CredentialsLDAP struct {
	Can        *map[string]bool `json:"can,omitempty"`          // Operations the current user is able to perform on this object
	CreatedAt  *string          `json:"created_at,omitempty"`   // Timestamp for the creation of this credential
	Email      *string          `json:"email,omitempty"`        // EMail address
	IsDisabled *bool            `json:"is_disabled,omitempty"`  // Has this credential been disabled?
	LdapDn     *string          `json:"ldap_dn,omitempty"`      // LDAP Distinguished name for this user (as-of the last login)
	LdapId     *string          `json:"ldap_id,omitempty"`      // LDAP Unique ID for this user
	LoggedInAt *string          `json:"logged_in_at,omitempty"` // Timestamp for most recent login using credential
	Type       *string          `json:"type,omitempty"`         // Short name for the type of this kind of credential
	Url        *string          `json:"url,omitempty"`          // Link to get this item
}

type CredentialsLookerOpenid struct {
	Can        *map[string]bool `json:"can,omitempty"`          // Operations the current user is able to perform on this object
	CreatedAt  *string          `json:"created_at,omitempty"`   // Timestamp for the creation of this credential
	Email      *string          `json:"email,omitempty"`        // EMail address used for user login
	IsDisabled *bool            `json:"is_disabled,omitempty"`  // Has this credential been disabled?
	LoggedInAt *string          `json:"logged_in_at,omitempty"` // Timestamp for most recent login using credential
	LoggedInIp *string          `json:"logged_in_ip,omitempty"` // IP address of client for most recent login using credential
	Type       *string          `json:"type,omitempty"`         // Short name for the type of this kind of credential
	Url        *string          `json:"url,omitempty"`          // Link to get this item
	UserUrl    *string          `json:"user_url,omitempty"`     // Link to get this user
}

type CredentialsOIDC struct {
	Can        *map[string]bool `json:"can,omitempty"`          // Operations the current user is able to perform on this object
	CreatedAt  *string          `json:"created_at,omitempty"`   // Timestamp for the creation of this credential
	Email      *string          `json:"email,omitempty"`        // EMail address
	IsDisabled *bool            `json:"is_disabled,omitempty"`  // Has this credential been disabled?
	LoggedInAt *string          `json:"logged_in_at,omitempty"` // Timestamp for most recent login using credential
	OidcUserId *string          `json:"oidc_user_id,omitempty"` // OIDC OP's Unique ID for this user
	Type       *string          `json:"type,omitempty"`         // Short name for the type of this kind of credential
	Url        *string          `json:"url,omitempty"`          // Link to get this item
}

type CredentialsSaml struct {
	Can        *map[string]bool `json:"can,omitempty"`          // Operations the current user is able to perform on this object
	CreatedAt  *string          `json:"created_at,omitempty"`   // Timestamp for the creation of this credential
	Email      *string          `json:"email,omitempty"`        // EMail address
	IsDisabled *bool            `json:"is_disabled,omitempty"`  // Has this credential been disabled?
	LoggedInAt *string          `json:"logged_in_at,omitempty"` // Timestamp for most recent login using credential
	SamlUserId *string          `json:"saml_user_id,omitempty"` // Saml IdP's Unique ID for this user
	Type       *string          `json:"type,omitempty"`         // Short name for the type of this kind of credential
	Url        *string          `json:"url,omitempty"`          // Link to get this item
}

// WARNING: no writeable properties found for POST, PUT, or PATCH
type CredentialsTotp struct {
	Can        *map[string]bool `json:"can,omitempty"`         // Operations the current user is able to perform on this object
	CreatedAt  *string          `json:"created_at,omitempty"`  // Timestamp for the creation of this credential
	IsDisabled *bool            `json:"is_disabled,omitempty"` // Has this credential been disabled?
	Type       *string          `json:"type,omitempty"`        // Short name for the type of this kind of credential
	Verified   *bool            `json:"verified,omitempty"`    // User has verified
	Url        *string          `json:"url,omitempty"`         // Link to get this item
}

type CustomWelcomeEmail struct {
	Enabled *bool   `json:"enabled,omitempty"` // If true, custom email content will replace the default body of welcome emails
	Content *string `json:"content,omitempty"` // The HTML to use as custom content for welcome emails. Script elements and other potentially dangerous markup will be removed.
	Subject *string `json:"subject,omitempty"` // The text to appear in the email subject line. Only available with a whitelabel license and whitelabel_configuration.advanced_custom_welcome_email enabled.
	Header  *string `json:"header,omitempty"`  // The text to appear in the header line of the email body. Only available with a whitelabel license and whitelabel_configuration.advanced_custom_welcome_email enabled.
}

type Dashboard struct {
	Can                                 *map[string]bool     `json:"can,omitempty"`                 // Operations the current user is able to perform on this object
	ContentFavoriteId                   *string              `json:"content_favorite_id,omitempty"` // Content Favorite Id
	ContentMetadataId                   *string              `json:"content_metadata_id,omitempty"` // Id of content metadata
	Description                         *string              `json:"description,omitempty"`         // Description
	Hidden                              *bool                `json:"hidden,omitempty"`              // Is Hidden
	Id                                  *string              `json:"id,omitempty"`                  // Unique Id
	Model                               *LookModel           `json:"model,omitempty"`
	QueryTimezone                       *string              `json:"query_timezone,omitempty"`        // Timezone in which the Dashboard will run by default.
	Readonly                            *bool                `json:"readonly,omitempty"`              // Is Read-only
	RefreshInterval                     *string              `json:"refresh_interval,omitempty"`      // Refresh Interval, as a time duration phrase like "2 hours 30 minutes". A number with no time units will be interpreted as whole seconds.
	RefreshIntervalToI                  *int64               `json:"refresh_interval_to_i,omitempty"` // Refresh Interval in milliseconds
	Folder                              *FolderBase          `json:"folder,omitempty"`
	Title                               *string              `json:"title,omitempty"`                                    // Dashboard Title
	UserId                              *string              `json:"user_id,omitempty"`                                  // Id of User
	Slug                                *string              `json:"slug,omitempty"`                                     // Content Metadata Slug
	PreferredViewer                     *string              `json:"preferred_viewer,omitempty"`                         // The preferred route for viewing this dashboard (ie: dashboards or dashboards-next)
	AlertSyncWithDashboardFilterEnabled *bool                `json:"alert_sync_with_dashboard_filter_enabled,omitempty"` // Enables alerts to keep in sync with dashboard filter changes
	BackgroundColor                     *string              `json:"background_color,omitempty"`                         // Background color
	CreatedAt                           *time.Time           `json:"created_at,omitempty"`                               // Time that the Dashboard was created.
	CrossfilterEnabled                  *bool                `json:"crossfilter_enabled,omitempty"`                      // Enables crossfiltering in dashboards - only available in dashboards-next (beta)
	DashboardElements                   *[]DashboardElement  `json:"dashboard_elements,omitempty"`                       // Elements
	DashboardFilters                    *[]DashboardFilter   `json:"dashboard_filters,omitempty"`                        // Filters
	DashboardLayouts                    *[]DashboardLayout   `json:"dashboard_layouts,omitempty"`                        // Layouts
	Deleted                             *bool                `json:"deleted,omitempty"`                                  // Whether or not a dashboard is 'soft' deleted.
	DeletedAt                           *time.Time           `json:"deleted_at,omitempty"`                               // Time that the Dashboard was 'soft' deleted.
	DeleterId                           *string              `json:"deleter_id,omitempty"`                               // Id of User that 'soft' deleted the dashboard.
	EditUri                             *string              `json:"edit_uri,omitempty"`                                 // Relative path of URI of LookML file to edit the dashboard (LookML dashboard only).
	EnableVizFullScreen                 *bool                `json:"enable_viz_full_screen,omitempty"`                   // Allow visualizations to be viewed in full screen mode
	FavoriteCount                       *int64               `json:"favorite_count,omitempty"`                           // Number of times favorited
	FiltersBarCollapsed                 *bool                `json:"filters_bar_collapsed,omitempty"`                    // Sets the default state of the filters bar to collapsed or open
	FiltersLocationTop                  *bool                `json:"filters_location_top,omitempty"`                     // Sets the default state of the filters location to top(true) or right(false)
	LastAccessedAt                      *time.Time           `json:"last_accessed_at,omitempty"`                         // Time the dashboard was last accessed
	LastViewedAt                        *time.Time           `json:"last_viewed_at,omitempty"`                           // Time last viewed in the Looker web UI
	UpdatedAt                           *time.Time           `json:"updated_at,omitempty"`                               // Time that the Dashboard was most recently updated.
	LastUpdaterId                       *string              `json:"last_updater_id,omitempty"`                          // Id of User that most recently updated the dashboard.
	LastUpdaterName                     *string              `json:"last_updater_name,omitempty"`                        // Name of User that most recently updated the dashboard.
	UserName                            *string              `json:"user_name,omitempty"`                                // Name of User that created the dashboard.
	LoadConfiguration                   *string              `json:"load_configuration,omitempty"`                       // configuration option that governs how dashboard loading will happen.
	LookmlLinkId                        *string              `json:"lookml_link_id,omitempty"`                           // Links this dashboard to a particular LookML dashboard such that calling a **sync** operation on that LookML dashboard will update this dashboard to match.
	ShowFiltersBar                      *bool                `json:"show_filters_bar,omitempty"`                         // Show filters bar.  **Security Note:** This property only affects the *cosmetic* appearance of the dashboard, not a user's ability to access data. Hiding the filters bar does **NOT** prevent users from changing filters by other means. For information on how to set up secure data access control policies, see [Control User Access to Data](https://cloud.google.com/looker/docs/r/api/control-access)
	ShowTitle                           *bool                `json:"show_title,omitempty"`                               // Show title
	FolderId                            *string              `json:"folder_id,omitempty"`                                // Id of folder
	TextTileTextColor                   *string              `json:"text_tile_text_color,omitempty"`                     // Color of text on text tiles
	TileBackgroundColor                 *string              `json:"tile_background_color,omitempty"`                    // Tile background color
	TileTextColor                       *string              `json:"tile_text_color,omitempty"`                          // Tile text color
	TitleColor                          *string              `json:"title_color,omitempty"`                              // Title color
	ViewCount                           *int64               `json:"view_count,omitempty"`                               // Number of times viewed in the Looker web UI
	Appearance                          *DashboardAppearance `json:"appearance,omitempty"`
	Url                                 *string              `json:"url,omitempty"` // Relative URL of the dashboard
}

type DashboardAggregateTableLookml struct {
	DashboardId          *string `json:"dashboard_id,omitempty"`           // Dashboard Id
	AggregateTableLookml *string `json:"aggregate_table_lookml,omitempty"` // Aggregate Table LookML
}

type DashboardAppearance struct {
	PageSideMargins     *int64  `json:"page_side_margins,omitempty"`     // Page margin (side) width
	PageBackgroundColor *string `json:"page_background_color,omitempty"` // Background color for the dashboard
	TileTitleAlignment  *string `json:"tile_title_alignment,omitempty"`  // Title alignment on dashboard tiles
	TileSpaceBetween    *int64  `json:"tile_space_between,omitempty"`    // Space between tiles
	TileBackgroundColor *string `json:"tile_background_color,omitempty"` // Background color for tiles
	TileShadow          *bool   `json:"tile_shadow,omitempty"`           // Tile shadow on/off
	KeyColor            *string `json:"key_color,omitempty"`             // Key color
}

type DashboardBase struct {
	Can                *map[string]bool `json:"can,omitempty"`                 // Operations the current user is able to perform on this object
	ContentFavoriteId  *string          `json:"content_favorite_id,omitempty"` // Content Favorite Id
	ContentMetadataId  *string          `json:"content_metadata_id,omitempty"` // Id of content metadata
	Description        *string          `json:"description,omitempty"`         // Description
	Hidden             *bool            `json:"hidden,omitempty"`              // Is Hidden
	Id                 *string          `json:"id,omitempty"`                  // Unique Id
	Model              *LookModel       `json:"model,omitempty"`
	QueryTimezone      *string          `json:"query_timezone,omitempty"`        // Timezone in which the Dashboard will run by default.
	Readonly           *bool            `json:"readonly,omitempty"`              // Is Read-only
	RefreshInterval    *string          `json:"refresh_interval,omitempty"`      // Refresh Interval, as a time duration phrase like "2 hours 30 minutes". A number with no time units will be interpreted as whole seconds.
	RefreshIntervalToI *int64           `json:"refresh_interval_to_i,omitempty"` // Refresh Interval in milliseconds
	Folder             *FolderBase      `json:"folder,omitempty"`
	Title              *string          `json:"title,omitempty"`            // Dashboard Title
	UserId             *string          `json:"user_id,omitempty"`          // Id of User
	Slug               *string          `json:"slug,omitempty"`             // Content Metadata Slug
	PreferredViewer    *string          `json:"preferred_viewer,omitempty"` // The preferred route for viewing this dashboard (ie: dashboards or dashboards-next)
}

type DashboardElement struct {
	Can                *map[string]bool                            `json:"can,omitempty"`               // Operations the current user is able to perform on this object
	BodyText           *string                                     `json:"body_text,omitempty"`         // Text tile body text
	BodyTextAsHtml     *string                                     `json:"body_text_as_html,omitempty"` // Text tile body text as Html
	DashboardId        *string                                     `json:"dashboard_id,omitempty"`      // Id of Dashboard
	EditUri            *string                                     `json:"edit_uri,omitempty"`          // Relative path of URI of LookML file to edit the dashboard element (LookML dashboard only).
	Id                 *string                                     `json:"id,omitempty"`                // Unique Id
	Look               *LookWithQuery                              `json:"look,omitempty"`
	LookId             *string                                     `json:"look_id,omitempty"`           // Id Of Look
	LookmlLinkId       *string                                     `json:"lookml_link_id,omitempty"`    // LookML link ID
	MergeResultId      *string                                     `json:"merge_result_id,omitempty"`   // ID of merge result
	NoteDisplay        *string                                     `json:"note_display,omitempty"`      // Note Display
	NoteState          *string                                     `json:"note_state,omitempty"`        // Note State
	NoteText           *string                                     `json:"note_text,omitempty"`         // Note Text
	NoteTextAsHtml     *string                                     `json:"note_text_as_html,omitempty"` // Note Text as Html
	Query              *Query                                      `json:"query,omitempty"`
	QueryId            *string                                     `json:"query_id,omitempty"`              // Id Of Query
	RefreshInterval    *string                                     `json:"refresh_interval,omitempty"`      // Refresh Interval
	RefreshIntervalToI *int64                                      `json:"refresh_interval_to_i,omitempty"` // Refresh Interval as integer
	ResultMaker        *ResultMakerWithIdVisConfigAndDynamicFields `json:"result_maker,omitempty"`
	ResultMakerId      *string                                     `json:"result_maker_id,omitempty"`       // ID of the ResultMakerLookup entry.
	SubtitleText       *string                                     `json:"subtitle_text,omitempty"`         // Text tile subtitle text
	Title              *string                                     `json:"title,omitempty"`                 // Title of dashboard element
	TitleHidden        *bool                                       `json:"title_hidden,omitempty"`          // Whether title is hidden
	TitleText          *string                                     `json:"title_text,omitempty"`            // Text tile title
	Type               *string                                     `json:"type,omitempty"`                  // Type
	AlertCount         *int64                                      `json:"alert_count,omitempty"`           // Count of Alerts associated to a dashboard element
	RichContentJson    *string                                     `json:"rich_content_json,omitempty"`     // JSON with all the properties required for rich editor and buttons elements
	TitleTextAsHtml    *string                                     `json:"title_text_as_html,omitempty"`    // Text tile title text as Html
	SubtitleTextAsHtml *string                                     `json:"subtitle_text_as_html,omitempty"` // Text tile subtitle text as Html
	ExtensionId        *string                                     `json:"extension_id,omitempty"`          // Extension ID
}

type DashboardFilter struct {
	Can                 *map[string]bool        `json:"can,omitempty"`                   // Operations the current user is able to perform on this object
	Id                  *string                 `json:"id,omitempty"`                    // Unique Id
	DashboardId         *string                 `json:"dashboard_id,omitempty"`          // Id of Dashboard
	Name                *string                 `json:"name,omitempty"`                  // Name of filter
	Title               *string                 `json:"title,omitempty"`                 // Title of filter
	Type                *string                 `json:"type,omitempty"`                  // Type of filter: one of date, number, string, or field
	DefaultValue        *string                 `json:"default_value,omitempty"`         // Default value of filter
	Model               *string                 `json:"model,omitempty"`                 // Model of filter (required if type = field)
	Explore             *string                 `json:"explore,omitempty"`               // Explore of filter (required if type = field)
	Dimension           *string                 `json:"dimension,omitempty"`             // Dimension of filter (required if type = field)
	Field               *map[string]interface{} `json:"field,omitempty"`                 // Field information
	Row                 *int64                  `json:"row,omitempty"`                   // Display order of this filter relative to other filters
	ListensToFilters    *[]string               `json:"listens_to_filters,omitempty"`    // Array of listeners for faceted filters
	AllowMultipleValues *bool                   `json:"allow_multiple_values,omitempty"` // Whether the filter allows multiple filter values (deprecated in the latest version of dashboards)
	Required            *bool                   `json:"required,omitempty"`              // Whether the filter requires a value to run the dashboard
	UiConfig            *map[string]interface{} `json:"ui_config,omitempty"`             // The visual configuration for this filter. Used to set up how the UI for this filter should appear.
}

type DashboardLayout struct {
	Can                       *map[string]bool            `json:"can,omitempty"`                         // Operations the current user is able to perform on this object
	Id                        *string                     `json:"id,omitempty"`                          // Unique Id
	DashboardId               *string                     `json:"dashboard_id,omitempty"`                // Id of Dashboard
	Type                      *string                     `json:"type,omitempty"`                        // Type
	Active                    *bool                       `json:"active,omitempty"`                      // Is Active
	ColumnWidth               *int64                      `json:"column_width,omitempty"`                // Column Width
	Width                     *int64                      `json:"width,omitempty"`                       // Width
	Deleted                   *bool                       `json:"deleted,omitempty"`                     // Whether or not the dashboard layout is deleted.
	DashboardTitle            *string                     `json:"dashboard_title,omitempty"`             // Title extracted from the dashboard this layout represents.
	DashboardLayoutComponents *[]DashboardLayoutComponent `json:"dashboard_layout_components,omitempty"` // Components
}

type DashboardLayoutComponent struct {
	Can                *map[string]bool `json:"can,omitempty"`                  // Operations the current user is able to perform on this object
	Id                 *string          `json:"id,omitempty"`                   // Unique Id
	DashboardLayoutId  *string          `json:"dashboard_layout_id,omitempty"`  // Id of Dashboard Layout
	DashboardElementId *string          `json:"dashboard_element_id,omitempty"` // Id Of Dashboard Element
	Row                *int64           `json:"row,omitempty"`                  // Row
	Column             *int64           `json:"column,omitempty"`               // Column
	Width              *int64           `json:"width,omitempty"`                // Width
	Height             *int64           `json:"height,omitempty"`               // Height
	Deleted            *bool            `json:"deleted,omitempty"`              // Whether or not the dashboard layout component is deleted
	ElementTitle       *string          `json:"element_title,omitempty"`        // Dashboard element title, extracted from the Dashboard Element.
	ElementTitleHidden *bool            `json:"element_title_hidden,omitempty"` // Whether or not the dashboard element title is displayed.
	VisType            *string          `json:"vis_type,omitempty"`             // Visualization type, extracted from a query's vis_config
}

type DashboardLookml struct {
	DashboardId *string `json:"dashboard_id,omitempty"` // Id of Dashboard
	FolderId    *string `json:"folder_id,omitempty"`    // (Write-Only) Id of the folder
	Lookml      *string `json:"lookml,omitempty"`       // lookml of UDD
}

type DataActionForm struct {
	State  *DataActionUserState   `json:"state,omitempty"`
	Fields *[]DataActionFormField `json:"fields,omitempty"` // Array of form fields.
}

type DataActionFormField struct {
	Name        *string                       `json:"name,omitempty"`        // Name
	Label       *string                       `json:"label,omitempty"`       // Human-readable label
	Description *string                       `json:"description,omitempty"` // Description of field
	Type        *string                       `json:"type,omitempty"`        // Type of field.
	Default     *string                       `json:"default,omitempty"`     // Default value of the field.
	OauthUrl    *string                       `json:"oauth_url,omitempty"`   // The URL for an oauth link, if type is 'oauth_link'.
	Interactive *bool                         `json:"interactive,omitempty"` // Whether or not a field supports interactive forms.
	Required    *bool                         `json:"required,omitempty"`    // Whether or not the field is required. This is a user-interface hint. A user interface displaying this form should not submit it without a value for this field. The action server must also perform this validation.
	Options     *[]DataActionFormSelectOption `json:"options,omitempty"`     // If the form type is 'select', a list of options to be selected from.
}

type DataActionFormSelectOption struct {
	Name  *string `json:"name,omitempty"`  // Name
	Label *string `json:"label,omitempty"` // Human-readable label
}

type DataActionRequest struct {
	Action     *map[string]interface{} `json:"action,omitempty"`      // The JSON describing the data action. This JSON should be considered opaque and should be passed through unmodified from the query result it came from.
	FormValues *map[string]interface{} `json:"form_values,omitempty"` // User input for any form values the data action might use.
}

type DataActionResponse struct {
	WebhookId        *string          `json:"webhook_id,omitempty"`    // ID of the webhook event that sent this data action. In some error conditions, this may be null.
	Success          *bool            `json:"success,omitempty"`       // Whether the data action was successful.
	RefreshQuery     *bool            `json:"refresh_query,omitempty"` // When true, indicates that the client should refresh (rerun) the source query because the data may have been changed by the action.
	ValidationErrors *ValidationError `json:"validation_errors,omitempty"`
	Message          *string          `json:"message,omitempty"` // Optional message returned by the data action server describing the state of the action that took place. This can be used to implement custom failure messages. If a failure is related to a particular form field, the server should send back a validation error instead. The Looker web UI does not currently display any message if the action indicates 'success', but may do so in the future.
}

type DataActionUserState struct {
	Data        *string `json:"data,omitempty"`         // User state data
	RefreshTime *int64  `json:"refresh_time,omitempty"` // Time in seconds until the state needs to be refreshed
}

type Datagroup struct {
	Can            *map[string]bool `json:"can,omitempty"`              // Operations the current user is able to perform on this object
	CreatedAt      *int64           `json:"created_at,omitempty"`       // UNIX timestamp at which this entry was created.
	Id             *string          `json:"id,omitempty"`               // Unique ID of the datagroup
	ModelName      *string          `json:"model_name,omitempty"`       // Name of the model containing the datagroup. Unique when combined with name.
	Name           *string          `json:"name,omitempty"`             // Name of the datagroup. Unique when combined with model_name.
	StaleBefore    *int64           `json:"stale_before,omitempty"`     // UNIX timestamp before which cache entries are considered stale. Cannot be in the future.
	TriggerCheckAt *int64           `json:"trigger_check_at,omitempty"` // UNIX timestamp at which this entry trigger was last checked.
	TriggerError   *string          `json:"trigger_error,omitempty"`    // The message returned with the error of the last trigger check.
	TriggerValue   *string          `json:"trigger_value,omitempty"`    // The value of the trigger when last checked.
	TriggeredAt    *int64           `json:"triggered_at,omitempty"`     // UNIX timestamp at which this entry became triggered. Cannot be in the future.
}

type DBConnection struct {
	Can                      *map[string]bool      `json:"can,omitempty"`  // Operations the current user is able to perform on this object
	Name                     *string               `json:"name,omitempty"` // Name of the connection. Also used as the unique identifier
	Dialect                  *Dialect              `json:"dialect,omitempty"`
	Snippets                 *[]Snippet            `json:"snippets,omitempty"`                     // SQL Runner snippets for this connection
	PdtsEnabled              *bool                 `json:"pdts_enabled,omitempty"`                 // True if PDTs are enabled on this connection
	Host                     *string               `json:"host,omitempty"`                         // Host name/address of server; or the string 'localhost' in case of a connection over an SSH tunnel.
	Port                     *string               `json:"port,omitempty"`                         // Port number on server. If the connection is over an SSH tunnel, then the local port associated with the SSH tunnel.
	Username                 *string               `json:"username,omitempty"`                     // Username for server authentication
	Password                 *string               `json:"password,omitempty"`                     // (Write-Only) Password for server authentication
	UsesOauth                *bool                 `json:"uses_oauth,omitempty"`                   // Whether the connection uses OAuth for authentication.
	Certificate              *string               `json:"certificate,omitempty"`                  // (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
	FileType                 *string               `json:"file_type,omitempty"`                    // (Write-Only) Certificate keyfile type - .json or .p12
	Database                 *string               `json:"database,omitempty"`                     // Database name
	DbTimezone               *string               `json:"db_timezone,omitempty"`                  // Time zone of database
	QueryTimezone            *string               `json:"query_timezone,omitempty"`               // Timezone to use in queries
	Schema                   *string               `json:"schema,omitempty"`                       // Schema name
	MaxConnections           *int64                `json:"max_connections,omitempty"`              // Maximum number of concurrent connection to use
	MaxBillingGigabytes      *string               `json:"max_billing_gigabytes,omitempty"`        // Maximum size of query in GBs (BigQuery only, can be a user_attribute name)
	Ssl                      *bool                 `json:"ssl,omitempty"`                          // Use SSL/TLS when connecting to server
	VerifySsl                *bool                 `json:"verify_ssl,omitempty"`                   // Verify the SSL
	TmpDbName                *string               `json:"tmp_db_name,omitempty"`                  // Name of temporary database (if used)
	JdbcAdditionalParams     *string               `json:"jdbc_additional_params,omitempty"`       // Additional params to add to JDBC connection string
	PoolTimeout              *int64                `json:"pool_timeout,omitempty"`                 // Connection Pool Timeout, in seconds
	DialectName              *string               `json:"dialect_name,omitempty"`                 // (Read/Write) SQL Dialect name
	SupportsDataStudioLink   *bool                 `json:"supports_data_studio_link,omitempty"`    // Database connection has the ability to support open data studio from explore
	CreatedAt                *string               `json:"created_at,omitempty"`                   // Creation date for this connection
	UserId                   *string               `json:"user_id,omitempty"`                      // Id of user who last modified this connection configuration
	Example                  *bool                 `json:"example,omitempty"`                      // Is this an example connection?
	UserDbCredentials        *bool                 `json:"user_db_credentials,omitempty"`          // (Limited access feature) Are per user db credentials enabled. Enabling will remove previously set username and password
	UserAttributeFields      *[]string             `json:"user_attribute_fields,omitempty"`        // Fields whose values map to user attribute names
	MaintenanceCron          *string               `json:"maintenance_cron,omitempty"`             // Cron string specifying when maintenance such as PDT trigger checks and drops should be performed
	LastRegenAt              *string               `json:"last_regen_at,omitempty"`                // Unix timestamp at start of last completed PDT trigger check process
	LastReapAt               *string               `json:"last_reap_at,omitempty"`                 // Unix timestamp at start of last completed PDT reap process
	SqlRunnerPrecacheTables  *bool                 `json:"sql_runner_precache_tables,omitempty"`   // Precache tables in the SQL Runner
	SqlWritingWithInfoSchema *bool                 `json:"sql_writing_with_info_schema,omitempty"` // Fetch Information Schema For SQL Writing
	AfterConnectStatements   *string               `json:"after_connect_statements,omitempty"`     // SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
	PdtContextOverride       *DBConnectionOverride `json:"pdt_context_override,omitempty"`
	Managed                  *bool                 `json:"managed,omitempty"`                    // Is this connection created and managed by Looker
	CustomLocalPort          *int64                `json:"custom_local_port,omitempty"`          // This field is only applicable to connections over an SSH Tunnel. The value of this field would be the local port associated with the SSH tunnel if configured manually. Otherwise either enter NULL or exclude this field.
	TunnelId                 *string               `json:"tunnel_id,omitempty"`                  // The Id of the ssh tunnel this connection uses
	UsesTns                  *bool                 `json:"uses_tns,omitempty"`                   // Enable Transparent Network Substrate (TNS) connections
	PdtConcurrency           *int64                `json:"pdt_concurrency,omitempty"`            // Maximum number of threads to use to build PDTs in parallel
	DisableContextComment    *bool                 `json:"disable_context_comment,omitempty"`    // When disable_context_comment is true comment will not be added to SQL
	OauthApplicationId       *string               `json:"oauth_application_id,omitempty"`       // An External OAuth Application to use for authenticating to the database
	AlwaysRetryFailedBuilds  *bool                 `json:"always_retry_failed_builds,omitempty"` // When true, error PDTs will be retried every regenerator cycle
	CostEstimateEnabled      *bool                 `json:"cost_estimate_enabled,omitempty"`      // When true, query cost estimate will be displayed in explore.
	PdtApiControlEnabled     *bool                 `json:"pdt_api_control_enabled,omitempty"`    // PDT builds on this connection can be kicked off and cancelled via API.
	ConnectionPooling        *bool                 `json:"connection_pooling,omitempty"`         // Enable database connection pooling.
}

type DBConnectionBase struct {
	Can         *map[string]bool `json:"can,omitempty"`  // Operations the current user is able to perform on this object
	Name        *string          `json:"name,omitempty"` // Name of the connection. Also used as the unique identifier
	Dialect     *Dialect         `json:"dialect,omitempty"`
	Snippets    *[]Snippet       `json:"snippets,omitempty"`     // SQL Runner snippets for this connection
	PdtsEnabled *bool            `json:"pdts_enabled,omitempty"` // True if PDTs are enabled on this connection
}

type DBConnectionOverride struct {
	Context                *string `json:"context,omitempty"`                  // Context in which to override (`pdt` is the only allowed value)
	Host                   *string `json:"host,omitempty"`                     // Host name/address of server
	Port                   *string `json:"port,omitempty"`                     // Port number on server
	Username               *string `json:"username,omitempty"`                 // Username for server authentication
	Password               *string `json:"password,omitempty"`                 // (Write-Only) Password for server authentication
	HasPassword            *bool   `json:"has_password,omitempty"`             // Whether or not the password is overridden in this context
	Certificate            *string `json:"certificate,omitempty"`              // (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
	FileType               *string `json:"file_type,omitempty"`                // (Write-Only) Certificate keyfile type - .json or .p12
	Database               *string `json:"database,omitempty"`                 // Database name
	Schema                 *string `json:"schema,omitempty"`                   // Schema name
	JdbcAdditionalParams   *string `json:"jdbc_additional_params,omitempty"`   // Additional params to add to JDBC connection string
	AfterConnectStatements *string `json:"after_connect_statements,omitempty"` // SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
}

type DBConnectionTestResult struct {
	Can              *map[string]bool `json:"can,omitempty"`               // Operations the current user is able to perform on this object
	ConnectionString *string          `json:"connection_string,omitempty"` // JDBC connection string. (only populated in the 'connect' test)
	Message          *string          `json:"message,omitempty"`           // Result message of test
	Name             *string          `json:"name,omitempty"`              // Name of test
	Status           *string          `json:"status,omitempty"`            // Result code of test
}

type DelegateOauthTest struct {
	Name                 *string `json:"name,omitempty"`                   // Delegate Oauth Connection Name
	InstallationTargetId *string `json:"installation_target_id,omitempty"` // The ID of the installation target. For Slack, this would be workspace id.
	InstallationId       *string `json:"installation_id,omitempty"`        // Installation ID
	Success              *bool   `json:"success,omitempty"`                // Whether or not the test was successful
}

type DependencyGraph struct {
	GraphText *string `json:"graph_text,omitempty"` // The graph structure in the dot language that can be rendered into an image.
}

type DependencyStatus string

const DependencyStatus_LockOptional DependencyStatus = "lock_optional"
const DependencyStatus_LockRequired DependencyStatus = "lock_required"
const DependencyStatus_LockError DependencyStatus = "lock_error"
const DependencyStatus_InstallNone DependencyStatus = "install_none"

type DestinationType string

const DestinationType_EMAIL DestinationType = "EMAIL"
const DestinationType_ACTION_HUB DestinationType = "ACTION_HUB"

type DeviceType string

const DeviceType_Android DeviceType = "android"
const DeviceType_Ios DeviceType = "ios"

type Dialect struct {
	Name                              *string   `json:"name,omitempty"`                                  // The name of the dialect
	Label                             *string   `json:"label,omitempty"`                                 // The human-readable label of the connection
	SupportsCostEstimate              *bool     `json:"supports_cost_estimate,omitempty"`                // Whether the dialect supports query cost estimates
	CostEstimateStyle                 *string   `json:"cost_estimate_style,omitempty"`                   // How the dialect handles cost estimation
	PersistentTableIndexes            *string   `json:"persistent_table_indexes,omitempty"`              // PDT index columns
	PersistentTableSortkeys           *string   `json:"persistent_table_sortkeys,omitempty"`             // PDT sortkey columns
	PersistentTableDistkey            *string   `json:"persistent_table_distkey,omitempty"`              // PDT distkey column
	SupportsStreaming                 *bool     `json:"supports_streaming,omitempty"`                    // Supports streaming results
	AutomaticallyRunSqlRunnerSnippets *bool     `json:"automatically_run_sql_runner_snippets,omitempty"` // Should SQL Runner snippets automatically be run
	ConnectionTests                   *[]string `json:"connection_tests,omitempty"`                      // Array of names of the tests that can be run on a connection using this dialect
	SupportsInducer                   *bool     `json:"supports_inducer,omitempty"`                      // Is supported with the inducer (i.e. generate from sql)
	SupportsMultipleDatabases         *bool     `json:"supports_multiple_databases,omitempty"`           // Can multiple databases be accessed from a connection using this dialect
	SupportsPersistentDerivedTables   *bool     `json:"supports_persistent_derived_tables,omitempty"`    // Whether the dialect supports allowing Looker to build persistent derived tables
	HasSslSupport                     *bool     `json:"has_ssl_support,omitempty"`                       // Does the database have client SSL support settable through the JDBC string explicitly?
}

type DialectInfo struct {
	Can                        *map[string]bool    `json:"can,omitempty"`                           // Operations the current user is able to perform on this object
	DefaultMaxConnections      *string             `json:"default_max_connections,omitempty"`       // Default number max connections
	DefaultPort                *string             `json:"default_port,omitempty"`                  // Default port number
	Installed                  *bool               `json:"installed,omitempty"`                     // Is the supporting driver installed
	Label                      *string             `json:"label,omitempty"`                         // The human-readable label of the connection
	LabelForDatabaseEquivalent *string             `json:"label_for_database_equivalent,omitempty"` // What the dialect calls the equivalent of a normal SQL table
	LabelForSchemaEquivalent   *string             `json:"label_for_schema_equivalent,omitempty"`   // What the dialect calls the equivalent of a schema-level namespace
	Name                       *string             `json:"name,omitempty"`                          // The name of the dialect
	SupportedOptions           *DialectInfoOptions `json:"supported_options,omitempty"`
}

type DialectInfoOptions struct {
	AdditionalParams          *bool `json:"additional_params,omitempty"`           // Has additional params support
	AfterConnectStatements    *bool `json:"after_connect_statements,omitempty"`    // Has support for issuing statements after connecting to the database
	AnalyticalViewDataset     *bool `json:"analytical_view_dataset,omitempty"`     // Has analytical view support
	Auth                      *bool `json:"auth,omitempty"`                        // Has auth support
	CostEstimate              *bool `json:"cost_estimate,omitempty"`               // Has configurable cost estimation
	DisableContextComment     *bool `json:"disable_context_comment,omitempty"`     // Can disable query context comments
	Host                      *bool `json:"host,omitempty"`                        // Host is required
	InstanceName              *bool `json:"instance_name,omitempty"`               // Instance name is required
	MaxBillingGigabytes       *bool `json:"max_billing_gigabytes,omitempty"`       // Has max billing gigabytes support
	OauthCredentials          *bool `json:"oauth_credentials,omitempty"`           // Has support for a service account
	PdtsForOauth              *bool `json:"pdts_for_oauth,omitempty"`              // Has OAuth for PDT support
	Port                      *bool `json:"port,omitempty"`                        // Port can be specified
	ProjectName               *bool `json:"project_name,omitempty"`                // Has project name support
	Schema                    *bool `json:"schema,omitempty"`                      // Schema can be specified
	ServiceAccountCredentials *bool `json:"service_account_credentials,omitempty"` // Has support for a service account
	Ssl                       *bool `json:"ssl,omitempty"`                         // Has TLS/SSL support
	Timezone                  *bool `json:"timezone,omitempty"`                    // Has timezone support
	TmpTable                  *bool `json:"tmp_table,omitempty"`                   // Has tmp table support
	Tns                       *bool `json:"tns,omitempty"`                         // Has Oracle TNS support
	Username                  *bool `json:"username,omitempty"`                    // Username can be specified
	UsernameRequired          *bool `json:"username_required,omitempty"`           // Username is required
	SupportsConnectionPooling *bool `json:"supports_connection_pooling,omitempty"` // Has support for connection pooling
}

type DigestEmails struct {
	IsEnabled *bool `json:"is_enabled,omitempty"` // Whether or not digest emails are enabled
}

type DigestEmailSend struct {
	ConfigurationDelivered *bool `json:"configuration_delivered,omitempty"` // True if content was successfully generated and delivered
}

type DiscretePalette struct {
	Id     *string   `json:"id,omitempty"`     // Unique identity string
	Label  *string   `json:"label,omitempty"`  // Label for palette
	Type   *string   `json:"type,omitempty"`   // Type of palette
	Colors *[]string `json:"colors,omitempty"` // Array of colors in the palette
}

type EgressIpAddresses struct {
	EgressIpAddresses *[]string `json:"egress_ip_addresses,omitempty"` // Egress IP addresses
}

type EmbedConfig struct {
	DomainAllowlist          *[]string `json:"domain_allowlist,omitempty"`            // List of domains to allow for embedding
	AlertUrlAllowlist        *[]string `json:"alert_url_allowlist,omitempty"`         // List of base urls to allow for alert/schedule
	AlertUrlParamOwner       *string   `json:"alert_url_param_owner,omitempty"`       // Owner of who defines the alert/schedule params on the base url
	AlertUrlLabel            *string   `json:"alert_url_label,omitempty"`             // Label for the alert/schedule url
	SsoAuthEnabled           *bool     `json:"sso_auth_enabled,omitempty"`            // Is SSO embedding enabled for this Looker
	EmbedCookielessV2        *bool     `json:"embed_cookieless_v2,omitempty"`         // Is Cookieless embedding enabled for this Looker
	EmbedContentNavigation   *bool     `json:"embed_content_navigation,omitempty"`    // Is embed content navigation enabled for this looker
	EmbedContentManagement   *bool     `json:"embed_content_management,omitempty"`    // Is embed content management enabled for this Looker
	StrictSameoriginForLogin *bool     `json:"strict_sameorigin_for_login,omitempty"` // When true, prohibits the use of Looker login pages in non-Looker iframes. When false, Looker login pages may be used in non-Looker hosted iframes.
	LookFilters              *bool     `json:"look_filters,omitempty"`                // When true, filters are enabled on embedded Looks
	HideLookNavigation       *bool     `json:"hide_look_navigation,omitempty"`        // When true, removes navigation to Looks from embedded dashboards and explores.
}

type EmbedCookielessSessionAcquire struct {
	SessionLength         *int64                  `json:"session_length,omitempty"`          // Number of seconds the signed embed session will be valid after the embed session is started. Defaults to 300 seconds. Maximum session length accepted is 2592000 seconds (30 days).
	ForceLogoutLogin      *bool                   `json:"force_logout_login,omitempty"`      // When true, the embed session will purge any residual Looker login state (such as in browser cookies) before creating a new login state with the given embed user info. Defaults to true.
	ExternalUserId        *string                 `json:"external_user_id,omitempty"`        // A value from an external system that uniquely identifies the embed user. Since the user_ids of Looker embed users may change with every embed session, external_user_id provides a way to assign a known, stable user identifier across multiple embed sessions. When the same external user id value is used for a new embed session, any existing session is terminated and existing access grants are replaced with the access grants associated with the new embed session.
	FirstName             *string                 `json:"first_name,omitempty"`              // First name of the embed user. Defaults to 'Embed' if not specified
	LastName              *string                 `json:"last_name,omitempty"`               // Last name of the embed user. Defaults to 'User' if not specified
	UserTimezone          *string                 `json:"user_timezone,omitempty"`           // Sets the user timezone for the embed user session, if the User Specific Timezones setting is enabled in the Looker admin settings. A value of `null` forces the embed user to use the Looker Application Default Timezone. You MUST omit this property from the request if the User Specific Timezones setting is disabled. Timezone values are validated against the IANA Timezone standard and can be seen in the Application Time Zone dropdown list on the Looker General Settings admin page.
	Permissions           *[]string               `json:"permissions,omitempty"`             // List of Looker permission names to grant to the embed user. Requested permissions will be filtered to permissions allowed for embed sessions.
	Models                *[]string               `json:"models,omitempty"`                  // List of model names that the embed user may access
	GroupIds              *[]string               `json:"group_ids,omitempty"`               // List of Looker group ids in which to enroll the embed user
	ExternalGroupId       *string                 `json:"external_group_id,omitempty"`       // A unique value identifying an embed-exclusive group. Multiple embed users using the same `external_group_id` value will be able to share Looker content with each other. Content and embed users associated with the `external_group_id` will not be accessible to normal Looker users or embed users not associated with this `external_group_id`.
	UserAttributes        *map[string]interface{} `json:"user_attributes,omitempty"`         // A dictionary of name-value pairs associating a Looker user attribute name with a value.
	EmbedDomain           *string                 `json:"embed_domain,omitempty"`            // The domain of the server embedding the Looker IFRAME. This is an alternative to specifying the domain in the embedded domain allow list in the Looker embed admin page.
	SessionReferenceToken *string                 `json:"session_reference_token,omitempty"` // Token referencing the embed session and is used to generate new authentication, navigation and api tokens.
}

type EmbedCookielessSessionAcquireResponse struct {
	AuthenticationToken      *string `json:"authentication_token,omitempty"`        // One time token used to create or to attach to an embedded session in the Looker application server.
	AuthenticationTokenTtl   *int64  `json:"authentication_token_ttl,omitempty"`    // Authentication token time to live in seconds.
	NavigationToken          *string `json:"navigation_token,omitempty"`            // Token used to load and navigate between Looker pages.
	NavigationTokenTtl       *int64  `json:"navigation_token_ttl,omitempty"`        // Navigation token time to live in seconds.
	ApiToken                 *string `json:"api_token,omitempty"`                   // Token to used to call Looker APIs.
	ApiTokenTtl              *int64  `json:"api_token_ttl,omitempty"`               // Api token time to live in seconds.
	SessionReferenceToken    *string `json:"session_reference_token,omitempty"`     // Token referencing the actual embed session. It is used to generate new api, navigation and authentication tokens. api and navigation tokens are short lived and must be refreshed regularly. A new authentication token must be acquired for each IFRAME that is created. The session_reference_token should be kept secure, ideally in the embed hosts application server.
	SessionReferenceTokenTtl *int64  `json:"session_reference_token_ttl,omitempty"` // Session reference token time to live in seconds. Note that this is the same as actual embed session. The session is expired when the value is set to zero. It is important to note that the generate token endpoint does NOT return an error when the embed session has expired. If an embedding application needs to monitor expiration of embed sessions, check this property for a value of zero.
}

type EmbedCookielessSessionGenerateTokens struct {
	SessionReferenceToken string  `json:"session_reference_token"`    // Token referencing the embed session and is used to generate new authentication, navigation and api tokens.
	NavigationToken       *string `json:"navigation_token,omitempty"` // Token used to load and navigate between Looker pages.
	ApiToken              *string `json:"api_token,omitempty"`        // Token to used to call Looker APIs.
}

type EmbedCookielessSessionGenerateTokensResponse struct {
	NavigationToken          *string `json:"navigation_token,omitempty"`            // Token used to load and navigate between Looker pages.
	NavigationTokenTtl       *int64  `json:"navigation_token_ttl,omitempty"`        // Navigation token time to live in seconds.
	ApiToken                 *string `json:"api_token,omitempty"`                   // Token to used to call Looker APIs.
	ApiTokenTtl              *int64  `json:"api_token_ttl,omitempty"`               // Api token time to live in seconds.
	SessionReferenceToken    string  `json:"session_reference_token"`               // Token referencing the embed session and is used to generate new authentication, navigation and api tokens.
	SessionReferenceTokenTtl *int64  `json:"session_reference_token_ttl,omitempty"` // Session reference token time to live in seconds. Note that this is the same as actual session.
}

type EmbedParams struct {
	TargetUrl        string `json:"target_url"`                   // The complete URL of the Looker UI page to display in the embed context. For example, to display the dashboard with id 34, `target_url` would look like: `https://mycompany.looker.com:9999/dashboards/34`. `target_uri` MUST contain a scheme (HTTPS), domain name, and URL path. Port must be included if it is required to reach the Looker server from browser clients. If the Looker instance is behind a load balancer or other proxy, `target_uri` must be the public-facing domain name and port required to reach the Looker instance, not the actual internal network machine name of the Looker instance.
	SessionLength    *int64 `json:"session_length,omitempty"`     // Number of seconds the signed embed session will be valid after the embed session is started. Defaults to 300 seconds. Maximum session length accepted is 2592000 seconds (30 days).
	ForceLogoutLogin *bool  `json:"force_logout_login,omitempty"` // When true, the embed session will purge any residual Looker login state (such as in browser cookies) before creating a new login state with the given embed user info. Defaults to true.
}

type EmbedSecret struct {
	Algorithm  *string     `json:"algorithm,omitempty"`   // Signing algorithm to use with this secret. Either `hmac/sha-256`(default) or `hmac/sha-1`
	CreatedAt  *string     `json:"created_at,omitempty"`  // When secret was created
	Enabled    *bool       `json:"enabled,omitempty"`     // Is this secret currently enabled
	Id         *string     `json:"id,omitempty"`          // Unique Id
	Secret     *string     `json:"secret,omitempty"`      // Secret for use with SSO embedding
	UserId     *string     `json:"user_id,omitempty"`     // Id of user who created this secret
	SecretType *SecretType `json:"secret_type,omitempty"` // Field to distinguish between SSO secrets and JWT secrets Valid values are: "SSO", "JWT".
}

type EmbedSsoParams struct {
	TargetUrl        string                  `json:"target_url"`                   // The complete URL of the Looker UI page to display in the embed context. For example, to display the dashboard with id 34, `target_url` would look like: `https://mycompany.looker.com:9999/dashboards/34`. `target_uri` MUST contain a scheme (HTTPS), domain name, and URL path. Port must be included if it is required to reach the Looker server from browser clients. If the Looker instance is behind a load balancer or other proxy, `target_uri` must be the public-facing domain name and port required to reach the Looker instance, not the actual internal network machine name of the Looker instance.
	SessionLength    *int64                  `json:"session_length,omitempty"`     // Number of seconds the signed embed session will be valid after the embed session is started. Defaults to 300 seconds. Maximum session length accepted is 2592000 seconds (30 days).
	ForceLogoutLogin *bool                   `json:"force_logout_login,omitempty"` // When true, the embed session will purge any residual Looker login state (such as in browser cookies) before creating a new login state with the given embed user info. Defaults to true.
	ExternalUserId   *string                 `json:"external_user_id,omitempty"`   // A value from an external system that uniquely identifies the embed user. Since the user_ids of Looker embed users may change with every embed session, external_user_id provides a way to assign a known, stable user identifier across multiple embed sessions. When the same external user id value is used for a new embed session, any existing session is terminated and existing access grants are replaced with the access grants associated with the new embed session.
	FirstName        *string                 `json:"first_name,omitempty"`         // First name of the embed user. Defaults to 'Embed' if not specified
	LastName         *string                 `json:"last_name,omitempty"`          // Last name of the embed user. Defaults to 'User' if not specified
	UserTimezone     *string                 `json:"user_timezone,omitempty"`      // Sets the user timezone for the embed user session, if the User Specific Timezones setting is enabled in the Looker admin settings. A value of `null` forces the embed user to use the Looker Application Default Timezone. You MUST omit this property from the request if the User Specific Timezones setting is disabled. Timezone values are validated against the IANA Timezone standard and can be seen in the Application Time Zone dropdown list on the Looker General Settings admin page.
	Permissions      *[]string               `json:"permissions,omitempty"`        // List of Looker permission names to grant to the embed user. Requested permissions will be filtered to permissions allowed for embed sessions.
	Models           *[]string               `json:"models,omitempty"`             // List of model names that the embed user may access
	GroupIds         *[]string               `json:"group_ids,omitempty"`          // List of Looker group ids in which to enroll the embed user
	ExternalGroupId  *string                 `json:"external_group_id,omitempty"`  // A unique value identifying an embed-exclusive group. Multiple embed users using the same `external_group_id` value will be able to share Looker content with each other. Content and embed users associated with the `external_group_id` will not be accessible to normal Looker users or embed users not associated with this `external_group_id`.
	UserAttributes   *map[string]interface{} `json:"user_attributes,omitempty"`    // A dictionary of name-value pairs associating a Looker user attribute name with a value.
	SecretId         *string                 `json:"secret_id,omitempty"`          // Id of the embed secret to use to sign this SSO url. If specified, the value must be an id of a valid (active) secret defined in the Looker instance. If not specified, the URL will be signed with the newest active embed secret defined in the Looker instance.
	EmbedDomain      *string                 `json:"embed_domain,omitempty"`       // Optional. URL of the domain hosting the signed embed URL. If provided and valid, the embed_domain will be added to the embed domain allowlist if it is not currently in the list
}

type EmbedUrlResponse struct {
	Url *string `json:"url,omitempty"` // The embed URL. Any modification to this string will make the URL unusable.
}

type Error struct {
	Message          string `json:"message"`           // Error details
	DocumentationUrl string `json:"documentation_url"` // Documentation link
}

type ExternalOauthApplication struct {
	Can          *map[string]bool `json:"can,omitempty"`           // Operations the current user is able to perform on this object
	Id           *string          `json:"id,omitempty"`            // ID of this OAuth Application
	Name         *string          `json:"name,omitempty"`          // The name of this application.  For Snowflake connections, this should be the name of the host database.
	ClientId     *string          `json:"client_id,omitempty"`     // The OAuth Client ID for this application
	ClientSecret *string          `json:"client_secret,omitempty"` // (Write-Only) The OAuth Client Secret for this application
	TenantId     *string          `json:"tenant_id,omitempty"`     // The OAuth Tenant ID for this application
	DialectName  *string          `json:"dialect_name,omitempty"`  // The database dialect for this application.
	CreatedAt    *time.Time       `json:"created_at,omitempty"`    // Creation time for this application
}

type FillStyle string

const FillStyle_Enumeration FillStyle = "enumeration"
const FillStyle_Range FillStyle = "range"

type Folder struct {
	Name                 string                `json:"name"`                             // Unique Name
	ParentId             *string               `json:"parent_id,omitempty"`              // Id of Parent. If the parent id is null, this is a root-level entry
	Id                   *string               `json:"id,omitempty"`                     // Unique Id
	ContentMetadataId    *string               `json:"content_metadata_id,omitempty"`    // Id of content metadata
	CreatedAt            *time.Time            `json:"created_at,omitempty"`             // Time the space was created
	CreatorId            *string               `json:"creator_id,omitempty"`             // User Id of Creator
	ChildCount           *int64                `json:"child_count,omitempty"`            // Children Count
	ExternalId           *string               `json:"external_id,omitempty"`            // Embedder's Id if this folder was autogenerated as an embedding shared folder via 'external_group_id' in an SSO embed login
	IsEmbed              *bool                 `json:"is_embed,omitempty"`               // Folder is an embed folder
	IsEmbedSharedRoot    *bool                 `json:"is_embed_shared_root,omitempty"`   // Folder is the root embed shared folder
	IsEmbedUsersRoot     *bool                 `json:"is_embed_users_root,omitempty"`    // Folder is the root embed users folder
	IsPersonal           *bool                 `json:"is_personal,omitempty"`            // Folder is a user's personal folder
	IsPersonalDescendant *bool                 `json:"is_personal_descendant,omitempty"` // Folder is descendant of a user's personal folder
	IsSharedRoot         *bool                 `json:"is_shared_root,omitempty"`         // Folder is the root shared folder
	IsUsersRoot          *bool                 `json:"is_users_root,omitempty"`          // Folder is the root user folder
	Can                  *map[string]bool      `json:"can,omitempty"`                    // Operations the current user is able to perform on this object
	Dashboards           *[]DashboardBase      `json:"dashboards,omitempty"`             // Dashboards
	Looks                *[]LookWithDashboards `json:"looks,omitempty"`                  // Looks
}

type FolderBase struct {
	Name                 string           `json:"name"`                             // Unique Name
	ParentId             *string          `json:"parent_id,omitempty"`              // Id of Parent. If the parent id is null, this is a root-level entry
	Id                   *string          `json:"id,omitempty"`                     // Unique Id
	ContentMetadataId    *string          `json:"content_metadata_id,omitempty"`    // Id of content metadata
	CreatedAt            *time.Time       `json:"created_at,omitempty"`             // Time the folder was created
	CreatorId            *string          `json:"creator_id,omitempty"`             // User Id of Creator
	ChildCount           *int64           `json:"child_count,omitempty"`            // Children Count
	ExternalId           *string          `json:"external_id,omitempty"`            // Embedder's Id if this folder was autogenerated as an embedding shared folder via 'external_group_id' in an SSO embed login
	IsEmbed              *bool            `json:"is_embed,omitempty"`               // Folder is an embed folder
	IsEmbedSharedRoot    *bool            `json:"is_embed_shared_root,omitempty"`   // Folder is the root embed shared folder
	IsEmbedUsersRoot     *bool            `json:"is_embed_users_root,omitempty"`    // Folder is the root embed users folder
	IsPersonal           *bool            `json:"is_personal,omitempty"`            // Folder is a user's personal folder
	IsPersonalDescendant *bool            `json:"is_personal_descendant,omitempty"` // Folder is descendant of a user's personal folder
	IsSharedRoot         *bool            `json:"is_shared_root,omitempty"`         // Folder is the root shared folder
	IsUsersRoot          *bool            `json:"is_users_root,omitempty"`          // Folder is the root user folder
	Can                  *map[string]bool `json:"can,omitempty"`                    // Operations the current user is able to perform on this object
}

type Format string

const Format_Topojson Format = "topojson"
const Format_VectorTileRegion Format = "vector_tile_region"

type GitBranch struct {
	Can          *map[string]bool `json:"can,omitempty"`           // Operations the current user is able to perform on this object
	Name         *string          `json:"name,omitempty"`          // The short name on the local. Updating `name` results in `git checkout <new_name>`
	Remote       *string          `json:"remote,omitempty"`        // The name of the remote
	RemoteName   *string          `json:"remote_name,omitempty"`   // The short name on the remote
	Error        *string          `json:"error,omitempty"`         // Name of error
	Message      *string          `json:"message,omitempty"`       // Message describing an error if present
	OwnerName    *string          `json:"owner_name,omitempty"`    // Name of the owner of a personal branch
	Readonly     *bool            `json:"readonly,omitempty"`      // Whether or not this branch is readonly
	Personal     *bool            `json:"personal,omitempty"`      // Whether or not this branch is a personal branch - readonly for all developers except the owner
	IsLocal      *bool            `json:"is_local,omitempty"`      // Whether or not a local ref exists for the branch
	IsRemote     *bool            `json:"is_remote,omitempty"`     // Whether or not a remote ref exists for the branch
	IsProduction *bool            `json:"is_production,omitempty"` // Whether or not this is the production branch
	AheadCount   *int64           `json:"ahead_count,omitempty"`   // Number of commits the local branch is ahead of the remote
	BehindCount  *int64           `json:"behind_count,omitempty"`  // Number of commits the local branch is behind the remote
	CommitAt     *int64           `json:"commit_at,omitempty"`     // UNIX timestamp at which this branch was last committed.
	Ref          *string          `json:"ref,omitempty"`           // The resolved ref of this branch. Updating `ref` results in `git reset --hard <new_ref>``.
	RemoteRef    *string          `json:"remote_ref,omitempty"`    // The resolved ref of this branch remote.
}

type GitConnectionTest struct {
	Can         *map[string]bool `json:"can,omitempty"`         // Operations the current user is able to perform on this object
	Description *string          `json:"description,omitempty"` // Human readable string describing the test
	Id          *string          `json:"id,omitempty"`          // A short string, uniquely naming this test
}

type GitConnectionTestResult struct {
	Can     *map[string]bool `json:"can,omitempty"`     // Operations the current user is able to perform on this object
	Id      *string          `json:"id,omitempty"`      // A short string, uniquely naming this test
	Message *string          `json:"message,omitempty"` // Additional data from the test
	Status  *string          `json:"status,omitempty"`  // Either 'pass' or 'fail'
}

type GitStatus struct {
	Action     *string `json:"action,omitempty"`     // Git action: add, delete, etc
	Conflict   *bool   `json:"conflict,omitempty"`   // When true, changes to the local file conflict with the remote repository
	Revertable *bool   `json:"revertable,omitempty"` // When true, the file can be reverted to an earlier state
	Text       *string `json:"text,omitempty"`       // Git description of the action
}

type Group struct {
	Can                     *map[string]bool `json:"can,omitempty"`                         // Operations the current user is able to perform on this object
	CanAddToContentMetadata *bool            `json:"can_add_to_content_metadata,omitempty"` // Group can be used in content access controls
	ContainsCurrentUser     *bool            `json:"contains_current_user,omitempty"`       // Currently logged in user is group member
	ExternalGroupId         *string          `json:"external_group_id,omitempty"`           // External Id group if embed group
	ExternallyManaged       *bool            `json:"externally_managed,omitempty"`          // Group membership controlled outside of Looker
	Id                      *string          `json:"id,omitempty"`                          // Unique Id
	IncludeByDefault        *bool            `json:"include_by_default,omitempty"`          // New users are added to this group by default
	Name                    *string          `json:"name,omitempty"`                        // Name of group
	UserCount               *int64           `json:"user_count,omitempty"`                  // Number of users included in this group
}

type GroupHierarchy struct {
	Can                     *map[string]bool `json:"can,omitempty"`                         // Operations the current user is able to perform on this object
	CanAddToContentMetadata *bool            `json:"can_add_to_content_metadata,omitempty"` // Group can be used in content access controls
	ContainsCurrentUser     *bool            `json:"contains_current_user,omitempty"`       // Currently logged in user is group member
	ExternalGroupId         *string          `json:"external_group_id,omitempty"`           // External Id group if embed group
	ExternallyManaged       *bool            `json:"externally_managed,omitempty"`          // Group membership controlled outside of Looker
	Id                      *string          `json:"id,omitempty"`                          // Unique Id
	IncludeByDefault        *bool            `json:"include_by_default,omitempty"`          // New users are added to this group by default
	Name                    *string          `json:"name,omitempty"`                        // Name of group
	UserCount               *int64           `json:"user_count,omitempty"`                  // Number of users included in this group
	ParentGroupIds          *[]string        `json:"parent_group_ids,omitempty"`            // IDs of parents of this group
	RoleIds                 *[]string        `json:"role_ids,omitempty"`                    // Role IDs assigned to group
}

// WARNING: no writeable properties found for POST, PUT, or PATCH
type GroupIdForGroupInclusion struct {
	GroupId *string `json:"group_id,omitempty"` // Id of group
}

// WARNING: no writeable properties found for POST, PUT, or PATCH
type GroupIdForGroupUserInclusion struct {
	UserId *string `json:"user_id,omitempty"` // Id of user
}

type GroupSearch struct {
	Can                     *map[string]bool `json:"can,omitempty"`                         // Operations the current user is able to perform on this object
	CanAddToContentMetadata *bool            `json:"can_add_to_content_metadata,omitempty"` // Group can be used in content access controls
	ContainsCurrentUser     *bool            `json:"contains_current_user,omitempty"`       // Currently logged in user is group member
	ExternalGroupId         *string          `json:"external_group_id,omitempty"`           // External Id group if embed group
	ExternallyManaged       *bool            `json:"externally_managed,omitempty"`          // Group membership controlled outside of Looker
	Id                      *string          `json:"id,omitempty"`                          // Unique Id
	IncludeByDefault        *bool            `json:"include_by_default,omitempty"`          // New users are added to this group by default
	Name                    *string          `json:"name,omitempty"`                        // Name of group
	UserCount               *int64           `json:"user_count,omitempty"`                  // Number of users included in this group
	Roles                   *[]Role          `json:"roles,omitempty"`                       // Roles assigned to group
}

type HomepageItem struct {
	Can                   *map[string]bool `json:"can,omitempty"`                      // Operations the current user is able to perform on this object
	ContentCreatedBy      *string          `json:"content_created_by,omitempty"`       // Name of user who created the content this item is based on
	ContentFavoriteId     *string          `json:"content_favorite_id,omitempty"`      // Content favorite id associated with the item this content is based on
	ContentMetadataId     *string          `json:"content_metadata_id,omitempty"`      // Content metadata id associated with the item this content is based on
	ContentUpdatedAt      *string          `json:"content_updated_at,omitempty"`       // Last time the content that this item is based on was updated
	CustomDescription     *string          `json:"custom_description,omitempty"`       // Custom description entered by the user, if present
	CustomImageDataBase64 *string          `json:"custom_image_data_base64,omitempty"` // (Write-Only) base64 encoded image data
	CustomImageUrl        *string          `json:"custom_image_url,omitempty"`         // Custom image_url entered by the user, if present
	CustomTitle           *string          `json:"custom_title,omitempty"`             // Custom title entered by the user, if present
	CustomUrl             *string          `json:"custom_url,omitempty"`               // Custom url entered by the user, if present
	DashboardId           *string          `json:"dashboard_id,omitempty"`             // Dashboard to base this item on
	Description           *string          `json:"description,omitempty"`              // The actual description for display
	FavoriteCount         *int64           `json:"favorite_count,omitempty"`           // Number of times content has been favorited, if present
	HomepageSectionId     *string          `json:"homepage_section_id,omitempty"`      // Associated Homepage Section
	Id                    *string          `json:"id,omitempty"`                       // Unique Id
	ImageUrl              *string          `json:"image_url,omitempty"`                // The actual image_url for display
	Location              *string          `json:"location,omitempty"`                 // The container folder name of the content
	LookId                *string          `json:"look_id,omitempty"`                  // Look to base this item on
	LookmlDashboardId     *string          `json:"lookml_dashboard_id,omitempty"`      // LookML Dashboard to base this item on
	Order                 *int64           `json:"order,omitempty"`                    // An arbitrary integer representing the sort order within the section
	SectionFetchTime      *float32         `json:"section_fetch_time,omitempty"`       // Number of seconds it took to fetch the section this item is in
	Title                 *string          `json:"title,omitempty"`                    // The actual title for display
	Url                   *string          `json:"url,omitempty"`                      // The actual url for display
	UseCustomDescription  *bool            `json:"use_custom_description,omitempty"`   // Whether the custom description should be used instead of the content description, if the item is associated with content
	UseCustomImage        *bool            `json:"use_custom_image,omitempty"`         // Whether the custom image should be used instead of the content image, if the item is associated with content
	UseCustomTitle        *bool            `json:"use_custom_title,omitempty"`         // Whether the custom title should be used instead of the content title, if the item is associated with content
	UseCustomUrl          *bool            `json:"use_custom_url,omitempty"`           // Whether the custom url should be used instead of the content url, if the item is associated with content
	ViewCount             *int64           `json:"view_count,omitempty"`               // Number of times content has been viewed, if present
}

type HomepageSection struct {
	Can              *map[string]bool `json:"can,omitempty"`                // Operations the current user is able to perform on this object
	CreatedAt        *time.Time       `json:"created_at,omitempty"`         // Time at which this section was created.
	DeletedAt        *time.Time       `json:"deleted_at,omitempty"`         // Time at which this section was deleted.
	DetailUrl        *string          `json:"detail_url,omitempty"`         // A URL pointing to a page showing further information about the content in the section.
	HomepageId       *string          `json:"homepage_id,omitempty"`        // Id reference to parent homepage
	HomepageItems    *[]HomepageItem  `json:"homepage_items,omitempty"`     // Items in the homepage section
	Id               *string          `json:"id,omitempty"`                 // Unique Id
	IsHeader         *bool            `json:"is_header,omitempty"`          // Is this a header section (has no items)
	ItemOrder        *[]string        `json:"item_order,omitempty"`         // ids of the homepage items in the order they should be displayed
	Title            *string          `json:"title,omitempty"`              // Name of row
	UpdatedAt        *time.Time       `json:"updated_at,omitempty"`         // Time at which this section was last updated.
	Description      *string          `json:"description,omitempty"`        // Description of the content found in this section.
	VisibleItemOrder *[]string        `json:"visible_item_order,omitempty"` // ids of the homepage items the user can see in the order they should be displayed
}

type ImportedProject struct {
	Name     *string `json:"name,omitempty"`      // Dependency name
	Url      *string `json:"url,omitempty"`       // Url for a remote dependency
	Ref      *string `json:"ref,omitempty"`       // Ref for a remote dependency
	IsRemote *bool   `json:"is_remote,omitempty"` // Flag signifying if a dependency is remote or local
}

type Integration struct {
	Can                               *map[string]bool                     `json:"can,omitempty"`                                 // Operations the current user is able to perform on this object
	Id                                *string                              `json:"id,omitempty"`                                  // ID of the integration.
	IntegrationHubId                  *string                              `json:"integration_hub_id,omitempty"`                  // ID of the integration hub.
	Label                             *string                              `json:"label,omitempty"`                               // Label for the integration.
	Description                       *string                              `json:"description,omitempty"`                         // Description of the integration.
	Enabled                           *bool                                `json:"enabled,omitempty"`                             // Whether the integration is available to users.
	Params                            *[]IntegrationParam                  `json:"params,omitempty"`                              // Array of params for the integration.
	SupportedFormats                  *[]SupportedFormats                  `json:"supported_formats,omitempty"`                   // A list of data formats the integration supports. If unspecified, the default is all data formats. Valid values are: "txt", "csv", "inline_json", "json", "json_label", "json_detail", "json_detail_lite_stream", "json_bi", "xlsx", "html", "wysiwyg_pdf", "assembled_pdf", "wysiwyg_png", "csv_zip".
	SupportedActionTypes              *[]SupportedActionTypes              `json:"supported_action_types,omitempty"`              // A list of action types the integration supports. Valid values are: "cell", "query", "dashboard", "none".
	SupportedFormattings              *[]SupportedFormattings              `json:"supported_formattings,omitempty"`               // A list of formatting options the integration supports. If unspecified, defaults to all formats. Valid values are: "formatted", "unformatted".
	SupportedVisualizationFormattings *[]SupportedVisualizationFormattings `json:"supported_visualization_formattings,omitempty"` // A list of visualization formatting options the integration supports. If unspecified, defaults to all formats. Valid values are: "apply", "noapply".
	SupportedDownloadSettings         *[]SupportedDownloadSettings         `json:"supported_download_settings,omitempty"`         // A list of all the download mechanisms the integration supports. The order of values is not significant: Looker will select the most appropriate supported download mechanism for a given query. The integration must ensure it can handle any of the mechanisms it claims to support. If unspecified, this defaults to all download setting values. Valid values are: "push", "url".
	IconUrl                           *string                              `json:"icon_url,omitempty"`                            // URL to an icon for the integration.
	UsesOauth                         *bool                                `json:"uses_oauth,omitempty"`                          // Whether the integration uses oauth.
	RequiredFields                    *[]IntegrationRequiredField          `json:"required_fields,omitempty"`                     // A list of descriptions of required fields that this integration is compatible with. If there are multiple entries in this list, the integration requires more than one field. If unspecified, no fields will be required.
	PrivacyLink                       *string                              `json:"privacy_link,omitempty"`                        // Link to privacy policy for destination
	DelegateOauth                     *bool                                `json:"delegate_oauth,omitempty"`                      // Whether the integration uses delegate oauth, which allows federation between an integration installation scope specific entity (like org, group, and team, etc.) and Looker.
	InstalledDelegateOauthTargets     *[]string                            `json:"installed_delegate_oauth_targets,omitempty"`    // Whether the integration is available to users.
}

type IntegrationHub struct {
	Can                    *map[string]bool `json:"can,omitempty"`                      // Operations the current user is able to perform on this object
	Id                     *string          `json:"id,omitempty"`                       // ID of the hub.
	Url                    *string          `json:"url,omitempty"`                      // URL of the hub.
	Label                  *string          `json:"label,omitempty"`                    // Label of the hub.
	Official               *bool            `json:"official,omitempty"`                 // Whether this hub is a first-party integration hub operated by Looker.
	FetchErrorMessage      *string          `json:"fetch_error_message,omitempty"`      // An error message, present if the integration hub metadata could not be fetched. If this is present, the integration hub is unusable.
	AuthorizationToken     *string          `json:"authorization_token,omitempty"`      // (Write-Only) An authorization key that will be sent to the integration hub on every request.
	HasAuthorizationToken  *bool            `json:"has_authorization_token,omitempty"`  // Whether the authorization_token is set for the hub.
	LegalAgreementSigned   *bool            `json:"legal_agreement_signed,omitempty"`   // Whether the legal agreement message has been signed by the user. This only matters if legal_agreement_required is true.
	LegalAgreementRequired *bool            `json:"legal_agreement_required,omitempty"` // Whether the legal terms for the integration hub are required before use.
	LegalAgreementText     *string          `json:"legal_agreement_text,omitempty"`     // The legal agreement text for this integration hub.
}

type IntegrationParam struct {
	Name              *string `json:"name,omitempty"`                // Name of the parameter.
	Label             *string `json:"label,omitempty"`               // Label of the parameter.
	Description       *string `json:"description,omitempty"`         // Short description of the parameter.
	Required          *bool   `json:"required,omitempty"`            // Whether the parameter is required to be set to use the destination. If unspecified, this defaults to false.
	HasValue          *bool   `json:"has_value,omitempty"`           // Whether the parameter has a value set.
	Value             *string `json:"value,omitempty"`               // The current value of the parameter. Always null if the value is sensitive. When writing, null values will be ignored. Set the value to an empty string to clear it.
	UserAttributeName *string `json:"user_attribute_name,omitempty"` // When present, the param's value comes from this user attribute instead of the 'value' parameter. Set to null to use the 'value'.
	Sensitive         *bool   `json:"sensitive,omitempty"`           // Whether the parameter contains sensitive data like API credentials. If unspecified, this defaults to true.
	PerUser           *bool   `json:"per_user,omitempty"`            // When true, this parameter must be assigned to a user attribute in the admin panel (instead of a constant value), and that value may be updated by the user as part of the integration flow.
	DelegateOauthUrl  *string `json:"delegate_oauth_url,omitempty"`  // When present, the param represents the oauth url the user will be taken to.
}

type IntegrationRequiredField struct {
	Tag     *string   `json:"tag,omitempty"`      // Matches a field that has this tag.
	AnyTag  *[]string `json:"any_tag,omitempty"`  // If present, supersedes 'tag' and matches a field that has any of the provided tags.
	AllTags *[]string `json:"all_tags,omitempty"` // If present, supersedes 'tag' and matches a field that has all of the provided tags.
}

type IntegrationTestResult struct {
	Success             *bool                `json:"success,omitempty"`               // Whether or not the test was successful
	Message             *string              `json:"message,omitempty"`               // A message representing the results of the test.
	DelegateOauthResult *[]DelegateOauthTest `json:"delegate_oauth_result,omitempty"` // An array of connection test result for delegate oauth actions.
}

type InternalHelpResources struct {
	Can     *map[string]bool `json:"can,omitempty"`     // Operations the current user is able to perform on this object
	Enabled *bool            `json:"enabled,omitempty"` // If true and internal help resources content is not blank then the link for internal help resources will be shown in the help menu and the content displayed within Looker
}

type InternalHelpResourcesContent struct {
	Can              *map[string]bool `json:"can,omitempty"`               // Operations the current user is able to perform on this object
	OrganizationName *string          `json:"organization_name,omitempty"` // Text to display in the help menu item which will display the internal help resources
	MarkdownContent  *string          `json:"markdown_content,omitempty"`  // Content to be displayed in the internal help resources page/modal
}

type InvestigativeContentType string

const InvestigativeContentType_Dashboard InvestigativeContentType = "dashboard"

type JsonBi struct {
	Metadata JsonBiMetadata `json:"metadata"`
	Rows     []string       `json:"rows"` // Json query results
}

type JsonBiBigQueryMetadata struct {
	TotalBytesProcessed int64 `json:"total_bytes_processed"` // Total bytes processed by the BigQuery job
	BackendCacheHit     bool  `json:"backend_cache_hit"`     // Return whether or not query results were served from the BigQuery cache.
}

type JsonBiField struct {
	Sql               string `json:"sql"`                 // SQL expressions for the field
	View              string `json:"view"`                // Explore name
	DimensionGroup    string `json:"dimension_group"`     // Which dimension group created this dimension
	Category          string `json:"category"`            // Dimension, Measure, etc.
	FieldGroupLabel   string `json:"field_group_label"`   // Field Group Label
	Name              string `json:"name"`                // Field Name
	Type              string `json:"type"`                // Field Type
	ViewLabel         string `json:"view_label"`          // View Label
	Label             string `json:"label"`               // Field Label
	FieldGroupVariant string `json:"field_group_variant"` // Field Group Variant
	Hidden            bool   `json:"hidden"`              // If the field is marked as hidden in the Lookml
	Description       string `json:"description"`         // Field Description
}

type JsonBiFields struct {
	Dimensions        []JsonBiField      `json:"dimensions"`                   // Dimensions represent a column in a table, or a computed value based on some sort of column manipulation or combination
	Measures          []JsonBiField      `json:"measures"`                     // Measures are similar to aggregate functions in SQL (for example, COUNT, SUM, AVG) and represent information about multiple rows
	Pivots            []JsonBiField      `json:"pivots"`                       // Pivots
	TableCalculations *[]JsonBiTableCalc `json:"table_calculations,omitempty"` // Table Calculations (beta: May not be included)
}

type JsonBiMetadata struct {
	BigQueryMetadata JsonBiBigQueryMetadata `json:"big_query_metadata"`
	Fields           JsonBiFields           `json:"fields"`
	Pivots           []JsonBiPivots         `json:"pivots"`            // Pivots
	HasSubtotals     bool                   `json:"has_subtotals"`     // If the query has subtotals
	HasTotals        bool                   `json:"has_totals"`        // If the query has totals
	ColumnsTruncated string                 `json:"columns_truncated"` // If the query results hit the maximum column limit and additional columns were truncated
	FilterExpression string                 `json:"filter_expression"` // Filter expression applied to the query results
	Filters          map[string]interface{} `json:"filters"`           // Filters applied to the query results
	Sql              string                 `json:"sql"`               // Raw sql query. Null if user does not have permission to view sql
}

type JsonBiPivots struct {
	Key        string                 `json:"key"`         // Pivot Column Value
	Data       map[string]interface{} `json:"data"`        // Pivot Data
	SortValues map[string]interface{} `json:"sort_values"` // Pivot Sort Values
	IsTotal    bool                   `json:"is_total"`    // If the value is a total
}

type JsonBiTableCalc struct {
	Name        string `json:"name"`         // Table Calc Name
	Label       string `json:"label"`        // Table Calc Label
	Align       string `json:"align"`        // Alignment
	Expression  string `json:"expression"`   // Evaluated table calculation expression
	ValueFormat string `json:"value_format"` // Value format
	Measure     bool   `json:"measure"`      // If table calculation is a measure
}

type LDAPConfig struct {
	Can                        *map[string]bool          `json:"can,omitempty"`                            // Operations the current user is able to perform on this object
	AlternateEmailLoginAllowed *bool                     `json:"alternate_email_login_allowed,omitempty"`  // Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
	AuthPassword               *string                   `json:"auth_password,omitempty"`                  // (Write-Only)  Password for the LDAP account used to access the LDAP server
	AuthRequiresRole           *bool                     `json:"auth_requires_role,omitempty"`             // Users will not be allowed to login at all unless a role for them is found in LDAP if set to true
	AuthUsername               *string                   `json:"auth_username,omitempty"`                  // Distinguished name of LDAP account used to access the LDAP server
	ConnectionHost             *string                   `json:"connection_host,omitempty"`                // LDAP server hostname
	ConnectionPort             *string                   `json:"connection_port,omitempty"`                // LDAP host port
	ConnectionTls              *bool                     `json:"connection_tls,omitempty"`                 // Use Transport Layer Security
	ConnectionTlsNoVerify      *bool                     `json:"connection_tls_no_verify,omitempty"`       // Do not verify peer when using TLS
	DefaultNewUserGroupIds     *[]string                 `json:"default_new_user_group_ids,omitempty"`     // (Write-Only)  Array of ids of groups that will be applied to new users the first time they login via LDAP
	DefaultNewUserGroups       *[]Group                  `json:"default_new_user_groups,omitempty"`        // (Read-only) Groups that will be applied to new users the first time they login via LDAP
	DefaultNewUserRoleIds      *[]string                 `json:"default_new_user_role_ids,omitempty"`      // (Write-Only)  Array of ids of roles that will be applied to new users the first time they login via LDAP
	DefaultNewUserRoles        *[]Role                   `json:"default_new_user_roles,omitempty"`         // (Read-only) Roles that will be applied to new users the first time they login via LDAP
	Enabled                    *bool                     `json:"enabled,omitempty"`                        // Enable/Disable LDAP authentication for the server
	ForceNoPage                *bool                     `json:"force_no_page,omitempty"`                  // Don't attempt to do LDAP search result paging (RFC 2696) even if the LDAP server claims to support it.
	Groups                     *[]LDAPGroupRead          `json:"groups,omitempty"`                         // (Read-only) Array of mappings between LDAP Groups and Looker Roles
	GroupsBaseDn               *string                   `json:"groups_base_dn,omitempty"`                 // Base dn for finding groups in LDAP searches
	GroupsFinderType           *string                   `json:"groups_finder_type,omitempty"`             // Identifier for a strategy for how Looker will search for groups in the LDAP server
	GroupsMemberAttribute      *string                   `json:"groups_member_attribute,omitempty"`        // LDAP Group attribute that signifies the members of the groups. Most commonly 'member'
	GroupsObjectclasses        *string                   `json:"groups_objectclasses,omitempty"`           // Optional comma-separated list of supported LDAP objectclass for groups when doing groups searches
	GroupsUserAttribute        *string                   `json:"groups_user_attribute,omitempty"`          // LDAP Group attribute that signifies the user in a group. Most commonly 'dn'
	GroupsWithRoleIds          *[]LDAPGroupWrite         `json:"groups_with_role_ids,omitempty"`           // (Read/Write) Array of mappings between LDAP Groups and arrays of Looker Role ids
	HasAuthPassword            *bool                     `json:"has_auth_password,omitempty"`              // (Read-only) Has the password been set for the LDAP account used to access the LDAP server
	MergeNewUsersByEmail       *bool                     `json:"merge_new_users_by_email,omitempty"`       // Merge first-time ldap login to existing user account by email addresses. When a user logs in for the first time via ldap this option will connect this user into their existing account by finding the account with a matching email address. Otherwise a new user account will be created for the user.
	ModifiedAt                 *string                   `json:"modified_at,omitempty"`                    // When this config was last modified
	ModifiedBy                 *string                   `json:"modified_by,omitempty"`                    // User id of user who last modified this config
	SetRolesFromGroups         *bool                     `json:"set_roles_from_groups,omitempty"`          // Set user roles in Looker based on groups from LDAP
	TestLdapPassword           *string                   `json:"test_ldap_password,omitempty"`             // (Write-Only)  Test LDAP user password. For ldap tests only.
	TestLdapUser               *string                   `json:"test_ldap_user,omitempty"`                 // (Write-Only)  Test LDAP user login id. For ldap tests only.
	UserAttributeMapEmail      *string                   `json:"user_attribute_map_email,omitempty"`       // Name of user record attributes used to indicate email address field
	UserAttributeMapFirstName  *string                   `json:"user_attribute_map_first_name,omitempty"`  // Name of user record attributes used to indicate first name
	UserAttributeMapLastName   *string                   `json:"user_attribute_map_last_name,omitempty"`   // Name of user record attributes used to indicate last name
	UserAttributeMapLdapId     *string                   `json:"user_attribute_map_ldap_id,omitempty"`     // Name of user record attributes used to indicate unique record id
	UserAttributes             *[]LDAPUserAttributeRead  `json:"user_attributes,omitempty"`                // (Read-only) Array of mappings between LDAP User Attributes and Looker User Attributes
	UserAttributesWithIds      *[]LDAPUserAttributeWrite `json:"user_attributes_with_ids,omitempty"`       // (Read/Write) Array of mappings between LDAP User Attributes and arrays of Looker User Attribute ids
	UserBindBaseDn             *string                   `json:"user_bind_base_dn,omitempty"`              // Distinguished name of LDAP node used as the base for user searches
	UserCustomFilter           *string                   `json:"user_custom_filter,omitempty"`             // (Optional) Custom RFC-2254 filter clause for use in finding user during login. Combined via 'and' with the other generated filter clauses.
	UserIdAttributeNames       *string                   `json:"user_id_attribute_names,omitempty"`        // Name(s) of user record attributes used for matching user login id (comma separated list)
	UserObjectclass            *string                   `json:"user_objectclass,omitempty"`               // (Optional) Name of user record objectclass used for finding user during login id
	AllowNormalGroupMembership *bool                     `json:"allow_normal_group_membership,omitempty"`  // Allow LDAP auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.
	AllowRolesFromNormalGroups *bool                     `json:"allow_roles_from_normal_groups,omitempty"` // LDAP auth'd users will be able to inherit roles from non-reflected Looker groups.
	AllowDirectRoles           *bool                     `json:"allow_direct_roles,omitempty"`             // Allows roles to be directly assigned to LDAP auth'd users.
	Url                        *string                   `json:"url,omitempty"`                            // Link to get this item
}

type LDAPConfigTestIssue struct {
	Severity *string `json:"severity,omitempty"` // Severity of the issue. Error or Warning
	Message  *string `json:"message,omitempty"`  // Message describing the issue
}

type LDAPConfigTestResult struct {
	Details *string                `json:"details,omitempty"` // Additional details for error cases
	Issues  *[]LDAPConfigTestIssue `json:"issues,omitempty"`  // Array of issues/considerations about the result
	Message *string                `json:"message,omitempty"` // Short human readable test about the result
	Status  *string                `json:"status,omitempty"`  // Test status code: always 'success' or 'error'
	Trace   *string                `json:"trace,omitempty"`   // A more detailed trace of incremental results during auth tests
	User    *LDAPUser              `json:"user,omitempty"`
	Url     *string                `json:"url,omitempty"` // Link to ldap config
}

type LDAPGroupRead struct {
	Id              *string `json:"id,omitempty"`                // Unique Id
	LookerGroupId   *string `json:"looker_group_id,omitempty"`   // Unique Id of group in Looker
	LookerGroupName *string `json:"looker_group_name,omitempty"` // Name of group in Looker
	Name            *string `json:"name,omitempty"`              // Name of group in LDAP
	Roles           *[]Role `json:"roles,omitempty"`             // Looker Roles
	Url             *string `json:"url,omitempty"`               // Link to ldap config
}

type LDAPGroupWrite struct {
	Id              *string   `json:"id,omitempty"`                // Unique Id
	LookerGroupId   *string   `json:"looker_group_id,omitempty"`   // Unique Id of group in Looker
	LookerGroupName *string   `json:"looker_group_name,omitempty"` // Name of group in Looker
	Name            *string   `json:"name,omitempty"`              // Name of group in LDAP
	RoleIds         *[]string `json:"role_ids,omitempty"`          // Looker Role Ids
	Url             *string   `json:"url,omitempty"`               // Link to ldap config
}

type LDAPUser struct {
	AllEmails  *[]string               `json:"all_emails,omitempty"` // Array of user's email addresses and aliases for use in migration
	Attributes *map[string]interface{} `json:"attributes,omitempty"` // Dictionary of user's attributes (name/value)
	Email      *string                 `json:"email,omitempty"`      // Primary email address
	FirstName  *string                 `json:"first_name,omitempty"` // First name
	Groups     *[]string               `json:"groups,omitempty"`     // Array of user's groups (group names only)
	LastName   *string                 `json:"last_name,omitempty"`  // Last Name
	LdapDn     *string                 `json:"ldap_dn,omitempty"`    // LDAP's distinguished name for the user record
	LdapId     *string                 `json:"ldap_id,omitempty"`    // LDAP's Unique ID for the user
	Roles      *[]string               `json:"roles,omitempty"`      // Array of user's roles (role names only)
	Url        *string                 `json:"url,omitempty"`        // Link to ldap config
}

type LDAPUserAttributeRead struct {
	Name           *string          `json:"name,omitempty"`            // Name of User Attribute in LDAP
	Required       *bool            `json:"required,omitempty"`        // Required to be in LDAP assertion for login to be allowed to succeed
	UserAttributes *[]UserAttribute `json:"user_attributes,omitempty"` // Looker User Attributes
	Url            *string          `json:"url,omitempty"`             // Link to ldap config
}

type LDAPUserAttributeWrite struct {
	Name             *string   `json:"name,omitempty"`               // Name of User Attribute in LDAP
	Required         *bool     `json:"required,omitempty"`           // Required to be in LDAP assertion for login to be allowed to succeed
	UserAttributeIds *[]string `json:"user_attribute_ids,omitempty"` // Looker User Attribute Ids
	Url              *string   `json:"url,omitempty"`                // Link to ldap config
}

type LegacyFeature struct {
	Can                       *map[string]bool `json:"can,omitempty"`                           // Operations the current user is able to perform on this object
	Id                        *string          `json:"id,omitempty"`                            // Unique Id
	Name                      *string          `json:"name,omitempty"`                          // Name
	Description               *string          `json:"description,omitempty"`                   // Description
	EnabledLocally            *bool            `json:"enabled_locally,omitempty"`               // Whether this feature has been enabled by a user
	Enabled                   *bool            `json:"enabled,omitempty"`                       // Whether this feature is currently enabled
	DisallowedAsOfVersion     *string          `json:"disallowed_as_of_version,omitempty"`      // Looker version where this feature became a legacy feature
	DisableOnUpgradeToVersion *string          `json:"disable_on_upgrade_to_version,omitempty"` // Looker version where this feature will be automatically disabled
	EndOfLifeVersion          *string          `json:"end_of_life_version,omitempty"`           // Future Looker version where this feature will be removed
	DocumentationUrl          *string          `json:"documentation_url,omitempty"`             // URL for documentation about this feature
	ApproximateDisableDate    *time.Time       `json:"approximate_disable_date,omitempty"`      // Approximate date that this feature will be automatically disabled.
	ApproximateEndOfLifeDate  *time.Time       `json:"approximate_end_of_life_date,omitempty"`  // Approximate date that this feature will be removed.
	HasDisabledOnUpgrade      *bool            `json:"has_disabled_on_upgrade,omitempty"`       // Whether this legacy feature may have been automatically disabled when upgrading to the current version.
}

type Locale struct {
	Code        *string `json:"code,omitempty"`         // Code for Locale
	NativeName  *string `json:"native_name,omitempty"`  // Name of Locale in its own language
	EnglishName *string `json:"english_name,omitempty"` // Name of Locale in English
}

type LocalizationSettings struct {
	DefaultLocale     *string `json:"default_locale,omitempty"`     // Default locale for localization
	LocalizationLevel *string `json:"localization_level,omitempty"` // Localization level - strict or permissive
}

type Look struct {
	Can                      *map[string]bool `json:"can,omitempty"`                        // Operations the current user is able to perform on this object
	ContentMetadataId        *string          `json:"content_metadata_id,omitempty"`        // Id of content metadata
	Id                       *string          `json:"id,omitempty"`                         // Unique Id
	Title                    *string          `json:"title,omitempty"`                      // Look Title
	UserId                   *string          `json:"user_id,omitempty"`                    // User Id
	ContentFavoriteId        *string          `json:"content_favorite_id,omitempty"`        // Content Favorite Id
	CreatedAt                *time.Time       `json:"created_at,omitempty"`                 // Time that the Look was created.
	Deleted                  *bool            `json:"deleted,omitempty"`                    // Whether or not a look is 'soft' deleted.
	DeletedAt                *time.Time       `json:"deleted_at,omitempty"`                 // Time that the Look was deleted.
	DeleterId                *string          `json:"deleter_id,omitempty"`                 // Id of User that deleted the look.
	Description              *string          `json:"description,omitempty"`                // Description
	EmbedUrl                 *string          `json:"embed_url,omitempty"`                  // Embed Url
	ExcelFileUrl             *string          `json:"excel_file_url,omitempty"`             // Excel File Url
	FavoriteCount            *int64           `json:"favorite_count,omitempty"`             // Number of times favorited
	GoogleSpreadsheetFormula *string          `json:"google_spreadsheet_formula,omitempty"` // Google Spreadsheet Formula
	ImageEmbedUrl            *string          `json:"image_embed_url,omitempty"`            // Image Embed Url
	IsRunOnLoad              *bool            `json:"is_run_on_load,omitempty"`             // auto-run query when Look viewed
	LastAccessedAt           *time.Time       `json:"last_accessed_at,omitempty"`           // Time that the Look was last accessed by any user
	LastUpdaterId            *string          `json:"last_updater_id,omitempty"`            // Id of User that last updated the look.
	LastViewedAt             *time.Time       `json:"last_viewed_at,omitempty"`             // Time last viewed in the Looker web UI
	Model                    *LookModel       `json:"model,omitempty"`
	Public                   *bool            `json:"public,omitempty"`      // Is Public
	PublicSlug               *string          `json:"public_slug,omitempty"` // Public Slug
	PublicUrl                *string          `json:"public_url,omitempty"`  // Public Url
	QueryId                  *string          `json:"query_id,omitempty"`    // Query Id
	ShortUrl                 *string          `json:"short_url,omitempty"`   // Short Url
	Folder                   *FolderBase      `json:"folder,omitempty"`
	FolderId                 *string          `json:"folder_id,omitempty"`  // Folder Id
	UpdatedAt                *time.Time       `json:"updated_at,omitempty"` // Time that the Look was updated.
	ViewCount                *int64           `json:"view_count,omitempty"` // Number of times viewed in the Looker web UI
}

type LookBasic struct {
	Can               *map[string]bool `json:"can,omitempty"`                 // Operations the current user is able to perform on this object
	ContentMetadataId *string          `json:"content_metadata_id,omitempty"` // Id of content metadata
	Id                *string          `json:"id,omitempty"`                  // Unique Id
	Title             *string          `json:"title,omitempty"`               // Look Title
	UserId            *string          `json:"user_id,omitempty"`             // User Id
}

type LookmlFieldLink struct {
	Label   *string `json:"label,omitempty"`    // The name of the link as it would appear to users.
	Url     *string `json:"url,omitempty"`      // URL the link will go to.
	IconUrl *string `json:"icon_url,omitempty"` // A URL containing an image file to display with a link.
}

type LookmlModel struct {
	Can                      *map[string]bool         `json:"can,omitempty"`                         // Operations the current user is able to perform on this object
	AllowedDbConnectionNames *[]string                `json:"allowed_db_connection_names,omitempty"` // Array of names of connections this model is allowed to use
	Explores                 *[]LookmlModelNavExplore `json:"explores,omitempty"`                    // Array of explores (if has_content)
	HasContent               *bool                    `json:"has_content,omitempty"`                 // Does this model declaration have have lookml content?
	Label                    *string                  `json:"label,omitempty"`                       // UI-friendly name for this model
	Name                     *string                  `json:"name,omitempty"`                        // Name of the model. Also used as the unique identifier
	ProjectName              *string                  `json:"project_name,omitempty"`                // Name of project containing the model
	UnlimitedDbConnections   *bool                    `json:"unlimited_db_connections,omitempty"`    // Is this model allowed to use all current and future connections
}

type LookmlModelExplore struct {
	Id                    *string                                   `json:"id,omitempty"`                     // Fully qualified explore name (model name plus explore name)
	Name                  *string                                   `json:"name,omitempty"`                   // Explore name
	Description           *string                                   `json:"description,omitempty"`            // Description
	Label                 *string                                   `json:"label,omitempty"`                  // Label
	Title                 *string                                   `json:"title,omitempty"`                  // Explore title
	Scopes                *[]string                                 `json:"scopes,omitempty"`                 // Scopes
	CanTotal              *bool                                     `json:"can_total,omitempty"`              // Can Total
	CanDevelop            *bool                                     `json:"can_develop,omitempty"`            // Can Develop LookML
	CanSeeLookml          *bool                                     `json:"can_see_lookml,omitempty"`         // Can See LookML
	LookmlLink            *string                                   `json:"lookml_link,omitempty"`            // A URL linking to the definition of this explore in the LookML IDE.
	CanSave               *bool                                     `json:"can_save,omitempty"`               // Can Save
	CanExplain            *bool                                     `json:"can_explain,omitempty"`            // Can Explain
	CanPivotInDb          *bool                                     `json:"can_pivot_in_db,omitempty"`        // Can pivot in the DB
	CanSubtotal           *bool                                     `json:"can_subtotal,omitempty"`           // Can use subtotals
	HasTimezoneSupport    *bool                                     `json:"has_timezone_support,omitempty"`   // Has timezone support
	SupportsCostEstimate  *bool                                     `json:"supports_cost_estimate,omitempty"` // Cost estimates supported
	ConnectionName        *string                                   `json:"connection_name,omitempty"`        // Connection name
	NullSortTreatment     *string                                   `json:"null_sort_treatment,omitempty"`    // How nulls are sorted, possible values are "low", "high", "first" and "last"
	Files                 *[]string                                 `json:"files,omitempty"`                  // List of model source files
	SourceFile            *string                                   `json:"source_file,omitempty"`            // Primary source_file file
	ProjectName           *string                                   `json:"project_name,omitempty"`           // Name of project
	ModelName             *string                                   `json:"model_name,omitempty"`             // Name of model
	ViewName              *string                                   `json:"view_name,omitempty"`              // Name of view
	Hidden                *bool                                     `json:"hidden,omitempty"`                 // Is hidden
	SqlTableName          *string                                   `json:"sql_table_name,omitempty"`         // A sql_table_name expression that defines what sql table the view/explore maps onto. Example: "prod_orders2 AS orders" in a view named orders.
	AccessFilterFields    *[]string                                 `json:"access_filter_fields,omitempty"`   // (DEPRECATED) Array of access filter field names
	AccessFilters         *[]LookmlModelExploreAccessFilter         `json:"access_filters,omitempty"`         // Access filters
	Aliases               *[]LookmlModelExploreAlias                `json:"aliases,omitempty"`                // Aliases
	AlwaysFilter          *[]LookmlModelExploreAlwaysFilter         `json:"always_filter,omitempty"`          // Always filter
	ConditionallyFilter   *[]LookmlModelExploreConditionallyFilter  `json:"conditionally_filter,omitempty"`   // Conditionally filter
	IndexFields           *[]string                                 `json:"index_fields,omitempty"`           // Array of index fields
	Sets                  *[]LookmlModelExploreSet                  `json:"sets,omitempty"`                   // Sets
	Tags                  *[]string                                 `json:"tags,omitempty"`                   // An array of arbitrary string tags provided in the model for this explore.
	Errors                *[]LookmlModelExploreError                `json:"errors,omitempty"`                 // Errors
	Fields                *LookmlModelExploreFieldset               `json:"fields,omitempty"`
	Joins                 *[]LookmlModelExploreJoins                `json:"joins,omitempty"`                   // Views joined into this explore
	GroupLabel            *string                                   `json:"group_label,omitempty"`             // Label used to group explores in the navigation menus
	SupportedMeasureTypes *[]LookmlModelExploreSupportedMeasureType `json:"supported_measure_types,omitempty"` // An array of items describing which custom measure types are supported for creating a custom measure 'based_on' each possible dimension type.
	AlwaysJoin            *[]string                                 `json:"always_join,omitempty"`             // An array of joins that will always be included in the SQL for this explore, even if the user has not selected a field from the joined view.
}

type LookmlModelExploreAccessFilter struct {
	Field         *string `json:"field,omitempty"`          // Field to be filtered
	UserAttribute *string `json:"user_attribute,omitempty"` // User attribute name
}

type LookmlModelExploreAlias struct {
	Name  *string `json:"name,omitempty"`  // Name
	Value *string `json:"value,omitempty"` // Value
}

type LookmlModelExploreAlwaysFilter struct {
	Name  *string `json:"name,omitempty"`  // Name
	Value *string `json:"value,omitempty"` // Value
}

type LookmlModelExploreConditionallyFilter struct {
	Name  *string `json:"name,omitempty"`  // Name
	Value *string `json:"value,omitempty"` // Value
}

type LookmlModelExploreError struct {
	Message    *string      `json:"message,omitempty"`     // Error Message
	Details    *interface{} `json:"details,omitempty"`     // Details
	ErrorPos   *string      `json:"error_pos,omitempty"`   // Error source location
	FieldError *bool        `json:"field_error,omitempty"` // Is this a field error
}

type LookmlModelExploreField struct {
	Align                    *Align                                   `json:"align,omitempty"`                // The appropriate horizontal text alignment the values of this field should be displayed in. Valid values are: "left", "right".
	CanFilter                *bool                                    `json:"can_filter,omitempty"`           // Whether it's possible to filter on this field.
	Category                 *Category                                `json:"category,omitempty"`             // Field category Valid values are: "parameter", "filter", "measure", "dimension".
	DefaultFilterValue       *string                                  `json:"default_filter_value,omitempty"` // The default value that this field uses when filtering. Null if there is no default value.
	Description              *string                                  `json:"description,omitempty"`          // Description
	DimensionGroup           *string                                  `json:"dimension_group,omitempty"`      // Dimension group if this field is part of a dimension group. If not, this will be null.
	DrillFields              *[]string                                `json:"drill_fields,omitempty"`         // Drill fields declared for this field in LookML or default drills for certain types.
	Enumerations             *[]LookmlModelExploreFieldEnumeration    `json:"enumerations,omitempty"`         // An array enumerating all the possible values that this field can contain. When null, there is no limit to the set of possible values this field can contain.
	Error                    *string                                  `json:"error,omitempty"`                // An error message indicating a problem with the definition of this field. If there are no errors, this will be null.
	FieldGroupLabel          *string                                  `json:"field_group_label,omitempty"`    // A label creating a grouping of fields. All fields with this label should be presented together when displayed in a UI.
	FieldGroupVariant        *string                                  `json:"field_group_variant,omitempty"`  // When presented in a field group via field_group_label, a shorter name of the field to be displayed in that context.
	FillStyle                *FillStyle                               `json:"fill_style,omitempty"`           // The style of dimension fill that is possible for this field. Null if no dimension fill is possible. Valid values are: "enumeration", "range".
	FiscalMonthOffset        *int64                                   `json:"fiscal_month_offset,omitempty"`  // An offset (in months) from the calendar start month to the fiscal start month defined in the LookML model this field belongs to.
	HasAllowedValues         *bool                                    `json:"has_allowed_values,omitempty"`   // Whether this field has a set of allowed_values specified in LookML.
	HasDrillsMetadata        *bool                                    `json:"has_drills_metadata,omitempty"`  // Whether this field has links or drill fields defined.
	Hidden                   *bool                                    `json:"hidden,omitempty"`               // Whether this field should be hidden from the user interface.
	IsFilter                 *bool                                    `json:"is_filter,omitempty"`            // Whether this field is a filter.
	IsFiscal                 *bool                                    `json:"is_fiscal,omitempty"`            // Whether this field represents a fiscal time value.
	IsNumeric                *bool                                    `json:"is_numeric,omitempty"`           // Whether this field is of a type that represents a numeric value.
	IsTimeframe              *bool                                    `json:"is_timeframe,omitempty"`         // Whether this field is of a type that represents a time value.
	CanTimeFilter            *bool                                    `json:"can_time_filter,omitempty"`      // Whether this field can be time filtered.
	TimeInterval             *LookmlModelExploreFieldTimeInterval     `json:"time_interval,omitempty"`
	Label                    *string                                  `json:"label,omitempty"`                // Fully-qualified human-readable label of the field.
	LabelFromParameter       *string                                  `json:"label_from_parameter,omitempty"` // The name of the parameter that will provide a parameterized label for this field, if available in the current context.
	LabelShort               *string                                  `json:"label_short,omitempty"`          // The human-readable label of the field, without the view label.
	LookmlLink               *string                                  `json:"lookml_link,omitempty"`          // A URL linking to the definition of this field in the LookML IDE.
	Links                    *[]LookmlFieldLink                       `json:"links,omitempty"`                // Links associated with this field.
	MapLayer                 *LookmlModelExploreFieldMapLayer         `json:"map_layer,omitempty"`
	Measure                  *bool                                    `json:"measure,omitempty"`                     // Whether this field is a measure.
	Name                     *string                                  `json:"name,omitempty"`                        // Fully-qualified name of the field.
	StrictValueFormat        *bool                                    `json:"strict_value_format,omitempty"`         // If yes, the field will not be localized with the user attribute number_format. Defaults to no
	Parameter                *bool                                    `json:"parameter,omitempty"`                   // Whether this field is a parameter.
	Permanent                *bool                                    `json:"permanent,omitempty"`                   // Whether this field can be removed from a query.
	PrimaryKey               *bool                                    `json:"primary_key,omitempty"`                 // Whether or not the field represents a primary key.
	ProjectName              *string                                  `json:"project_name,omitempty"`                // The name of the project this field is defined in.
	RequiresRefreshOnSort    *bool                                    `json:"requires_refresh_on_sort,omitempty"`    // When true, it's not possible to re-sort this field's values without re-running the SQL query, due to database logic that affects the sort.
	Scope                    *string                                  `json:"scope,omitempty"`                       // The LookML scope this field belongs to. The scope is typically the field's view.
	Sortable                 *bool                                    `json:"sortable,omitempty"`                    // Whether this field can be sorted.
	SourceFile               *string                                  `json:"source_file,omitempty"`                 // The path portion of source_file_path.
	SourceFilePath           *string                                  `json:"source_file_path,omitempty"`            // The fully-qualified path of the project file this field is defined in.
	Sql                      *string                                  `json:"sql,omitempty"`                         // SQL expression as defined in the LookML model. The SQL syntax shown here is a representation intended for auditability, and is not neccessarily an exact match for what will ultimately be run in the database. It may contain special LookML syntax or annotations that are not valid SQL. This will be null if the current user does not have the see_lookml permission for the field's model.
	SqlCase                  *[]LookmlModelExploreFieldSqlCase        `json:"sql_case,omitempty"`                    // An array of conditions and values that make up a SQL Case expression, as defined in the LookML model. The SQL syntax shown here is a representation intended for auditability, and is not neccessarily an exact match for what will ultimately be run in the database. It may contain special LookML syntax or annotations that are not valid SQL. This will be null if the current user does not have the see_lookml permission for the field's model.
	Filters                  *[]LookmlModelExploreFieldMeasureFilters `json:"filters,omitempty"`                     // Array of filter conditions defined for the measure in LookML.
	SuggestDimension         *string                                  `json:"suggest_dimension,omitempty"`           // The name of the dimension to base suggest queries from.
	SuggestExplore           *string                                  `json:"suggest_explore,omitempty"`             // The name of the explore to base suggest queries from.
	Suggestable              *bool                                    `json:"suggestable,omitempty"`                 // Whether or not suggestions are possible for this field.
	Suggestions              *[]string                                `json:"suggestions,omitempty"`                 // If available, a list of suggestions for this field. For most fields, a suggest query is a more appropriate way to get an up-to-date list of suggestions. Or use enumerations to list all the possible values.
	Tags                     *[]string                                `json:"tags,omitempty"`                        // An array of arbitrary string tags provided in the model for this field.
	Type                     *string                                  `json:"type,omitempty"`                        // The LookML type of the field.
	UserAttributeFilterTypes *[]UserAttributeFilterTypes              `json:"user_attribute_filter_types,omitempty"` // An array of user attribute types that are allowed to be used in filters on this field. Valid values are: "advanced_filter_string", "advanced_filter_number", "advanced_filter_datetime", "string", "number", "datetime", "relative_url", "yesno", "zipcode".
	ValueFormat              *string                                  `json:"value_format,omitempty"`                // If specified, the LookML value format string for formatting values of this field.
	View                     *string                                  `json:"view,omitempty"`                        // The name of the view this field belongs to.
	ViewLabel                *string                                  `json:"view_label,omitempty"`                  // The human-readable label of the view the field belongs to.
	Dynamic                  *bool                                    `json:"dynamic,omitempty"`                     // Whether this field was specified in "dynamic_fields" and is not part of the model.
	WeekStartDay             *WeekStartDay                            `json:"week_start_day,omitempty"`              // The name of the starting day of the week. Valid values are: "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday".
	TimesUsed                *int64                                   `json:"times_used,omitempty"`                  // The number of times this field has been used in queries
	OriginalView             *string                                  `json:"original_view,omitempty"`               // The name of the view this field is defined in. This will be different than "view" when the view has been joined via a different name using the "from" parameter.
}

type LookmlModelExploreFieldEnumeration struct {
	Label *string      `json:"label,omitempty"` // Label
	Value *interface{} `json:"value,omitempty"` // Value
}

type LookmlModelExploreFieldMapLayer struct {
	Url              *string `json:"url,omitempty"`                // URL to the map layer resource.
	Name             *string `json:"name,omitempty"`               // Name of the map layer, as defined in LookML.
	FeatureKey       *string `json:"feature_key,omitempty"`        // Specifies the name of the TopoJSON object that the map layer references. If not specified, use the first object..
	PropertyKey      *string `json:"property_key,omitempty"`       // Selects which property from the TopoJSON data to plot against. TopoJSON supports arbitrary metadata for each region. When null, the first matching property should be used.
	PropertyLabelKey *string `json:"property_label_key,omitempty"` // Which property from the TopoJSON data to use to label the region. When null, property_key should be used.
	Projection       *string `json:"projection,omitempty"`         // The preferred geographic projection of the map layer when displayed in a visualization that supports multiple geographic projections.
	Format           *Format `json:"format,omitempty"`             // Specifies the data format of the region information. Valid values are: "topojson", "vector_tile_region".
	ExtentsJsonUrl   *string `json:"extents_json_url,omitempty"`   // Specifies the URL to a JSON file that defines the geographic extents of each region available in the map layer. This data is used to automatically center the map on the available data for visualization purposes. The JSON file must be a JSON object where the keys are the mapping value of the feature (as specified by property_key) and the values are arrays of four numbers representing the west longitude, south latitude, east longitude, and north latitude extents of the region. The object must include a key for every possible value of property_key.
	MaxZoomLevel     *int64  `json:"max_zoom_level,omitempty"`     // The minimum zoom level that the map layer may be displayed at, for visualizations that support zooming.
	MinZoomLevel     *int64  `json:"min_zoom_level,omitempty"`     // The maximum zoom level that the map layer may be displayed at, for visualizations that support zooming.
}

type LookmlModelExploreFieldMeasureFilters struct {
	Field     *string `json:"field,omitempty"`     // Filter field name
	Condition *string `json:"condition,omitempty"` // Filter condition value
}

type LookmlModelExploreFieldset struct {
	Dimensions *[]LookmlModelExploreField `json:"dimensions,omitempty"` // Array of dimensions
	Measures   *[]LookmlModelExploreField `json:"measures,omitempty"`   // Array of measures
	Filters    *[]LookmlModelExploreField `json:"filters,omitempty"`    // Array of filters
	Parameters *[]LookmlModelExploreField `json:"parameters,omitempty"` // Array of parameters
}

type LookmlModelExploreFieldSqlCase struct {
	Value     *string `json:"value,omitempty"`     // SQL Case label value
	Condition *string `json:"condition,omitempty"` // SQL Case condition expression
}

type LookmlModelExploreFieldTimeInterval struct {
	Name  *Name  `json:"name,omitempty"`  // The type of time interval this field represents a grouping of. Valid values are: "day", "hour", "minute", "second", "millisecond", "microsecond", "week", "month", "quarter", "year".
	Count *int64 `json:"count,omitempty"` // The number of intervals this field represents a grouping of.
}

type LookmlModelExploreJoins struct {
	Name            *string   `json:"name,omitempty"`             // Name of this join (and name of the view to join)
	DependentFields *[]string `json:"dependent_fields,omitempty"` // Fields referenced by the join
	Fields          *[]string `json:"fields,omitempty"`           // Fields of the joined view to pull into this explore
	ForeignKey      *string   `json:"foreign_key,omitempty"`      // Name of the dimension in this explore whose value is in the primary key of the joined view
	From            *string   `json:"from,omitempty"`             // Name of view to join
	OuterOnly       *bool     `json:"outer_only,omitempty"`       // Specifies whether all queries must use an outer join
	Relationship    *string   `json:"relationship,omitempty"`     // many_to_one, one_to_one, one_to_many, many_to_many
	RequiredJoins   *[]string `json:"required_joins,omitempty"`   // Names of joins that must always be included in SQL queries
	SqlForeignKey   *string   `json:"sql_foreign_key,omitempty"`  // SQL expression that produces a foreign key
	SqlOn           *string   `json:"sql_on,omitempty"`           // SQL ON expression describing the join condition
	SqlTableName    *string   `json:"sql_table_name,omitempty"`   // SQL table name to join
	Type            *string   `json:"type,omitempty"`             // The join type: left_outer, full_outer, inner, or cross
	ViewLabel       *string   `json:"view_label,omitempty"`       // Label to display in UI selectors
}

type LookmlModelExploreSet struct {
	Name  *string   `json:"name,omitempty"`  // Name
	Value *[]string `json:"value,omitempty"` // Value set
}

type LookmlModelExploreSupportedMeasureType struct {
	DimensionType *string   `json:"dimension_type,omitempty"`
	MeasureTypes  *[]string `json:"measure_types,omitempty"`
}

type LookmlModelNavExplore struct {
	Name        *string `json:"name,omitempty"`        // Name of the explore
	Description *string `json:"description,omitempty"` // Description for the explore
	Label       *string `json:"label,omitempty"`       // Label for the explore
	Hidden      *bool   `json:"hidden,omitempty"`      // Is this explore marked as hidden
	GroupLabel  *string `json:"group_label,omitempty"` // Label used to group explores in the navigation menus
}

type LookmlTest struct {
	Can            *map[string]bool `json:"can,omitempty"`              // Operations the current user is able to perform on this object
	ModelName      *string          `json:"model_name,omitempty"`       // Name of model containing this test.
	Name           *string          `json:"name,omitempty"`             // Name of this test.
	ExploreName    *string          `json:"explore_name,omitempty"`     // Name of the explore this test runs a query against
	QueryUrlParams *string          `json:"query_url_params,omitempty"` // The url parameters that can be used to reproduce this test's query on an explore.
	File           *string          `json:"file,omitempty"`             // Name of the LookML file containing this test.
	Line           *int64           `json:"line,omitempty"`             // Line number of this test in LookML.
}

type LookmlTestResult struct {
	Can              *map[string]bool `json:"can,omitempty"`               // Operations the current user is able to perform on this object
	ModelName        *string          `json:"model_name,omitempty"`        // Name of model containing this test.
	TestName         *string          `json:"test_name,omitempty"`         // Name of this test.
	AssertionsCount  *int64           `json:"assertions_count,omitempty"`  // Number of assertions in this test
	AssertionsFailed *int64           `json:"assertions_failed,omitempty"` // Number of assertions passed in this test
	Errors           *[]ProjectError  `json:"errors,omitempty"`            // A list of any errors encountered by the test.
	Warnings         *[]ProjectError  `json:"warnings,omitempty"`          // A list of any warnings encountered by the test.
	Success          *bool            `json:"success,omitempty"`           // True if this test passsed without errors.
}

type LookModel struct {
	Id    *string `json:"id,omitempty"`    // Model Id
	Label *string `json:"label,omitempty"` // Model Label
}

type LookWithDashboards struct {
	Can                      *map[string]bool `json:"can,omitempty"`                        // Operations the current user is able to perform on this object
	ContentMetadataId        *string          `json:"content_metadata_id,omitempty"`        // Id of content metadata
	Id                       *string          `json:"id,omitempty"`                         // Unique Id
	Title                    *string          `json:"title,omitempty"`                      // Look Title
	UserId                   *string          `json:"user_id,omitempty"`                    // User Id
	ContentFavoriteId        *string          `json:"content_favorite_id,omitempty"`        // Content Favorite Id
	CreatedAt                *time.Time       `json:"created_at,omitempty"`                 // Time that the Look was created.
	Deleted                  *bool            `json:"deleted,omitempty"`                    // Whether or not a look is 'soft' deleted.
	DeletedAt                *time.Time       `json:"deleted_at,omitempty"`                 // Time that the Look was deleted.
	DeleterId                *string          `json:"deleter_id,omitempty"`                 // Id of User that deleted the look.
	Description              *string          `json:"description,omitempty"`                // Description
	EmbedUrl                 *string          `json:"embed_url,omitempty"`                  // Embed Url
	ExcelFileUrl             *string          `json:"excel_file_url,omitempty"`             // Excel File Url
	FavoriteCount            *int64           `json:"favorite_count,omitempty"`             // Number of times favorited
	GoogleSpreadsheetFormula *string          `json:"google_spreadsheet_formula,omitempty"` // Google Spreadsheet Formula
	ImageEmbedUrl            *string          `json:"image_embed_url,omitempty"`            // Image Embed Url
	IsRunOnLoad              *bool            `json:"is_run_on_load,omitempty"`             // auto-run query when Look viewed
	LastAccessedAt           *time.Time       `json:"last_accessed_at,omitempty"`           // Time that the Look was last accessed by any user
	LastUpdaterId            *string          `json:"last_updater_id,omitempty"`            // Id of User that last updated the look.
	LastViewedAt             *time.Time       `json:"last_viewed_at,omitempty"`             // Time last viewed in the Looker web UI
	Model                    *LookModel       `json:"model,omitempty"`
	Public                   *bool            `json:"public,omitempty"`      // Is Public
	PublicSlug               *string          `json:"public_slug,omitempty"` // Public Slug
	PublicUrl                *string          `json:"public_url,omitempty"`  // Public Url
	QueryId                  *string          `json:"query_id,omitempty"`    // Query Id
	ShortUrl                 *string          `json:"short_url,omitempty"`   // Short Url
	Folder                   *FolderBase      `json:"folder,omitempty"`
	FolderId                 *string          `json:"folder_id,omitempty"`  // Folder Id
	UpdatedAt                *time.Time       `json:"updated_at,omitempty"` // Time that the Look was updated.
	ViewCount                *int64           `json:"view_count,omitempty"` // Number of times viewed in the Looker web UI
	Dashboards               *[]DashboardBase `json:"dashboards,omitempty"` // Dashboards
}

type LookWithQuery struct {
	Can                      *map[string]bool `json:"can,omitempty"`                        // Operations the current user is able to perform on this object
	ContentMetadataId        *string          `json:"content_metadata_id,omitempty"`        // Id of content metadata
	Id                       *string          `json:"id,omitempty"`                         // Unique Id
	Title                    *string          `json:"title,omitempty"`                      // Look Title
	UserId                   *string          `json:"user_id,omitempty"`                    // User Id
	ContentFavoriteId        *string          `json:"content_favorite_id,omitempty"`        // Content Favorite Id
	CreatedAt                *time.Time       `json:"created_at,omitempty"`                 // Time that the Look was created.
	Deleted                  *bool            `json:"deleted,omitempty"`                    // Whether or not a look is 'soft' deleted.
	DeletedAt                *time.Time       `json:"deleted_at,omitempty"`                 // Time that the Look was deleted.
	DeleterId                *string          `json:"deleter_id,omitempty"`                 // Id of User that deleted the look.
	Description              *string          `json:"description,omitempty"`                // Description
	EmbedUrl                 *string          `json:"embed_url,omitempty"`                  // Embed Url
	ExcelFileUrl             *string          `json:"excel_file_url,omitempty"`             // Excel File Url
	FavoriteCount            *int64           `json:"favorite_count,omitempty"`             // Number of times favorited
	GoogleSpreadsheetFormula *string          `json:"google_spreadsheet_formula,omitempty"` // Google Spreadsheet Formula
	ImageEmbedUrl            *string          `json:"image_embed_url,omitempty"`            // Image Embed Url
	IsRunOnLoad              *bool            `json:"is_run_on_load,omitempty"`             // auto-run query when Look viewed
	LastAccessedAt           *time.Time       `json:"last_accessed_at,omitempty"`           // Time that the Look was last accessed by any user
	LastUpdaterId            *string          `json:"last_updater_id,omitempty"`            // Id of User that last updated the look.
	LastViewedAt             *time.Time       `json:"last_viewed_at,omitempty"`             // Time last viewed in the Looker web UI
	Model                    *LookModel       `json:"model,omitempty"`
	Public                   *bool            `json:"public,omitempty"`      // Is Public
	PublicSlug               *string          `json:"public_slug,omitempty"` // Public Slug
	PublicUrl                *string          `json:"public_url,omitempty"`  // Public Url
	QueryId                  *string          `json:"query_id,omitempty"`    // Query Id
	ShortUrl                 *string          `json:"short_url,omitempty"`   // Short Url
	Folder                   *FolderBase      `json:"folder,omitempty"`
	FolderId                 *string          `json:"folder_id,omitempty"`  // Folder Id
	UpdatedAt                *time.Time       `json:"updated_at,omitempty"` // Time that the Look was updated.
	ViewCount                *int64           `json:"view_count,omitempty"` // Number of times viewed in the Looker web UI
	Query                    *Query           `json:"query,omitempty"`
	Url                      *string          `json:"url,omitempty"` // Url
}

type Manifest struct {
	Can                  *map[string]bool      `json:"can,omitempty"`     // Operations the current user is able to perform on this object
	Name                 *string               `json:"name,omitempty"`    // Manifest project name
	Imports              *[]ImportedProject    `json:"imports,omitempty"` // Imports for a project
	LocalizationSettings *LocalizationSettings `json:"localization_settings,omitempty"`
}

type MarketplaceAutomation struct {
	InstallEnabled          *bool `json:"install_enabled,omitempty"`            // Whether marketplace auto installation is enabled
	UpdateLookerEnabled     *bool `json:"update_looker_enabled,omitempty"`      // Whether marketplace auto update is enabled for looker extensions
	UpdateThirdPartyEnabled *bool `json:"update_third_party_enabled,omitempty"` // Whether marketplace auto update is enabled for third party extensions
}

type MaterializePDT struct {
	MaterializationId *string `json:"materialization_id,omitempty"` // The ID of the enqueued materialization task
	RespText          *string `json:"resp_text,omitempty"`          // Detailed response in text format
}

type MergeFields struct {
	FieldName       *string `json:"field_name,omitempty"`        // Field name to map onto in the merged results
	SourceFieldName *string `json:"source_field_name,omitempty"` // Field name from the source query
}

type MergeQuery struct {
	Can           *map[string]bool         `json:"can,omitempty"`             // Operations the current user is able to perform on this object
	ColumnLimit   *string                  `json:"column_limit,omitempty"`    // Column Limit
	DynamicFields *string                  `json:"dynamic_fields,omitempty"`  // Dynamic Fields
	Id            *string                  `json:"id,omitempty"`              // Unique Id
	Pivots        *[]string                `json:"pivots,omitempty"`          // Pivots
	ResultMakerId *string                  `json:"result_maker_id,omitempty"` // Unique to get results
	Sorts         *[]string                `json:"sorts,omitempty"`           // Sorts
	SourceQueries *[]MergeQuerySourceQuery `json:"source_queries,omitempty"`  // Source Queries defining the results to be merged.
	Total         *bool                    `json:"total,omitempty"`           // Total
	VisConfig     *map[string]interface{}  `json:"vis_config,omitempty"`      // Visualization Config
}

type MergeQuerySourceQuery struct {
	MergeFields *[]MergeFields `json:"merge_fields,omitempty"` // An array defining which fields of the source query are mapped onto fields of the merge query
	Name        *string        `json:"name,omitempty"`         // Display name
	QueryId     *string        `json:"query_id,omitempty"`     // Id of the query to merge
	QuerySlug   *string        `json:"query_slug,omitempty"`   // Slug of the query to merge
}

type MobileFeatureFlags struct {
	FeatureFlagName  *string `json:"feature_flag_name,omitempty"`  // Specifies the name of feature flag.
	FeatureFlagState *bool   `json:"feature_flag_state,omitempty"` // Specifies the state of feature flag
}

type MobilePayload struct {
	Title                  *string `json:"title,omitempty"`                    // Title of the alert
	AlertId                string  `json:"alert_id"`                           // ID of the alert
	InvestigativeContentId *string `json:"investigative_content_id,omitempty"` // ID of the investigative content
	DashboardName          *string `json:"dashboard_name,omitempty"`           // Name of the dashboard on which the alert has been set
	DashboardId            *string `json:"dashboard_id,omitempty"`             // ID of the dashboard on which the alert has been set
	QuerySlug              *string `json:"query_slug,omitempty"`               // Slug of the query which runs the alert queries.
}

type MobileSettings struct {
	MobileForceAuthentication *bool                 `json:"mobile_force_authentication,omitempty"` // Specifies whether the force authentication option is enabled for mobile
	MobileAppIntegration      *bool                 `json:"mobile_app_integration,omitempty"`      // Specifies whether mobile access for this instance is enabled.
	MobileFeatureFlags        *[]MobileFeatureFlags `json:"mobile_feature_flags,omitempty"`        // Specifies feature flag and state relevant to mobile.
}

type MobileToken struct {
	Id          *string    `json:"id,omitempty"` // Unique ID.
	DeviceToken string     `json:"device_token"` // Specifies the device token
	DeviceType  DeviceType `json:"device_type"`  // Specifies type of device. Valid values are: "android", "ios".
}

type Model struct {
	Connection   *string                   `json:"connection,omitempty"`
	Name         *string                   `json:"name,omitempty"`
	ValueFormats *[]ModelNamedValueFormats `json:"value_formats,omitempty"` // Array of named value formats
}

type ModelFieldSuggestions struct {
	Suggestions                *[]string `json:"suggestions,omitempty"`                  // List of suggestions
	Error                      *string   `json:"error,omitempty"`                        // Error message
	FromCache                  *bool     `json:"from_cache,omitempty"`                   // True if result came from the cache
	HitLimit                   *bool     `json:"hit_limit,omitempty"`                    // True if this was a hit limit
	UsedCalciteMaterialization *bool     `json:"used_calcite_materialization,omitempty"` // True if calcite was used
}

type ModelNamedValueFormats struct {
	FormatString      *string `json:"format_string,omitempty"`
	Label             *string `json:"label,omitempty"`
	Name              *string `json:"name,omitempty"`
	StrictValueFormat *bool   `json:"strict_value_format,omitempty"`
}

type ModelSet struct {
	Can       *map[string]bool `json:"can,omitempty"` // Operations the current user is able to perform on this object
	AllAccess *bool            `json:"all_access,omitempty"`
	BuiltIn   *bool            `json:"built_in,omitempty"`
	Id        *string          `json:"id,omitempty"` // Unique Id
	Models    *[]string        `json:"models,omitempty"`
	Name      *string          `json:"name,omitempty"` // Name of ModelSet
	Url       *string          `json:"url,omitempty"`  // Link to get this item
}

type ModelsNotValidated struct {
	Name          *string `json:"name,omitempty"`            // Model name
	ProjectFileId *string `json:"project_file_id,omitempty"` // Project file
}

type Name string

const Name_Day Name = "day"
const Name_Hour Name = "hour"
const Name_Minute Name = "minute"
const Name_Second Name = "second"
const Name_Millisecond Name = "millisecond"
const Name_Microsecond Name = "microsecond"
const Name_Week Name = "week"
const Name_Month Name = "month"
const Name_Quarter Name = "quarter"
const Name_Year Name = "year"

type OauthClientApp struct {
	Can                 *map[string]bool `json:"can,omitempty"`                   // Operations the current user is able to perform on this object
	ClientGuid          *string          `json:"client_guid,omitempty"`           // The globally unique id of this application
	RedirectUri         *string          `json:"redirect_uri,omitempty"`          // The uri with which this application will receive an auth code by browser redirect.
	DisplayName         *string          `json:"display_name,omitempty"`          // The application's display name
	Description         *string          `json:"description,omitempty"`           // A description of the application that will be displayed to users
	Enabled             *bool            `json:"enabled,omitempty"`               // When enabled is true, OAuth2 and API requests will be accepted from this app. When false, all requests from this app will be refused. Setting disabled invalidates existing tokens.
	GroupId             *string          `json:"group_id,omitempty"`              // If set, only Looker users who are members of this group can use this web app with Looker. If group_id is not set, any Looker user may use this app to access this Looker instance
	TokensInvalidBefore *time.Time       `json:"tokens_invalid_before,omitempty"` // All auth codes, access tokens, and refresh tokens issued for this application prior to this date-time for ALL USERS will be invalid.
	ActivatedUsers      *[]UserPublic    `json:"activated_users,omitempty"`       // All users who have been activated to use this app
}

type OIDCConfig struct {
	Can                        *map[string]bool          `json:"can,omitempty"`                            // Operations the current user is able to perform on this object
	AlternateEmailLoginAllowed *bool                     `json:"alternate_email_login_allowed,omitempty"`  // Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
	Audience                   *string                   `json:"audience,omitempty"`                       // OpenID Provider Audience
	AuthRequiresRole           *bool                     `json:"auth_requires_role,omitempty"`             // Users will not be allowed to login at all unless a role for them is found in OIDC if set to true
	AuthorizationEndpoint      *string                   `json:"authorization_endpoint,omitempty"`         // OpenID Provider Authorization Url
	DefaultNewUserGroupIds     *[]string                 `json:"default_new_user_group_ids,omitempty"`     // (Write-Only) Array of ids of groups that will be applied to new users the first time they login via OIDC
	DefaultNewUserGroups       *[]Group                  `json:"default_new_user_groups,omitempty"`        // (Read-only) Groups that will be applied to new users the first time they login via OIDC
	DefaultNewUserRoleIds      *[]string                 `json:"default_new_user_role_ids,omitempty"`      // (Write-Only) Array of ids of roles that will be applied to new users the first time they login via OIDC
	DefaultNewUserRoles        *[]Role                   `json:"default_new_user_roles,omitempty"`         // (Read-only) Roles that will be applied to new users the first time they login via OIDC
	Enabled                    *bool                     `json:"enabled,omitempty"`                        // Enable/Disable OIDC authentication for the server
	Groups                     *[]OIDCGroupRead          `json:"groups,omitempty"`                         // (Read-only) Array of mappings between OIDC Groups and Looker Roles
	GroupsAttribute            *string                   `json:"groups_attribute,omitempty"`               // Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
	GroupsWithRoleIds          *[]OIDCGroupWrite         `json:"groups_with_role_ids,omitempty"`           // (Read/Write) Array of mappings between OIDC Groups and arrays of Looker Role ids
	Identifier                 *string                   `json:"identifier,omitempty"`                     // Relying Party Identifier (provided by OpenID Provider)
	Issuer                     *string                   `json:"issuer,omitempty"`                         // OpenID Provider Issuer
	ModifiedAt                 *time.Time                `json:"modified_at,omitempty"`                    // When this config was last modified
	ModifiedBy                 *string                   `json:"modified_by,omitempty"`                    // User id of user who last modified this config
	NewUserMigrationTypes      *string                   `json:"new_user_migration_types,omitempty"`       // Merge first-time oidc login to existing user account by email addresses. When a user logs in for the first time via oidc this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
	Scopes                     *[]string                 `json:"scopes,omitempty"`                         // Array of scopes to request.
	Secret                     *string                   `json:"secret,omitempty"`                         // (Write-Only) Relying Party Secret (provided by OpenID Provider)
	SetRolesFromGroups         *bool                     `json:"set_roles_from_groups,omitempty"`          // Set user roles in Looker based on groups from OIDC
	TestSlug                   *string                   `json:"test_slug,omitempty"`                      // Slug to identify configurations that are created in order to run a OIDC config test
	TokenEndpoint              *string                   `json:"token_endpoint,omitempty"`                 // OpenID Provider Token Url
	UserAttributeMapEmail      *string                   `json:"user_attribute_map_email,omitempty"`       // Name of user record attributes used to indicate email address field
	UserAttributeMapFirstName  *string                   `json:"user_attribute_map_first_name,omitempty"`  // Name of user record attributes used to indicate first name
	UserAttributeMapLastName   *string                   `json:"user_attribute_map_last_name,omitempty"`   // Name of user record attributes used to indicate last name
	UserAttributes             *[]OIDCUserAttributeRead  `json:"user_attributes,omitempty"`                // (Read-only) Array of mappings between OIDC User Attributes and Looker User Attributes
	UserAttributesWithIds      *[]OIDCUserAttributeWrite `json:"user_attributes_with_ids,omitempty"`       // (Read/Write) Array of mappings between OIDC User Attributes and arrays of Looker User Attribute ids
	UserinfoEndpoint           *string                   `json:"userinfo_endpoint,omitempty"`              // OpenID Provider User Information Url
	AllowNormalGroupMembership *bool                     `json:"allow_normal_group_membership,omitempty"`  // Allow OIDC auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.
	AllowRolesFromNormalGroups *bool                     `json:"allow_roles_from_normal_groups,omitempty"` // OIDC auth'd users will inherit roles from non-reflected Looker groups.
	AllowDirectRoles           *bool                     `json:"allow_direct_roles,omitempty"`             // Allows roles to be directly assigned to OIDC auth'd users.
	Url                        *string                   `json:"url,omitempty"`                            // Link to get this item
}

type OIDCGroupRead struct {
	Id              *string `json:"id,omitempty"`                // Unique Id
	LookerGroupId   *string `json:"looker_group_id,omitempty"`   // Unique Id of group in Looker
	LookerGroupName *string `json:"looker_group_name,omitempty"` // Name of group in Looker
	Name            *string `json:"name,omitempty"`              // Name of group in OIDC
	Roles           *[]Role `json:"roles,omitempty"`             // Looker Roles
}

type OIDCGroupWrite struct {
	Id              *string   `json:"id,omitempty"`                // Unique Id
	LookerGroupId   *string   `json:"looker_group_id,omitempty"`   // Unique Id of group in Looker
	LookerGroupName *string   `json:"looker_group_name,omitempty"` // Name of group in Looker
	Name            *string   `json:"name,omitempty"`              // Name of group in OIDC
	RoleIds         *[]string `json:"role_ids,omitempty"`          // Looker Role Ids
}

type OIDCUserAttributeRead struct {
	Name           *string          `json:"name,omitempty"`            // Name of User Attribute in OIDC
	Required       *bool            `json:"required,omitempty"`        // Required to be in OIDC assertion for login to be allowed to succeed
	UserAttributes *[]UserAttribute `json:"user_attributes,omitempty"` // Looker User Attributes
}

type OIDCUserAttributeWrite struct {
	Name             *string   `json:"name,omitempty"`               // Name of User Attribute in OIDC
	Required         *bool     `json:"required,omitempty"`           // Required to be in OIDC assertion for login to be allowed to succeed
	UserAttributeIds *[]string `json:"user_attribute_ids,omitempty"` // Looker User Attribute Ids
}

type PasswordConfig struct {
	Can               *map[string]bool `json:"can,omitempty"`                // Operations the current user is able to perform on this object
	MinLength         *int64           `json:"min_length,omitempty"`         // Minimum number of characters required for a new password.  Must be between 7 and 100
	RequireNumeric    *bool            `json:"require_numeric,omitempty"`    // Require at least one numeric character
	RequireUpperlower *bool            `json:"require_upperlower,omitempty"` // Require at least one uppercase and one lowercase letter
	RequireSpecial    *bool            `json:"require_special,omitempty"`    // Require at least one special character
}

type Permission struct {
	Can         *map[string]bool `json:"can,omitempty"`         // Operations the current user is able to perform on this object
	Permission  *string          `json:"permission,omitempty"`  // Permission symbol
	Parent      *string          `json:"parent,omitempty"`      // Dependency parent symbol
	Description *string          `json:"description,omitempty"` // Description
}

type PermissionSet struct {
	Can         *map[string]bool `json:"can,omitempty"` // Operations the current user is able to perform on this object
	AllAccess   *bool            `json:"all_access,omitempty"`
	BuiltIn     *bool            `json:"built_in,omitempty"`
	Id          *string          `json:"id,omitempty"`   // Unique Id
	Name        *string          `json:"name,omitempty"` // Name of PermissionSet
	Permissions *[]string        `json:"permissions,omitempty"`
	Url         *string          `json:"url,omitempty"` // Link to get this item
}

type PermissionType string

const PermissionType_View PermissionType = "view"
const PermissionType_Edit PermissionType = "edit"

type PrivatelabelConfiguration struct {
	LogoFile                   *string `json:"logo_file,omitempty"`                     // Customer logo image. Expected base64 encoded data (write-only)
	LogoUrl                    *string `json:"logo_url,omitempty"`                      // Logo image url (read-only)
	FaviconFile                *string `json:"favicon_file,omitempty"`                  // Custom favicon image. Expected base64 encoded data (write-only)
	FaviconUrl                 *string `json:"favicon_url,omitempty"`                   // Favicon image url (read-only)
	DefaultTitle               *string `json:"default_title,omitempty"`                 // Default page title
	ShowHelpMenu               *bool   `json:"show_help_menu,omitempty"`                // Boolean to toggle showing help menus
	ShowDocs                   *bool   `json:"show_docs,omitempty"`                     // Boolean to toggle showing docs
	ShowEmailSubOptions        *bool   `json:"show_email_sub_options,omitempty"`        // Boolean to toggle showing email subscription options.
	AllowLookerMentions        *bool   `json:"allow_looker_mentions,omitempty"`         // Boolean to toggle mentions of Looker in emails
	AllowLookerLinks           *bool   `json:"allow_looker_links,omitempty"`            // Boolean to toggle links to Looker in emails
	CustomWelcomeEmailAdvanced *bool   `json:"custom_welcome_email_advanced,omitempty"` // Allow subject line and email heading customization in customized emails
	SetupMentions              *bool   `json:"setup_mentions,omitempty"`                // Remove the word Looker from appearing in the account setup page
	AlertsLogo                 *bool   `json:"alerts_logo,omitempty"`                   // Remove Looker logo from Alerts
	AlertsLinks                *bool   `json:"alerts_links,omitempty"`                  // Remove Looker links from Alerts
	FoldersMentions            *bool   `json:"folders_mentions,omitempty"`              // Remove Looker mentions in home folder page when you dont have any items saved
}

type Project struct {
	Can                            *map[string]bool `json:"can,omitempty"`                                // Operations the current user is able to perform on this object
	Id                             *string          `json:"id,omitempty"`                                 // Project Id
	Name                           *string          `json:"name,omitempty"`                               // Project display name
	UsesGit                        *bool            `json:"uses_git,omitempty"`                           // If true the project is configured with a git repository
	GitRemoteUrl                   *string          `json:"git_remote_url,omitempty"`                     // Git remote repository url
	GitUsername                    *string          `json:"git_username,omitempty"`                       // Git username for HTTPS authentication. (For production only, if using user attributes.)
	GitPassword                    *string          `json:"git_password,omitempty"`                       // (Write-Only) Git password for HTTPS authentication. (For production only, if using user attributes.)
	GitProductionBranchName        *string          `json:"git_production_branch_name,omitempty"`         // Git production branch name. Defaults to master. Supported only in Looker 21.0 and higher.
	UseGitCookieAuth               *bool            `json:"use_git_cookie_auth,omitempty"`                // If true, the project uses a git cookie for authentication.
	GitUsernameUserAttribute       *string          `json:"git_username_user_attribute,omitempty"`        // User attribute name for username in per-user HTTPS authentication.
	GitPasswordUserAttribute       *string          `json:"git_password_user_attribute,omitempty"`        // User attribute name for password in per-user HTTPS authentication.
	GitServiceName                 *string          `json:"git_service_name,omitempty"`                   // Name of the git service provider
	GitApplicationServerHttpPort   *int64           `json:"git_application_server_http_port,omitempty"`   // Port that HTTP(S) application server is running on (for PRs, file browsing, etc.)
	GitApplicationServerHttpScheme *string          `json:"git_application_server_http_scheme,omitempty"` // Scheme that is running on application server (for PRs, file browsing, etc.)
	DeploySecret                   *string          `json:"deploy_secret,omitempty"`                      // (Write-Only) Optional secret token with which to authenticate requests to the webhook deploy endpoint. If not set, endpoint is unauthenticated.
	UnsetDeploySecret              *bool            `json:"unset_deploy_secret,omitempty"`                // (Write-Only) When true, unsets the deploy secret to allow unauthenticated access to the webhook deploy endpoint.
	PullRequestMode                *PullRequestMode `json:"pull_request_mode,omitempty"`                  // The git pull request policy for this project. Valid values are: "off", "links", "recommended", "required".
	ValidationRequired             *bool            `json:"validation_required,omitempty"`                // Validation policy: If true, the project must pass validation checks before project changes can be committed to the git repository
	GitReleaseMgmtEnabled          *bool            `json:"git_release_mgmt_enabled,omitempty"`           // If true, advanced git release management is enabled for this project
	AllowWarnings                  *bool            `json:"allow_warnings,omitempty"`                     // Validation policy: If true, the project can be committed with warnings when `validation_required` is true. (`allow_warnings` does nothing if `validation_required` is false).
	IsExample                      *bool            `json:"is_example,omitempty"`                         // If true the project is an example project and cannot be modified
	DependencyStatus               *string          `json:"dependency_status,omitempty"`                  // Status of dependencies in your manifest & lockfile
}

type ProjectError struct {
	Code             *string                 `json:"code,omitempty"`              // A stable token that uniquely identifies this class of error, ignoring parameter values. Error message text may vary due to parameters or localization, but error codes do not. For example, a "File not found" error will have the same error code regardless of the filename in question or the user's display language
	Severity         *string                 `json:"severity,omitempty"`          // Severity: fatal, error, warning, info, success
	Kind             *string                 `json:"kind,omitempty"`              // Error classification: syntax, deprecation, model_configuration, etc
	Message          *string                 `json:"message,omitempty"`           // Error message which may contain information such as dashboard or model names that may be considered sensitive in some use cases. Avoid storing or sending this message outside of Looker
	FieldName        *string                 `json:"field_name,omitempty"`        // The field associated with this error
	FilePath         *string                 `json:"file_path,omitempty"`         // Name of the file containing this error
	LineNumber       *int64                  `json:"line_number,omitempty"`       // Line number in the file of this error
	ModelId          *string                 `json:"model_id,omitempty"`          // The model associated with this error
	Explore          *string                 `json:"explore,omitempty"`           // The explore associated with this error
	HelpUrl          *string                 `json:"help_url,omitempty"`          // A link to Looker documentation about this error
	Params           *map[string]interface{} `json:"params,omitempty"`            // Error parameters
	SanitizedMessage *string                 `json:"sanitized_message,omitempty"` // A version of the error message that does not contain potentially sensitive information. Suitable for situations in which messages are stored or sent to consumers outside of Looker, such as external logs. Sanitized messages will display "(?)" where sensitive information would appear in the corresponding non-sanitized message
}

type ProjectFile struct {
	Can       *map[string]bool `json:"can,omitempty"`       // Operations the current user is able to perform on this object
	Id        *string          `json:"id,omitempty"`        // An opaque token uniquely identifying a file within a project. Avoid parsing or decomposing the text of this token. This token is stable within a Looker release but may change between Looker releases
	Path      *string          `json:"path,omitempty"`      // Path, file name, and extension of the file relative to the project root directory
	Title     *string          `json:"title,omitempty"`     // Display name
	Type      *string          `json:"type,omitempty"`      // File type: model, view, etc
	Extension *string          `json:"extension,omitempty"` // The extension of the file: .view.lkml, .model.lkml, etc
	MimeType  *string          `json:"mime_type,omitempty"` // File mime type
	Editable  *bool            `json:"editable,omitempty"`  // State of editability for the file.
	GitStatus *GitStatus       `json:"git_status,omitempty"`
}

type ProjectValidation struct {
	Errors             *[]ProjectError       `json:"errors,omitempty"`               // A list of project errors
	ProjectDigest      *string               `json:"project_digest,omitempty"`       // A hash value computed from the project's current state
	ModelsNotValidated *[]ModelsNotValidated `json:"models_not_validated,omitempty"` // A list of models which were not fully validated
	ComputationTime    *float32              `json:"computation_time,omitempty"`     // Duration of project validation in seconds
}

type ProjectValidationCache struct {
	Errors             *[]ProjectError       `json:"errors,omitempty"`               // A list of project errors
	ProjectDigest      *string               `json:"project_digest,omitempty"`       // A hash value computed from the project's current state
	ModelsNotValidated *[]ModelsNotValidated `json:"models_not_validated,omitempty"` // A list of models which were not fully validated
	ComputationTime    *float32              `json:"computation_time,omitempty"`     // Duration of project validation in seconds
	Stale              *bool                 `json:"stale,omitempty"`                // If true, the cached project validation results are no longer accurate because the project has changed since the cached results were calculated
}

type ProjectWorkspace struct {
	Can              *map[string]bool  `json:"can,omitempty"`               // Operations the current user is able to perform on this object
	ProjectId        *string           `json:"project_id,omitempty"`        // The id of the project
	WorkspaceId      *string           `json:"workspace_id,omitempty"`      // The id of the local workspace containing the project files
	GitStatus        *string           `json:"git_status,omitempty"`        // The status of the local git directory
	GitHead          *string           `json:"git_head,omitempty"`          // Git head revision name
	DependencyStatus *DependencyStatus `json:"dependency_status,omitempty"` // Status of the dependencies in your project. Valid values are: "lock_optional", "lock_required", "lock_error", "install_none".
	GitBranch        *GitBranch        `json:"git_branch,omitempty"`
	LookmlType       *string           `json:"lookml_type,omitempty"` // The lookml syntax used by all files in this project
}

type PullRequestMode string

const PullRequestMode_Off PullRequestMode = "off"
const PullRequestMode_Links PullRequestMode = "links"
const PullRequestMode_Recommended PullRequestMode = "recommended"
const PullRequestMode_Required PullRequestMode = "required"

type Query struct {
	Can                  *map[string]bool        `json:"can,omitempty"`                    // Operations the current user is able to perform on this object
	Id                   *string                 `json:"id,omitempty"`                     // Unique Id
	Model                string                  `json:"model"`                            // Model
	View                 string                  `json:"view"`                             // Explore Name
	Fields               *[]string               `json:"fields,omitempty"`                 // Fields
	Pivots               *[]string               `json:"pivots,omitempty"`                 // Pivots
	FillFields           *[]string               `json:"fill_fields,omitempty"`            // Fill Fields
	Filters              *map[string]interface{} `json:"filters,omitempty"`                // Filters will contain data pertaining to complex filters that do not contain "or" conditions. When "or" conditions are present, filter data will be found on the `filter_expression` property.
	FilterExpression     *string                 `json:"filter_expression,omitempty"`      // Filter Expression
	Sorts                *[]string               `json:"sorts,omitempty"`                  // Sorting for the query results. Use the format `["view.field", ...]` to sort on fields in ascending order. Use the format `["view.field desc", ...]` to sort on fields in descending order. Use `["__UNSORTED__"]` (2 underscores before and after) to disable sorting entirely. Empty sorts `[]` will trigger a default sort.
	Limit                *string                 `json:"limit,omitempty"`                  // Limit
	ColumnLimit          *string                 `json:"column_limit,omitempty"`           // Column Limit
	Total                *bool                   `json:"total,omitempty"`                  // Total
	RowTotal             *string                 `json:"row_total,omitempty"`              // Raw Total
	Subtotals            *[]string               `json:"subtotals,omitempty"`              // Fields on which to run subtotals
	VisConfig            *map[string]interface{} `json:"vis_config,omitempty"`             // Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
	FilterConfig         *map[string]interface{} `json:"filter_config,omitempty"`          // The filter_config represents the state of the filter UI on the explore page for a given query. When running a query via the Looker UI, this parameter takes precedence over "filters". When creating a query or modifying an existing query, "filter_config" should be set to null. Setting it to any other value could cause unexpected filtering behavior. The format should be considered opaque.
	VisibleUiSections    *string                 `json:"visible_ui_sections,omitempty"`    // Visible UI Sections
	Slug                 *string                 `json:"slug,omitempty"`                   // Slug
	DynamicFields        *string                 `json:"dynamic_fields,omitempty"`         // Dynamic Fields
	ClientId             *string                 `json:"client_id,omitempty"`              // Client Id: used to generate shortened explore URLs. If set by client, must be a unique 22 character alphanumeric string. Otherwise one will be generated.
	ShareUrl             *string                 `json:"share_url,omitempty"`              // Share Url
	ExpandedShareUrl     *string                 `json:"expanded_share_url,omitempty"`     // Expanded Share Url
	Url                  *string                 `json:"url,omitempty"`                    // Expanded Url
	QueryTimezone        *string                 `json:"query_timezone,omitempty"`         // Query Timezone
	HasTableCalculations *bool                   `json:"has_table_calculations,omitempty"` // Has Table Calculations
}

type QueryFormats struct {
	JsonBi     *JsonBi `json:"json_bi,omitempty"`
	Json       *string `json:"json,omitempty"`
	JsonDetail *string `json:"json_detail,omitempty"`
	Csv        *string `json:"csv,omitempty"`
	Txt        *string `json:"txt,omitempty"`
	Html       *string `json:"html,omitempty"`
	Md         *string `json:"md,omitempty"`
	Xlsx       *string `json:"xlsx,omitempty"`
	Sql        *string `json:"sql,omitempty"`
}

type QueryTask struct {
	Can              *map[string]bool `json:"can,omitempty"`      // Operations the current user is able to perform on this object
	Id               *string          `json:"id,omitempty"`       // Unique Id
	QueryId          *string          `json:"query_id,omitempty"` // Id of query
	Query            *Query           `json:"query,omitempty"`
	GenerateLinks    *bool            `json:"generate_links,omitempty"`     // whether or not to generate links in the query response.
	ForceProduction  *bool            `json:"force_production,omitempty"`   // Use production models to run query (even is user is in dev mode).
	PathPrefix       *string          `json:"path_prefix,omitempty"`        // Prefix to use for drill links.
	Cache            *bool            `json:"cache,omitempty"`              // Whether or not to use the cache
	ServerTableCalcs *bool            `json:"server_table_calcs,omitempty"` // Whether or not to run table calculations on the server
	CacheOnly        *bool            `json:"cache_only,omitempty"`         // Retrieve any results from cache even if the results have expired.
	CacheKey         *string          `json:"cache_key,omitempty"`          // cache key used to cache query.
	Status           *string          `json:"status,omitempty"`             // Status of query task.
	Source           *string          `json:"source,omitempty"`             // Source of query task.
	Runtime          *float32         `json:"runtime,omitempty"`            // Runtime of prior queries.
	RebuildPdts      *bool            `json:"rebuild_pdts,omitempty"`       // Rebuild PDTS used in query.
	ResultSource     *string          `json:"result_source,omitempty"`      // Source of the results of the query.
	LookId           *string          `json:"look_id,omitempty"`            // Id of look associated with query.
	DashboardId      *string          `json:"dashboard_id,omitempty"`       // Id of dashboard associated with query.
	ResultFormat     *string          `json:"result_format,omitempty"`      // The data format of the query results.
}

type RenderTask struct {
	Can                *map[string]bool `json:"can,omitempty"`                  // Operations the current user is able to perform on this object
	CreatedAt          *string          `json:"created_at,omitempty"`           // Date/Time render task was created
	DashboardFilters   *string          `json:"dashboard_filters,omitempty"`    // Filter values to apply to the dashboard queries, in URL query format
	DashboardId        *string          `json:"dashboard_id,omitempty"`         // Id of dashboard to render
	DashboardStyle     *string          `json:"dashboard_style,omitempty"`      // Dashboard layout style: single_column or tiled
	FinalizedAt        *string          `json:"finalized_at,omitempty"`         // Date/Time render task was completed
	Height             *int64           `json:"height,omitempty"`               // Output height in pixels. Flowed layouts may ignore this value.
	Id                 *string          `json:"id,omitempty"`                   // Id of this render task
	LookId             *string          `json:"look_id,omitempty"`              // Id of look to render
	LookmlDashboardId  *string          `json:"lookml_dashboard_id,omitempty"`  // Id of lookml dashboard to render
	QueryId            *string          `json:"query_id,omitempty"`             // Id of query to render
	DashboardElementId *string          `json:"dashboard_element_id,omitempty"` // Id of dashboard element to render: UDD dashboard element would be numeric and LookML dashboard element would be model_name::dashboard_title::lookml_link_id
	QueryRuntime       *float64         `json:"query_runtime,omitempty"`        // Number of seconds elapsed running queries
	RenderRuntime      *float64         `json:"render_runtime,omitempty"`       // Number of seconds elapsed rendering data
	ResultFormat       *string          `json:"result_format,omitempty"`        // Output format: pdf, png, or jpg
	Runtime            *float64         `json:"runtime,omitempty"`              // Total seconds elapsed for render task
	Status             *string          `json:"status,omitempty"`               // Render task status: enqueued_for_query, querying, enqueued_for_render, rendering, success, failure
	StatusDetail       *string          `json:"status_detail,omitempty"`        // Additional information about the current status
	UserId             *string          `json:"user_id,omitempty"`              // The user account permissions in which the render task will execute
	Width              *int64           `json:"width,omitempty"`                // Output width in pixels
}

type RepositoryCredential struct {
	Can           *map[string]bool `json:"can,omitempty"`             // Operations the current user is able to perform on this object
	Id            *string          `json:"id,omitempty"`              // Unique Id
	RootProjectId *string          `json:"root_project_id,omitempty"` // Root project Id
	RemoteUrl     *string          `json:"remote_url,omitempty"`      // Git remote repository url
	GitUsername   *string          `json:"git_username,omitempty"`    // Git username for HTTPS authentication.
	GitPassword   *string          `json:"git_password,omitempty"`    // (Write-Only) Git password for HTTPS authentication.
	SshPublicKey  *string          `json:"ssh_public_key,omitempty"`  // Public deploy key for SSH authentication.
	IsConfigured  *bool            `json:"is_configured,omitempty"`   // Whether the credentials have been configured for the Git Repository.
}

// Dynamically generated request type for active_themes
type RequestActiveThemes struct {
	Name   *string    `json:"name,omitempty"`   // Name of theme
	Ts     *time.Time `json:"ts,omitempty"`     // Timestamp representing the target datetime for the active period. Defaults to 'now'
	Fields *string    `json:"fields,omitempty"` // Requested fields.
}

// Dynamically generated request type for alert_notifications
type RequestAlertNotifications struct {
	Limit  *int64 `json:"limit,omitempty"`  // (Optional) Number of results to return (used with `offset`).
	Offset *int64 `json:"offset,omitempty"` // (Optional) Number of results to skip before returning any (used with `limit`).
}

// Dynamically generated request type for all_board_items
type RequestAllBoardItems struct {
	Fields         *string `json:"fields,omitempty"`           // Requested fields.
	Sorts          *string `json:"sorts,omitempty"`            // Fields to sort by.
	BoardSectionId *string `json:"board_section_id,omitempty"` // Filter to a specific board section
}

// Dynamically generated request type for all_board_sections
type RequestAllBoardSections struct {
	Fields *string `json:"fields,omitempty"` // Requested fields.
	Sorts  *string `json:"sorts,omitempty"`  // Fields to sort by.
}

// Dynamically generated request type for all_external_oauth_applications
type RequestAllExternalOauthApplications struct {
	Name     *string `json:"name,omitempty"`      // Application name
	ClientId *string `json:"client_id,omitempty"` // Application Client ID
}

// Dynamically generated request type for all_groups
type RequestAllGroups struct {
	Fields                  *string          `json:"fields,omitempty"`                      // Requested fields.
	Page                    *int64           `json:"page,omitempty"`                        // DEPRECATED. Use limit and offset instead. Return only page N of paginated results
	PerPage                 *int64           `json:"per_page,omitempty"`                    // DEPRECATED. Use limit and offset instead. Return N rows of data per page
	Limit                   *int64           `json:"limit,omitempty"`                       // Number of results to return. (used with offset and takes priority over page and per_page)
	Offset                  *int64           `json:"offset,omitempty"`                      // Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
	Sorts                   *string          `json:"sorts,omitempty"`                       // Fields to sort by.
	Ids                     *rtl.DelimString `json:"ids,omitempty"`                         // Optional of ids to get specific groups.
	ContentMetadataId       *string          `json:"content_metadata_id,omitempty"`         // Id of content metadata to which groups must have access.
	CanAddToContentMetadata *bool            `json:"can_add_to_content_metadata,omitempty"` // Select only groups that either can/cannot be given access to content.
}

// Dynamically generated request type for all_group_users
type RequestAllGroupUsers struct {
	GroupId string  `json:"group_id"`           // Id of group
	Fields  *string `json:"fields,omitempty"`   // Requested fields.
	Page    *int64  `json:"page,omitempty"`     // DEPRECATED. Use limit and offset instead. Return only page N of paginated results
	PerPage *int64  `json:"per_page,omitempty"` // DEPRECATED. Use limit and offset instead. Return N rows of data per page
	Limit   *int64  `json:"limit,omitempty"`    // Number of results to return. (used with offset and takes priority over page and per_page)
	Offset  *int64  `json:"offset,omitempty"`   // Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
	Sorts   *string `json:"sorts,omitempty"`    // Fields to sort by.
}

// Dynamically generated request type for all_integrations
type RequestAllIntegrations struct {
	Fields           *string `json:"fields,omitempty"`             // Requested fields.
	IntegrationHubId *string `json:"integration_hub_id,omitempty"` // Filter to a specific provider
}

// Dynamically generated request type for all_lookml_models
type RequestAllLookmlModels struct {
	Fields *string `json:"fields,omitempty"` // Requested fields.
	Limit  *int64  `json:"limit,omitempty"`  // Number of results to return. (can be used with offset)
	Offset *int64  `json:"offset,omitempty"` // Number of results to skip before returning any. (Defaults to 0 if not set when limit is used)
}

// Dynamically generated request type for all_roles
type RequestAllRoles struct {
	Fields *string          `json:"fields,omitempty"` // Requested fields.
	Ids    *rtl.DelimString `json:"ids,omitempty"`    // Optional list of ids to get specific roles.
}

// Dynamically generated request type for all_scheduled_plans
type RequestAllScheduledPlans struct {
	UserId   *string `json:"user_id,omitempty"`   // Return scheduled plans belonging to this user_id. If not provided, returns scheduled plans owned by the caller.
	Fields   *string `json:"fields,omitempty"`    // Comma delimited list of field names. If provided, only the fields specified will be included in the response
	AllUsers *bool   `json:"all_users,omitempty"` // Return scheduled plans belonging to all users (caller needs see_schedules permission)
}

// Dynamically generated request type for all_user_attributes
type RequestAllUserAttributes struct {
	Fields *string `json:"fields,omitempty"` // Requested fields.
	Sorts  *string `json:"sorts,omitempty"`  // Fields to order the results by. Sortable fields include: name, label
}

// Dynamically generated request type for all_users
type RequestAllUsers struct {
	Fields  *string          `json:"fields,omitempty"`   // Requested fields.
	Page    *int64           `json:"page,omitempty"`     // DEPRECATED. Use limit and offset instead. Return only page N of paginated results
	PerPage *int64           `json:"per_page,omitempty"` // DEPRECATED. Use limit and offset instead. Return N rows of data per page
	Limit   *int64           `json:"limit,omitempty"`    // Number of results to return. (used with offset and takes priority over page and per_page)
	Offset  *int64           `json:"offset,omitempty"`   // Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
	Sorts   *string          `json:"sorts,omitempty"`    // Fields to sort by.
	Ids     *rtl.DelimString `json:"ids,omitempty"`      // Optional list of ids to get specific users.
}

// Dynamically generated request type for artifact
type RequestArtifact struct {
	Namespace string  `json:"namespace"`        // Artifact storage namespace
	Key       string  `json:"key"`              // Comma-delimited list of keys. Wildcards not allowed.
	Fields    *string `json:"fields,omitempty"` // Comma-delimited names of fields to return in responses. Omit for all fields
	Limit     *int64  `json:"limit,omitempty"`  // Number of results to return. (used with offset)
	Offset    *int64  `json:"offset,omitempty"` // Number of results to skip before returning any. (used with limit)
}

// Dynamically generated request type for artifact_namespaces
type RequestArtifactNamespaces struct {
	Fields *string `json:"fields,omitempty"` // Comma-delimited names of fields to return in responses. Omit for all fields
	Limit  *int64  `json:"limit,omitempty"`  // Number of results to return. (used with offset)
	Offset *int64  `json:"offset,omitempty"` // Number of results to skip before returning any. (used with limit)
}

// Dynamically generated request type for connection_columns
type RequestConnectionColumns struct {
	ConnectionName string  `json:"connection_name"`       // Name of connection
	Database       *string `json:"database,omitempty"`    // For dialects that support multiple databases, optionally identify which to use
	SchemaName     *string `json:"schema_name,omitempty"` // Name of schema to use.
	Cache          *bool   `json:"cache,omitempty"`       // True to fetch from cache, false to load fresh
	TableLimit     *int64  `json:"table_limit,omitempty"` // limits the tables per schema returned
	TableNames     *string `json:"table_names,omitempty"` // only fetch columns for a given (comma-separated) list of tables
	Fields         *string `json:"fields,omitempty"`      // Requested fields.
}

// Dynamically generated request type for connection_schemas
type RequestConnectionSchemas struct {
	ConnectionName string  `json:"connection_name"`    // Name of connection
	Database       *string `json:"database,omitempty"` // For dialects that support multiple databases, optionally identify which to use
	Cache          *bool   `json:"cache,omitempty"`    // True to use fetch from cache, false to load fresh
	Fields         *string `json:"fields,omitempty"`   // Requested fields.
}

// Dynamically generated request type for connection_search_columns
type RequestConnectionSearchColumns struct {
	ConnectionName string  `json:"connection_name"`       // Name of connection
	ColumnName     *string `json:"column_name,omitempty"` // Column name to find
	Fields         *string `json:"fields,omitempty"`      // Requested fields.
}

// Dynamically generated request type for connection_tables
type RequestConnectionTables struct {
	ConnectionName string  `json:"connection_name"`        // Name of connection
	Database       *string `json:"database,omitempty"`     // Optional. Name of database to use for the query, only if applicable
	SchemaName     *string `json:"schema_name,omitempty"`  // Optional. Return only tables for this schema
	Cache          *bool   `json:"cache,omitempty"`        // True to fetch from cache, false to load fresh
	Fields         *string `json:"fields,omitempty"`       // Requested fields.
	TableFilter    *string `json:"table_filter,omitempty"` // Optional. Return tables with names that contain this value
	TableLimit     *int64  `json:"table_limit,omitempty"`  // Optional. Return tables up to the table_limit
}

// Dynamically generated request type for content_thumbnail
type RequestContentThumbnail struct {
	Type       string  `json:"type"`             // Either dashboard or look
	ResourceId string  `json:"resource_id"`      // ID of the dashboard or look to render
	Reload     *string `json:"reload,omitempty"` // Whether or not to refresh the rendered image with the latest content
	Theme      *string `json:"theme,omitempty"`  // Light or dark background. Default is "light"
	Format     *string `json:"format,omitempty"` // A value of png produces a thumbnail in PNG format instead of SVG (default)
	Width      *int64  `json:"width,omitempty"`  // The width of the image if format is supplied
	Height     *int64  `json:"height,omitempty"` // The height of the image if format is supplied
}

// Dynamically generated request type for create_dashboard_element
type RequestCreateDashboardElement struct {
	Body         WriteDashboardElement `json:"body"`
	Fields       *string               `json:"fields,omitempty"`        // Requested fields.
	ApplyFilters *bool                 `json:"apply_filters,omitempty"` // Apply relevant filters on dashboard to this tile
}

// Dynamically generated request type for create_dashboard_render_task
type RequestCreateDashboardRenderTask struct {
	DashboardId  string                    `json:"dashboard_id"`  // Id of dashboard to render. The ID can be a LookML dashboard also.
	ResultFormat string                    `json:"result_format"` // Output type: pdf, png, or jpg
	Body         CreateDashboardRenderTask `json:"body"`
	Width        int64                     `json:"width"`                    // Output width in pixels
	Height       int64                     `json:"height"`                   // Output height in pixels
	Fields       *string                   `json:"fields,omitempty"`         // Requested fields.
	PdfPaperSize *string                   `json:"pdf_paper_size,omitempty"` // Paper size for pdf. Value can be one of: ["letter","legal","tabloid","a0","a1","a2","a3","a4","a5"]
	PdfLandscape *bool                     `json:"pdf_landscape,omitempty"`  // Whether to render pdf in landscape paper orientation
	LongTables   *bool                     `json:"long_tables,omitempty"`    // Whether or not to expand table vis to full length
	Theme        *string                   `json:"theme,omitempty"`          // Theme to apply. Will render embedded version of dashboard if valid
}

// Dynamically generated request type for create_query_task
type RequestCreateQueryTask struct {
	Body               WriteCreateQueryTask `json:"body"`
	Limit              *int64               `json:"limit,omitempty"`                // Row limit (may override the limit in the saved query).
	ApplyFormatting    *bool                `json:"apply_formatting,omitempty"`     // Apply model-specified formatting to each result.
	ApplyVis           *bool                `json:"apply_vis,omitempty"`            // Apply visualization options to results.
	Cache              *bool                `json:"cache,omitempty"`                // Get results from cache if available.
	GenerateDrillLinks *bool                `json:"generate_drill_links,omitempty"` // Generate drill links (only applicable to 'json_detail' format.
	ForceProduction    *bool                `json:"force_production,omitempty"`     // Force use of production models even if the user is in development mode. Note that this flag being false does not guarantee development models will be used.
	CacheOnly          *bool                `json:"cache_only,omitempty"`           // Retrieve any results from cache even if the results have expired.
	PathPrefix         *string              `json:"path_prefix,omitempty"`          // Prefix to use for drill links (url encoded).
	RebuildPdts        *bool                `json:"rebuild_pdts,omitempty"`         // Rebuild PDTS used in query.
	ServerTableCalcs   *bool                `json:"server_table_calcs,omitempty"`   // Perform table calculations on query results
	Fields             *string              `json:"fields,omitempty"`               // Requested fields
}

// Dynamically generated request type for create_user_credentials_email_password_reset
type RequestCreateUserCredentialsEmailPasswordReset struct {
	UserId  string  `json:"user_id"`           // Id of user
	Expires *bool   `json:"expires,omitempty"` // Expiring token.
	Fields  *string `json:"fields,omitempty"`  // Requested fields.
}

// Dynamically generated request type for deploy_ref_to_production
type RequestDeployRefToProduction struct {
	ProjectId string  `json:"project_id"`       // Id of project
	Branch    *string `json:"branch,omitempty"` // Branch to deploy to production
	Ref       *string `json:"ref,omitempty"`    // Ref to deploy to production
}

// Dynamically generated request type for folder_children
type RequestFolderChildren struct {
	FolderId string  `json:"folder_id"`          // Id of folder
	Fields   *string `json:"fields,omitempty"`   // Requested fields.
	Page     *int64  `json:"page,omitempty"`     // DEPRECATED. Use limit and offset instead. Return only page N of paginated results
	PerPage  *int64  `json:"per_page,omitempty"` // DEPRECATED. Use limit and offset instead. Return N rows of data per page
	Limit    *int64  `json:"limit,omitempty"`    // Number of results to return. (used with offset and takes priority over page and per_page)
	Offset   *int64  `json:"offset,omitempty"`   // Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
	Sorts    *string `json:"sorts,omitempty"`    // Fields to sort by.
}

// Dynamically generated request type for folder_children_search
type RequestFolderChildrenSearch struct {
	FolderId string  `json:"folder_id"`        // Id of folder
	Fields   *string `json:"fields,omitempty"` // Requested fields.
	Sorts    *string `json:"sorts,omitempty"`  // Fields to sort by.
	Name     *string `json:"name,omitempty"`   // Match folder name.
}

// Dynamically generated request type for graph_derived_tables_for_model
type RequestGraphDerivedTablesForModel struct {
	Model  string  `json:"model"`            // The name of the Lookml model.
	Format *string `json:"format,omitempty"` // The format of the graph. Valid values are [dot]. Default is `dot`
	Color  *string `json:"color,omitempty"`  // Color denoting the build status of the graph. Grey = not built, green = built, yellow = building, red = error.
}

// Dynamically generated request type for graph_derived_tables_for_view
type RequestGraphDerivedTablesForView struct {
	View      string  `json:"view"`                // The derived table's view name.
	Models    *string `json:"models,omitempty"`    // The models where this derived table is defined.
	Workspace *string `json:"workspace,omitempty"` // The model directory to look in, either `dev` or `production`.
}

// Dynamically generated request type for login
type RequestLogin struct {
	ClientId     *string `json:"client_id,omitempty"`     // client_id part of API Key.
	ClientSecret *string `json:"client_secret,omitempty"` // client_secret part of API Key.
}

// Dynamically generated request type for lookml_model_explore
type RequestLookmlModelExplore struct {
	LookmlModelName   string  `json:"lookml_model_name"`             // Name of lookml model.
	ExploreName       string  `json:"explore_name"`                  // Name of explore.
	Fields            *string `json:"fields,omitempty"`              // Requested fields.
	AddDrillsMetadata *bool   `json:"add_drills_metadata,omitempty"` // Whether response should include drill field metadata.
}

// Dynamically generated request type for model_fieldname_suggestions
type RequestModelFieldnameSuggestions struct {
	ModelName string       `json:"model_name"`        // Name of model
	ViewName  string       `json:"view_name"`         // Name of view
	FieldName string       `json:"field_name"`        // Name of field to use for suggestions
	Term      *string      `json:"term,omitempty"`    // Search term pattern (evaluated as as `%term%`)
	Filters   *interface{} `json:"filters,omitempty"` // Suggestion filters with field name keys and comparison expressions
}

// Dynamically generated request type for role_users
type RequestRoleUsers struct {
	RoleId                string  `json:"role_id"`                           // id of role
	Fields                *string `json:"fields,omitempty"`                  // Requested fields.
	DirectAssociationOnly *bool   `json:"direct_association_only,omitempty"` // Get only users associated directly with the role: exclude those only associated through groups.
}

// Dynamically generated request type for run_git_connection_test
type RequestRunGitConnectionTest struct {
	ProjectId     string  `json:"project_id"`               // Project Id
	TestId        string  `json:"test_id"`                  // Test Id
	RemoteUrl     *string `json:"remote_url,omitempty"`     // (Optional: leave blank for root project) The remote url for remote dependency to test.
	UseProduction *string `json:"use_production,omitempty"` // (Optional: leave blank for dev credentials) Whether to use git production credentials.
}

// Dynamically generated request type for run_inline_query
type RequestRunInlineQuery struct {
	ResultFormat       string     `json:"result_format"` // Format of result
	Body               WriteQuery `json:"body"`
	Limit              *int64     `json:"limit,omitempty"`                // Row limit (may override the limit in the saved query).
	ApplyFormatting    *bool      `json:"apply_formatting,omitempty"`     // Apply model-specified formatting to each result.
	ApplyVis           *bool      `json:"apply_vis,omitempty"`            // Apply visualization options to results.
	Cache              *bool      `json:"cache,omitempty"`                // Get results from cache if available.
	ImageWidth         *int64     `json:"image_width,omitempty"`          // Render width for image formats.
	ImageHeight        *int64     `json:"image_height,omitempty"`         // Render height for image formats.
	GenerateDrillLinks *bool      `json:"generate_drill_links,omitempty"` // Generate drill links (only applicable to 'json_detail' format.
	ForceProduction    *bool      `json:"force_production,omitempty"`     // Force use of production models even if the user is in development mode. Note that this flag being false does not guarantee development models will be used.
	CacheOnly          *bool      `json:"cache_only,omitempty"`           // Retrieve any results from cache even if the results have expired.
	PathPrefix         *string    `json:"path_prefix,omitempty"`          // Prefix to use for drill links (url encoded).
	RebuildPdts        *bool      `json:"rebuild_pdts,omitempty"`         // Rebuild PDTS used in query.
	ServerTableCalcs   *bool      `json:"server_table_calcs,omitempty"`   // Perform table calculations on query results
}

// Dynamically generated request type for run_look
type RequestRunLook struct {
	LookId             string  `json:"look_id"`                        // Id of look
	ResultFormat       string  `json:"result_format"`                  // Format of result
	Limit              *int64  `json:"limit,omitempty"`                // Row limit (may override the limit in the saved query).
	ApplyFormatting    *bool   `json:"apply_formatting,omitempty"`     // Apply model-specified formatting to each result.
	ApplyVis           *bool   `json:"apply_vis,omitempty"`            // Apply visualization options to results.
	Cache              *bool   `json:"cache,omitempty"`                // Get results from cache if available.
	ImageWidth         *int64  `json:"image_width,omitempty"`          // Render width for image formats.
	ImageHeight        *int64  `json:"image_height,omitempty"`         // Render height for image formats.
	GenerateDrillLinks *bool   `json:"generate_drill_links,omitempty"` // Generate drill links (only applicable to 'json_detail' format.
	ForceProduction    *bool   `json:"force_production,omitempty"`     // Force use of production models even if the user is in development mode. Note that this flag being false does not guarantee development models will be used.
	CacheOnly          *bool   `json:"cache_only,omitempty"`           // Retrieve any results from cache even if the results have expired.
	PathPrefix         *string `json:"path_prefix,omitempty"`          // Prefix to use for drill links (url encoded).
	RebuildPdts        *bool   `json:"rebuild_pdts,omitempty"`         // Rebuild PDTS used in query.
	ServerTableCalcs   *bool   `json:"server_table_calcs,omitempty"`   // Perform table calculations on query results
}

// Dynamically generated request type for run_lookml_test
type RequestRunLookmlTest struct {
	ProjectId string  `json:"project_id"`        // Project Id
	FileId    *string `json:"file_id,omitempty"` // File Name
	Test      *string `json:"test,omitempty"`    // Test Name
	Model     *string `json:"model,omitempty"`   // Model Name
}

// Dynamically generated request type for run_query
type RequestRunQuery struct {
	QueryId            string  `json:"query_id"`                       // Id of query
	ResultFormat       string  `json:"result_format"`                  // Format of result
	Limit              *int64  `json:"limit,omitempty"`                // Row limit (may override the limit in the saved query).
	ApplyFormatting    *bool   `json:"apply_formatting,omitempty"`     // Apply model-specified formatting to each result.
	ApplyVis           *bool   `json:"apply_vis,omitempty"`            // Apply visualization options to results.
	Cache              *bool   `json:"cache,omitempty"`                // Get results from cache if available.
	ImageWidth         *int64  `json:"image_width,omitempty"`          // Render width for image formats.
	ImageHeight        *int64  `json:"image_height,omitempty"`         // Render height for image formats.
	GenerateDrillLinks *bool   `json:"generate_drill_links,omitempty"` // Generate drill links (only applicable to 'json_detail' format.
	ForceProduction    *bool   `json:"force_production,omitempty"`     // Force use of production models even if the user is in development mode. Note that this flag being false does not guarantee development models will be used.
	CacheOnly          *bool   `json:"cache_only,omitempty"`           // Retrieve any results from cache even if the results have expired.
	PathPrefix         *string `json:"path_prefix,omitempty"`          // Prefix to use for drill links (url encoded).
	RebuildPdts        *bool   `json:"rebuild_pdts,omitempty"`         // Rebuild PDTS used in query.
	ServerTableCalcs   *bool   `json:"server_table_calcs,omitempty"`   // Perform table calculations on query results
	Source             *string `json:"source,omitempty"`               // Specifies the source of this call.
}

// Dynamically generated request type for scheduled_plans_for_dashboard
type RequestScheduledPlansForDashboard struct {
	DashboardId string  `json:"dashboard_id"`        // Dashboard Id
	UserId      *string `json:"user_id,omitempty"`   // User Id (default is requesting user if not specified)
	AllUsers    *bool   `json:"all_users,omitempty"` // Return scheduled plans belonging to all users for the dashboard
	Fields      *string `json:"fields,omitempty"`    // Requested fields.
}

// Dynamically generated request type for scheduled_plans_for_look
type RequestScheduledPlansForLook struct {
	LookId   string  `json:"look_id"`             // Look Id
	UserId   *string `json:"user_id,omitempty"`   // User Id (default is requesting user if not specified)
	Fields   *string `json:"fields,omitempty"`    // Requested fields.
	AllUsers *bool   `json:"all_users,omitempty"` // Return scheduled plans belonging to all users for the look
}

// Dynamically generated request type for scheduled_plans_for_lookml_dashboard
type RequestScheduledPlansForLookmlDashboard struct {
	LookmlDashboardId string  `json:"lookml_dashboard_id"` // LookML Dashboard Id
	UserId            *string `json:"user_id,omitempty"`   // User Id (default is requesting user if not specified)
	Fields            *string `json:"fields,omitempty"`    // Requested fields.
	AllUsers          *bool   `json:"all_users,omitempty"` // Return scheduled plans belonging to all users for the dashboard
}

// Dynamically generated request type for search_alerts
type RequestSearchAlerts struct {
	Limit        *int64  `json:"limit,omitempty"`          // (Optional) Number of results to return (used with `offset`).
	Offset       *int64  `json:"offset,omitempty"`         // (Optional) Number of results to skip before returning any (used with `limit`).
	GroupBy      *string `json:"group_by,omitempty"`       // (Optional) Dimension by which to order the results(`dashboard` | `owner`)
	Fields       *string `json:"fields,omitempty"`         // (Optional) Requested fields.
	Disabled     *bool   `json:"disabled,omitempty"`       // (Optional) Filter on returning only enabled or disabled alerts.
	Frequency    *string `json:"frequency,omitempty"`      // (Optional) Filter on alert frequency, such as: monthly, weekly, daily, hourly, minutes
	ConditionMet *bool   `json:"condition_met,omitempty"`  // (Optional) Filter on whether the alert has met its condition when it last executed
	LastRunStart *string `json:"last_run_start,omitempty"` // (Optional) Filter on the start range of the last time the alerts were run. Example: 2021-01-01T01:01:01-08:00.
	LastRunEnd   *string `json:"last_run_end,omitempty"`   // (Optional) Filter on the start range of the last time the alerts were run. Example: 2021-01-01T01:01:01-08:00.
	AllOwners    *bool   `json:"all_owners,omitempty"`     // (Admin only) (Optional) Filter for all owners.
}

// Dynamically generated request type for search_artifacts
type RequestSearchArtifacts struct {
	Namespace string  `json:"namespace"`          // Artifact storage namespace
	Fields    *string `json:"fields,omitempty"`   // Comma-delimited names of fields to return in responses. Omit for all fields
	Key       *string `json:"key,omitempty"`      // Key pattern to match
	UserIds   *string `json:"user_ids,omitempty"` // Ids of users who created or updated the artifact (comma-delimited list)
	MinSize   *int64  `json:"min_size,omitempty"` // Minimum storage size of the artifact
	MaxSize   *int64  `json:"max_size,omitempty"` // Maximum storage size of the artifact
	Limit     *int64  `json:"limit,omitempty"`    // Number of results to return. (used with offset)
	Offset    *int64  `json:"offset,omitempty"`   // Number of results to skip before returning any. (used with limit)
}

// Dynamically generated request type for search_boards
type RequestSearchBoards struct {
	Title      *string `json:"title,omitempty"`      // Matches board title.
	CreatedAt  *string `json:"created_at,omitempty"` // Matches the timestamp for when the board was created.
	FirstName  *string `json:"first_name,omitempty"` // The first name of the user who created this board.
	LastName   *string `json:"last_name,omitempty"`  // The last name of the user who created this board.
	Fields     *string `json:"fields,omitempty"`     // Requested fields.
	Favorited  *bool   `json:"favorited,omitempty"`  // Return favorited boards when true.
	CreatorId  *string `json:"creator_id,omitempty"` // Filter on boards created by a particular user.
	Sorts      *string `json:"sorts,omitempty"`      // The fields to sort the results by
	Page       *int64  `json:"page,omitempty"`       // DEPRECATED. Use limit and offset instead. Return only page N of paginated results
	PerPage    *int64  `json:"per_page,omitempty"`   // DEPRECATED. Use limit and offset instead. Return N rows of data per page
	Offset     *int64  `json:"offset,omitempty"`     // Number of results to return. (used with offset and takes priority over page and per_page)
	Limit      *int64  `json:"limit,omitempty"`      // Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
	FilterOr   *bool   `json:"filter_or,omitempty"`  // Combine given search criteria in a boolean OR expression
	Permission *string `json:"permission,omitempty"` // Filter results based on permission, either show (default) or update
}

// Dynamically generated request type for search_content
type RequestSearchContent struct {
	Terms   string  `json:"terms"`              // Search terms
	Fields  *string `json:"fields,omitempty"`   // Requested fields.
	Types   *string `json:"types,omitempty"`    // Content types requested (dashboard, look, lookml_dashboard).
	Limit   *int64  `json:"limit,omitempty"`    // Number of results to return. (used with offset and takes priority over page and per_page)
	Offset  *int64  `json:"offset,omitempty"`   // Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
	Page    *int64  `json:"page,omitempty"`     // DEPRECATED. Use limit and offset instead. Return only page N of paginated results
	PerPage *int64  `json:"per_page,omitempty"` // DEPRECATED. Use limit and offset instead. Return N rows of data per page
}

// Dynamically generated request type for search_content_favorites
type RequestSearchContentFavorites struct {
	Id                *string `json:"id,omitempty"`                  // Match content favorite id(s)
	UserId            *string `json:"user_id,omitempty"`             // Match user id(s).To create a list of multiple ids, use commas as separators
	ContentMetadataId *string `json:"content_metadata_id,omitempty"` // Match content metadata id(s).To create a list of multiple ids, use commas as separators
	DashboardId       *string `json:"dashboard_id,omitempty"`        // Match dashboard id(s).To create a list of multiple ids, use commas as separators
	LookId            *string `json:"look_id,omitempty"`             // Match look id(s).To create a list of multiple ids, use commas as separators
	BoardId           *string `json:"board_id,omitempty"`            // Match board id(s).To create a list of multiple ids, use commas as separators
	Limit             *int64  `json:"limit,omitempty"`               // Number of results to return. (used with offset)
	Offset            *int64  `json:"offset,omitempty"`              // Number of results to skip before returning any. (used with limit)
	Sorts             *string `json:"sorts,omitempty"`               // Fields to sort by.
	Fields            *string `json:"fields,omitempty"`              // Requested fields.
	FilterOr          *bool   `json:"filter_or,omitempty"`           // Combine given search criteria in a boolean OR expression
}

// Dynamically generated request type for search_content_views
type RequestSearchContentViews struct {
	ViewCount         *string `json:"view_count,omitempty"`          // Match view count
	GroupId           *string `json:"group_id,omitempty"`            // Match Group Id
	LookId            *string `json:"look_id,omitempty"`             // Match look_id
	DashboardId       *string `json:"dashboard_id,omitempty"`        // Match dashboard_id
	ContentMetadataId *string `json:"content_metadata_id,omitempty"` // Match content metadata id
	StartOfWeekDate   *string `json:"start_of_week_date,omitempty"`  // Match start of week date (format is "YYYY-MM-DD")
	AllTime           *bool   `json:"all_time,omitempty"`            // True if only all time view records should be returned
	UserId            *string `json:"user_id,omitempty"`             // Match user id
	Fields            *string `json:"fields,omitempty"`              // Requested fields
	Limit             *int64  `json:"limit,omitempty"`               // Number of results to return. Use with `offset` to manage pagination of results
	Offset            *int64  `json:"offset,omitempty"`              // Number of results to skip before returning data
	Sorts             *string `json:"sorts,omitempty"`               // Fields to sort by
	FilterOr          *bool   `json:"filter_or,omitempty"`           // Combine given search criteria in a boolean OR expression
}

// Dynamically generated request type for search_credentials_email
type RequestSearchCredentialsEmail struct {
	Fields   *string `json:"fields,omitempty"`    // Requested fields.
	Limit    *int64  `json:"limit,omitempty"`     // Number of results to return (used with `offset`).
	Offset   *int64  `json:"offset,omitempty"`    // Number of results to skip before returning any (used with `limit`).
	Sorts    *string `json:"sorts,omitempty"`     // Fields to sort by.
	Id       *string `json:"id,omitempty"`        // Match credentials_email id.
	Email    *string `json:"email,omitempty"`     // Match credentials_email email.
	Emails   *string `json:"emails,omitempty"`    // Find credentials_email that match given emails.
	FilterOr *bool   `json:"filter_or,omitempty"` // Combine given search criteria in a boolean OR expression.
}

// Dynamically generated request type for search_dashboard_elements
type RequestSearchDashboardElements struct {
	DashboardId *string `json:"dashboard_id,omitempty"` // Select elements that refer to a given dashboard id
	LookId      *string `json:"look_id,omitempty"`      // Select elements that refer to a given look id
	Title       *string `json:"title,omitempty"`        // Match the title of element
	Deleted     *bool   `json:"deleted,omitempty"`      // Select soft-deleted dashboard elements
	Fields      *string `json:"fields,omitempty"`       // Requested fields.
	FilterOr    *bool   `json:"filter_or,omitempty"`    // Combine given search criteria in a boolean OR expression
	Sorts       *string `json:"sorts,omitempty"`        // Fields to sort by. Sortable fields: [:look_id, :dashboard_id, :deleted, :title]
}

// Dynamically generated request type for search_dashboards
type RequestSearchDashboards struct {
	Id                *string `json:"id,omitempty"`                  // Match dashboard id.
	Slug              *string `json:"slug,omitempty"`                // Match dashboard slug.
	Title             *string `json:"title,omitempty"`               // Match Dashboard title.
	Description       *string `json:"description,omitempty"`         // Match Dashboard description.
	ContentFavoriteId *string `json:"content_favorite_id,omitempty"` // Filter on a content favorite id.
	FolderId          *string `json:"folder_id,omitempty"`           // Filter on a particular folder.
	Deleted           *string `json:"deleted,omitempty"`             // Filter on dashboards deleted status.
	UserId            *string `json:"user_id,omitempty"`             // Filter on dashboards created by a particular user.
	ViewCount         *string `json:"view_count,omitempty"`          // Filter on a particular value of view_count
	ContentMetadataId *string `json:"content_metadata_id,omitempty"` // Filter on a content favorite id.
	Curate            *bool   `json:"curate,omitempty"`              // Exclude items that exist only in personal spaces other than the users
	LastViewedAt      *string `json:"last_viewed_at,omitempty"`      // Select dashboards based on when they were last viewed
	Fields            *string `json:"fields,omitempty"`              // Requested fields.
	Page              *int64  `json:"page,omitempty"`                // DEPRECATED. Use limit and offset instead. Return only page N of paginated results
	PerPage           *int64  `json:"per_page,omitempty"`            // DEPRECATED. Use limit and offset instead. Return N rows of data per page
	Limit             *int64  `json:"limit,omitempty"`               // Number of results to return. (used with offset and takes priority over page and per_page)
	Offset            *int64  `json:"offset,omitempty"`              // Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
	Sorts             *string `json:"sorts,omitempty"`               // One or more fields to sort by. Sortable fields: [:title, :user_id, :id, :created_at, :space_id, :folder_id, :description, :view_count, :favorite_count, :slug, :content_favorite_id, :content_metadata_id, :deleted, :deleted_at, :last_viewed_at, :last_accessed_at]
	FilterOr          *bool   `json:"filter_or,omitempty"`           // Combine given search criteria in a boolean OR expression
	NotOwnedBy        *bool   `json:"not_owned_by,omitempty"`        // Filter out the dashboards owned by the user passed at the :user_id params
}

// Dynamically generated request type for search_folders
type RequestSearchFolders struct {
	Fields       *string `json:"fields,omitempty"`         // Requested fields.
	Page         *int64  `json:"page,omitempty"`           // DEPRECATED. Use limit and offset instead. Return only page N of paginated results
	PerPage      *int64  `json:"per_page,omitempty"`       // DEPRECATED. Use limit and offset instead. Return N rows of data per page
	Limit        *int64  `json:"limit,omitempty"`          // Number of results to return. (used with offset and takes priority over page and per_page)
	Offset       *int64  `json:"offset,omitempty"`         // Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
	Sorts        *string `json:"sorts,omitempty"`          // Fields to sort by.
	Name         *string `json:"name,omitempty"`           // Match Space title.
	Id           *string `json:"id,omitempty"`             // Match Space id
	ParentId     *string `json:"parent_id,omitempty"`      // Filter on a children of a particular folder.
	CreatorId    *string `json:"creator_id,omitempty"`     // Filter on folder created by a particular user.
	FilterOr     *bool   `json:"filter_or,omitempty"`      // Combine given search criteria in a boolean OR expression
	IsSharedRoot *bool   `json:"is_shared_root,omitempty"` // Match is shared root
	IsUsersRoot  *bool   `json:"is_users_root,omitempty"`  // Match is users root
}

// Dynamically generated request type for search_groups
type RequestSearchGroups struct {
	Fields             *string `json:"fields,omitempty"`              // Requested fields.
	Limit              *int64  `json:"limit,omitempty"`               // Number of results to return (used with `offset`).
	Offset             *int64  `json:"offset,omitempty"`              // Number of results to skip before returning any (used with `limit`).
	Sorts              *string `json:"sorts,omitempty"`               // Fields to sort by.
	FilterOr           *bool   `json:"filter_or,omitempty"`           // Combine given search criteria in a boolean OR expression
	Id                 *string `json:"id,omitempty"`                  // Match group id.
	Name               *string `json:"name,omitempty"`                // Match group name.
	ExternalGroupId    *string `json:"external_group_id,omitempty"`   // Match group external_group_id.
	ExternallyManaged  *bool   `json:"externally_managed,omitempty"`  // Match group externally_managed.
	ExternallyOrphaned *bool   `json:"externally_orphaned,omitempty"` // Match group externally_orphaned.
}

// Dynamically generated request type for search_groups_with_hierarchy
type RequestSearchGroupsWithHierarchy struct {
	Fields             *string `json:"fields,omitempty"`              // Requested fields.
	Limit              *int64  `json:"limit,omitempty"`               // Number of results to return (used with `offset`).
	Offset             *int64  `json:"offset,omitempty"`              // Number of results to skip before returning any (used with `limit`).
	Sorts              *string `json:"sorts,omitempty"`               // Fields to sort by.
	FilterOr           *bool   `json:"filter_or,omitempty"`           // Combine given search criteria in a boolean OR expression
	Id                 *string `json:"id,omitempty"`                  // Match group id.
	Name               *string `json:"name,omitempty"`                // Match group name.
	ExternalGroupId    *string `json:"external_group_id,omitempty"`   // Match group external_group_id.
	ExternallyManaged  *bool   `json:"externally_managed,omitempty"`  // Match group externally_managed.
	ExternallyOrphaned *bool   `json:"externally_orphaned,omitempty"` // Match group externally_orphaned.
}

// Dynamically generated request type for search_groups_with_roles
type RequestSearchGroupsWithRoles struct {
	Fields             *string `json:"fields,omitempty"`              // Requested fields.
	Limit              *int64  `json:"limit,omitempty"`               // Number of results to return (used with `offset`).
	Offset             *int64  `json:"offset,omitempty"`              // Number of results to skip before returning any (used with `limit`).
	Sorts              *string `json:"sorts,omitempty"`               // Fields to sort by.
	FilterOr           *bool   `json:"filter_or,omitempty"`           // Combine given search criteria in a boolean OR expression
	Id                 *string `json:"id,omitempty"`                  // Match group id.
	Name               *string `json:"name,omitempty"`                // Match group name.
	ExternalGroupId    *string `json:"external_group_id,omitempty"`   // Match group external_group_id.
	ExternallyManaged  *bool   `json:"externally_managed,omitempty"`  // Match group externally_managed.
	ExternallyOrphaned *bool   `json:"externally_orphaned,omitempty"` // Match group externally_orphaned.
}

// Dynamically generated request type for search_looks
type RequestSearchLooks struct {
	Id                *string `json:"id,omitempty"`                  // Match look id.
	Title             *string `json:"title,omitempty"`               // Match Look title.
	Description       *string `json:"description,omitempty"`         // Match Look description.
	ContentFavoriteId *string `json:"content_favorite_id,omitempty"` // Select looks with a particular content favorite id
	FolderId          *string `json:"folder_id,omitempty"`           // Select looks in a particular folder.
	UserId            *string `json:"user_id,omitempty"`             // Select looks created by a particular user.
	ViewCount         *string `json:"view_count,omitempty"`          // Select looks with particular view_count value
	Deleted           *bool   `json:"deleted,omitempty"`             // Select soft-deleted looks
	QueryId           *string `json:"query_id,omitempty"`            // Select looks that reference a particular query by query_id
	Curate            *bool   `json:"curate,omitempty"`              // Exclude items that exist only in personal spaces other than the users
	LastViewedAt      *string `json:"last_viewed_at,omitempty"`      // Select looks based on when they were last viewed
	Fields            *string `json:"fields,omitempty"`              // Requested fields.
	Page              *int64  `json:"page,omitempty"`                // DEPRECATED. Use limit and offset instead. Return only page N of paginated results
	PerPage           *int64  `json:"per_page,omitempty"`            // DEPRECATED. Use limit and offset instead. Return N rows of data per page
	Limit             *int64  `json:"limit,omitempty"`               // Number of results to return. (used with offset and takes priority over page and per_page)
	Offset            *int64  `json:"offset,omitempty"`              // Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
	Sorts             *string `json:"sorts,omitempty"`               // One or more fields to sort results by. Sortable fields: [:title, :user_id, :id, :created_at, :space_id, :folder_id, :description, :updated_at, :last_updater_id, :view_count, :favorite_count, :content_favorite_id, :deleted, :deleted_at, :last_viewed_at, :last_accessed_at, :query_id]
	FilterOr          *bool   `json:"filter_or,omitempty"`           // Combine given search criteria in a boolean OR expression
}

// Dynamically generated request type for search_model_sets
type RequestSearchModelSets struct {
	Fields    *string `json:"fields,omitempty"`     // Requested fields.
	Limit     *int64  `json:"limit,omitempty"`      // Number of results to return (used with `offset`).
	Offset    *int64  `json:"offset,omitempty"`     // Number of results to skip before returning any (used with `limit`).
	Sorts     *string `json:"sorts,omitempty"`      // Fields to sort by.
	Id        *string `json:"id,omitempty"`         // Match model set id.
	Name      *string `json:"name,omitempty"`       // Match model set name.
	AllAccess *bool   `json:"all_access,omitempty"` // Match model sets by all_access status.
	BuiltIn   *bool   `json:"built_in,omitempty"`   // Match model sets by built_in status.
	FilterOr  *bool   `json:"filter_or,omitempty"`  // Combine given search criteria in a boolean OR expression.
}

// Dynamically generated request type for search_permission_sets
type RequestSearchPermissionSets struct {
	Fields    *string `json:"fields,omitempty"`     // Requested fields.
	Limit     *int64  `json:"limit,omitempty"`      // Number of results to return (used with `offset`).
	Offset    *int64  `json:"offset,omitempty"`     // Number of results to skip before returning any (used with `limit`).
	Sorts     *string `json:"sorts,omitempty"`      // Fields to sort by.
	Id        *string `json:"id,omitempty"`         // Match permission set id.
	Name      *string `json:"name,omitempty"`       // Match permission set name.
	AllAccess *bool   `json:"all_access,omitempty"` // Match permission sets by all_access status.
	BuiltIn   *bool   `json:"built_in,omitempty"`   // Match permission sets by built_in status.
	FilterOr  *bool   `json:"filter_or,omitempty"`  // Combine given search criteria in a boolean OR expression.
}

// Dynamically generated request type for search_roles
type RequestSearchRoles struct {
	Fields   *string `json:"fields,omitempty"`    // Requested fields.
	Limit    *int64  `json:"limit,omitempty"`     // Number of results to return (used with `offset`).
	Offset   *int64  `json:"offset,omitempty"`    // Number of results to skip before returning any (used with `limit`).
	Sorts    *string `json:"sorts,omitempty"`     // Fields to sort by.
	Id       *string `json:"id,omitempty"`        // Match role id.
	Name     *string `json:"name,omitempty"`      // Match role name.
	BuiltIn  *bool   `json:"built_in,omitempty"`  // Match roles by built_in status.
	FilterOr *bool   `json:"filter_or,omitempty"` // Combine given search criteria in a boolean OR expression.
}

// Dynamically generated request type for search_roles_with_user_count
type RequestSearchRolesWithUserCount struct {
	Fields   *string `json:"fields,omitempty"`    // Requested fields.
	Limit    *int64  `json:"limit,omitempty"`     // Number of results to return (used with `offset`).
	Offset   *int64  `json:"offset,omitempty"`    // Number of results to skip before returning any (used with `limit`).
	Sorts    *string `json:"sorts,omitempty"`     // Fields to sort by.
	Id       *string `json:"id,omitempty"`        // Match role id.
	Name     *string `json:"name,omitempty"`      // Match role name.
	BuiltIn  *bool   `json:"built_in,omitempty"`  // Match roles by built_in status.
	FilterOr *bool   `json:"filter_or,omitempty"` // Combine given search criteria in a boolean OR expression.
}

// Dynamically generated request type for search_themes
type RequestSearchThemes struct {
	Id       *string    `json:"id,omitempty"`        // Match theme id.
	Name     *string    `json:"name,omitempty"`      // Match theme name.
	BeginAt  *time.Time `json:"begin_at,omitempty"`  // Timestamp for activation.
	EndAt    *time.Time `json:"end_at,omitempty"`    // Timestamp for expiration.
	Limit    *int64     `json:"limit,omitempty"`     // Number of results to return (used with `offset`).
	Offset   *int64     `json:"offset,omitempty"`    // Number of results to skip before returning any (used with `limit`).
	Sorts    *string    `json:"sorts,omitempty"`     // Fields to sort by.
	Fields   *string    `json:"fields,omitempty"`    // Requested fields.
	FilterOr *bool      `json:"filter_or,omitempty"` // Combine given search criteria in a boolean OR expression
}

// Dynamically generated request type for search_user_login_lockouts
type RequestSearchUserLoginLockouts struct {
	Fields   *string `json:"fields,omitempty"`    // Include only these fields in the response
	Page     *int64  `json:"page,omitempty"`      // DEPRECATED. Use limit and offset instead. Return only page N of paginated results
	PerPage  *int64  `json:"per_page,omitempty"`  // DEPRECATED. Use limit and offset instead. Return N rows of data per page
	Limit    *int64  `json:"limit,omitempty"`     // Number of results to return. (used with offset and takes priority over page and per_page)
	Offset   *int64  `json:"offset,omitempty"`    // Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
	Sorts    *string `json:"sorts,omitempty"`     // Fields to sort by.
	AuthType *string `json:"auth_type,omitempty"` // Auth type user is locked out for (email, ldap, totp, api)
	FullName *string `json:"full_name,omitempty"` // Match name
	Email    *string `json:"email,omitempty"`     // Match email
	RemoteId *string `json:"remote_id,omitempty"` // Match remote LDAP ID
	FilterOr *bool   `json:"filter_or,omitempty"` // Combine given search criteria in a boolean OR expression
}

// Dynamically generated request type for search_users
type RequestSearchUsers struct {
	Fields                 *string `json:"fields,omitempty"`                   // Include only these fields in the response
	Page                   *int64  `json:"page,omitempty"`                     // DEPRECATED. Use limit and offset instead. Return only page N of paginated results
	PerPage                *int64  `json:"per_page,omitempty"`                 // DEPRECATED. Use limit and offset instead. Return N rows of data per page
	Limit                  *int64  `json:"limit,omitempty"`                    // Number of results to return. (used with offset and takes priority over page and per_page)
	Offset                 *int64  `json:"offset,omitempty"`                   // Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
	Sorts                  *string `json:"sorts,omitempty"`                    // Fields to sort by.
	Id                     *string `json:"id,omitempty"`                       // Match User Id.
	FirstName              *string `json:"first_name,omitempty"`               // Match First name.
	LastName               *string `json:"last_name,omitempty"`                // Match Last name.
	VerifiedLookerEmployee *bool   `json:"verified_looker_employee,omitempty"` // Search for user accounts associated with Looker employees
	EmbedUser              *bool   `json:"embed_user,omitempty"`               // Search for only embed users
	Email                  *string `json:"email,omitempty"`                    // Search for the user with this email address
	IsDisabled             *bool   `json:"is_disabled,omitempty"`              // Search for disabled user accounts
	FilterOr               *bool   `json:"filter_or,omitempty"`                // Combine given search criteria in a boolean OR expression
	ContentMetadataId      *string `json:"content_metadata_id,omitempty"`      // Search for users who have access to this content_metadata item
	GroupId                *string `json:"group_id,omitempty"`                 // Search for users who are direct members of this group
}

// Dynamically generated request type for search_users_names
type RequestSearchUsersNames struct {
	Pattern                string  `json:"pattern"`                            // Pattern to match
	Fields                 *string `json:"fields,omitempty"`                   // Include only these fields in the response
	Page                   *int64  `json:"page,omitempty"`                     // DEPRECATED. Use limit and offset instead. Return only page N of paginated results
	PerPage                *int64  `json:"per_page,omitempty"`                 // DEPRECATED. Use limit and offset instead. Return N rows of data per page
	Limit                  *int64  `json:"limit,omitempty"`                    // Number of results to return. (used with offset and takes priority over page and per_page)
	Offset                 *int64  `json:"offset,omitempty"`                   // Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
	Sorts                  *string `json:"sorts,omitempty"`                    // Fields to sort by
	Id                     *string `json:"id,omitempty"`                       // Match User Id
	FirstName              *string `json:"first_name,omitempty"`               // Match First name
	LastName               *string `json:"last_name,omitempty"`                // Match Last name
	VerifiedLookerEmployee *bool   `json:"verified_looker_employee,omitempty"` // Match Verified Looker employee
	Email                  *string `json:"email,omitempty"`                    // Match Email Address
	IsDisabled             *bool   `json:"is_disabled,omitempty"`              // Include or exclude disabled accounts in the results
}

// Dynamically generated request type for start_pdt_build
type RequestStartPdtBuild struct {
	ModelName            string  `json:"model_name"`                       // The model of the PDT to start building.
	ViewName             string  `json:"view_name"`                        // The view name of the PDT to start building.
	ForceRebuild         *string `json:"force_rebuild,omitempty"`          // Force rebuild of required dependent PDTs, even if they are already materialized.
	ForceFullIncremental *string `json:"force_full_incremental,omitempty"` // Force involved incremental PDTs to fully re-materialize.
	Workspace            *string `json:"workspace,omitempty"`              // Workspace in which to materialize selected PDT ('dev' or default 'production').
	Source               *string `json:"source,omitempty"`                 // The source of this request.
}

// Dynamically generated request type for tag_ref
type RequestTagRef struct {
	ProjectId  string       `json:"project_id"` // Project Id
	Body       WriteProject `json:"body"`
	CommitSha  *string      `json:"commit_sha,omitempty"`  // (Optional): Commit Sha to Tag
	TagName    *string      `json:"tag_name,omitempty"`    // Tag Name
	TagMessage *string      `json:"tag_message,omitempty"` // (Optional): Tag Message
}

// Dynamically generated request type for user_attribute_user_values
type RequestUserAttributeUserValues struct {
	UserId           string           `json:"user_id"`                      // Id of user
	Fields           *string          `json:"fields,omitempty"`             // Requested fields.
	UserAttributeIds *rtl.DelimString `json:"user_attribute_ids,omitempty"` // Specific user attributes to request. Omit or leave blank to request all user attributes.
	AllValues        *bool            `json:"all_values,omitempty"`         // If true, returns all values in the search path instead of just the first value found. Useful for debugging group precedence.
	IncludeUnset     *bool            `json:"include_unset,omitempty"`      // If true, returns an empty record for each requested attribute that has no user, group, or default value.
}

// Dynamically generated request type for user_roles
type RequestUserRoles struct {
	UserId                string  `json:"user_id"`                           // Id of user
	Fields                *string `json:"fields,omitempty"`                  // Requested fields.
	DirectAssociationOnly *bool   `json:"direct_association_only,omitempty"` // Get only roles associated directly with the user: exclude those only associated through groups.
}

type ResultFormat string

const ResultFormat_InlineJson ResultFormat = "inline_json"
const ResultFormat_Json ResultFormat = "json"
const ResultFormat_JsonDetail ResultFormat = "json_detail"
const ResultFormat_JsonFe ResultFormat = "json_fe"
const ResultFormat_JsonBi ResultFormat = "json_bi"
const ResultFormat_Csv ResultFormat = "csv"
const ResultFormat_Html ResultFormat = "html"
const ResultFormat_Md ResultFormat = "md"
const ResultFormat_Txt ResultFormat = "txt"
const ResultFormat_Xlsx ResultFormat = "xlsx"
const ResultFormat_Gsxml ResultFormat = "gsxml"
const ResultFormat_Sql ResultFormat = "sql"

type ResultMakerFilterables struct {
	Model  *string                         `json:"model,omitempty"`  // The model this filterable comes from (used for field suggestions).
	View   *string                         `json:"view,omitempty"`   // The view this filterable comes from (used for field suggestions).
	Name   *string                         `json:"name,omitempty"`   // The name of the filterable thing (Query or Merged Results).
	Listen *[]ResultMakerFilterablesListen `json:"listen,omitempty"` // array of dashboard_filter_name: and field: objects.
}

type ResultMakerFilterablesListen struct {
	DashboardFilterName *string `json:"dashboard_filter_name,omitempty"` // The name of a dashboard filter to listen to.
	Field               *string `json:"field,omitempty"`                 // The name of the field in the filterable to filter with the value of the dashboard filter.
}

type ResultMakerWithIdVisConfigAndDynamicFields struct {
	Id            *string                   `json:"id,omitempty"`              // Unique Id.
	DynamicFields *string                   `json:"dynamic_fields,omitempty"`  // JSON string of dynamic field information.
	Filterables   *[]ResultMakerFilterables `json:"filterables,omitempty"`     // array of items that can be filtered and information about them.
	Sorts         *[]string                 `json:"sorts,omitempty"`           // Sorts of the constituent Look, Query, or Merge Query
	MergeResultId *string                   `json:"merge_result_id,omitempty"` // ID of merge result if this is a merge_result.
	Total         *bool                     `json:"total,omitempty"`           // Total of the constituent Look, Query, or Merge Query
	QueryId       *string                   `json:"query_id,omitempty"`        // ID of query if this is a query.
	SqlQueryId    *string                   `json:"sql_query_id,omitempty"`    // ID of SQL Query if this is a SQL Runner Query
	Query         *Query                    `json:"query,omitempty"`
	VisConfig     *map[string]interface{}   `json:"vis_config,omitempty"` // Vis config of the constituent Query, or Merge Query.
}

type Role struct {
	Can             *map[string]bool `json:"can,omitempty"`  // Operations the current user is able to perform on this object
	Id              *string          `json:"id,omitempty"`   // Unique Id
	Name            *string          `json:"name,omitempty"` // Name of Role
	PermissionSet   *PermissionSet   `json:"permission_set,omitempty"`
	PermissionSetId *string          `json:"permission_set_id,omitempty"` // (Write-Only) Id of permission set
	ModelSet        *ModelSet        `json:"model_set,omitempty"`
	ModelSetId      *string          `json:"model_set_id,omitempty"` // (Write-Only) Id of model set
	Url             *string          `json:"url,omitempty"`          // Link to get this item
	UsersUrl        *string          `json:"users_url,omitempty"`    // Link to get list of users with this role
}

type RoleSearch struct {
	Can             *map[string]bool `json:"can,omitempty"`  // Operations the current user is able to perform on this object
	Id              *string          `json:"id,omitempty"`   // Unique Id
	Name            *string          `json:"name,omitempty"` // Name of Role
	PermissionSet   *PermissionSet   `json:"permission_set,omitempty"`
	PermissionSetId *string          `json:"permission_set_id,omitempty"` // (Write-Only) Id of permission set
	ModelSet        *ModelSet        `json:"model_set,omitempty"`
	ModelSetId      *string          `json:"model_set_id,omitempty"` // (Write-Only) Id of model set
	UserCount       *int64           `json:"user_count,omitempty"`   // Count of users with this role
	Url             *string          `json:"url,omitempty"`          // Link to get this item
	UsersUrl        *string          `json:"users_url,omitempty"`    // Link to get list of users with this role
}

type RunningQueries struct {
	Can            *map[string]bool `json:"can,omitempty"` // Operations the current user is able to perform on this object
	Id             *string          `json:"id,omitempty"`  // Unique Id
	User           *UserPublic      `json:"user,omitempty"`
	Query          *Query           `json:"query,omitempty"`
	SqlQuery       *SqlQuery        `json:"sql_query,omitempty"`
	Look           *LookBasic       `json:"look,omitempty"`
	CreatedAt      *string          `json:"created_at,omitempty"`      // Date/Time Query was initiated
	CompletedAt    *string          `json:"completed_at,omitempty"`    // Date/Time Query was completed
	QueryId        *string          `json:"query_id,omitempty"`        // Query Id
	Source         *string          `json:"source,omitempty"`          // Source (look, dashboard, queryrunner, explore, etc.)
	NodeId         *string          `json:"node_id,omitempty"`         // Node Id
	Slug           *string          `json:"slug,omitempty"`            // Slug
	QueryTaskId    *string          `json:"query_task_id,omitempty"`   // ID of a Query Task
	CacheKey       *string          `json:"cache_key,omitempty"`       // Cache Key
	ConnectionName *string          `json:"connection_name,omitempty"` // Connection
	Dialect        *string          `json:"dialect,omitempty"`         // Dialect
	ConnectionId   *string          `json:"connection_id,omitempty"`   // Connection ID
	Message        *string          `json:"message,omitempty"`         // Additional Information(Error message or verbose status)
	Status         *string          `json:"status,omitempty"`          // Status description
	Runtime        *float64         `json:"runtime,omitempty"`         // Number of seconds elapsed running the Query
	Sql            *string          `json:"sql,omitempty"`             // SQL text of the query as run
}

type SamlConfig struct {
	Can                        *map[string]bool          `json:"can,omitempty"`                            // Operations the current user is able to perform on this object
	Enabled                    *bool                     `json:"enabled,omitempty"`                        // Enable/Disable Saml authentication for the server
	IdpCert                    *string                   `json:"idp_cert,omitempty"`                       // Identity Provider Certificate (provided by IdP)
	IdpUrl                     *string                   `json:"idp_url,omitempty"`                        // Identity Provider Url (provided by IdP)
	IdpIssuer                  *string                   `json:"idp_issuer,omitempty"`                     // Identity Provider Issuer (provided by IdP)
	IdpAudience                *string                   `json:"idp_audience,omitempty"`                   // Identity Provider Audience (set in IdP config). Optional in Looker. Set this only if you want Looker to validate the audience value returned by the IdP.
	AllowedClockDrift          *int64                    `json:"allowed_clock_drift,omitempty"`            // Count of seconds of clock drift to allow when validating timestamps of assertions.
	UserAttributeMapEmail      *string                   `json:"user_attribute_map_email,omitempty"`       // Name of user record attributes used to indicate email address field
	UserAttributeMapFirstName  *string                   `json:"user_attribute_map_first_name,omitempty"`  // Name of user record attributes used to indicate first name
	UserAttributeMapLastName   *string                   `json:"user_attribute_map_last_name,omitempty"`   // Name of user record attributes used to indicate last name
	NewUserMigrationTypes      *string                   `json:"new_user_migration_types,omitempty"`       // Merge first-time saml login to existing user account by email addresses. When a user logs in for the first time via saml this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
	AlternateEmailLoginAllowed *bool                     `json:"alternate_email_login_allowed,omitempty"`  // Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
	TestSlug                   *string                   `json:"test_slug,omitempty"`                      // Slug to identify configurations that are created in order to run a Saml config test
	ModifiedAt                 *string                   `json:"modified_at,omitempty"`                    // When this config was last modified
	ModifiedBy                 *string                   `json:"modified_by,omitempty"`                    // User id of user who last modified this config
	DefaultNewUserRoles        *[]Role                   `json:"default_new_user_roles,omitempty"`         // (Read-only) Roles that will be applied to new users the first time they login via Saml
	DefaultNewUserGroups       *[]Group                  `json:"default_new_user_groups,omitempty"`        // (Read-only) Groups that will be applied to new users the first time they login via Saml
	DefaultNewUserRoleIds      *[]string                 `json:"default_new_user_role_ids,omitempty"`      // (Write-Only) Array of ids of roles that will be applied to new users the first time they login via Saml
	DefaultNewUserGroupIds     *[]string                 `json:"default_new_user_group_ids,omitempty"`     // (Write-Only) Array of ids of groups that will be applied to new users the first time they login via Saml
	SetRolesFromGroups         *bool                     `json:"set_roles_from_groups,omitempty"`          // Set user roles in Looker based on groups from Saml
	GroupsAttribute            *string                   `json:"groups_attribute,omitempty"`               // Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
	Groups                     *[]SamlGroupRead          `json:"groups,omitempty"`                         // (Read-only) Array of mappings between Saml Groups and Looker Roles
	GroupsWithRoleIds          *[]SamlGroupWrite         `json:"groups_with_role_ids,omitempty"`           // (Read/Write) Array of mappings between Saml Groups and arrays of Looker Role ids
	AuthRequiresRole           *bool                     `json:"auth_requires_role,omitempty"`             // Users will not be allowed to login at all unless a role for them is found in Saml if set to true
	UserAttributes             *[]SamlUserAttributeRead  `json:"user_attributes,omitempty"`                // (Read-only) Array of mappings between Saml User Attributes and Looker User Attributes
	UserAttributesWithIds      *[]SamlUserAttributeWrite `json:"user_attributes_with_ids,omitempty"`       // (Read/Write) Array of mappings between Saml User Attributes and arrays of Looker User Attribute ids
	GroupsFinderType           *string                   `json:"groups_finder_type,omitempty"`             // Identifier for a strategy for how Looker will find groups in the SAML response. One of ['grouped_attribute_values', 'individual_attributes']
	GroupsMemberValue          *string                   `json:"groups_member_value,omitempty"`            // Value for group attribute used to indicate membership. Used when 'groups_finder_type' is set to 'individual_attributes'
	BypassLoginPage            *bool                     `json:"bypass_login_page,omitempty"`              // Bypass the login page when user authentication is required. Redirect to IdP immediately instead.
	AllowNormalGroupMembership *bool                     `json:"allow_normal_group_membership,omitempty"`  // Allow SAML auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.
	AllowRolesFromNormalGroups *bool                     `json:"allow_roles_from_normal_groups,omitempty"` // SAML auth'd users will inherit roles from non-reflected Looker groups.
	AllowDirectRoles           *bool                     `json:"allow_direct_roles,omitempty"`             // Allows roles to be directly assigned to SAML auth'd users.
	Url                        *string                   `json:"url,omitempty"`                            // Link to get this item
}

type SamlGroupRead struct {
	Id              *string `json:"id,omitempty"`                // Unique Id
	LookerGroupId   *string `json:"looker_group_id,omitempty"`   // Unique Id of group in Looker
	LookerGroupName *string `json:"looker_group_name,omitempty"` // Name of group in Looker
	Name            *string `json:"name,omitempty"`              // Name of group in Saml
	Roles           *[]Role `json:"roles,omitempty"`             // Looker Roles
	Url             *string `json:"url,omitempty"`               // Link to saml config
}

type SamlGroupWrite struct {
	Id              *string   `json:"id,omitempty"`                // Unique Id
	LookerGroupId   *string   `json:"looker_group_id,omitempty"`   // Unique Id of group in Looker
	LookerGroupName *string   `json:"looker_group_name,omitempty"` // Name of group in Looker
	Name            *string   `json:"name,omitempty"`              // Name of group in Saml
	RoleIds         *[]string `json:"role_ids,omitempty"`          // Looker Role Ids
	Url             *string   `json:"url,omitempty"`               // Link to saml config
}

type SamlMetadataParseResult struct {
	Can       *map[string]bool `json:"can,omitempty"`        // Operations the current user is able to perform on this object
	IdpIssuer *string          `json:"idp_issuer,omitempty"` // Identify Provider Issuer
	IdpUrl    *string          `json:"idp_url,omitempty"`    // Identify Provider Url
	IdpCert   *string          `json:"idp_cert,omitempty"`   // Identify Provider Certificate
}

type SamlUserAttributeRead struct {
	Name           *string          `json:"name,omitempty"`            // Name of User Attribute in Saml
	Required       *bool            `json:"required,omitempty"`        // Required to be in Saml assertion for login to be allowed to succeed
	UserAttributes *[]UserAttribute `json:"user_attributes,omitempty"` // Looker User Attributes
	Url            *string          `json:"url,omitempty"`             // Link to saml config
}

type SamlUserAttributeWrite struct {
	Name             *string   `json:"name,omitempty"`               // Name of User Attribute in Saml
	Required         *bool     `json:"required,omitempty"`           // Required to be in Saml assertion for login to be allowed to succeed
	UserAttributeIds *[]string `json:"user_attribute_ids,omitempty"` // Looker User Attribute Ids
	Url              *string   `json:"url,omitempty"`                // Link to saml config
}

type ScheduledPlan struct {
	Name                     *string                     `json:"name,omitempty"`                       // Name of this scheduled plan
	UserId                   *string                     `json:"user_id,omitempty"`                    // User Id which owns this scheduled plan
	RunAsRecipient           *bool                       `json:"run_as_recipient,omitempty"`           // Whether schedule is run as recipient (only applicable for email recipients)
	Enabled                  *bool                       `json:"enabled,omitempty"`                    // Whether the ScheduledPlan is enabled
	LookId                   *string                     `json:"look_id,omitempty"`                    // Id of a look
	DashboardId              *string                     `json:"dashboard_id,omitempty"`               // Id of a dashboard
	LookmlDashboardId        *string                     `json:"lookml_dashboard_id,omitempty"`        // Id of a LookML dashboard
	FiltersString            *string                     `json:"filters_string,omitempty"`             // Query string to run look or dashboard with
	DashboardFilters         *string                     `json:"dashboard_filters,omitempty"`          // (DEPRECATED) Alias for filters_string field
	RequireResults           *bool                       `json:"require_results,omitempty"`            // Delivery should occur if running the dashboard or look returns results
	RequireNoResults         *bool                       `json:"require_no_results,omitempty"`         // Delivery should occur if the dashboard look does not return results
	RequireChange            *bool                       `json:"require_change,omitempty"`             // Delivery should occur if data have changed since the last run
	SendAllResults           *bool                       `json:"send_all_results,omitempty"`           // Will run an unlimited query and send all results.
	Crontab                  *string                     `json:"crontab,omitempty"`                    // Vixie-Style crontab specification when to run
	Datagroup                *string                     `json:"datagroup,omitempty"`                  // Name of a datagroup; if specified will run when datagroup triggered (can't be used with cron string)
	Timezone                 *string                     `json:"timezone,omitempty"`                   // Timezone for interpreting the specified crontab (default is Looker instance timezone)
	QueryId                  *string                     `json:"query_id,omitempty"`                   // Query id
	ScheduledPlanDestination *[]ScheduledPlanDestination `json:"scheduled_plan_destination,omitempty"` // Scheduled plan destinations
	RunOnce                  *bool                       `json:"run_once,omitempty"`                   // Whether the plan in question should only be run once (usually for testing)
	IncludeLinks             *bool                       `json:"include_links,omitempty"`              // Whether links back to Looker should be included in this ScheduledPlan
	CustomUrlBase            *string                     `json:"custom_url_base,omitempty"`            // Custom url domain for the scheduled entity
	CustomUrlParams          *string                     `json:"custom_url_params,omitempty"`          // Custom url path and parameters for the scheduled entity
	CustomUrlLabel           *string                     `json:"custom_url_label,omitempty"`           // Custom url label for the scheduled entity
	ShowCustomUrl            *bool                       `json:"show_custom_url,omitempty"`            // Whether to show custom link back instead of standard looker link
	PdfPaperSize             *string                     `json:"pdf_paper_size,omitempty"`             // The size of paper the PDF should be formatted to fit. Valid values are: "letter", "legal", "tabloid", "a0", "a1", "a2", "a3", "a4", "a5".
	PdfLandscape             *bool                       `json:"pdf_landscape,omitempty"`              // Whether the PDF should be formatted for landscape orientation
	Embed                    *bool                       `json:"embed,omitempty"`                      // Whether this schedule is in an embed context or not
	ColorTheme               *string                     `json:"color_theme,omitempty"`                // Color scheme of the dashboard if applicable
	LongTables               *bool                       `json:"long_tables,omitempty"`                // Whether or not to expand table vis to full length
	InlineTableWidth         *int64                      `json:"inline_table_width,omitempty"`         // The pixel width at which we render the inline table visualizations
	Id                       *string                     `json:"id,omitempty"`                         // Unique Id
	CreatedAt                *time.Time                  `json:"created_at,omitempty"`                 // Date and time when ScheduledPlan was created
	UpdatedAt                *time.Time                  `json:"updated_at,omitempty"`                 // Date and time when ScheduledPlan was last updated
	Title                    *string                     `json:"title,omitempty"`                      // Title
	User                     *UserPublic                 `json:"user,omitempty"`
	NextRunAt                *time.Time                  `json:"next_run_at,omitempty"` // When the ScheduledPlan will next run (null if running once)
	LastRunAt                *time.Time                  `json:"last_run_at,omitempty"` // When the ScheduledPlan was last run
	Can                      *map[string]bool            `json:"can,omitempty"`         // Operations the current user is able to perform on this object
}

type ScheduledPlanDestination struct {
	Id               *string `json:"id,omitempty"`                // Unique Id
	ScheduledPlanId  *string `json:"scheduled_plan_id,omitempty"` // Id of a scheduled plan you own
	Format           *string `json:"format,omitempty"`            // The data format to send to the given destination. Supported formats vary by destination, but include: "txt", "csv", "inline_json", "json", "json_detail", "xlsx", "html", "wysiwyg_pdf", "assembled_pdf", "wysiwyg_png"
	ApplyFormatting  *bool   `json:"apply_formatting,omitempty"`  // Are values formatted? (containing currency symbols, digit separators, etc.
	ApplyVis         *bool   `json:"apply_vis,omitempty"`         // Whether visualization options are applied to the results.
	Address          *string `json:"address,omitempty"`           // Address for recipient. For email e.g. 'user@example.com'. For webhooks e.g. 'https://domain/path'. For Amazon S3 e.g. 's3://bucket-name/path/'. For SFTP e.g. 'sftp://host-name/path/'.
	LookerRecipient  *bool   `json:"looker_recipient,omitempty"`  // Whether the recipient is a Looker user on the current instance (only applicable for email recipients)
	Type             *string `json:"type,omitempty"`              // Type of the address ('email', 'webhook', 's3', or 'sftp')
	Parameters       *string `json:"parameters,omitempty"`        // JSON object containing parameters for external scheduling. For Amazon S3, this requires keys and values for access_key_id and region. For SFTP, this requires a key and value for username.
	SecretParameters *string `json:"secret_parameters,omitempty"` // (Write-Only) JSON object containing secret parameters for external scheduling. For Amazon S3, this requires a key and value for secret_access_key. For SFTP, this requires a key and value for password.
	Message          *string `json:"message,omitempty"`           // Optional message to be included in scheduled emails
}

type Schema struct {
	Name      *string `json:"name,omitempty"`       // Schema name
	IsDefault *bool   `json:"is_default,omitempty"` // True if this is the default schema
}

type SchemaColumn struct {
	Name             *string    `json:"name,omitempty"`               // Schema item name
	SqlEscapedName   *string    `json:"sql_escaped_name,omitempty"`   // Full name of item
	SchemaName       *string    `json:"schema_name,omitempty"`        // Name of schema
	DataTypeDatabase *string    `json:"data_type_database,omitempty"` // SQL dialect data type
	DataType         *string    `json:"data_type,omitempty"`          // Data type
	DataTypeLooker   *string    `json:"data_type_looker,omitempty"`   // Looker data type
	Description      *string    `json:"description,omitempty"`        // SQL data type
	ColumnSize       *int64     `json:"column_size,omitempty"`        // Column data size
	Snippets         *[]Snippet `json:"snippets,omitempty"`           // SQL Runner snippets for this connection
}

type SchemaColumns struct {
	Name           *string         `json:"name,omitempty"`             // Schema item name
	SqlEscapedName *string         `json:"sql_escaped_name,omitempty"` // Full name of item
	SchemaName     *string         `json:"schema_name,omitempty"`      // Name of schema
	Columns        *[]SchemaColumn `json:"columns,omitempty"`          // Columns for this schema
}

type SchemaTable struct {
	Name           *string    `json:"name,omitempty"`             // Schema item name
	SqlEscapedName *string    `json:"sql_escaped_name,omitempty"` // Full name of item
	SchemaName     *string    `json:"schema_name,omitempty"`      // Name of schema
	Rows           *int64     `json:"rows,omitempty"`             // Number of data rows
	External       *string    `json:"external,omitempty"`         // External reference???
	Snippets       *[]Snippet `json:"snippets,omitempty"`         // SQL Runner snippets for connection
}

type SchemaTables struct {
	Name          *string        `json:"name,omitempty"`            // Schema name
	IsDefault     *bool          `json:"is_default,omitempty"`      // True if this is the default schema
	Tables        *[]SchemaTable `json:"tables,omitempty"`          // Tables for this schema
	TableLimitHit *bool          `json:"table_limit_hit,omitempty"` // True if the table limit was hit while retrieving tables in this schema
}

type SecretType string

const SecretType_SSO SecretType = "SSO"
const SecretType_JWT SecretType = "JWT"

type Session struct {
	Can             *map[string]bool `json:"can,omitempty"`              // Operations the current user is able to perform on this object
	Id              *string          `json:"id,omitempty"`               // Unique Id
	IpAddress       *string          `json:"ip_address,omitempty"`       // IP address of user when this session was initiated
	Browser         *string          `json:"browser,omitempty"`          // User's browser type
	OperatingSystem *string          `json:"operating_system,omitempty"` // User's Operating System
	City            *string          `json:"city,omitempty"`             // City component of user location (derived from IP address)
	State           *string          `json:"state,omitempty"`            // State component of user location (derived from IP address)
	Country         *string          `json:"country,omitempty"`          // Country component of user location (derived from IP address)
	CredentialsType *string          `json:"credentials_type,omitempty"` // Type of credentials used for logging in this session
	ExtendedAt      *string          `json:"extended_at,omitempty"`      // Time when this session was last extended by the user
	ExtendedCount   *int64           `json:"extended_count,omitempty"`   // Number of times this session was extended
	SudoUserId      *string          `json:"sudo_user_id,omitempty"`     // Actual user in the case when this session represents one user sudo'ing as another
	CreatedAt       *string          `json:"created_at,omitempty"`       // Time when this session was initiated
	ExpiresAt       *string          `json:"expires_at,omitempty"`       // Time when this session will expire
	Url             *string          `json:"url,omitempty"`              // Link to get this item
}

type SessionConfig struct {
	Can                      *map[string]bool `json:"can,omitempty"`                         // Operations the current user is able to perform on this object
	AllowPersistentSessions  *bool            `json:"allow_persistent_sessions,omitempty"`   // Allow users to have persistent sessions when they login
	SessionMinutes           *int64           `json:"session_minutes,omitempty"`             // Number of minutes for user sessions.  Must be between 5 and 43200
	UnlimitedSessionsPerUser *bool            `json:"unlimited_sessions_per_user,omitempty"` // Allow users to have an unbounded number of concurrent sessions (otherwise, users will be limited to only one session at a time).
	UseInactivityBasedLogout *bool            `json:"use_inactivity_based_logout,omitempty"` // Enforce session logout for sessions that are inactive for 15 minutes.
	TrackSessionLocation     *bool            `json:"track_session_location,omitempty"`      // Track location of session when user logs in.
}

type Setting struct {
	ExtensionFrameworkEnabled     *bool                      `json:"extension_framework_enabled,omitempty"`      // Toggle extension framework on or off
	ExtensionLoadUrlEnabled       *bool                      `json:"extension_load_url_enabled,omitempty"`       // (DEPRECATED) Toggle extension load url on or off. Do not use. This is temporary setting that will eventually become a noop and subsequently deleted.
	MarketplaceAutoInstallEnabled *bool                      `json:"marketplace_auto_install_enabled,omitempty"` // (DEPRECATED) Toggle marketplace auto install on or off. Deprecated - do not use. Auto install can now be enabled via marketplace automation settings
	MarketplaceAutomation         *MarketplaceAutomation     `json:"marketplace_automation,omitempty"`
	MarketplaceEnabled            *bool                      `json:"marketplace_enabled,omitempty"`        // Toggle marketplace on or off
	MarketplaceSite               *string                    `json:"marketplace_site,omitempty"`           // Location of Looker marketplace CDN
	MarketplaceTermsAccepted      *bool                      `json:"marketplace_terms_accepted,omitempty"` // Accept marketplace terms by setting this value to true, or get the current status. Marketplace terms CANNOT be declined once accepted. Accepting marketplace terms automatically enables the marketplace. The marketplace can still be disabled after it has been enabled.
	PrivatelabelConfiguration     *PrivatelabelConfiguration `json:"privatelabel_configuration,omitempty"`
	CustomWelcomeEmail            *CustomWelcomeEmail        `json:"custom_welcome_email,omitempty"`
	OnboardingEnabled             *bool                      `json:"onboarding_enabled,omitempty"`             // Toggle onboarding on or off
	Timezone                      *string                    `json:"timezone,omitempty"`                       // Change instance-wide default timezone
	AllowUserTimezones            *bool                      `json:"allow_user_timezones,omitempty"`           // Toggle user-specific timezones on or off
	DataConnectorDefaultEnabled   *bool                      `json:"data_connector_default_enabled,omitempty"` // Toggle default future connectors on or off
	HostUrl                       *string                    `json:"host_url,omitempty"`                       // Change the base portion of your Looker instance URL setting
	OverrideWarnings              *bool                      `json:"override_warnings,omitempty"`              // (Write-Only) If warnings are preventing a host URL change, this parameter allows for overriding warnings to force update the setting. Does not directly change any Looker settings.
	EmailDomainAllowlist          *[]string                  `json:"email_domain_allowlist,omitempty"`         // An array of Email Domain Allowlist of type string for Scheduled Content
	EmbedCookielessV2             *bool                      `json:"embed_cookieless_v2,omitempty"`            // (DEPRECATED) Use embed_config.embed_cookieless_v2 instead. If embed_config.embed_cookieless_v2 is specified, it overrides this value.
	EmbedEnabled                  *bool                      `json:"embed_enabled,omitempty"`                  // True if embedding is enabled https://cloud.google.com/looker/docs/r/looker-core-feature-embed, false otherwise
	EmbedConfig                   *EmbedConfig               `json:"embed_config,omitempty"`
	LoginNotificationEnabled      *bool                      `json:"login_notification_enabled,omitempty"` // Login notification enabled
	LoginNotificationText         *string                    `json:"login_notification_text,omitempty"`    // Login notification text
}

type SmtpNodeStatus struct {
	IsValid  *bool   `json:"is_valid,omitempty"` // SMTP status of node
	Message  *string `json:"message,omitempty"`  // Error message for node
	Hostname *string `json:"hostname,omitempty"` // Host name of node
}

type SmtpSettings struct {
	Address            *string     `json:"address,omitempty"`              // SMTP Server url
	From               *string     `json:"from,omitempty"`                 // From e-mail address
	UserName           *string     `json:"user_name,omitempty"`            // User name
	Password           *string     `json:"password,omitempty"`             // Password
	Port               *int64      `json:"port,omitempty"`                 // SMTP Server's port
	EnableStarttlsAuto *bool       `json:"enable_starttls_auto,omitempty"` // Is TLS encryption enabled?
	SslVersion         *SslVersion `json:"ssl_version,omitempty"`          // TLS version selected Valid values are: "TLSv1_1", "SSLv23", "TLSv1_2".
	DefaultSmtp        *bool       `json:"default_smtp,omitempty"`         // Whether to enable built-in Looker SMTP
}

type SmtpStatus struct {
	IsValid    *bool             `json:"is_valid,omitempty"`    // Overall SMTP status of cluster
	NodeCount  *int64            `json:"node_count,omitempty"`  // Total number of nodes in cluster
	NodeStatus *[]SmtpNodeStatus `json:"node_status,omitempty"` // array of each node's status containing is_valid, message, hostname
}

type Snippet struct {
	Name  *string `json:"name,omitempty"`  // Name of the snippet
	Label *string `json:"label,omitempty"` // Label of the snippet
	Sql   *string `json:"sql,omitempty"`   // SQL text of the snippet
}

type SqlInterfaceQuery struct {
	Can       *map[string]bool `json:"can,omitempty"` // Operations the current user is able to perform on this object
	Id        *int64           `json:"id,omitempty"`  // Unique Id
	Signature string           `json:"signature"`     // Calcite signature
}

type SqlInterfaceQueryCreate struct {
	Can        *map[string]bool `json:"can,omitempty"`         // Operations the current user is able to perform on this object
	Sql        string           `json:"sql"`                   // Original SQL request
	JdbcClient *bool            `json:"jdbc_client,omitempty"` // Whether the query should be run for use in a JDBC Client. This changes the formatting of some datetime based values.
}

type SqlInterfaceQueryMetadata struct {
	Results *string `json:"results,omitempty"` // JDBC Metadata to inflate Avatica response classes.
}

type SqlQuery struct {
	Can           *map[string]bool        `json:"can,omitempty"`           // Operations the current user is able to perform on this object
	Slug          *string                 `json:"slug,omitempty"`          // The identifier of the SQL query
	LastRuntime   *float32                `json:"last_runtime,omitempty"`  // Number of seconds this query took to run the most recent time it was run
	RunCount      *int64                  `json:"run_count,omitempty"`     // Number of times this query has been run
	BrowserLimit  *int64                  `json:"browser_limit,omitempty"` // Maximum number of rows this query will display on the SQL Runner page
	Sql           *string                 `json:"sql,omitempty"`           // SQL query text
	LastRunAt     *string                 `json:"last_run_at,omitempty"`   // The most recent time this query was run
	Connection    *DBConnectionBase       `json:"connection,omitempty"`
	ModelName     *string                 `json:"model_name,omitempty"` // Model name this query uses
	Creator       *UserPublic             `json:"creator,omitempty"`
	ExploreUrl    *string                 `json:"explore_url,omitempty"`     // Explore page URL for this SQL query
	Plaintext     *bool                   `json:"plaintext,omitempty"`       // Should this query be rendered as plain text
	VisConfig     *map[string]interface{} `json:"vis_config,omitempty"`      // Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
	ResultMakerId *string                 `json:"result_maker_id,omitempty"` // ID of the ResultMakerLookup entry.
}

type SqlQueryCreate struct {
	ConnectionName *string                 `json:"connection_name,omitempty"` // Name of the db connection on which to run this query
	ConnectionId   *string                 `json:"connection_id,omitempty"`   // (DEPRECATED) Use `connection_name` instead
	ModelName      *string                 `json:"model_name,omitempty"`      // Name of LookML Model (this or `connection_id` required)
	Sql            *string                 `json:"sql,omitempty"`             // SQL query
	VisConfig      *map[string]interface{} `json:"vis_config,omitempty"`      // Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
}

type SshPublicKey struct {
	PublicKey *string `json:"public_key,omitempty"` // The SSH public key created for this instance
}

type SshServer struct {
	SshServerId    *string `json:"ssh_server_id,omitempty"`    // A unique id used to identify this SSH Server
	SshServerName  *string `json:"ssh_server_name,omitempty"`  // The name to identify this SSH Server
	SshServerHost  *string `json:"ssh_server_host,omitempty"`  // The hostname or ip address of the SSH Server
	SshServerPort  *int64  `json:"ssh_server_port,omitempty"`  // The port to connect to on the SSH Server
	SshServerUser  *string `json:"ssh_server_user,omitempty"`  // The username used to connect to the SSH Server
	FingerPrint    *string `json:"finger_print,omitempty"`     // The md5 fingerprint used to identify the SSH Server
	ShaFingerPrint *string `json:"sha_finger_print,omitempty"` // The SHA fingerprint used to identify the SSH Server
	PublicKey      *string `json:"public_key,omitempty"`       // The SSH public key created for this instance
	Status         *string `json:"status,omitempty"`           // The current connection status to this SSH Server
}

type SshTunnel struct {
	TunnelId      *string `json:"tunnel_id,omitempty"`       // Unique ID for the tunnel
	SshServerId   *string `json:"ssh_server_id,omitempty"`   // SSH Server ID
	SshServerName *string `json:"ssh_server_name,omitempty"` // SSH Server name
	SshServerHost *string `json:"ssh_server_host,omitempty"` // SSH Server Hostname or IP Address
	SshServerPort *int64  `json:"ssh_server_port,omitempty"` // SSH Server port
	SshServerUser *string `json:"ssh_server_user,omitempty"` // Username used to connect to the SSH Server
	LastAttempt   *string `json:"last_attempt,omitempty"`    // Time of last connect attempt
	LocalHostPort *int64  `json:"local_host_port,omitempty"` // Localhost Port used by the Looker instance to connect to the remote DB
	DatabaseHost  *string `json:"database_host,omitempty"`   // Hostname or IP Address of the Database Server
	DatabasePort  *int64  `json:"database_port,omitempty"`   // Port that the Database Server is listening on
	Status        *string `json:"status,omitempty"`          // Current connection status for this Tunnel
}

type SslVersion string

const SslVersion_TLSv1_1 SslVersion = "TLSv1_1"
const SslVersion_SSLv23 SslVersion = "SSLv23"
const SslVersion_TLSv1_2 SslVersion = "TLSv1_2"

type SupportAccessAddEntries struct {
	Emails *[]string `json:"emails,omitempty"` // An array of emails to add to the Allowlist
	Reason *string   `json:"reason,omitempty"` // Reason for adding emails to the Allowlist
}

type SupportAccessAllowlistEntry struct {
	Id          *string    `json:"id,omitempty"`           // Unique ID
	Email       *string    `json:"email,omitempty"`        // Email address
	FullName    *string    `json:"full_name,omitempty"`    // Full name of allowlisted user
	Reason      *string    `json:"reason,omitempty"`       // Reason the Email is included in the Allowlist
	CreatedDate *time.Time `json:"created_date,omitempty"` // Date the Email was added to the Allowlist
}

type SupportAccessEnable struct {
	DurationInSeconds int64 `json:"duration_in_seconds"` // Duration Support Access will remain enabled
}

type SupportAccessStatus struct {
	Open      *bool      `json:"open,omitempty"`       // Whether or not Support Access is open
	OpenUntil *time.Time `json:"open_until,omitempty"` // Time that Support Access will expire
}

type SupportedActionTypes string

const SupportedActionTypes_Cell SupportedActionTypes = "cell"
const SupportedActionTypes_Query SupportedActionTypes = "query"
const SupportedActionTypes_Dashboard SupportedActionTypes = "dashboard"
const SupportedActionTypes_None SupportedActionTypes = "none"

type SupportedDownloadSettings string

const SupportedDownloadSettings_Push SupportedDownloadSettings = "push"
const SupportedDownloadSettings_Url SupportedDownloadSettings = "url"

type SupportedFormats string

const SupportedFormats_Txt SupportedFormats = "txt"
const SupportedFormats_Csv SupportedFormats = "csv"
const SupportedFormats_InlineJson SupportedFormats = "inline_json"
const SupportedFormats_Json SupportedFormats = "json"
const SupportedFormats_JsonLabel SupportedFormats = "json_label"
const SupportedFormats_JsonDetail SupportedFormats = "json_detail"
const SupportedFormats_JsonDetailLiteStream SupportedFormats = "json_detail_lite_stream"
const SupportedFormats_JsonBi SupportedFormats = "json_bi"
const SupportedFormats_Xlsx SupportedFormats = "xlsx"
const SupportedFormats_Html SupportedFormats = "html"
const SupportedFormats_WysiwygPdf SupportedFormats = "wysiwyg_pdf"
const SupportedFormats_AssembledPdf SupportedFormats = "assembled_pdf"
const SupportedFormats_WysiwygPng SupportedFormats = "wysiwyg_png"
const SupportedFormats_CsvZip SupportedFormats = "csv_zip"

type SupportedFormattings string

const SupportedFormattings_Formatted SupportedFormattings = "formatted"
const SupportedFormattings_Unformatted SupportedFormattings = "unformatted"

type SupportedVisualizationFormattings string

const SupportedVisualizationFormattings_Apply SupportedVisualizationFormattings = "apply"
const SupportedVisualizationFormattings_Noapply SupportedVisualizationFormattings = "noapply"

type Theme struct {
	Can      *map[string]bool `json:"can,omitempty"`      // Operations the current user is able to perform on this object
	BeginAt  *time.Time       `json:"begin_at,omitempty"` // Timestamp for when this theme becomes active. Null=always
	EndAt    *time.Time       `json:"end_at,omitempty"`   // Timestamp for when this theme expires. Null=never
	Id       *string          `json:"id,omitempty"`       // Unique Id
	Name     *string          `json:"name,omitempty"`     // Name of theme. Can only be alphanumeric and underscores.
	Settings *ThemeSettings   `json:"settings,omitempty"`
}

type ThemeSettings struct {
	BackgroundColor          *string `json:"background_color,omitempty"`             // Default background color
	BaseFontSize             *string `json:"base_font_size,omitempty"`               // Base font size for scaling fonts (only supported by legacy dashboards)
	ColorCollectionId        *string `json:"color_collection_id,omitempty"`          // Optional. ID of color collection to use with the theme. Use an empty string for none.
	FontColor                *string `json:"font_color,omitempty"`                   // Default font color
	FontFamily               *string `json:"font_family,omitempty"`                  // Primary font family
	FontSource               *string `json:"font_source,omitempty"`                  // Source specification for font
	InfoButtonColor          *string `json:"info_button_color,omitempty"`            // (DEPRECATED) Info button color
	PrimaryButtonColor       *string `json:"primary_button_color,omitempty"`         // Primary button color
	ShowFiltersBar           *bool   `json:"show_filters_bar,omitempty"`             // Toggle to show filters. Defaults to true.
	ShowTitle                *bool   `json:"show_title,omitempty"`                   // Toggle to show the title. Defaults to true.
	TextTileTextColor        *string `json:"text_tile_text_color,omitempty"`         // Text color for text tiles
	TileBackgroundColor      *string `json:"tile_background_color,omitempty"`        // Background color for tiles
	TextTileBackgroundColor  *string `json:"text_tile_background_color,omitempty"`   // Background color for text tiles
	TileTextColor            *string `json:"tile_text_color,omitempty"`              // Text color for tiles
	TitleColor               *string `json:"title_color,omitempty"`                  // Color for titles
	WarnButtonColor          *string `json:"warn_button_color,omitempty"`            // (DEPRECATED) Warning button color
	TileTitleAlignment       *string `json:"tile_title_alignment,omitempty"`         // The text alignment of tile titles (New Dashboards)
	TileShadow               *bool   `json:"tile_shadow,omitempty"`                  // Toggles the tile shadow (not supported)
	ShowLastUpdatedIndicator *bool   `json:"show_last_updated_indicator,omitempty"`  // Toggle to show the dashboard last updated indicator. Defaults to true.
	ShowReloadDataIcon       *bool   `json:"show_reload_data_icon,omitempty"`        // Toggle to show reload data icon/button. Defaults to true.
	ShowDashboardMenu        *bool   `json:"show_dashboard_menu,omitempty"`          // Toggle to show the dashboard actions menu. Defaults to true.
	ShowFiltersToggle        *bool   `json:"show_filters_toggle,omitempty"`          // Toggle to show the filters icon/toggle. Defaults to true.
	ShowDashboardHeader      *bool   `json:"show_dashboard_header,omitempty"`        // Toggle to show the dashboard header. Defaults to true.
	CenterDashboardTitle     *bool   `json:"center_dashboard_title,omitempty"`       // Toggle to center the dashboard title. Defaults to false.
	DashboardTitleFontSize   *string `json:"dashboard_title_font_size,omitempty"`    // Dashboard title font size.
	BoxShadow                *string `json:"box_shadow,omitempty"`                   // Default box shadow.
	PageMarginTop            *string `json:"page_margin_top,omitempty"`              // Dashboard page margin top.
	PageMarginBottom         *string `json:"page_margin_bottom,omitempty"`           // Dashboard page margin bottom.
	PageMarginSides          *string `json:"page_margin_sides,omitempty"`            // Dashboard page margin left and right.
	ShowExploreHeader        *bool   `json:"show_explore_header,omitempty"`          // Toggle to show the explore page header. Defaults to true.
	ShowExploreTitle         *bool   `json:"show_explore_title,omitempty"`           // Toggle to show the explore page title. Defaults to true.
	ShowExploreLastRun       *bool   `json:"show_explore_last_run,omitempty"`        // Toggle to show the explore page last run. Defaults to true.
	ShowExploreTimezone      *bool   `json:"show_explore_timezone,omitempty"`        // Toggle to show the explore page timezone. Defaults to true.
	ShowExploreRunStopButton *bool   `json:"show_explore_run_stop_button,omitempty"` // Toggle to show the explore page run button. Defaults to true.
	ShowExploreActionsButton *bool   `json:"show_explore_actions_button,omitempty"`  // Toggle to show the explore page actions button. Defaults to true.
	ShowLookHeader           *bool   `json:"show_look_header,omitempty"`             // Toggle to show the look page header. Defaults to true.
	ShowLookTitle            *bool   `json:"show_look_title,omitempty"`              // Toggle to show the look page title. Defaults to true.
	ShowLookLastRun          *bool   `json:"show_look_last_run,omitempty"`           // Toggle to show the look page last run. Defaults to true.
	ShowLookTimezone         *bool   `json:"show_look_timezone,omitempty"`           // Toggle to show the look page timezone Defaults to true.
	ShowLookRunStopButton    *bool   `json:"show_look_run_stop_button,omitempty"`    // Toggle to show the look page run button. Defaults to true.
	ShowLookActionsButton    *bool   `json:"show_look_actions_button,omitempty"`     // Toggle to show the look page actions button. Defaults to true.
	TileTitleFontSize        *string `json:"tile_title_font_size,omitempty"`         // Font size for tiles.
	ColumnGapSize            *string `json:"column_gap_size,omitempty"`              // The vertical gap/gutter size between tiles.
	RowGapSize               *string `json:"row_gap_size,omitempty"`                 // The horizontal gap/gutter size between tiles.
	BorderRadius             *string `json:"border_radius,omitempty"`                // The border radius for tiles.
}

type Timezone struct {
	Value *string `json:"value,omitempty"` // Timezone
	Label *string `json:"label,omitempty"` // Description of timezone
	Group *string `json:"group,omitempty"` // Timezone group (e.g Common, Other, etc.)
}

type UpdateArtifact struct {
	Key         string  `json:"key"`                    // Key of value to store. Namespace + Key must be unique.
	Value       string  `json:"value"`                  // Value to store.
	ContentType *string `json:"content_type,omitempty"` // MIME type of content. This can only be used to override content that is detected as text/plain. Needed to set application/json content types, which are analyzed as plain text.
	Version     *int64  `json:"version,omitempty"`      // Version number of the stored value. The version must be provided for any updates to an existing artifact.
}

type UpdateFolder struct {
	Name     *string `json:"name,omitempty"`      // Unique Name
	ParentId *string `json:"parent_id,omitempty"` // Id of Parent. If the parent id is null, this is a root-level entry
}

type User struct {
	Can                        *map[string]bool         `json:"can,omitempty"`                       // Operations the current user is able to perform on this object
	AvatarUrl                  *string                  `json:"avatar_url,omitempty"`                // URL for the avatar image (may be generic)
	AvatarUrlWithoutSizing     *string                  `json:"avatar_url_without_sizing,omitempty"` // URL for the avatar image (may be generic), does not specify size
	CredentialsApi3            *[]CredentialsApi3       `json:"credentials_api3,omitempty"`          // API credentials
	CredentialsEmail           *CredentialsEmail        `json:"credentials_email,omitempty"`
	CredentialsEmbed           *[]CredentialsEmbed      `json:"credentials_embed,omitempty"` // Embed credentials
	CredentialsGoogle          *CredentialsGoogle       `json:"credentials_google,omitempty"`
	CredentialsLdap            *CredentialsLDAP         `json:"credentials_ldap,omitempty"`
	CredentialsLookerOpenid    *CredentialsLookerOpenid `json:"credentials_looker_openid,omitempty"`
	CredentialsOidc            *CredentialsOIDC         `json:"credentials_oidc,omitempty"`
	CredentialsSaml            *CredentialsSaml         `json:"credentials_saml,omitempty"`
	CredentialsTotp            *CredentialsTotp         `json:"credentials_totp,omitempty"`
	DisplayName                *string                  `json:"display_name,omitempty"`                   // Full name for display (available only if both first_name and last_name are set)
	Email                      *string                  `json:"email,omitempty"`                          // EMail address
	EmbedGroupSpaceId          *string                  `json:"embed_group_space_id,omitempty"`           // (DEPRECATED) (Embed only) ID of user's group space based on the external_group_id optionally specified during embed user login
	FirstName                  *string                  `json:"first_name,omitempty"`                     // First name
	GroupIds                   *[]string                `json:"group_ids,omitempty"`                      // Array of ids of the groups for this user
	HomeFolderId               *string                  `json:"home_folder_id,omitempty"`                 // ID string for user's home folder
	Id                         *string                  `json:"id,omitempty"`                             // Unique Id
	IsDisabled                 *bool                    `json:"is_disabled,omitempty"`                    // Account has been disabled
	LastName                   *string                  `json:"last_name,omitempty"`                      // Last name
	Locale                     *string                  `json:"locale,omitempty"`                         // User's preferred locale. User locale takes precedence over Looker's system-wide default locale. Locale determines language of display strings and date and numeric formatting in API responses. Locale string must be a 2 letter language code or a combination of language code and region code: 'en' or 'en-US', for example.
	LookerVersions             *[]string                `json:"looker_versions,omitempty"`                // Array of strings representing the Looker versions that this user has used (this only goes back as far as '3.54.0')
	ModelsDirValidated         *bool                    `json:"models_dir_validated,omitempty"`           // User's dev workspace has been checked for presence of applicable production projects
	PersonalFolderId           *string                  `json:"personal_folder_id,omitempty"`             // ID of user's personal folder
	PresumedLookerEmployee     *bool                    `json:"presumed_looker_employee,omitempty"`       // User is identified as an employee of Looker
	RoleIds                    *[]string                `json:"role_ids,omitempty"`                       // Array of ids of the roles for this user
	Sessions                   *[]Session               `json:"sessions,omitempty"`                       // Active sessions
	UiState                    *map[string]interface{}  `json:"ui_state,omitempty"`                       // Per user dictionary of undocumented state information owned by the Looker UI.
	VerifiedLookerEmployee     *bool                    `json:"verified_looker_employee,omitempty"`       // User is identified as an employee of Looker who has been verified via Looker corporate authentication
	RolesExternallyManaged     *bool                    `json:"roles_externally_managed,omitempty"`       // User's roles are managed by an external directory like SAML or LDAP and can not be changed directly.
	AllowDirectRoles           *bool                    `json:"allow_direct_roles,omitempty"`             // User can be directly assigned a role.
	AllowNormalGroupMembership *bool                    `json:"allow_normal_group_membership,omitempty"`  // User can be a direct member of a normal Looker group.
	AllowRolesFromNormalGroups *bool                    `json:"allow_roles_from_normal_groups,omitempty"` // User can inherit roles from a normal Looker group.
	EmbedGroupFolderId         *string                  `json:"embed_group_folder_id,omitempty"`          // (Embed only) ID of user's group folder based on the external_group_id optionally specified during embed user login
	IsIamAdmin                 *bool                    `json:"is_iam_admin,omitempty"`                   // User is an IAM Admin - only available in Looker (Google Cloud core)
	Url                        *string                  `json:"url,omitempty"`                            // Link to get this item
}

type UserAttribute struct {
	Can                        *map[string]bool `json:"can,omitempty"`                           // Operations the current user is able to perform on this object
	Id                         *string          `json:"id,omitempty"`                            // Unique Id
	Name                       string           `json:"name"`                                    // Name of user attribute
	Label                      string           `json:"label"`                                   // Human-friendly label for user attribute
	Type                       string           `json:"type"`                                    // Type of user attribute ("string", "number", "datetime", "yesno", "zipcode", "advanced_filter_string", "advanced_filter_number")
	DefaultValue               *string          `json:"default_value,omitempty"`                 // Default value for when no value is set on the user
	IsSystem                   *bool            `json:"is_system,omitempty"`                     // Attribute is a system default
	IsPermanent                *bool            `json:"is_permanent,omitempty"`                  // Attribute is permanent and cannot be deleted
	ValueIsHidden              *bool            `json:"value_is_hidden,omitempty"`               // If true, users will not be able to view values of this attribute
	UserCanView                *bool            `json:"user_can_view,omitempty"`                 // Non-admin users can see the values of their attributes and use them in filters
	UserCanEdit                *bool            `json:"user_can_edit,omitempty"`                 // Users can change the value of this attribute for themselves
	HiddenValueDomainWhitelist *string          `json:"hidden_value_domain_whitelist,omitempty"` // Destinations to which a hidden attribute may be sent. Once set, cannot be edited.
}

type UserAttributeFilterTypes string

const UserAttributeFilterTypes_AdvancedFilterString UserAttributeFilterTypes = "advanced_filter_string"
const UserAttributeFilterTypes_AdvancedFilterNumber UserAttributeFilterTypes = "advanced_filter_number"
const UserAttributeFilterTypes_AdvancedFilterDatetime UserAttributeFilterTypes = "advanced_filter_datetime"
const UserAttributeFilterTypes_String UserAttributeFilterTypes = "string"
const UserAttributeFilterTypes_Number UserAttributeFilterTypes = "number"
const UserAttributeFilterTypes_Datetime UserAttributeFilterTypes = "datetime"
const UserAttributeFilterTypes_RelativeUrl UserAttributeFilterTypes = "relative_url"
const UserAttributeFilterTypes_Yesno UserAttributeFilterTypes = "yesno"
const UserAttributeFilterTypes_Zipcode UserAttributeFilterTypes = "zipcode"

// WARNING: no writeable properties found for POST, PUT, or PATCH
type UserAttributeGroupValue struct {
	Can             *map[string]bool `json:"can,omitempty"`               // Operations the current user is able to perform on this object
	Id              *string          `json:"id,omitempty"`                // Unique Id of this group-attribute relation
	GroupId         *string          `json:"group_id,omitempty"`          // Id of group
	UserAttributeId *string          `json:"user_attribute_id,omitempty"` // Id of user attribute
	ValueIsHidden   *bool            `json:"value_is_hidden,omitempty"`   // If true, the "value" field will be null, because the attribute settings block access to this value
	Rank            *int64           `json:"rank,omitempty"`              // Precedence for resolving value for user
	Value           *string          `json:"value,omitempty"`             // Value of user attribute for group
}

type UserAttributeWithValue struct {
	Can                        *map[string]bool `json:"can,omitempty"`                           // Operations the current user is able to perform on this object
	Name                       *string          `json:"name,omitempty"`                          // Name of user attribute
	Label                      *string          `json:"label,omitempty"`                         // Human-friendly label for user attribute
	Rank                       *int64           `json:"rank,omitempty"`                          // Precedence for setting value on user (lowest wins)
	Value                      *string          `json:"value,omitempty"`                         // Value of attribute for user
	UserId                     *string          `json:"user_id,omitempty"`                       // Id of User
	UserCanEdit                *bool            `json:"user_can_edit,omitempty"`                 // Can the user set this value
	ValueIsHidden              *bool            `json:"value_is_hidden,omitempty"`               // If true, the "value" field will be null, because the attribute settings block access to this value
	UserAttributeId            *string          `json:"user_attribute_id,omitempty"`             // Id of User Attribute
	Source                     *string          `json:"source,omitempty"`                        // How user got this value for this attribute
	HiddenValueDomainWhitelist *string          `json:"hidden_value_domain_whitelist,omitempty"` // If this user attribute is hidden, allowed list of destinations to which it may be sent.
}

type UserEmailOnly struct {
	Email string `json:"email"` // Email Address
}

type UserLoginLockout struct {
	Can       *map[string]bool `json:"can,omitempty"`        // Operations the current user is able to perform on this object
	Key       *string          `json:"key,omitempty"`        // Hash of user's client id
	AuthType  *string          `json:"auth_type,omitempty"`  // Authentication method for login failures
	Ip        *string          `json:"ip,omitempty"`         // IP address of most recent failed attempt
	UserId    *string          `json:"user_id,omitempty"`    // User ID
	RemoteId  *string          `json:"remote_id,omitempty"`  // Remote ID of user if using LDAP
	FullName  *string          `json:"full_name,omitempty"`  // User's name
	Email     *string          `json:"email,omitempty"`      // Email address associated with the user's account
	FailCount *int64           `json:"fail_count,omitempty"` // Number of failures that triggered the lockout
	LockoutAt *time.Time       `json:"lockout_at,omitempty"` // Time when lockout was triggered
}

type UserPublic struct {
	Can         *map[string]bool `json:"can,omitempty"`          // Operations the current user is able to perform on this object
	Id          *string          `json:"id,omitempty"`           // Unique Id
	FirstName   *string          `json:"first_name,omitempty"`   // First Name
	LastName    *string          `json:"last_name,omitempty"`    // Last Name
	DisplayName *string          `json:"display_name,omitempty"` // Full name for display (available only if both first_name and last_name are set)
	AvatarUrl   *string          `json:"avatar_url,omitempty"`   // URL for the avatar image (may be generic)
	Url         *string          `json:"url,omitempty"`          // Link to get this item
}

type ValidationError struct {
	Message          string                   `json:"message"`           // Error details
	Errors           *[]ValidationErrorDetail `json:"errors,omitempty"`  // Error detail array
	DocumentationUrl string                   `json:"documentation_url"` // Documentation link
}

type ValidationErrorDetail struct {
	Field            *string `json:"field,omitempty"`   // Field with error
	Code             *string `json:"code,omitempty"`    // Error code
	Message          *string `json:"message,omitempty"` // Error info message
	DocumentationUrl string  `json:"documentation_url"` // Documentation link
}

type WeekStartDay string

const WeekStartDay_Monday WeekStartDay = "monday"
const WeekStartDay_Tuesday WeekStartDay = "tuesday"
const WeekStartDay_Wednesday WeekStartDay = "wednesday"
const WeekStartDay_Thursday WeekStartDay = "thursday"
const WeekStartDay_Friday WeekStartDay = "friday"
const WeekStartDay_Saturday WeekStartDay = "saturday"
const WeekStartDay_Sunday WeekStartDay = "sunday"

type WelcomeEmailTest struct {
	Content *string `json:"content,omitempty"` // The content that would be sent in the body of a custom welcome email
	Subject *string `json:"subject,omitempty"` // The subject that would be sent for the custom welcome email
	Header  *string `json:"header,omitempty"`  // The header that would be sent in the body of a custom welcome email
}

type WhitelabelConfiguration struct {
	Id                         *string `json:"id,omitempty"`                            // Unique Id
	LogoFile                   *string `json:"logo_file,omitempty"`                     // Customer logo image. Expected base64 encoded data (write-only)
	LogoUrl                    *string `json:"logo_url,omitempty"`                      // Logo image url (read-only)
	FaviconFile                *string `json:"favicon_file,omitempty"`                  // Custom favicon image. Expected base64 encoded data (write-only)
	FaviconUrl                 *string `json:"favicon_url,omitempty"`                   // Favicon image url (read-only)
	DefaultTitle               *string `json:"default_title,omitempty"`                 // Default page title
	ShowHelpMenu               *bool   `json:"show_help_menu,omitempty"`                // Boolean to toggle showing help menus
	ShowDocs                   *bool   `json:"show_docs,omitempty"`                     // Boolean to toggle showing docs
	ShowEmailSubOptions        *bool   `json:"show_email_sub_options,omitempty"`        // Boolean to toggle showing email subscription options.
	AllowLookerMentions        *bool   `json:"allow_looker_mentions,omitempty"`         // Boolean to toggle mentions of Looker in emails
	AllowLookerLinks           *bool   `json:"allow_looker_links,omitempty"`            // Boolean to toggle links to Looker in emails
	CustomWelcomeEmailAdvanced *bool   `json:"custom_welcome_email_advanced,omitempty"` // Allow subject line and email heading customization in customized emails
	SetupMentions              *bool   `json:"setup_mentions,omitempty"`                // Remove the word Looker from appearing in the account setup page
	AlertsLogo                 *bool   `json:"alerts_logo,omitempty"`                   // Remove Looker logo from Alerts
	AlertsLinks                *bool   `json:"alerts_links,omitempty"`                  // Remove Looker links from Alerts
	FoldersMentions            *bool   `json:"folders_mentions,omitempty"`              // Remove Looker mentions in home folder page when you dont have any items saved
}

type Workspace struct {
	Can      *map[string]bool `json:"can,omitempty"`      // Operations the current user is able to perform on this object
	Id       *string          `json:"id,omitempty"`       // The unique id of this user workspace. Predefined workspace ids include "production" and "dev"
	Projects *[]Project       `json:"projects,omitempty"` // The local state of each project in the workspace
}

// Dynamic writeable type for Alert removes:
// followed, followable, id, investigative_content_title, owner_display_name
type WriteAlert struct {
	AppliedDashboardFilters  *[]AlertAppliedDashboardFilter `json:"applied_dashboard_filters,omitempty"` // Filters coming from the dashboard that are applied. Example `[{ "filter_title": "Name", "field_name": "distribution_centers.name", "filter_value": "Los Angeles CA" }]`
	ComparisonType           ComparisonType                 `json:"comparison_type"`                     // This property informs the check what kind of comparison we are performing. Only certain condition types are valid for time series alerts. For details, refer to [Setting Alert Conditions](https://cloud.google.com/looker/docs/sharing-and-publishing/creating-alerts#setting_alert_conditions) Valid values are: "EQUAL_TO", "GREATER_THAN", "GREATER_THAN_OR_EQUAL_TO", "LESS_THAN", "LESS_THAN_OR_EQUAL_TO", "INCREASES_BY", "DECREASES_BY", "CHANGES_BY".
	Cron                     string                         `json:"cron"`                                // Vixie-Style crontab specification when to run. At minimum, it has to be longer than 15 minute intervals
	CustomUrlBase            *string                        `json:"custom_url_base,omitempty"`           // Domain for the custom url selected by the alert creator from the admin defined domain allowlist
	CustomUrlParams          *string                        `json:"custom_url_params,omitempty"`         // Parameters and path for the custom url defined by the alert creator
	CustomUrlLabel           *string                        `json:"custom_url_label,omitempty"`          // Label for the custom url defined by the alert creator
	ShowCustomUrl            *bool                          `json:"show_custom_url,omitempty"`           // Boolean to determine if the custom url should be used
	CustomTitle              *string                        `json:"custom_title,omitempty"`              // An optional, user-defined title for the alert
	DashboardElementId       *string                        `json:"dashboard_element_id,omitempty"`      // ID of the dashboard element associated with the alert. Refer to [dashboard_element()](#!/Dashboard/DashboardElement)
	Description              *string                        `json:"description,omitempty"`               // An optional description for the alert. This supplements the title
	Destinations             []AlertDestination             `json:"destinations"`                        // Array of destinations to send alerts to. Must be the same type of destination. Example `[{ "destination_type": "EMAIL", "email_address": "test@test.com" }]`
	Field                    AlertField                     `json:"field"`
	IsDisabled               *bool                          `json:"is_disabled,omitempty"`                // Whether or not the alert is disabled
	DisabledReason           *string                        `json:"disabled_reason,omitempty"`            // Reason for disabling alert
	IsPublic                 *bool                          `json:"is_public,omitempty"`                  // Whether or not the alert is public
	InvestigativeContentType *InvestigativeContentType      `json:"investigative_content_type,omitempty"` // The type of the investigative content Valid values are: "dashboard".
	InvestigativeContentId   *string                        `json:"investigative_content_id,omitempty"`   // The ID of the investigative content. For dashboards, this will be the dashboard ID
	LookmlDashboardId        *string                        `json:"lookml_dashboard_id,omitempty"`        // ID of the LookML dashboard associated with the alert
	LookmlLinkId             *string                        `json:"lookml_link_id,omitempty"`             // ID of the LookML dashboard element associated with the alert
	OwnerId                  string                         `json:"owner_id"`                             // User id of alert owner
	Threshold                float64                        `json:"threshold"`                            // Value of the alert threshold
	TimeSeriesConditionState *AlertConditionState           `json:"time_series_condition_state,omitempty"`
}

// Dynamic writeable type for ApiSession removes:
// can, sudo_user_id
type WriteApiSession struct {
	WorkspaceId *string `json:"workspace_id,omitempty"` // The id of active workspace for this session
}

// Dynamic writeable type for BackupConfiguration removes:
// can, url
type WriteBackupConfiguration struct {
	Type                 *string `json:"type,omitempty"`                    // Type of backup: looker-s3 or custom-s3
	CustomS3Bucket       *string `json:"custom_s3_bucket,omitempty"`        // Name of bucket for custom-s3 backups
	CustomS3BucketRegion *string `json:"custom_s3_bucket_region,omitempty"` // Name of region where the bucket is located
	CustomS3Key          *string `json:"custom_s3_key,omitempty"`           // (Write-Only) AWS S3 key used for custom-s3 backups
	CustomS3Secret       *string `json:"custom_s3_secret,omitempty"`        // (Write-Only) AWS S3 secret used for custom-s3 backups
}

// Dynamic writeable type for Board removes:
// can, content_metadata_id, created_at, board_sections, id, updated_at, user_id, primary_homepage
type WriteBoard struct {
	DeletedAt    *time.Time `json:"deleted_at,omitempty"`    // Date of board deletion
	Description  *string    `json:"description,omitempty"`   // Description of the board
	SectionOrder *[]string  `json:"section_order,omitempty"` // ids of the board sections in the order they should be displayed
	Title        *string    `json:"title,omitempty"`         // Title of the board
}

// Dynamic writeable type for BoardItem removes:
// can, content_created_by, content_favorite_id, content_metadata_id, content_updated_at, description, favorite_count, id, image_url, location, title, url, view_count, custom_image_url
type WriteBoardItem struct {
	CustomDescription     *string `json:"custom_description,omitempty"`       // Custom description entered by the user, if present
	CustomTitle           *string `json:"custom_title,omitempty"`             // Custom title entered by the user, if present
	CustomUrl             *string `json:"custom_url,omitempty"`               // Custom url entered by the user, if present
	DashboardId           *string `json:"dashboard_id,omitempty"`             // Dashboard to base this item on
	BoardSectionId        *string `json:"board_section_id,omitempty"`         // Associated Board Section
	LookId                *string `json:"look_id,omitempty"`                  // Look to base this item on
	LookmlDashboardId     *string `json:"lookml_dashboard_id,omitempty"`      // LookML Dashboard to base this item on
	Order                 *int64  `json:"order,omitempty"`                    // An arbitrary integer representing the sort order within the section
	UseCustomDescription  *bool   `json:"use_custom_description,omitempty"`   // Whether the custom description should be used instead of the content description, if the item is associated with content
	UseCustomTitle        *bool   `json:"use_custom_title,omitempty"`         // Whether the custom title should be used instead of the content title, if the item is associated with content
	UseCustomUrl          *bool   `json:"use_custom_url,omitempty"`           // Whether the custom url should be used instead of the content url, if the item is associated with content
	CustomImageDataBase64 *string `json:"custom_image_data_base64,omitempty"` // (Write-Only) base64 encoded image data
	UseCustomImage        *bool   `json:"use_custom_image,omitempty"`         // Whether the custom image should be used instead of the content image, if the item is associated with content
}

// Dynamic writeable type for BoardSection removes:
// can, created_at, board_items, id, visible_item_order, updated_at
type WriteBoardSection struct {
	DeletedAt   *time.Time `json:"deleted_at,omitempty"`  // Time at which this section was deleted.
	Description *string    `json:"description,omitempty"` // Description of the content found in this section.
	BoardId     *string    `json:"board_id,omitempty"`    // Id reference to parent board
	ItemOrder   *[]string  `json:"item_order,omitempty"`  // ids of the board items in the order they should be displayed
	Title       *string    `json:"title,omitempty"`       // Name of row
}

// Dynamic writeable type for ColorCollection removes:
// id
type WriteColorCollection struct {
	Label               *string              `json:"label,omitempty"`               // Label of color collection
	CategoricalPalettes *[]DiscretePalette   `json:"categoricalPalettes,omitempty"` // Array of categorical palette definitions
	SequentialPalettes  *[]ContinuousPalette `json:"sequentialPalettes,omitempty"`  // Array of discrete palette definitions
	DivergingPalettes   *[]ContinuousPalette `json:"divergingPalettes,omitempty"`   // Array of diverging palette definitions
}

// Dynamic writeable type for ContentFavorite removes:
// id, look_id, dashboard_id, board_id
type WriteContentFavorite struct {
	UserId            *string         `json:"user_id,omitempty"`             // User Id which owns this ContentFavorite
	ContentMetadataId *string         `json:"content_metadata_id,omitempty"` // Content Metadata Id associated with this ContentFavorite
	Look              *WriteLookBasic `json:"look,omitempty"`                // Dynamic writeable type for LookBasic removes:
	// can, content_metadata_id, id, title
	Dashboard *WriteDashboardBase `json:"dashboard,omitempty"` // Dynamic writeable type for DashboardBase removes:
	// can, content_favorite_id, content_metadata_id, description, hidden, id, model, query_timezone, readonly, refresh_interval, refresh_interval_to_i, title, user_id, slug, preferred_viewer
}

// Dynamic writeable type for ContentMeta removes:
// can, id, name, parent_id, dashboard_id, look_id, folder_id, content_type, inheriting_id, slug
type WriteContentMeta struct {
	Inherits *bool `json:"inherits,omitempty"` // Whether content inherits its access levels from parent
}

// Dynamic writeable type for CreateDashboardFilter removes:
// id, field
type WriteCreateDashboardFilter struct {
	DashboardId         string                  `json:"dashboard_id"`                    // Id of Dashboard
	Name                string                  `json:"name"`                            // Name of filter
	Title               string                  `json:"title"`                           // Title of filter
	Type                string                  `json:"type"`                            // Type of filter: one of date, number, string, or field
	DefaultValue        *string                 `json:"default_value,omitempty"`         // Default value of filter
	Model               *string                 `json:"model,omitempty"`                 // Model of filter (required if type = field)
	Explore             *string                 `json:"explore,omitempty"`               // Explore of filter (required if type = field)
	Dimension           *string                 `json:"dimension,omitempty"`             // Dimension of filter (required if type = field)
	Row                 *int64                  `json:"row,omitempty"`                   // Display order of this filter relative to other filters
	ListensToFilters    *[]string               `json:"listens_to_filters,omitempty"`    // Array of listeners for faceted filters
	AllowMultipleValues *bool                   `json:"allow_multiple_values,omitempty"` // Whether the filter allows multiple filter values (deprecated in the latest version of dashboards)
	Required            *bool                   `json:"required,omitempty"`              // Whether the filter requires a value to run the dashboard
	UiConfig            *map[string]interface{} `json:"ui_config,omitempty"`             // The visual configuration for this filter. Used to set up how the UI for this filter should appear.
}

// Dynamic writeable type for CreateQueryTask removes:
// can
type WriteCreateQueryTask struct {
	QueryId      string       `json:"query_id"`               // Id of query to run
	ResultFormat ResultFormat `json:"result_format"`          // Desired async query result format. Valid values are: "inline_json", "json", "json_detail", "json_fe", "json_bi", "csv", "html", "md", "txt", "xlsx", "gsxml", "sql".
	Source       *string      `json:"source,omitempty"`       // Source of query task
	Deferred     *bool        `json:"deferred,omitempty"`     // Create the task but defer execution
	LookId       *string      `json:"look_id,omitempty"`      // Id of look associated with query.
	DashboardId  *string      `json:"dashboard_id,omitempty"` // Id of dashboard associated with query.
}

// Dynamic writeable type for CredentialsEmail removes:
// can, created_at, user_id, is_disabled, logged_in_at, password_reset_url, account_setup_url, type, url, user_url
type WriteCredentialsEmail struct {
	Email                          *string `json:"email,omitempty"`                               // EMail address used for user login
	ForcedPasswordResetAtNextLogin *bool   `json:"forced_password_reset_at_next_login,omitempty"` // Force the user to change their password upon their next login
}

// Dynamic writeable type for Dashboard removes:
// can, content_favorite_id, content_metadata_id, id, model, readonly, refresh_interval_to_i, user_id, created_at, dashboard_elements, dashboard_filters, dashboard_layouts, deleted_at, deleter_id, edit_uri, favorite_count, last_accessed_at, last_viewed_at, updated_at, last_updater_id, last_updater_name, user_name, view_count, url
type WriteDashboard struct {
	Description     *string          `json:"description,omitempty"`      // Description
	Hidden          *bool            `json:"hidden,omitempty"`           // Is Hidden
	QueryTimezone   *string          `json:"query_timezone,omitempty"`   // Timezone in which the Dashboard will run by default.
	RefreshInterval *string          `json:"refresh_interval,omitempty"` // Refresh Interval, as a time duration phrase like "2 hours 30 minutes". A number with no time units will be interpreted as whole seconds.
	Folder          *WriteFolderBase `json:"folder,omitempty"`           // Dynamic writeable type for FolderBase removes:
	// id, content_metadata_id, created_at, creator_id, child_count, external_id, is_embed, is_embed_shared_root, is_embed_users_root, is_personal, is_personal_descendant, is_shared_root, is_users_root, can
	Title                               *string              `json:"title,omitempty"`                                    // Dashboard Title
	Slug                                *string              `json:"slug,omitempty"`                                     // Content Metadata Slug
	PreferredViewer                     *string              `json:"preferred_viewer,omitempty"`                         // The preferred route for viewing this dashboard (ie: dashboards or dashboards-next)
	AlertSyncWithDashboardFilterEnabled *bool                `json:"alert_sync_with_dashboard_filter_enabled,omitempty"` // Enables alerts to keep in sync with dashboard filter changes
	BackgroundColor                     *string              `json:"background_color,omitempty"`                         // Background color
	CrossfilterEnabled                  *bool                `json:"crossfilter_enabled,omitempty"`                      // Enables crossfiltering in dashboards - only available in dashboards-next (beta)
	Deleted                             *bool                `json:"deleted,omitempty"`                                  // Whether or not a dashboard is 'soft' deleted.
	EnableVizFullScreen                 *bool                `json:"enable_viz_full_screen,omitempty"`                   // Allow visualizations to be viewed in full screen mode
	FiltersBarCollapsed                 *bool                `json:"filters_bar_collapsed,omitempty"`                    // Sets the default state of the filters bar to collapsed or open
	FiltersLocationTop                  *bool                `json:"filters_location_top,omitempty"`                     // Sets the default state of the filters location to top(true) or right(false)
	LoadConfiguration                   *string              `json:"load_configuration,omitempty"`                       // configuration option that governs how dashboard loading will happen.
	LookmlLinkId                        *string              `json:"lookml_link_id,omitempty"`                           // Links this dashboard to a particular LookML dashboard such that calling a **sync** operation on that LookML dashboard will update this dashboard to match.
	ShowFiltersBar                      *bool                `json:"show_filters_bar,omitempty"`                         // Show filters bar.  **Security Note:** This property only affects the *cosmetic* appearance of the dashboard, not a user's ability to access data. Hiding the filters bar does **NOT** prevent users from changing filters by other means. For information on how to set up secure data access control policies, see [Control User Access to Data](https://cloud.google.com/looker/docs/r/api/control-access)
	ShowTitle                           *bool                `json:"show_title,omitempty"`                               // Show title
	FolderId                            *string              `json:"folder_id,omitempty"`                                // Id of folder
	TextTileTextColor                   *string              `json:"text_tile_text_color,omitempty"`                     // Color of text on text tiles
	TileBackgroundColor                 *string              `json:"tile_background_color,omitempty"`                    // Tile background color
	TileTextColor                       *string              `json:"tile_text_color,omitempty"`                          // Tile text color
	TitleColor                          *string              `json:"title_color,omitempty"`                              // Title color
	Appearance                          *DashboardAppearance `json:"appearance,omitempty"`
}

// Dynamic writeable type for DashboardBase removes:
// can, content_favorite_id, content_metadata_id, description, hidden, id, model, query_timezone, readonly, refresh_interval, refresh_interval_to_i, title, user_id, slug, preferred_viewer
type WriteDashboardBase struct {
	Folder *WriteFolderBase `json:"folder,omitempty"` // Dynamic writeable type for FolderBase removes:
	// id, content_metadata_id, created_at, creator_id, child_count, external_id, is_embed, is_embed_shared_root, is_embed_users_root, is_personal, is_personal_descendant, is_shared_root, is_users_root, can
}

// Dynamic writeable type for DashboardElement removes:
// can, body_text_as_html, edit_uri, id, lookml_link_id, note_text_as_html, refresh_interval_to_i, alert_count, title_text_as_html, subtitle_text_as_html
type WriteDashboardElement struct {
	BodyText    *string             `json:"body_text,omitempty"`    // Text tile body text
	DashboardId *string             `json:"dashboard_id,omitempty"` // Id of Dashboard
	Look        *WriteLookWithQuery `json:"look,omitempty"`         // Dynamic writeable type for LookWithQuery removes:
	// can, content_metadata_id, id, content_favorite_id, created_at, deleted_at, deleter_id, embed_url, excel_file_url, favorite_count, google_spreadsheet_formula, image_embed_url, last_accessed_at, last_updater_id, last_viewed_at, model, public_slug, public_url, short_url, updated_at, view_count, url
	LookId        *string     `json:"look_id,omitempty"`         // Id Of Look
	MergeResultId *string     `json:"merge_result_id,omitempty"` // ID of merge result
	NoteDisplay   *string     `json:"note_display,omitempty"`    // Note Display
	NoteState     *string     `json:"note_state,omitempty"`      // Note State
	NoteText      *string     `json:"note_text,omitempty"`       // Note Text
	Query         *WriteQuery `json:"query,omitempty"`           // Dynamic writeable type for Query removes:
	// can, id, slug, share_url, expanded_share_url, url, has_table_calculations
	QueryId         *string                                          `json:"query_id,omitempty"`         // Id Of Query
	RefreshInterval *string                                          `json:"refresh_interval,omitempty"` // Refresh Interval
	ResultMaker     *WriteResultMakerWithIdVisConfigAndDynamicFields `json:"result_maker,omitempty"`     // Dynamic writeable type for ResultMakerWithIdVisConfigAndDynamicFields removes:
	// id, dynamic_fields, filterables, sorts, merge_result_id, total, query_id, sql_query_id, vis_config
	ResultMakerId   *string `json:"result_maker_id,omitempty"`   // ID of the ResultMakerLookup entry.
	SubtitleText    *string `json:"subtitle_text,omitempty"`     // Text tile subtitle text
	Title           *string `json:"title,omitempty"`             // Title of dashboard element
	TitleHidden     *bool   `json:"title_hidden,omitempty"`      // Whether title is hidden
	TitleText       *string `json:"title_text,omitempty"`        // Text tile title
	Type            *string `json:"type,omitempty"`              // Type
	RichContentJson *string `json:"rich_content_json,omitempty"` // JSON with all the properties required for rich editor and buttons elements
	ExtensionId     *string `json:"extension_id,omitempty"`      // Extension ID
}

// Dynamic writeable type for DashboardFilter removes:
// can, id, dashboard_id, field
type WriteDashboardFilter struct {
	Name                *string                 `json:"name,omitempty"`                  // Name of filter
	Title               *string                 `json:"title,omitempty"`                 // Title of filter
	Type                *string                 `json:"type,omitempty"`                  // Type of filter: one of date, number, string, or field
	DefaultValue        *string                 `json:"default_value,omitempty"`         // Default value of filter
	Model               *string                 `json:"model,omitempty"`                 // Model of filter (required if type = field)
	Explore             *string                 `json:"explore,omitempty"`               // Explore of filter (required if type = field)
	Dimension           *string                 `json:"dimension,omitempty"`             // Dimension of filter (required if type = field)
	Row                 *int64                  `json:"row,omitempty"`                   // Display order of this filter relative to other filters
	ListensToFilters    *[]string               `json:"listens_to_filters,omitempty"`    // Array of listeners for faceted filters
	AllowMultipleValues *bool                   `json:"allow_multiple_values,omitempty"` // Whether the filter allows multiple filter values (deprecated in the latest version of dashboards)
	Required            *bool                   `json:"required,omitempty"`              // Whether the filter requires a value to run the dashboard
	UiConfig            *map[string]interface{} `json:"ui_config,omitempty"`             // The visual configuration for this filter. Used to set up how the UI for this filter should appear.
}

// Dynamic writeable type for DashboardLayout removes:
// can, id, deleted, dashboard_title, dashboard_layout_components
type WriteDashboardLayout struct {
	DashboardId *string `json:"dashboard_id,omitempty"` // Id of Dashboard
	Type        *string `json:"type,omitempty"`         // Type
	Active      *bool   `json:"active,omitempty"`       // Is Active
	ColumnWidth *int64  `json:"column_width,omitempty"` // Column Width
	Width       *int64  `json:"width,omitempty"`        // Width
}

// Dynamic writeable type for DashboardLayoutComponent removes:
// can, id, deleted, element_title, element_title_hidden, vis_type
type WriteDashboardLayoutComponent struct {
	DashboardLayoutId  *string `json:"dashboard_layout_id,omitempty"`  // Id of Dashboard Layout
	DashboardElementId *string `json:"dashboard_element_id,omitempty"` // Id Of Dashboard Element
	Row                *int64  `json:"row,omitempty"`                  // Row
	Column             *int64  `json:"column,omitempty"`               // Column
	Width              *int64  `json:"width,omitempty"`                // Width
	Height             *int64  `json:"height,omitempty"`               // Height
}

// Dynamic writeable type for DashboardLookml removes:
// dashboard_id
type WriteDashboardLookml struct {
	FolderId *string `json:"folder_id,omitempty"` // (Write-Only) Id of the folder
	Lookml   *string `json:"lookml,omitempty"`    // lookml of UDD
}

// Dynamic writeable type for Datagroup removes:
// can, created_at, id, model_name, name, trigger_check_at, trigger_error, trigger_value
type WriteDatagroup struct {
	StaleBefore *int64 `json:"stale_before,omitempty"` // UNIX timestamp before which cache entries are considered stale. Cannot be in the future.
	TriggeredAt *int64 `json:"triggered_at,omitempty"` // UNIX timestamp at which this entry became triggered. Cannot be in the future.
}

// Dynamic writeable type for DBConnection removes:
// can, dialect, snippets, pdts_enabled, uses_oauth, supports_data_studio_link, created_at, user_id, example, last_regen_at, last_reap_at, managed
type WriteDBConnection struct {
	Name                     *string                    `json:"name,omitempty"`                         // Name of the connection. Also used as the unique identifier
	Host                     *string                    `json:"host,omitempty"`                         // Host name/address of server; or the string 'localhost' in case of a connection over an SSH tunnel.
	Port                     *string                    `json:"port,omitempty"`                         // Port number on server. If the connection is over an SSH tunnel, then the local port associated with the SSH tunnel.
	Username                 *string                    `json:"username,omitempty"`                     // Username for server authentication
	Password                 *string                    `json:"password,omitempty"`                     // (Write-Only) Password for server authentication
	Certificate              *string                    `json:"certificate,omitempty"`                  // (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
	FileType                 *string                    `json:"file_type,omitempty"`                    // (Write-Only) Certificate keyfile type - .json or .p12
	Database                 *string                    `json:"database,omitempty"`                     // Database name
	DbTimezone               *string                    `json:"db_timezone,omitempty"`                  // Time zone of database
	QueryTimezone            *string                    `json:"query_timezone,omitempty"`               // Timezone to use in queries
	Schema                   *string                    `json:"schema,omitempty"`                       // Schema name
	MaxConnections           *int64                     `json:"max_connections,omitempty"`              // Maximum number of concurrent connection to use
	MaxBillingGigabytes      *string                    `json:"max_billing_gigabytes,omitempty"`        // Maximum size of query in GBs (BigQuery only, can be a user_attribute name)
	Ssl                      *bool                      `json:"ssl,omitempty"`                          // Use SSL/TLS when connecting to server
	VerifySsl                *bool                      `json:"verify_ssl,omitempty"`                   // Verify the SSL
	TmpDbName                *string                    `json:"tmp_db_name,omitempty"`                  // Name of temporary database (if used)
	JdbcAdditionalParams     *string                    `json:"jdbc_additional_params,omitempty"`       // Additional params to add to JDBC connection string
	PoolTimeout              *int64                     `json:"pool_timeout,omitempty"`                 // Connection Pool Timeout, in seconds
	DialectName              *string                    `json:"dialect_name,omitempty"`                 // (Read/Write) SQL Dialect name
	UserDbCredentials        *bool                      `json:"user_db_credentials,omitempty"`          // (Limited access feature) Are per user db credentials enabled. Enabling will remove previously set username and password
	UserAttributeFields      *[]string                  `json:"user_attribute_fields,omitempty"`        // Fields whose values map to user attribute names
	MaintenanceCron          *string                    `json:"maintenance_cron,omitempty"`             // Cron string specifying when maintenance such as PDT trigger checks and drops should be performed
	SqlRunnerPrecacheTables  *bool                      `json:"sql_runner_precache_tables,omitempty"`   // Precache tables in the SQL Runner
	SqlWritingWithInfoSchema *bool                      `json:"sql_writing_with_info_schema,omitempty"` // Fetch Information Schema For SQL Writing
	AfterConnectStatements   *string                    `json:"after_connect_statements,omitempty"`     // SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
	PdtContextOverride       *WriteDBConnectionOverride `json:"pdt_context_override,omitempty"`         // Dynamic writeable type for DBConnectionOverride removes:
	// has_password
	CustomLocalPort         *int64  `json:"custom_local_port,omitempty"`          // This field is only applicable to connections over an SSH Tunnel. The value of this field would be the local port associated with the SSH tunnel if configured manually. Otherwise either enter NULL or exclude this field.
	TunnelId                *string `json:"tunnel_id,omitempty"`                  // The Id of the ssh tunnel this connection uses
	UsesTns                 *bool   `json:"uses_tns,omitempty"`                   // Enable Transparent Network Substrate (TNS) connections
	PdtConcurrency          *int64  `json:"pdt_concurrency,omitempty"`            // Maximum number of threads to use to build PDTs in parallel
	DisableContextComment   *bool   `json:"disable_context_comment,omitempty"`    // When disable_context_comment is true comment will not be added to SQL
	OauthApplicationId      *string `json:"oauth_application_id,omitempty"`       // An External OAuth Application to use for authenticating to the database
	AlwaysRetryFailedBuilds *bool   `json:"always_retry_failed_builds,omitempty"` // When true, error PDTs will be retried every regenerator cycle
	CostEstimateEnabled     *bool   `json:"cost_estimate_enabled,omitempty"`      // When true, query cost estimate will be displayed in explore.
	PdtApiControlEnabled    *bool   `json:"pdt_api_control_enabled,omitempty"`    // PDT builds on this connection can be kicked off and cancelled via API.
	ConnectionPooling       *bool   `json:"connection_pooling,omitempty"`         // Enable database connection pooling.
}

// Dynamic writeable type for DBConnectionOverride removes:
// has_password
type WriteDBConnectionOverride struct {
	Context                *string `json:"context,omitempty"`                  // Context in which to override (`pdt` is the only allowed value)
	Host                   *string `json:"host,omitempty"`                     // Host name/address of server
	Port                   *string `json:"port,omitempty"`                     // Port number on server
	Username               *string `json:"username,omitempty"`                 // Username for server authentication
	Password               *string `json:"password,omitempty"`                 // (Write-Only) Password for server authentication
	Certificate            *string `json:"certificate,omitempty"`              // (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
	FileType               *string `json:"file_type,omitempty"`                // (Write-Only) Certificate keyfile type - .json or .p12
	Database               *string `json:"database,omitempty"`                 // Database name
	Schema                 *string `json:"schema,omitempty"`                   // Schema name
	JdbcAdditionalParams   *string `json:"jdbc_additional_params,omitempty"`   // Additional params to add to JDBC connection string
	AfterConnectStatements *string `json:"after_connect_statements,omitempty"` // SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
}

// Dynamic writeable type for EmbedSecret removes:
// created_at, id, secret, user_id
type WriteEmbedSecret struct {
	Algorithm  *string     `json:"algorithm,omitempty"`   // Signing algorithm to use with this secret. Either `hmac/sha-256`(default) or `hmac/sha-1`
	Enabled    *bool       `json:"enabled,omitempty"`     // Is this secret currently enabled
	SecretType *SecretType `json:"secret_type,omitempty"` // Field to distinguish between SSO secrets and JWT secrets Valid values are: "SSO", "JWT".
}

// Dynamic writeable type for ExternalOauthApplication removes:
// can, id, created_at
type WriteExternalOauthApplication struct {
	Name         *string `json:"name,omitempty"`          // The name of this application.  For Snowflake connections, this should be the name of the host database.
	ClientId     *string `json:"client_id,omitempty"`     // The OAuth Client ID for this application
	ClientSecret *string `json:"client_secret,omitempty"` // (Write-Only) The OAuth Client Secret for this application
	TenantId     *string `json:"tenant_id,omitempty"`     // The OAuth Tenant ID for this application
	DialectName  *string `json:"dialect_name,omitempty"`  // The database dialect for this application.
}

// Dynamic writeable type for FolderBase removes:
// id, content_metadata_id, created_at, creator_id, child_count, external_id, is_embed, is_embed_shared_root, is_embed_users_root, is_personal, is_personal_descendant, is_shared_root, is_users_root, can
type WriteFolderBase struct {
	Name     string  `json:"name"`                // Unique Name
	ParentId *string `json:"parent_id,omitempty"` // Id of Parent. If the parent id is null, this is a root-level entry
}

// Dynamic writeable type for GitBranch removes:
// can, remote, remote_name, error, message, owner_name, readonly, personal, is_local, is_remote, is_production, ahead_count, behind_count, commit_at, remote_ref
type WriteGitBranch struct {
	Name *string `json:"name,omitempty"` // The short name on the local. Updating `name` results in `git checkout <new_name>`
	Ref  *string `json:"ref,omitempty"`  // The resolved ref of this branch. Updating `ref` results in `git reset --hard <new_ref>``.
}

// Dynamic writeable type for Group removes:
// can, contains_current_user, external_group_id, externally_managed, id, include_by_default, user_count
type WriteGroup struct {
	CanAddToContentMetadata *bool   `json:"can_add_to_content_metadata,omitempty"` // Group can be used in content access controls
	Name                    *string `json:"name,omitempty"`                        // Name of group
}

// Dynamic writeable type for Integration removes:
// can, id, integration_hub_id, label, description, supported_formats, supported_action_types, supported_formattings, supported_visualization_formattings, supported_download_settings, icon_url, uses_oauth, required_fields, privacy_link, delegate_oauth
type WriteIntegration struct {
	Enabled                       *bool               `json:"enabled,omitempty"`                          // Whether the integration is available to users.
	Params                        *[]IntegrationParam `json:"params,omitempty"`                           // Array of params for the integration.
	InstalledDelegateOauthTargets *[]string           `json:"installed_delegate_oauth_targets,omitempty"` // Whether the integration is available to users.
}

// Dynamic writeable type for IntegrationHub removes:
// can, id, label, official, fetch_error_message, has_authorization_token, legal_agreement_signed, legal_agreement_required, legal_agreement_text
type WriteIntegrationHub struct {
	Url                *string `json:"url,omitempty"`                 // URL of the hub.
	AuthorizationToken *string `json:"authorization_token,omitempty"` // (Write-Only) An authorization key that will be sent to the integration hub on every request.
}

// Dynamic writeable type for InternalHelpResources removes:
// can
type WriteInternalHelpResources struct {
	Enabled *bool `json:"enabled,omitempty"` // If true and internal help resources content is not blank then the link for internal help resources will be shown in the help menu and the content displayed within Looker
}

// Dynamic writeable type for InternalHelpResourcesContent removes:
// can
type WriteInternalHelpResourcesContent struct {
	OrganizationName *string `json:"organization_name,omitempty"` // Text to display in the help menu item which will display the internal help resources
	MarkdownContent  *string `json:"markdown_content,omitempty"`  // Content to be displayed in the internal help resources page/modal
}

// Dynamic writeable type for LDAPConfig removes:
// can, default_new_user_groups, default_new_user_roles, groups, has_auth_password, modified_at, modified_by, user_attributes, url
type WriteLDAPConfig struct {
	AlternateEmailLoginAllowed *bool                     `json:"alternate_email_login_allowed,omitempty"`  // Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
	AuthPassword               *string                   `json:"auth_password,omitempty"`                  // (Write-Only)  Password for the LDAP account used to access the LDAP server
	AuthRequiresRole           *bool                     `json:"auth_requires_role,omitempty"`             // Users will not be allowed to login at all unless a role for them is found in LDAP if set to true
	AuthUsername               *string                   `json:"auth_username,omitempty"`                  // Distinguished name of LDAP account used to access the LDAP server
	ConnectionHost             *string                   `json:"connection_host,omitempty"`                // LDAP server hostname
	ConnectionPort             *string                   `json:"connection_port,omitempty"`                // LDAP host port
	ConnectionTls              *bool                     `json:"connection_tls,omitempty"`                 // Use Transport Layer Security
	ConnectionTlsNoVerify      *bool                     `json:"connection_tls_no_verify,omitempty"`       // Do not verify peer when using TLS
	DefaultNewUserGroupIds     *[]string                 `json:"default_new_user_group_ids,omitempty"`     // (Write-Only)  Array of ids of groups that will be applied to new users the first time they login via LDAP
	DefaultNewUserRoleIds      *[]string                 `json:"default_new_user_role_ids,omitempty"`      // (Write-Only)  Array of ids of roles that will be applied to new users the first time they login via LDAP
	Enabled                    *bool                     `json:"enabled,omitempty"`                        // Enable/Disable LDAP authentication for the server
	ForceNoPage                *bool                     `json:"force_no_page,omitempty"`                  // Don't attempt to do LDAP search result paging (RFC 2696) even if the LDAP server claims to support it.
	GroupsBaseDn               *string                   `json:"groups_base_dn,omitempty"`                 // Base dn for finding groups in LDAP searches
	GroupsFinderType           *string                   `json:"groups_finder_type,omitempty"`             // Identifier for a strategy for how Looker will search for groups in the LDAP server
	GroupsMemberAttribute      *string                   `json:"groups_member_attribute,omitempty"`        // LDAP Group attribute that signifies the members of the groups. Most commonly 'member'
	GroupsObjectclasses        *string                   `json:"groups_objectclasses,omitempty"`           // Optional comma-separated list of supported LDAP objectclass for groups when doing groups searches
	GroupsUserAttribute        *string                   `json:"groups_user_attribute,omitempty"`          // LDAP Group attribute that signifies the user in a group. Most commonly 'dn'
	GroupsWithRoleIds          *[]LDAPGroupWrite         `json:"groups_with_role_ids,omitempty"`           // (Read/Write) Array of mappings between LDAP Groups and arrays of Looker Role ids
	MergeNewUsersByEmail       *bool                     `json:"merge_new_users_by_email,omitempty"`       // Merge first-time ldap login to existing user account by email addresses. When a user logs in for the first time via ldap this option will connect this user into their existing account by finding the account with a matching email address. Otherwise a new user account will be created for the user.
	SetRolesFromGroups         *bool                     `json:"set_roles_from_groups,omitempty"`          // Set user roles in Looker based on groups from LDAP
	TestLdapPassword           *string                   `json:"test_ldap_password,omitempty"`             // (Write-Only)  Test LDAP user password. For ldap tests only.
	TestLdapUser               *string                   `json:"test_ldap_user,omitempty"`                 // (Write-Only)  Test LDAP user login id. For ldap tests only.
	UserAttributeMapEmail      *string                   `json:"user_attribute_map_email,omitempty"`       // Name of user record attributes used to indicate email address field
	UserAttributeMapFirstName  *string                   `json:"user_attribute_map_first_name,omitempty"`  // Name of user record attributes used to indicate first name
	UserAttributeMapLastName   *string                   `json:"user_attribute_map_last_name,omitempty"`   // Name of user record attributes used to indicate last name
	UserAttributeMapLdapId     *string                   `json:"user_attribute_map_ldap_id,omitempty"`     // Name of user record attributes used to indicate unique record id
	UserAttributesWithIds      *[]LDAPUserAttributeWrite `json:"user_attributes_with_ids,omitempty"`       // (Read/Write) Array of mappings between LDAP User Attributes and arrays of Looker User Attribute ids
	UserBindBaseDn             *string                   `json:"user_bind_base_dn,omitempty"`              // Distinguished name of LDAP node used as the base for user searches
	UserCustomFilter           *string                   `json:"user_custom_filter,omitempty"`             // (Optional) Custom RFC-2254 filter clause for use in finding user during login. Combined via 'and' with the other generated filter clauses.
	UserIdAttributeNames       *string                   `json:"user_id_attribute_names,omitempty"`        // Name(s) of user record attributes used for matching user login id (comma separated list)
	UserObjectclass            *string                   `json:"user_objectclass,omitempty"`               // (Optional) Name of user record objectclass used for finding user during login id
	AllowNormalGroupMembership *bool                     `json:"allow_normal_group_membership,omitempty"`  // Allow LDAP auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.
	AllowRolesFromNormalGroups *bool                     `json:"allow_roles_from_normal_groups,omitempty"` // LDAP auth'd users will be able to inherit roles from non-reflected Looker groups.
	AllowDirectRoles           *bool                     `json:"allow_direct_roles,omitempty"`             // Allows roles to be directly assigned to LDAP auth'd users.
}

// Dynamic writeable type for LegacyFeature removes:
// can, id, name, description, enabled, disallowed_as_of_version, disable_on_upgrade_to_version, end_of_life_version, documentation_url, approximate_disable_date, approximate_end_of_life_date, has_disabled_on_upgrade
type WriteLegacyFeature struct {
	EnabledLocally *bool `json:"enabled_locally,omitempty"` // Whether this feature has been enabled by a user
}

// Dynamic writeable type for LookBasic removes:
// can, content_metadata_id, id, title
type WriteLookBasic struct {
	UserId *string `json:"user_id,omitempty"` // User Id
}

// Dynamic writeable type for LookmlModel removes:
// can, explores, has_content, label
type WriteLookmlModel struct {
	AllowedDbConnectionNames *[]string `json:"allowed_db_connection_names,omitempty"` // Array of names of connections this model is allowed to use
	Name                     *string   `json:"name,omitempty"`                        // Name of the model. Also used as the unique identifier
	ProjectName              *string   `json:"project_name,omitempty"`                // Name of project containing the model
	UnlimitedDbConnections   *bool     `json:"unlimited_db_connections,omitempty"`    // Is this model allowed to use all current and future connections
}

// Dynamic writeable type for LookWithQuery removes:
// can, content_metadata_id, id, content_favorite_id, created_at, deleted_at, deleter_id, embed_url, excel_file_url, favorite_count, google_spreadsheet_formula, image_embed_url, last_accessed_at, last_updater_id, last_viewed_at, model, public_slug, public_url, short_url, updated_at, view_count, url
type WriteLookWithQuery struct {
	Title       *string          `json:"title,omitempty"`          // Look Title
	UserId      *string          `json:"user_id,omitempty"`        // User Id
	Deleted     *bool            `json:"deleted,omitempty"`        // Whether or not a look is 'soft' deleted.
	Description *string          `json:"description,omitempty"`    // Description
	IsRunOnLoad *bool            `json:"is_run_on_load,omitempty"` // auto-run query when Look viewed
	Public      *bool            `json:"public,omitempty"`         // Is Public
	QueryId     *string          `json:"query_id,omitempty"`       // Query Id
	Folder      *WriteFolderBase `json:"folder,omitempty"`         // Dynamic writeable type for FolderBase removes:
	// id, content_metadata_id, created_at, creator_id, child_count, external_id, is_embed, is_embed_shared_root, is_embed_users_root, is_personal, is_personal_descendant, is_shared_root, is_users_root, can
	FolderId *string     `json:"folder_id,omitempty"` // Folder Id
	Query    *WriteQuery `json:"query,omitempty"`     // Dynamic writeable type for Query removes:
	// can, id, slug, share_url, expanded_share_url, url, has_table_calculations
}

// Dynamic writeable type for MergeQuery removes:
// can, id, result_maker_id
type WriteMergeQuery struct {
	ColumnLimit   *string                  `json:"column_limit,omitempty"`   // Column Limit
	DynamicFields *string                  `json:"dynamic_fields,omitempty"` // Dynamic Fields
	Pivots        *[]string                `json:"pivots,omitempty"`         // Pivots
	Sorts         *[]string                `json:"sorts,omitempty"`          // Sorts
	SourceQueries *[]MergeQuerySourceQuery `json:"source_queries,omitempty"` // Source Queries defining the results to be merged.
	Total         *bool                    `json:"total,omitempty"`          // Total
	VisConfig     *map[string]interface{}  `json:"vis_config,omitempty"`     // Visualization Config
}

// Dynamic writeable type for MobileToken removes:
// id
type WriteMobileToken struct {
	DeviceToken string     `json:"device_token"` // Specifies the device token
	DeviceType  DeviceType `json:"device_type"`  // Specifies type of device. Valid values are: "android", "ios".
}

// Dynamic writeable type for ModelSet removes:
// can, all_access, built_in, id, url
type WriteModelSet struct {
	Models *[]string `json:"models,omitempty"`
	Name   *string   `json:"name,omitempty"` // Name of ModelSet
}

// Dynamic writeable type for OauthClientApp removes:
// can, client_guid, tokens_invalid_before, activated_users
type WriteOauthClientApp struct {
	RedirectUri *string `json:"redirect_uri,omitempty"` // The uri with which this application will receive an auth code by browser redirect.
	DisplayName *string `json:"display_name,omitempty"` // The application's display name
	Description *string `json:"description,omitempty"`  // A description of the application that will be displayed to users
	Enabled     *bool   `json:"enabled,omitempty"`      // When enabled is true, OAuth2 and API requests will be accepted from this app. When false, all requests from this app will be refused. Setting disabled invalidates existing tokens.
	GroupId     *string `json:"group_id,omitempty"`     // If set, only Looker users who are members of this group can use this web app with Looker. If group_id is not set, any Looker user may use this app to access this Looker instance
}

// Dynamic writeable type for OIDCConfig removes:
// can, default_new_user_groups, default_new_user_roles, groups, modified_at, modified_by, test_slug, user_attributes, url
type WriteOIDCConfig struct {
	AlternateEmailLoginAllowed *bool                     `json:"alternate_email_login_allowed,omitempty"`  // Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
	Audience                   *string                   `json:"audience,omitempty"`                       // OpenID Provider Audience
	AuthRequiresRole           *bool                     `json:"auth_requires_role,omitempty"`             // Users will not be allowed to login at all unless a role for them is found in OIDC if set to true
	AuthorizationEndpoint      *string                   `json:"authorization_endpoint,omitempty"`         // OpenID Provider Authorization Url
	DefaultNewUserGroupIds     *[]string                 `json:"default_new_user_group_ids,omitempty"`     // (Write-Only) Array of ids of groups that will be applied to new users the first time they login via OIDC
	DefaultNewUserRoleIds      *[]string                 `json:"default_new_user_role_ids,omitempty"`      // (Write-Only) Array of ids of roles that will be applied to new users the first time they login via OIDC
	Enabled                    *bool                     `json:"enabled,omitempty"`                        // Enable/Disable OIDC authentication for the server
	GroupsAttribute            *string                   `json:"groups_attribute,omitempty"`               // Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
	GroupsWithRoleIds          *[]OIDCGroupWrite         `json:"groups_with_role_ids,omitempty"`           // (Read/Write) Array of mappings between OIDC Groups and arrays of Looker Role ids
	Identifier                 *string                   `json:"identifier,omitempty"`                     // Relying Party Identifier (provided by OpenID Provider)
	Issuer                     *string                   `json:"issuer,omitempty"`                         // OpenID Provider Issuer
	NewUserMigrationTypes      *string                   `json:"new_user_migration_types,omitempty"`       // Merge first-time oidc login to existing user account by email addresses. When a user logs in for the first time via oidc this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
	Scopes                     *[]string                 `json:"scopes,omitempty"`                         // Array of scopes to request.
	Secret                     *string                   `json:"secret,omitempty"`                         // (Write-Only) Relying Party Secret (provided by OpenID Provider)
	SetRolesFromGroups         *bool                     `json:"set_roles_from_groups,omitempty"`          // Set user roles in Looker based on groups from OIDC
	TokenEndpoint              *string                   `json:"token_endpoint,omitempty"`                 // OpenID Provider Token Url
	UserAttributeMapEmail      *string                   `json:"user_attribute_map_email,omitempty"`       // Name of user record attributes used to indicate email address field
	UserAttributeMapFirstName  *string                   `json:"user_attribute_map_first_name,omitempty"`  // Name of user record attributes used to indicate first name
	UserAttributeMapLastName   *string                   `json:"user_attribute_map_last_name,omitempty"`   // Name of user record attributes used to indicate last name
	UserAttributesWithIds      *[]OIDCUserAttributeWrite `json:"user_attributes_with_ids,omitempty"`       // (Read/Write) Array of mappings between OIDC User Attributes and arrays of Looker User Attribute ids
	UserinfoEndpoint           *string                   `json:"userinfo_endpoint,omitempty"`              // OpenID Provider User Information Url
	AllowNormalGroupMembership *bool                     `json:"allow_normal_group_membership,omitempty"`  // Allow OIDC auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.
	AllowRolesFromNormalGroups *bool                     `json:"allow_roles_from_normal_groups,omitempty"` // OIDC auth'd users will inherit roles from non-reflected Looker groups.
	AllowDirectRoles           *bool                     `json:"allow_direct_roles,omitempty"`             // Allows roles to be directly assigned to OIDC auth'd users.
}

// Dynamic writeable type for PasswordConfig removes:
// can
type WritePasswordConfig struct {
	MinLength         *int64 `json:"min_length,omitempty"`         // Minimum number of characters required for a new password.  Must be between 7 and 100
	RequireNumeric    *bool  `json:"require_numeric,omitempty"`    // Require at least one numeric character
	RequireUpperlower *bool  `json:"require_upperlower,omitempty"` // Require at least one uppercase and one lowercase letter
	RequireSpecial    *bool  `json:"require_special,omitempty"`    // Require at least one special character
}

// Dynamic writeable type for PermissionSet removes:
// can, all_access, built_in, id, url
type WritePermissionSet struct {
	Name        *string   `json:"name,omitempty"` // Name of PermissionSet
	Permissions *[]string `json:"permissions,omitempty"`
}

// Dynamic writeable type for PrivatelabelConfiguration removes:
// logo_url, favicon_url
type WritePrivatelabelConfiguration struct {
	LogoFile                   *string `json:"logo_file,omitempty"`                     // Customer logo image. Expected base64 encoded data (write-only)
	FaviconFile                *string `json:"favicon_file,omitempty"`                  // Custom favicon image. Expected base64 encoded data (write-only)
	DefaultTitle               *string `json:"default_title,omitempty"`                 // Default page title
	ShowHelpMenu               *bool   `json:"show_help_menu,omitempty"`                // Boolean to toggle showing help menus
	ShowDocs                   *bool   `json:"show_docs,omitempty"`                     // Boolean to toggle showing docs
	ShowEmailSubOptions        *bool   `json:"show_email_sub_options,omitempty"`        // Boolean to toggle showing email subscription options.
	AllowLookerMentions        *bool   `json:"allow_looker_mentions,omitempty"`         // Boolean to toggle mentions of Looker in emails
	AllowLookerLinks           *bool   `json:"allow_looker_links,omitempty"`            // Boolean to toggle links to Looker in emails
	CustomWelcomeEmailAdvanced *bool   `json:"custom_welcome_email_advanced,omitempty"` // Allow subject line and email heading customization in customized emails
	SetupMentions              *bool   `json:"setup_mentions,omitempty"`                // Remove the word Looker from appearing in the account setup page
	AlertsLogo                 *bool   `json:"alerts_logo,omitempty"`                   // Remove Looker logo from Alerts
	AlertsLinks                *bool   `json:"alerts_links,omitempty"`                  // Remove Looker links from Alerts
	FoldersMentions            *bool   `json:"folders_mentions,omitempty"`              // Remove Looker mentions in home folder page when you dont have any items saved
}

// Dynamic writeable type for Project removes:
// can, id, uses_git, is_example
type WriteProject struct {
	Name                           *string          `json:"name,omitempty"`                               // Project display name
	GitRemoteUrl                   *string          `json:"git_remote_url,omitempty"`                     // Git remote repository url
	GitUsername                    *string          `json:"git_username,omitempty"`                       // Git username for HTTPS authentication. (For production only, if using user attributes.)
	GitPassword                    *string          `json:"git_password,omitempty"`                       // (Write-Only) Git password for HTTPS authentication. (For production only, if using user attributes.)
	GitProductionBranchName        *string          `json:"git_production_branch_name,omitempty"`         // Git production branch name. Defaults to master. Supported only in Looker 21.0 and higher.
	UseGitCookieAuth               *bool            `json:"use_git_cookie_auth,omitempty"`                // If true, the project uses a git cookie for authentication.
	GitUsernameUserAttribute       *string          `json:"git_username_user_attribute,omitempty"`        // User attribute name for username in per-user HTTPS authentication.
	GitPasswordUserAttribute       *string          `json:"git_password_user_attribute,omitempty"`        // User attribute name for password in per-user HTTPS authentication.
	GitServiceName                 *string          `json:"git_service_name,omitempty"`                   // Name of the git service provider
	GitApplicationServerHttpPort   *int64           `json:"git_application_server_http_port,omitempty"`   // Port that HTTP(S) application server is running on (for PRs, file browsing, etc.)
	GitApplicationServerHttpScheme *string          `json:"git_application_server_http_scheme,omitempty"` // Scheme that is running on application server (for PRs, file browsing, etc.)
	DeploySecret                   *string          `json:"deploy_secret,omitempty"`                      // (Write-Only) Optional secret token with which to authenticate requests to the webhook deploy endpoint. If not set, endpoint is unauthenticated.
	UnsetDeploySecret              *bool            `json:"unset_deploy_secret,omitempty"`                // (Write-Only) When true, unsets the deploy secret to allow unauthenticated access to the webhook deploy endpoint.
	PullRequestMode                *PullRequestMode `json:"pull_request_mode,omitempty"`                  // The git pull request policy for this project. Valid values are: "off", "links", "recommended", "required".
	ValidationRequired             *bool            `json:"validation_required,omitempty"`                // Validation policy: If true, the project must pass validation checks before project changes can be committed to the git repository
	GitReleaseMgmtEnabled          *bool            `json:"git_release_mgmt_enabled,omitempty"`           // If true, advanced git release management is enabled for this project
	AllowWarnings                  *bool            `json:"allow_warnings,omitempty"`                     // Validation policy: If true, the project can be committed with warnings when `validation_required` is true. (`allow_warnings` does nothing if `validation_required` is false).
	DependencyStatus               *string          `json:"dependency_status,omitempty"`                  // Status of dependencies in your manifest & lockfile
}

// Dynamic writeable type for Query removes:
// can, id, slug, share_url, expanded_share_url, url, has_table_calculations
type WriteQuery struct {
	Model             string                  `json:"model"`                         // Model
	View              string                  `json:"view"`                          // Explore Name
	Fields            *[]string               `json:"fields,omitempty"`              // Fields
	Pivots            *[]string               `json:"pivots,omitempty"`              // Pivots
	FillFields        *[]string               `json:"fill_fields,omitempty"`         // Fill Fields
	Filters           *map[string]interface{} `json:"filters,omitempty"`             // Filters will contain data pertaining to complex filters that do not contain "or" conditions. When "or" conditions are present, filter data will be found on the `filter_expression` property.
	FilterExpression  *string                 `json:"filter_expression,omitempty"`   // Filter Expression
	Sorts             *[]string               `json:"sorts,omitempty"`               // Sorting for the query results. Use the format `["view.field", ...]` to sort on fields in ascending order. Use the format `["view.field desc", ...]` to sort on fields in descending order. Use `["__UNSORTED__"]` (2 underscores before and after) to disable sorting entirely. Empty sorts `[]` will trigger a default sort.
	Limit             *string                 `json:"limit,omitempty"`               // Limit
	ColumnLimit       *string                 `json:"column_limit,omitempty"`        // Column Limit
	Total             *bool                   `json:"total,omitempty"`               // Total
	RowTotal          *string                 `json:"row_total,omitempty"`           // Raw Total
	Subtotals         *[]string               `json:"subtotals,omitempty"`           // Fields on which to run subtotals
	VisConfig         *map[string]interface{} `json:"vis_config,omitempty"`          // Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
	FilterConfig      *map[string]interface{} `json:"filter_config,omitempty"`       // The filter_config represents the state of the filter UI on the explore page for a given query. When running a query via the Looker UI, this parameter takes precedence over "filters". When creating a query or modifying an existing query, "filter_config" should be set to null. Setting it to any other value could cause unexpected filtering behavior. The format should be considered opaque.
	VisibleUiSections *string                 `json:"visible_ui_sections,omitempty"` // Visible UI Sections
	DynamicFields     *string                 `json:"dynamic_fields,omitempty"`      // Dynamic Fields
	ClientId          *string                 `json:"client_id,omitempty"`           // Client Id: used to generate shortened explore URLs. If set by client, must be a unique 22 character alphanumeric string. Otherwise one will be generated.
	QueryTimezone     *string                 `json:"query_timezone,omitempty"`      // Query Timezone
}

// Dynamic writeable type for RepositoryCredential removes:
// can, id, root_project_id, remote_url, is_configured
type WriteRepositoryCredential struct {
	GitUsername  *string `json:"git_username,omitempty"`   // Git username for HTTPS authentication.
	GitPassword  *string `json:"git_password,omitempty"`   // (Write-Only) Git password for HTTPS authentication.
	SshPublicKey *string `json:"ssh_public_key,omitempty"` // Public deploy key for SSH authentication.
}

// Dynamic writeable type for ResultMakerWithIdVisConfigAndDynamicFields removes:
// id, dynamic_fields, filterables, sorts, merge_result_id, total, query_id, sql_query_id, vis_config
type WriteResultMakerWithIdVisConfigAndDynamicFields struct {
	Query *WriteQuery `json:"query,omitempty"` // Dynamic writeable type for Query removes:
	// can, id, slug, share_url, expanded_share_url, url, has_table_calculations
}

// Dynamic writeable type for Role removes:
// can, id, url, users_url
type WriteRole struct {
	Name          *string             `json:"name,omitempty"`           // Name of Role
	PermissionSet *WritePermissionSet `json:"permission_set,omitempty"` // Dynamic writeable type for PermissionSet removes:
	// can, all_access, built_in, id, url
	PermissionSetId *string        `json:"permission_set_id,omitempty"` // (Write-Only) Id of permission set
	ModelSet        *WriteModelSet `json:"model_set,omitempty"`         // Dynamic writeable type for ModelSet removes:
	// can, all_access, built_in, id, url
	ModelSetId *string `json:"model_set_id,omitempty"` // (Write-Only) Id of model set
}

// Dynamic writeable type for SamlConfig removes:
// can, test_slug, modified_at, modified_by, default_new_user_roles, default_new_user_groups, groups, user_attributes, url
type WriteSamlConfig struct {
	Enabled                    *bool                     `json:"enabled,omitempty"`                        // Enable/Disable Saml authentication for the server
	IdpCert                    *string                   `json:"idp_cert,omitempty"`                       // Identity Provider Certificate (provided by IdP)
	IdpUrl                     *string                   `json:"idp_url,omitempty"`                        // Identity Provider Url (provided by IdP)
	IdpIssuer                  *string                   `json:"idp_issuer,omitempty"`                     // Identity Provider Issuer (provided by IdP)
	IdpAudience                *string                   `json:"idp_audience,omitempty"`                   // Identity Provider Audience (set in IdP config). Optional in Looker. Set this only if you want Looker to validate the audience value returned by the IdP.
	AllowedClockDrift          *int64                    `json:"allowed_clock_drift,omitempty"`            // Count of seconds of clock drift to allow when validating timestamps of assertions.
	UserAttributeMapEmail      *string                   `json:"user_attribute_map_email,omitempty"`       // Name of user record attributes used to indicate email address field
	UserAttributeMapFirstName  *string                   `json:"user_attribute_map_first_name,omitempty"`  // Name of user record attributes used to indicate first name
	UserAttributeMapLastName   *string                   `json:"user_attribute_map_last_name,omitempty"`   // Name of user record attributes used to indicate last name
	NewUserMigrationTypes      *string                   `json:"new_user_migration_types,omitempty"`       // Merge first-time saml login to existing user account by email addresses. When a user logs in for the first time via saml this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
	AlternateEmailLoginAllowed *bool                     `json:"alternate_email_login_allowed,omitempty"`  // Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
	DefaultNewUserRoleIds      *[]string                 `json:"default_new_user_role_ids,omitempty"`      // (Write-Only) Array of ids of roles that will be applied to new users the first time they login via Saml
	DefaultNewUserGroupIds     *[]string                 `json:"default_new_user_group_ids,omitempty"`     // (Write-Only) Array of ids of groups that will be applied to new users the first time they login via Saml
	SetRolesFromGroups         *bool                     `json:"set_roles_from_groups,omitempty"`          // Set user roles in Looker based on groups from Saml
	GroupsAttribute            *string                   `json:"groups_attribute,omitempty"`               // Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
	GroupsWithRoleIds          *[]SamlGroupWrite         `json:"groups_with_role_ids,omitempty"`           // (Read/Write) Array of mappings between Saml Groups and arrays of Looker Role ids
	AuthRequiresRole           *bool                     `json:"auth_requires_role,omitempty"`             // Users will not be allowed to login at all unless a role for them is found in Saml if set to true
	UserAttributesWithIds      *[]SamlUserAttributeWrite `json:"user_attributes_with_ids,omitempty"`       // (Read/Write) Array of mappings between Saml User Attributes and arrays of Looker User Attribute ids
	GroupsFinderType           *string                   `json:"groups_finder_type,omitempty"`             // Identifier for a strategy for how Looker will find groups in the SAML response. One of ['grouped_attribute_values', 'individual_attributes']
	GroupsMemberValue          *string                   `json:"groups_member_value,omitempty"`            // Value for group attribute used to indicate membership. Used when 'groups_finder_type' is set to 'individual_attributes'
	BypassLoginPage            *bool                     `json:"bypass_login_page,omitempty"`              // Bypass the login page when user authentication is required. Redirect to IdP immediately instead.
	AllowNormalGroupMembership *bool                     `json:"allow_normal_group_membership,omitempty"`  // Allow SAML auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.
	AllowRolesFromNormalGroups *bool                     `json:"allow_roles_from_normal_groups,omitempty"` // SAML auth'd users will inherit roles from non-reflected Looker groups.
	AllowDirectRoles           *bool                     `json:"allow_direct_roles,omitempty"`             // Allows roles to be directly assigned to SAML auth'd users.
}

// Dynamic writeable type for ScheduledPlan removes:
// id, created_at, updated_at, title, user, next_run_at, last_run_at, can
type WriteScheduledPlan struct {
	Name                     *string                     `json:"name,omitempty"`                       // Name of this scheduled plan
	UserId                   *string                     `json:"user_id,omitempty"`                    // User Id which owns this scheduled plan
	RunAsRecipient           *bool                       `json:"run_as_recipient,omitempty"`           // Whether schedule is run as recipient (only applicable for email recipients)
	Enabled                  *bool                       `json:"enabled,omitempty"`                    // Whether the ScheduledPlan is enabled
	LookId                   *string                     `json:"look_id,omitempty"`                    // Id of a look
	DashboardId              *string                     `json:"dashboard_id,omitempty"`               // Id of a dashboard
	LookmlDashboardId        *string                     `json:"lookml_dashboard_id,omitempty"`        // Id of a LookML dashboard
	FiltersString            *string                     `json:"filters_string,omitempty"`             // Query string to run look or dashboard with
	DashboardFilters         *string                     `json:"dashboard_filters,omitempty"`          // (DEPRECATED) Alias for filters_string field
	RequireResults           *bool                       `json:"require_results,omitempty"`            // Delivery should occur if running the dashboard or look returns results
	RequireNoResults         *bool                       `json:"require_no_results,omitempty"`         // Delivery should occur if the dashboard look does not return results
	RequireChange            *bool                       `json:"require_change,omitempty"`             // Delivery should occur if data have changed since the last run
	SendAllResults           *bool                       `json:"send_all_results,omitempty"`           // Will run an unlimited query and send all results.
	Crontab                  *string                     `json:"crontab,omitempty"`                    // Vixie-Style crontab specification when to run
	Datagroup                *string                     `json:"datagroup,omitempty"`                  // Name of a datagroup; if specified will run when datagroup triggered (can't be used with cron string)
	Timezone                 *string                     `json:"timezone,omitempty"`                   // Timezone for interpreting the specified crontab (default is Looker instance timezone)
	QueryId                  *string                     `json:"query_id,omitempty"`                   // Query id
	ScheduledPlanDestination *[]ScheduledPlanDestination `json:"scheduled_plan_destination,omitempty"` // Scheduled plan destinations
	RunOnce                  *bool                       `json:"run_once,omitempty"`                   // Whether the plan in question should only be run once (usually for testing)
	IncludeLinks             *bool                       `json:"include_links,omitempty"`              // Whether links back to Looker should be included in this ScheduledPlan
	CustomUrlBase            *string                     `json:"custom_url_base,omitempty"`            // Custom url domain for the scheduled entity
	CustomUrlParams          *string                     `json:"custom_url_params,omitempty"`          // Custom url path and parameters for the scheduled entity
	CustomUrlLabel           *string                     `json:"custom_url_label,omitempty"`           // Custom url label for the scheduled entity
	ShowCustomUrl            *bool                       `json:"show_custom_url,omitempty"`            // Whether to show custom link back instead of standard looker link
	PdfPaperSize             *string                     `json:"pdf_paper_size,omitempty"`             // The size of paper the PDF should be formatted to fit. Valid values are: "letter", "legal", "tabloid", "a0", "a1", "a2", "a3", "a4", "a5".
	PdfLandscape             *bool                       `json:"pdf_landscape,omitempty"`              // Whether the PDF should be formatted for landscape orientation
	Embed                    *bool                       `json:"embed,omitempty"`                      // Whether this schedule is in an embed context or not
	ColorTheme               *string                     `json:"color_theme,omitempty"`                // Color scheme of the dashboard if applicable
	LongTables               *bool                       `json:"long_tables,omitempty"`                // Whether or not to expand table vis to full length
	InlineTableWidth         *int64                      `json:"inline_table_width,omitempty"`         // The pixel width at which we render the inline table visualizations
}

// Dynamic writeable type for SessionConfig removes:
// can
type WriteSessionConfig struct {
	AllowPersistentSessions  *bool  `json:"allow_persistent_sessions,omitempty"`   // Allow users to have persistent sessions when they login
	SessionMinutes           *int64 `json:"session_minutes,omitempty"`             // Number of minutes for user sessions.  Must be between 5 and 43200
	UnlimitedSessionsPerUser *bool  `json:"unlimited_sessions_per_user,omitempty"` // Allow users to have an unbounded number of concurrent sessions (otherwise, users will be limited to only one session at a time).
	UseInactivityBasedLogout *bool  `json:"use_inactivity_based_logout,omitempty"` // Enforce session logout for sessions that are inactive for 15 minutes.
	TrackSessionLocation     *bool  `json:"track_session_location,omitempty"`      // Track location of session when user logs in.
}

// Dynamic writeable type for Setting removes:
// marketplace_site, embed_enabled, login_notification_enabled, login_notification_text
type WriteSetting struct {
	ExtensionFrameworkEnabled     *bool                           `json:"extension_framework_enabled,omitempty"`      // Toggle extension framework on or off
	ExtensionLoadUrlEnabled       *bool                           `json:"extension_load_url_enabled,omitempty"`       // (DEPRECATED) Toggle extension load url on or off. Do not use. This is temporary setting that will eventually become a noop and subsequently deleted.
	MarketplaceAutoInstallEnabled *bool                           `json:"marketplace_auto_install_enabled,omitempty"` // (DEPRECATED) Toggle marketplace auto install on or off. Deprecated - do not use. Auto install can now be enabled via marketplace automation settings
	MarketplaceAutomation         *MarketplaceAutomation          `json:"marketplace_automation,omitempty"`
	MarketplaceEnabled            *bool                           `json:"marketplace_enabled,omitempty"`        // Toggle marketplace on or off
	MarketplaceTermsAccepted      *bool                           `json:"marketplace_terms_accepted,omitempty"` // Accept marketplace terms by setting this value to true, or get the current status. Marketplace terms CANNOT be declined once accepted. Accepting marketplace terms automatically enables the marketplace. The marketplace can still be disabled after it has been enabled.
	PrivatelabelConfiguration     *WritePrivatelabelConfiguration `json:"privatelabel_configuration,omitempty"` // Dynamic writeable type for PrivatelabelConfiguration removes:
	// logo_url, favicon_url
	CustomWelcomeEmail          *CustomWelcomeEmail `json:"custom_welcome_email,omitempty"`
	OnboardingEnabled           *bool               `json:"onboarding_enabled,omitempty"`             // Toggle onboarding on or off
	Timezone                    *string             `json:"timezone,omitempty"`                       // Change instance-wide default timezone
	AllowUserTimezones          *bool               `json:"allow_user_timezones,omitempty"`           // Toggle user-specific timezones on or off
	DataConnectorDefaultEnabled *bool               `json:"data_connector_default_enabled,omitempty"` // Toggle default future connectors on or off
	HostUrl                     *string             `json:"host_url,omitempty"`                       // Change the base portion of your Looker instance URL setting
	OverrideWarnings            *bool               `json:"override_warnings,omitempty"`              // (Write-Only) If warnings are preventing a host URL change, this parameter allows for overriding warnings to force update the setting. Does not directly change any Looker settings.
	EmailDomainAllowlist        *[]string           `json:"email_domain_allowlist,omitempty"`         // An array of Email Domain Allowlist of type string for Scheduled Content
	EmbedCookielessV2           *bool               `json:"embed_cookieless_v2,omitempty"`            // (DEPRECATED) Use embed_config.embed_cookieless_v2 instead. If embed_config.embed_cookieless_v2 is specified, it overrides this value.
	EmbedConfig                 *EmbedConfig        `json:"embed_config,omitempty"`
}

// Dynamic writeable type for SqlInterfaceQueryCreate removes:
// can
type WriteSqlInterfaceQueryCreate struct {
	Sql        string `json:"sql"`                   // Original SQL request
	JdbcClient *bool  `json:"jdbc_client,omitempty"` // Whether the query should be run for use in a JDBC Client. This changes the formatting of some datetime based values.
}

// Dynamic writeable type for SshServer removes:
// ssh_server_id, finger_print, sha_finger_print, public_key, status
type WriteSshServer struct {
	SshServerName *string `json:"ssh_server_name,omitempty"` // The name to identify this SSH Server
	SshServerHost *string `json:"ssh_server_host,omitempty"` // The hostname or ip address of the SSH Server
	SshServerPort *int64  `json:"ssh_server_port,omitempty"` // The port to connect to on the SSH Server
	SshServerUser *string `json:"ssh_server_user,omitempty"` // The username used to connect to the SSH Server
}

// Dynamic writeable type for SshTunnel removes:
// tunnel_id, ssh_server_name, ssh_server_host, ssh_server_port, ssh_server_user, last_attempt, status
type WriteSshTunnel struct {
	SshServerId   *string `json:"ssh_server_id,omitempty"`   // SSH Server ID
	LocalHostPort *int64  `json:"local_host_port,omitempty"` // Localhost Port used by the Looker instance to connect to the remote DB
	DatabaseHost  *string `json:"database_host,omitempty"`   // Hostname or IP Address of the Database Server
	DatabasePort  *int64  `json:"database_port,omitempty"`   // Port that the Database Server is listening on
}

// Dynamic writeable type for Theme removes:
// can, id
type WriteTheme struct {
	BeginAt  *time.Time     `json:"begin_at,omitempty"` // Timestamp for when this theme becomes active. Null=always
	EndAt    *time.Time     `json:"end_at,omitempty"`   // Timestamp for when this theme expires. Null=never
	Name     *string        `json:"name,omitempty"`     // Name of theme. Can only be alphanumeric and underscores.
	Settings *ThemeSettings `json:"settings,omitempty"`
}

// Dynamic writeable type for User removes:
// can, avatar_url, avatar_url_without_sizing, credentials_api3, credentials_embed, credentials_google, credentials_ldap, credentials_looker_openid, credentials_oidc, credentials_saml, credentials_totp, display_name, email, embed_group_space_id, group_ids, id, looker_versions, personal_folder_id, presumed_looker_employee, role_ids, sessions, verified_looker_employee, roles_externally_managed, allow_direct_roles, allow_normal_group_membership, allow_roles_from_normal_groups, embed_group_folder_id, is_iam_admin, url
type WriteUser struct {
	CredentialsEmail *WriteCredentialsEmail `json:"credentials_email,omitempty"` // Dynamic writeable type for CredentialsEmail removes:
	// can, created_at, user_id, is_disabled, logged_in_at, password_reset_url, account_setup_url, type, url, user_url
	FirstName          *string                 `json:"first_name,omitempty"`           // First name
	HomeFolderId       *string                 `json:"home_folder_id,omitempty"`       // ID string for user's home folder
	IsDisabled         *bool                   `json:"is_disabled,omitempty"`          // Account has been disabled
	LastName           *string                 `json:"last_name,omitempty"`            // Last name
	Locale             *string                 `json:"locale,omitempty"`               // User's preferred locale. User locale takes precedence over Looker's system-wide default locale. Locale determines language of display strings and date and numeric formatting in API responses. Locale string must be a 2 letter language code or a combination of language code and region code: 'en' or 'en-US', for example.
	ModelsDirValidated *bool                   `json:"models_dir_validated,omitempty"` // User's dev workspace has been checked for presence of applicable production projects
	UiState            *map[string]interface{} `json:"ui_state,omitempty"`             // Per user dictionary of undocumented state information owned by the Looker UI.
}

// Dynamic writeable type for UserAttribute removes:
// can, id, is_system, is_permanent
type WriteUserAttribute struct {
	Name                       string  `json:"name"`                                    // Name of user attribute
	Label                      string  `json:"label"`                                   // Human-friendly label for user attribute
	Type                       string  `json:"type"`                                    // Type of user attribute ("string", "number", "datetime", "yesno", "zipcode", "advanced_filter_string", "advanced_filter_number")
	DefaultValue               *string `json:"default_value,omitempty"`                 // Default value for when no value is set on the user
	ValueIsHidden              *bool   `json:"value_is_hidden,omitempty"`               // If true, users will not be able to view values of this attribute
	UserCanView                *bool   `json:"user_can_view,omitempty"`                 // Non-admin users can see the values of their attributes and use them in filters
	UserCanEdit                *bool   `json:"user_can_edit,omitempty"`                 // Users can change the value of this attribute for themselves
	HiddenValueDomainWhitelist *string `json:"hidden_value_domain_whitelist,omitempty"` // Destinations to which a hidden attribute may be sent. Once set, cannot be edited.
}

// Dynamic writeable type for UserAttributeWithValue removes:
// can, name, label, rank, user_id, user_can_edit, value_is_hidden, user_attribute_id, source, hidden_value_domain_whitelist
type WriteUserAttributeWithValue struct {
	Value *string `json:"value,omitempty"` // Value of attribute for user
}

// Dynamic writeable type for WhitelabelConfiguration removes:
// id, logo_url, favicon_url
type WriteWhitelabelConfiguration struct {
	LogoFile                   *string `json:"logo_file,omitempty"`                     // Customer logo image. Expected base64 encoded data (write-only)
	FaviconFile                *string `json:"favicon_file,omitempty"`                  // Custom favicon image. Expected base64 encoded data (write-only)
	DefaultTitle               *string `json:"default_title,omitempty"`                 // Default page title
	ShowHelpMenu               *bool   `json:"show_help_menu,omitempty"`                // Boolean to toggle showing help menus
	ShowDocs                   *bool   `json:"show_docs,omitempty"`                     // Boolean to toggle showing docs
	ShowEmailSubOptions        *bool   `json:"show_email_sub_options,omitempty"`        // Boolean to toggle showing email subscription options.
	AllowLookerMentions        *bool   `json:"allow_looker_mentions,omitempty"`         // Boolean to toggle mentions of Looker in emails
	AllowLookerLinks           *bool   `json:"allow_looker_links,omitempty"`            // Boolean to toggle links to Looker in emails
	CustomWelcomeEmailAdvanced *bool   `json:"custom_welcome_email_advanced,omitempty"` // Allow subject line and email heading customization in customized emails
	SetupMentions              *bool   `json:"setup_mentions,omitempty"`                // Remove the word Looker from appearing in the account setup page
	AlertsLogo                 *bool   `json:"alerts_logo,omitempty"`                   // Remove Looker logo from Alerts
	AlertsLinks                *bool   `json:"alerts_links,omitempty"`                  // Remove Looker links from Alerts
	FoldersMentions            *bool   `json:"folders_mentions,omitempty"`              // Remove Looker mentions in home folder page when you dont have any items saved
}
