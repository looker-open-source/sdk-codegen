/*

MIT License

Copyright (c) 2019 Looker Data Sciences, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

/*

289 API models: 180 Spec, 42 Request, 52 Write, 15 Enum

*/


// NOTE: Do not edit this file generated by Looker SDK Codegen for Looker 7.4 API v4

package v4

import (
  "github.com/looker-open-source/sdk-codegen/go/rtl"
  "net/url"
  "time"
)


type AccessToken struct {
  AccessToken *string `json:"access_token,omitempty"`  // Access Token used for API calls
  TokenType   *string `json:"token_type,omitempty"`    // Type of Token
  ExpiresIn   *int64  `json:"expires_in,omitempty"`    // Number of seconds before the token expires
}

type AlignType string
const AlignType_Left  AlignType = "left"
const AlignType_Right AlignType = "right"



type ApiSession struct {
  Can         *map[string]bool `json:"can,omitempty"`           // Operations the current user is able to perform on this object
  WorkspaceId *string          `json:"workspace_id,omitempty"`  // The id of active workspace for this session
  SudoUserId  *int64           `json:"sudo_user_id,omitempty"`  // The id of the actual user in the case when this session represents one user sudo'ing as another
}


type ApiVersion struct {
  LookerReleaseVersion *string              `json:"looker_release_version,omitempty"`  // Current Looker release version number
  CurrentVersion       *ApiVersionElement   `json:"current_version,omitempty"`        
  SupportedVersions    *[]ApiVersionElement `json:"supported_versions,omitempty"`      // Array of versions supported by this Looker instance
}


type ApiVersionElement struct {
  Version     *string  `json:"version,omitempty"`       // Version number as it appears in '/api/xxx/' urls
  FullVersion *string  `json:"full_version,omitempty"`  // Full version number including minor version
  Status      *string  `json:"status,omitempty"`        // Status of this version
  SwaggerUrl  *url.URL `json:"swagger_url,omitempty"`   // Url for swagger.json for this version
}


type BackupConfiguration struct {
  Can                  *map[string]bool `json:"can,omitempty"`                      // Operations the current user is able to perform on this object
  Type                 *string          `json:"type,omitempty"`                     // Type of backup: looker-s3 or custom-s3
  CustomS3Bucket       *string          `json:"custom_s3_bucket,omitempty"`         // Name of bucket for custom-s3 backups
  CustomS3BucketRegion *string          `json:"custom_s3_bucket_region,omitempty"`  // Name of region where the bucket is located
  CustomS3Key          *string          `json:"custom_s3_key,omitempty"`            // (Write-Only) AWS S3 key used for custom-s3 backups
  CustomS3Secret       *string          `json:"custom_s3_secret,omitempty"`         // (Write-Only) AWS S3 secret used for custom-s3 backups
  Url                  *url.URL         `json:"url,omitempty"`                      // Link to get this item
}

type CategoryType string
const CategoryType_Parameter CategoryType = "parameter"
const CategoryType_Filter    CategoryType = "filter"
const CategoryType_Measure   CategoryType = "measure"
const CategoryType_Dimension CategoryType = "dimension"



type ColorCollection struct {
  Id                  *string              `json:"id,omitempty"`                   // Unique Id
  Label               *string              `json:"label,omitempty"`                // Label of color collection
  CategoricalPalettes *[]DiscretePalette   `json:"categoricalPalettes,omitempty"`  // Array of categorical palette definitions
  SequentialPalettes  *[]ContinuousPalette `json:"sequentialPalettes,omitempty"`   // Array of discrete palette definitions
  DivergingPalettes   *[]ContinuousPalette `json:"divergingPalettes,omitempty"`    // Array of diverging palette definitions
}


type ColorStop struct {
  Color  *string `json:"color,omitempty"`   // CSS color string
  Offset *int64  `json:"offset,omitempty"`  // Offset in continuous palette (0 to 100)
}


type ContentFavorite struct {
  Id                *int64         `json:"id,omitempty"`                   // Unique Id
  UserId            *int64         `json:"user_id,omitempty"`              // User Id which owns this ContentFavorite
  ContentMetadataId *int64         `json:"content_metadata_id,omitempty"`  // Content Metadata Id associated with this ContentFavorite
  LookId            *int64         `json:"look_id,omitempty"`              // Id of a look
  DashboardId       *int64         `json:"dashboard_id,omitempty"`         // Id of a dashboard
  Look              *LookBasic     `json:"look,omitempty"`                
  Dashboard         *DashboardBase `json:"dashboard,omitempty"`           
  BoardId           *int64         `json:"board_id,omitempty"`             // Id of a board
}


type ContentMeta struct {
  Can          *map[string]bool `json:"can,omitempty"`            // Operations the current user is able to perform on this object
  Id           *int64           `json:"id,omitempty"`             // Unique Id
  Name         *string          `json:"name,omitempty"`           // Name or title of underlying content
  ParentId     *int64           `json:"parent_id,omitempty"`      // Id of Parent Content
  SpaceId      *string          `json:"space_id,omitempty"`       // Id of associated space when content_type is "space"
  FolderId     *string          `json:"folder_id,omitempty"`      // Id of associated folder when content_type is "space"
  DashboardId  *string          `json:"dashboard_id,omitempty"`   // Id of associated dashboard when content_type is "dashboard"
  LookId       *int64           `json:"look_id,omitempty"`        // Id of associated look when content_type is "look"
  ContentType  *string          `json:"content_type,omitempty"`   // Content Type ("dashboard", "look", or "space")
  Inherits     *bool            `json:"inherits,omitempty"`       // Whether content inherits its access levels from parent
  InheritingId *int64           `json:"inheriting_id,omitempty"`  // Id of Inherited Content
  Slug         *string          `json:"slug,omitempty"`           // Content Slug
}


type ContentMetaGroupUser struct {
  Can               *map[string]bool    `json:"can,omitempty"`                  // Operations the current user is able to perform on this object
  Id                *string             `json:"id,omitempty"`                   // Unique Id
  ContentMetadataId *string             `json:"content_metadata_id,omitempty"`  // Id of associated Content Metadata
  PermissionType    *PermissionTypeType `json:"permission_type,omitempty"`      // Type of permission: "view" or "edit" Valid values are: "view", "edit".
  GroupId           *int64              `json:"group_id,omitempty"`             // ID of associated group
  UserId            *int64              `json:"user_id,omitempty"`              // ID of associated user
}


type ContentValidation struct {
  ContentWithErrors               *[]ContentValidatorError `json:"content_with_errors,omitempty"`                 // A list of content errors
  ComputationTime                 *float32                 `json:"computation_time,omitempty"`                    // Duration of content validation in seconds
  TotalLooksValidated             *int64                   `json:"total_looks_validated,omitempty"`               // The number of looks validated
  TotalDashboardElementsValidated *int64                   `json:"total_dashboard_elements_validated,omitempty"`  // The number of dashboard elements validated
  TotalExploresValidated          *int64                   `json:"total_explores_validated,omitempty"`            // The number of explores used across all content validated
}


type ContentValidationDashboard struct {
  Description *string                  `json:"description,omitempty"`  // Description
  Id          *string                  `json:"id,omitempty"`           // Unique Id
  Space       *ContentValidationSpace  `json:"space,omitempty"`       
  Folder      *ContentValidationFolder `json:"folder,omitempty"`      
  Title       *string                  `json:"title,omitempty"`        // Dashboard Title
}


type ContentValidationDashboardElement struct {
  BodyText       *string `json:"body_text,omitempty"`          // Text tile body text
  DashboardId    *string `json:"dashboard_id,omitempty"`       // Id of Dashboard
  Id             *string `json:"id,omitempty"`                 // Unique Id
  LookId         *string `json:"look_id,omitempty"`            // Id Of Look
  NoteDisplay    *string `json:"note_display,omitempty"`       // Note Display
  NoteState      *string `json:"note_state,omitempty"`         // Note State
  NoteText       *string `json:"note_text,omitempty"`          // Note Text
  NoteTextAsHtml *string `json:"note_text_as_html,omitempty"`  // Note Text as Html
  QueryId        *int64  `json:"query_id,omitempty"`           // Id Of Query
  SubtitleText   *string `json:"subtitle_text,omitempty"`      // Text tile subtitle text
  Title          *string `json:"title,omitempty"`              // Title of dashboard element
  TitleHidden    *bool   `json:"title_hidden,omitempty"`       // Whether title is hidden
  TitleText      *string `json:"title_text,omitempty"`         // Text tile title
  Type           *string `json:"type,omitempty"`               // Type
}


type ContentValidationDashboardFilter struct {
  Id           *string `json:"id,omitempty"`             // Unique Id
  DashboardId  *string `json:"dashboard_id,omitempty"`   // Id of Dashboard
  Name         *string `json:"name,omitempty"`           // Name of filter
  Title        *string `json:"title,omitempty"`          // Title of filter
  Type         *string `json:"type,omitempty"`           // Type of filter: one of date, number, string, or field
  DefaultValue *string `json:"default_value,omitempty"`  // Default value of filter
  Model        *string `json:"model,omitempty"`          // Model of filter (required if type = field)
  Explore      *string `json:"explore,omitempty"`        // Explore of filter (required if type = field)
  Dimension    *string `json:"dimension,omitempty"`      // Dimension of filter (required if type = field)
}


type ContentValidationError struct {
  Message     *string `json:"message,omitempty"`       // Error message
  FieldName   *string `json:"field_name,omitempty"`    // Name of the field involved in the error
  ModelName   *string `json:"model_name,omitempty"`    // Name of the model involved in the error
  ExploreName *string `json:"explore_name,omitempty"`  // Name of the explore involved in the error
  Removable   *bool   `json:"removable,omitempty"`     // Whether this validation error is removable
}


type ContentValidationFolder struct {
  Name string  `json:"name"`          // Unique Name
  Id   *string `json:"id,omitempty"`  // Unique Id
}


type ContentValidationLook struct {
  Id     *int64                   `json:"id,omitempty"`      // Unique Id
  Title  *string                  `json:"title,omitempty"`   // Look Title
  Space  *ContentValidationSpace  `json:"space,omitempty"`  
  Folder *ContentValidationFolder `json:"folder,omitempty"` 
}


type ContentValidationSpace struct {
  Name string  `json:"name"`          // Unique Name
  Id   *string `json:"id,omitempty"`  // Unique Id
}


type ContentValidatorError struct {
  Look             *ContentValidationLook             `json:"look,omitempty"`              
  Dashboard        *ContentValidationDashboard        `json:"dashboard,omitempty"`         
  DashboardElement *ContentValidationDashboardElement `json:"dashboard_element,omitempty"` 
  DashboardFilter  *ContentValidationDashboardFilter  `json:"dashboard_filter,omitempty"`  
  Errors           *[]ContentValidationError          `json:"errors,omitempty"`             // A list of errors found for this piece of content
  Id               *string                            `json:"id,omitempty"`                 // An id unique to this piece of content for this validation run
}


type ContentView struct {
  Can               *map[string]bool `json:"can,omitempty"`                  // Operations the current user is able to perform on this object
  Id                *int64           `json:"id,omitempty"`                   // Unique Id
  LookId            *int64           `json:"look_id,omitempty"`              // Id of viewed Look
  DashboardId       *int64           `json:"dashboard_id,omitempty"`         // Id of the viewed Dashboard
  ContentMetadataId *int64           `json:"content_metadata_id,omitempty"`  // Content metadata id of the Look or Dashboard
  UserId            *int64           `json:"user_id,omitempty"`              // Id of user content was viewed by
  GroupId           *int64           `json:"group_id,omitempty"`             // Id of group content was viewed by
  ViewCount         *int64           `json:"view_count,omitempty"`           // Number of times piece of content was viewed
  FavoriteCount     *int64           `json:"favorite_count,omitempty"`       // Number of times piece of content was favorited
  LastViewedAt      *string          `json:"last_viewed_at,omitempty"`       // Date the piece of content was last viewed
  StartOfWeekDate   *string          `json:"start_of_week_date,omitempty"`   // Week start date for the view and favorite count during that given week
}


type ContinuousPalette struct {
  Id    *string      `json:"id,omitempty"`     // Unique identity string
  Label *string      `json:"label,omitempty"`  // Label for palette
  Type  *string      `json:"type,omitempty"`   // Type of palette
  Stops *[]ColorStop `json:"stops,omitempty"`  // Array of ColorStops in the palette
}


type CreateDashboardFilter struct {
  Id                  *string                 `json:"id,omitempty"`                     // Unique Id
  DashboardId         string                  `json:"dashboard_id"`                     // Id of Dashboard
  Name                string                  `json:"name"`                             // Name of filter
  Title               string                  `json:"title"`                            // Title of filter
  Type                string                  `json:"type"`                             // Type of filter: one of date, number, string, or field
  DefaultValue        *string                 `json:"default_value,omitempty"`          // Default value of filter
  Model               *string                 `json:"model,omitempty"`                  // Model of filter (required if type = field)
  Explore             *string                 `json:"explore,omitempty"`                // Explore of filter (required if type = field)
  Dimension           *string                 `json:"dimension,omitempty"`              // Dimension of filter (required if type = field)
  Field               *map[string]interface{} `json:"field,omitempty"`                  // Field information
  Row                 *int64                  `json:"row,omitempty"`                    // Display order of this filter relative to other filters
  ListensToFilters    *[]string               `json:"listens_to_filters,omitempty"`     // Array of listeners for faceted filters
  AllowMultipleValues *bool                   `json:"allow_multiple_values,omitempty"`  // Whether the filter allows multiple filter values
  Required            *bool                   `json:"required,omitempty"`               // Whether the filter requires a value to run the dashboard
  UiConfig            *map[string]interface{} `json:"ui_config,omitempty"`              // The visual configuration for this filter. Used to set up how the UI for this filter should appear.
}


type CreateDashboardRenderTask struct {
  DashboardFilters *string `json:"dashboard_filters,omitempty"`  // Filter values to apply to the dashboard queries, in URL query format
  DashboardStyle   *string `json:"dashboard_style,omitempty"`    // Dashboard layout style: single_column or tiled
}


type CreateFolder struct {
  Name     string `json:"name"`       // Unique Name
  ParentId string `json:"parent_id"`  // Id of Parent. If the parent id is null, this is a root-level entry
}


type CreateQueryTask struct {
  Can          *map[string]bool `json:"can,omitempty"`           // Operations the current user is able to perform on this object
  QueryId      int64            `json:"query_id"`                // Id of query to run
  ResultFormat ResultFormatType `json:"result_format"`           // Desired async query result format. Valid values are: "json", "json_detail", "json_fe", "csv", "html", "md", "txt", "xlsx", "gsxml".
  Source       *string          `json:"source,omitempty"`        // Source of query task
  Deferred     *bool            `json:"deferred,omitempty"`      // Create the task but defer execution
  LookId       *int64           `json:"look_id,omitempty"`       // Id of look associated with query.
  DashboardId  *string          `json:"dashboard_id,omitempty"`  // Id of dashboard associated with query.
}


type CreateSpace struct {
  Name     string `json:"name"`       // Unique Name
  ParentId string `json:"parent_id"`  // Id of Parent. If the parent id is null, this is a root-level entry
}


type CredentialsApi3 struct {
  Can        *map[string]bool `json:"can,omitempty"`          // Operations the current user is able to perform on this object
  Id         *int64           `json:"id,omitempty"`           // Unique Id
  ClientId   *string          `json:"client_id,omitempty"`    // API key client_id
  CreatedAt  *string          `json:"created_at,omitempty"`   // Timestamp for the creation of this credential
  IsDisabled *bool            `json:"is_disabled,omitempty"`  // Has this credential been disabled?
  Type       *string          `json:"type,omitempty"`         // Short name for the type of this kind of credential
  Url        *url.URL         `json:"url,omitempty"`          // Link to get this item
}


type CredentialsEmail struct {
  Can                            *map[string]bool `json:"can,omitempty"`                                  // Operations the current user is able to perform on this object
  CreatedAt                      *string          `json:"created_at,omitempty"`                           // Timestamp for the creation of this credential
  Email                          *string          `json:"email,omitempty"`                                // EMail address used for user login
  ForcedPasswordResetAtNextLogin *bool            `json:"forced_password_reset_at_next_login,omitempty"`  // Force the user to change their password upon their next login
  IsDisabled                     *bool            `json:"is_disabled,omitempty"`                          // Has this credential been disabled?
  LoggedInAt                     *string          `json:"logged_in_at,omitempty"`                         // Timestamp for most recent login using credential
  PasswordResetUrl               *string          `json:"password_reset_url,omitempty"`                   // Url with one-time use secret token that the user can use to reset password
  Type                           *string          `json:"type,omitempty"`                                 // Short name for the type of this kind of credential
  Url                            *url.URL         `json:"url,omitempty"`                                  // Link to get this item
  UserUrl                        *url.URL         `json:"user_url,omitempty"`                             // Link to get this user
}


type CredentialsEmbed struct {
  Can             *map[string]bool `json:"can,omitempty"`                // Operations the current user is able to perform on this object
  CreatedAt       *string          `json:"created_at,omitempty"`         // Timestamp for the creation of this credential
  ExternalGroupId *string          `json:"external_group_id,omitempty"`  // Embedder's id for a group to which this user was added during the most recent login
  ExternalUserId  *string          `json:"external_user_id,omitempty"`   // Embedder's unique id for the user
  Id              *int64           `json:"id,omitempty"`                 // Unique Id
  IsDisabled      *bool            `json:"is_disabled,omitempty"`        // Has this credential been disabled?
  LoggedInAt      *string          `json:"logged_in_at,omitempty"`       // Timestamp for most recent login using credential
  Type            *string          `json:"type,omitempty"`               // Short name for the type of this kind of credential
  Url             *url.URL         `json:"url,omitempty"`                // Link to get this item
}


type CredentialsGoogle struct {
  Can          *map[string]bool `json:"can,omitempty"`             // Operations the current user is able to perform on this object
  CreatedAt    *string          `json:"created_at,omitempty"`      // Timestamp for the creation of this credential
  Domain       *string          `json:"domain,omitempty"`          // Google domain
  Email        *string          `json:"email,omitempty"`           // EMail address
  GoogleUserId *string          `json:"google_user_id,omitempty"`  // Google's Unique ID for this user
  IsDisabled   *bool            `json:"is_disabled,omitempty"`     // Has this credential been disabled?
  LoggedInAt   *string          `json:"logged_in_at,omitempty"`    // Timestamp for most recent login using credential
  Type         *string          `json:"type,omitempty"`            // Short name for the type of this kind of credential
  Url          *url.URL         `json:"url,omitempty"`             // Link to get this item
}


type CredentialsLDAP struct {
  Can        *map[string]bool `json:"can,omitempty"`           // Operations the current user is able to perform on this object
  CreatedAt  *string          `json:"created_at,omitempty"`    // Timestamp for the creation of this credential
  Email      *string          `json:"email,omitempty"`         // EMail address
  IsDisabled *bool            `json:"is_disabled,omitempty"`   // Has this credential been disabled?
  LdapDn     *string          `json:"ldap_dn,omitempty"`       // LDAP Distinguished name for this user (as-of the last login)
  LdapId     *string          `json:"ldap_id,omitempty"`       // LDAP Unique ID for this user
  LoggedInAt *string          `json:"logged_in_at,omitempty"`  // Timestamp for most recent login using credential
  Type       *string          `json:"type,omitempty"`          // Short name for the type of this kind of credential
  Url        *url.URL         `json:"url,omitempty"`           // Link to get this item
}


type CredentialsLookerOpenid struct {
  Can        *map[string]bool `json:"can,omitempty"`           // Operations the current user is able to perform on this object
  CreatedAt  *string          `json:"created_at,omitempty"`    // Timestamp for the creation of this credential
  Email      *string          `json:"email,omitempty"`         // EMail address used for user login
  IsDisabled *bool            `json:"is_disabled,omitempty"`   // Has this credential been disabled?
  LoggedInAt *string          `json:"logged_in_at,omitempty"`  // Timestamp for most recent login using credential
  LoggedInIp *string          `json:"logged_in_ip,omitempty"`  // IP address of client for most recent login using credential
  Type       *string          `json:"type,omitempty"`          // Short name for the type of this kind of credential
  Url        *url.URL         `json:"url,omitempty"`           // Link to get this item
  UserUrl    *url.URL         `json:"user_url,omitempty"`      // Link to get this user
}


type CredentialsOIDC struct {
  Can        *map[string]bool `json:"can,omitempty"`           // Operations the current user is able to perform on this object
  CreatedAt  *string          `json:"created_at,omitempty"`    // Timestamp for the creation of this credential
  Email      *string          `json:"email,omitempty"`         // EMail address
  IsDisabled *bool            `json:"is_disabled,omitempty"`   // Has this credential been disabled?
  LoggedInAt *string          `json:"logged_in_at,omitempty"`  // Timestamp for most recent login using credential
  OidcUserId *string          `json:"oidc_user_id,omitempty"`  // OIDC OP's Unique ID for this user
  Type       *string          `json:"type,omitempty"`          // Short name for the type of this kind of credential
  Url        *url.URL         `json:"url,omitempty"`           // Link to get this item
}


type CredentialsSaml struct {
  Can        *map[string]bool `json:"can,omitempty"`           // Operations the current user is able to perform on this object
  CreatedAt  *string          `json:"created_at,omitempty"`    // Timestamp for the creation of this credential
  Email      *string          `json:"email,omitempty"`         // EMail address
  IsDisabled *bool            `json:"is_disabled,omitempty"`   // Has this credential been disabled?
  LoggedInAt *string          `json:"logged_in_at,omitempty"`  // Timestamp for most recent login using credential
  SamlUserId *string          `json:"saml_user_id,omitempty"`  // Saml IdP's Unique ID for this user
  Type       *string          `json:"type,omitempty"`          // Short name for the type of this kind of credential
  Url        *url.URL         `json:"url,omitempty"`           // Link to get this item
}


type CredentialsTotp struct {
  Can        *map[string]bool `json:"can,omitempty"`          // Operations the current user is able to perform on this object
  CreatedAt  *string          `json:"created_at,omitempty"`   // Timestamp for the creation of this credential
  IsDisabled *bool            `json:"is_disabled,omitempty"`  // Has this credential been disabled?
  Type       *string          `json:"type,omitempty"`         // Short name for the type of this kind of credential
  Verified   *bool            `json:"verified,omitempty"`     // User has verified
  Url        *url.URL         `json:"url,omitempty"`          // Link to get this item
}


type CustomWelcomeEmail struct {
  Can     *map[string]bool `json:"can,omitempty"`      // Operations the current user is able to perform on this object
  Enabled *bool            `json:"enabled,omitempty"`  // If true, custom email content will replace the default body of welcome emails
  Content *string          `json:"content,omitempty"`  // The HTML to use as custom content for welcome emails. Script elements and other potentially dangerous markup will be removed.
}


type Dashboard struct {
  Can                 *map[string]bool     `json:"can,omitempty"`                    // Operations the current user is able to perform on this object
  ContentFavoriteId   *int64               `json:"content_favorite_id,omitempty"`    // Content Favorite Id
  ContentMetadataId   *int64               `json:"content_metadata_id,omitempty"`    // Id of content metadata
  Description         *string              `json:"description,omitempty"`            // Description
  Hidden              *bool                `json:"hidden,omitempty"`                 // Is Hidden
  Id                  *string              `json:"id,omitempty"`                     // Unique Id
  Model               *LookModel           `json:"model,omitempty"`                 
  QueryTimezone       *string              `json:"query_timezone,omitempty"`         // Timezone in which the Dashboard will run by default.
  Readonly            *bool                `json:"readonly,omitempty"`               // Is Read-only
  RefreshInterval     *string              `json:"refresh_interval,omitempty"`       // Refresh Interval, as a time duration phrase like "2 hours 30 minutes". A number with no time units will be interpreted as whole seconds.
  RefreshIntervalToI  *int64               `json:"refresh_interval_to_i,omitempty"`  // Refresh Interval in milliseconds
  Space               *SpaceBase           `json:"space,omitempty"`                 
  Folder              *FolderBase          `json:"folder,omitempty"`                
  Title               *string              `json:"title,omitempty"`                  // Dashboard Title
  UserId              *int64               `json:"user_id,omitempty"`                // Id of User
  BackgroundColor     *string              `json:"background_color,omitempty"`       // Background color
  CreatedAt           *time.Time           `json:"created_at,omitempty"`             // Time that the Dashboard was created.
  CrossfilterEnabled  *bool                `json:"crossfilter_enabled,omitempty"`    // Enables crossfiltering in dashboards - only available in dashboards-next (beta)
  DashboardElements   *[]DashboardElement  `json:"dashboard_elements,omitempty"`     // Elements
  DashboardFilters    *[]DashboardFilter   `json:"dashboard_filters,omitempty"`      // Filters
  DashboardLayouts    *[]DashboardLayout   `json:"dashboard_layouts,omitempty"`      // Layouts
  Deleted             *bool                `json:"deleted,omitempty"`                // Whether or not a dashboard is 'soft' deleted.
  DeletedAt           *time.Time           `json:"deleted_at,omitempty"`             // Time that the Dashboard was 'soft' deleted.
  DeleterId           *int64               `json:"deleter_id,omitempty"`             // Id of User that 'soft' deleted the dashboard.
  EditUri             *url.URL             `json:"edit_uri,omitempty"`               // Relative path of URI of LookML file to edit the dashboard (LookML dashboard only).
  FavoriteCount       *int64               `json:"favorite_count,omitempty"`         // Number of times favorited
  LastAccessedAt      *time.Time           `json:"last_accessed_at,omitempty"`       // Time the dashboard was last accessed
  LastViewedAt        *time.Time           `json:"last_viewed_at,omitempty"`         // Time last viewed in the Looker web UI
  LoadConfiguration   *string              `json:"load_configuration,omitempty"`     // configuration option that governs how dashboard loading will happen.
  LookmlLinkId        *string              `json:"lookml_link_id,omitempty"`         // Links this dashboard to a particular LookML dashboard such that calling a **sync** operation on that LookML dashboard will update this dashboard to match.
  ShowFiltersBar      *bool                `json:"show_filters_bar,omitempty"`       // Show filters bar.  **Security Note:** This property only affects the *cosmetic* appearance of the dashboard, not a user's ability to access data. Hiding the filters bar does **NOT** prevent users from changing filters by other means. For information on how to set up secure data access control policies, see [Control User Access to Data](https://looker.com/docs/r/api/control-access)
  ShowTitle           *bool                `json:"show_title,omitempty"`             // Show title
  Slug                *string              `json:"slug,omitempty"`                   // Content Metadata Slug
  SpaceId             *string              `json:"space_id,omitempty"`               // Id of Space
  FolderId            *string              `json:"folder_id,omitempty"`              // Id of folder
  TextTileTextColor   *string              `json:"text_tile_text_color,omitempty"`   // Color of text on text tiles
  TileBackgroundColor *string              `json:"tile_background_color,omitempty"`  // Tile background color
  TileTextColor       *string              `json:"tile_text_color,omitempty"`        // Tile text color
  TitleColor          *string              `json:"title_color,omitempty"`            // Title color
  ViewCount           *int64               `json:"view_count,omitempty"`             // Number of times viewed in the Looker web UI
  Appearance          *DashboardAppearance `json:"appearance,omitempty"`            
  PreferredViewer     *string              `json:"preferred_viewer,omitempty"`       // The preferred route for viewing this dashboard (ie: dashboards or dashboards-next)
}


type DashboardAppearance struct {
  PageSideMargins     *int64  `json:"page_side_margins,omitempty"`      // Page margin (side) width
  PageBackgroundColor *string `json:"page_background_color,omitempty"`  // Background color for the dashboard
  TileTitleAlignment  *string `json:"tile_title_alignment,omitempty"`   // Title alignment on dashboard tiles
  TileSpaceBetween    *int64  `json:"tile_space_between,omitempty"`     // Space between tiles
  TileBackgroundColor *string `json:"tile_background_color,omitempty"`  // Background color for tiles
  TileShadow          *bool   `json:"tile_shadow,omitempty"`            // Tile shadow on/off
  KeyColor            *string `json:"key_color,omitempty"`              // Key color
}


type DashboardBase struct {
  Can                *map[string]bool `json:"can,omitempty"`                    // Operations the current user is able to perform on this object
  ContentFavoriteId  *int64           `json:"content_favorite_id,omitempty"`    // Content Favorite Id
  ContentMetadataId  *int64           `json:"content_metadata_id,omitempty"`    // Id of content metadata
  Description        *string          `json:"description,omitempty"`            // Description
  Hidden             *bool            `json:"hidden,omitempty"`                 // Is Hidden
  Id                 *string          `json:"id,omitempty"`                     // Unique Id
  Model              *LookModel       `json:"model,omitempty"`                 
  QueryTimezone      *string          `json:"query_timezone,omitempty"`         // Timezone in which the Dashboard will run by default.
  Readonly           *bool            `json:"readonly,omitempty"`               // Is Read-only
  RefreshInterval    *string          `json:"refresh_interval,omitempty"`       // Refresh Interval, as a time duration phrase like "2 hours 30 minutes". A number with no time units will be interpreted as whole seconds.
  RefreshIntervalToI *int64           `json:"refresh_interval_to_i,omitempty"`  // Refresh Interval in milliseconds
  Space              *SpaceBase       `json:"space,omitempty"`                 
  Folder             *FolderBase      `json:"folder,omitempty"`                
  Title              *string          `json:"title,omitempty"`                  // Dashboard Title
  UserId             *int64           `json:"user_id,omitempty"`                // Id of User
}


type DashboardElement struct {
  Can                *map[string]bool                            `json:"can,omitempty"`                    // Operations the current user is able to perform on this object
  BodyText           *string                                     `json:"body_text,omitempty"`              // Text tile body text
  BodyTextAsHtml     *string                                     `json:"body_text_as_html,omitempty"`      // Text tile body text as Html
  DashboardId        *string                                     `json:"dashboard_id,omitempty"`           // Id of Dashboard
  EditUri            *url.URL                                    `json:"edit_uri,omitempty"`               // Relative path of URI of LookML file to edit the dashboard element (LookML dashboard only).
  Id                 *string                                     `json:"id,omitempty"`                     // Unique Id
  Look               *LookWithQuery                              `json:"look,omitempty"`                  
  LookId             *string                                     `json:"look_id,omitempty"`                // Id Of Look
  LookmlLinkId       *string                                     `json:"lookml_link_id,omitempty"`         // LookML link ID
  MergeResultId      *string                                     `json:"merge_result_id,omitempty"`        // ID of merge result
  NoteDisplay        *string                                     `json:"note_display,omitempty"`           // Note Display
  NoteState          *string                                     `json:"note_state,omitempty"`             // Note State
  NoteText           *string                                     `json:"note_text,omitempty"`              // Note Text
  NoteTextAsHtml     *string                                     `json:"note_text_as_html,omitempty"`      // Note Text as Html
  Query              *Query                                      `json:"query,omitempty"`                 
  QueryId            *int64                                      `json:"query_id,omitempty"`               // Id Of Query
  RefreshInterval    *string                                     `json:"refresh_interval,omitempty"`       // Refresh Interval
  RefreshIntervalToI *int64                                      `json:"refresh_interval_to_i,omitempty"`  // Refresh Interval as integer
  ResultMaker        *ResultMakerWithIdVisConfigAndDynamicFields `json:"result_maker,omitempty"`          
  ResultMakerId      *int64                                      `json:"result_maker_id,omitempty"`        // ID of the ResultMakerLookup entry.
  SubtitleText       *string                                     `json:"subtitle_text,omitempty"`          // Text tile subtitle text
  Title              *string                                     `json:"title,omitempty"`                  // Title of dashboard element
  TitleHidden        *bool                                       `json:"title_hidden,omitempty"`           // Whether title is hidden
  TitleText          *string                                     `json:"title_text,omitempty"`             // Text tile title
  Type               *string                                     `json:"type,omitempty"`                   // Type
  AlertCount         *int64                                      `json:"alert_count,omitempty"`            // Count of Alerts associated to a dashboard element
  TitleTextAsHtml    *string                                     `json:"title_text_as_html,omitempty"`     // Text tile title text as Html
  SubtitleTextAsHtml *string                                     `json:"subtitle_text_as_html,omitempty"`  // Text tile subtitle text as Html
}


type DashboardFilter struct {
  Can                 *map[string]bool        `json:"can,omitempty"`                    // Operations the current user is able to perform on this object
  Id                  *string                 `json:"id,omitempty"`                     // Unique Id
  DashboardId         *string                 `json:"dashboard_id,omitempty"`           // Id of Dashboard
  Name                *string                 `json:"name,omitempty"`                   // Name of filter
  Title               *string                 `json:"title,omitempty"`                  // Title of filter
  Type                *string                 `json:"type,omitempty"`                   // Type of filter: one of date, number, string, or field
  DefaultValue        *string                 `json:"default_value,omitempty"`          // Default value of filter
  Model               *string                 `json:"model,omitempty"`                  // Model of filter (required if type = field)
  Explore             *string                 `json:"explore,omitempty"`                // Explore of filter (required if type = field)
  Dimension           *string                 `json:"dimension,omitempty"`              // Dimension of filter (required if type = field)
  Field               *map[string]interface{} `json:"field,omitempty"`                  // Field information
  Row                 *int64                  `json:"row,omitempty"`                    // Display order of this filter relative to other filters
  ListensToFilters    *[]string               `json:"listens_to_filters,omitempty"`     // Array of listeners for faceted filters
  AllowMultipleValues *bool                   `json:"allow_multiple_values,omitempty"`  // Whether the filter allows multiple filter values
  Required            *bool                   `json:"required,omitempty"`               // Whether the filter requires a value to run the dashboard
  UiConfig            *map[string]interface{} `json:"ui_config,omitempty"`              // The visual configuration for this filter. Used to set up how the UI for this filter should appear.
}


type DashboardLayout struct {
  Can                       *map[string]bool            `json:"can,omitempty"`                          // Operations the current user is able to perform on this object
  Id                        *string                     `json:"id,omitempty"`                           // Unique Id
  DashboardId               *string                     `json:"dashboard_id,omitempty"`                 // Id of Dashboard
  Type                      *string                     `json:"type,omitempty"`                         // Type
  Active                    *bool                       `json:"active,omitempty"`                       // Is Active
  ColumnWidth               *int64                      `json:"column_width,omitempty"`                 // Column Width
  Width                     *int64                      `json:"width,omitempty"`                        // Width
  Deleted                   *bool                       `json:"deleted,omitempty"`                      // Whether or not the dashboard layout is deleted.
  DashboardTitle            *string                     `json:"dashboard_title,omitempty"`              // Title extracted from the dashboard this layout represents.
  DashboardLayoutComponents *[]DashboardLayoutComponent `json:"dashboard_layout_components,omitempty"`  // Components
}


type DashboardLayoutComponent struct {
  Can                *map[string]bool `json:"can,omitempty"`                   // Operations the current user is able to perform on this object
  Id                 *string          `json:"id,omitempty"`                    // Unique Id
  DashboardLayoutId  *string          `json:"dashboard_layout_id,omitempty"`   // Id of Dashboard Layout
  DashboardElementId *string          `json:"dashboard_element_id,omitempty"`  // Id Of Dashboard Element
  Row                *int64           `json:"row,omitempty"`                   // Row
  Column             *int64           `json:"column,omitempty"`                // Column
  Width              *int64           `json:"width,omitempty"`                 // Width
  Height             *int64           `json:"height,omitempty"`                // Height
  Deleted            *bool            `json:"deleted,omitempty"`               // Whether or not the dashboard layout component is deleted
  ElementTitle       *string          `json:"element_title,omitempty"`         // Dashboard element title, extracted from the Dashboard Element.
  ElementTitleHidden *bool            `json:"element_title_hidden,omitempty"`  // Whether or not the dashboard element title is displayed.
  VisType            *string          `json:"vis_type,omitempty"`              // Visualization type, extracted from a query's vis_config
}


type DashboardLookml struct {
  DashboardId *string `json:"dashboard_id,omitempty"`  // Id of Dashboard
  Lookml      *string `json:"lookml,omitempty"`        // lookml of UDD
}


type DataActionForm struct {
  State  *DataActionUserState   `json:"state,omitempty"`  
  Fields *[]DataActionFormField `json:"fields,omitempty"`  // Array of form fields.
}


type DataActionFormField struct {
  Name        *string                       `json:"name,omitempty"`         // Name
  Label       *string                       `json:"label,omitempty"`        // Human-readable label
  Description *string                       `json:"description,omitempty"`  // Description of field
  Type        *string                       `json:"type,omitempty"`         // Type of field.
  Default     *string                       `json:"default,omitempty"`      // Default value of the field.
  OauthUrl    *string                       `json:"oauth_url,omitempty"`    // The URL for an oauth link, if type is 'oauth_link'.
  Interactive *bool                         `json:"interactive,omitempty"`  // Whether or not a field supports interactive forms.
  Required    *bool                         `json:"required,omitempty"`     // Whether or not the field is required. This is a user-interface hint. A user interface displaying this form should not submit it without a value for this field. The action server must also perform this validation.
  Options     *[]DataActionFormSelectOption `json:"options,omitempty"`      // If the form type is 'select', a list of options to be selected from.
}


type DataActionFormSelectOption struct {
  Name  *string `json:"name,omitempty"`   // Name
  Label *string `json:"label,omitempty"`  // Human-readable label
}


type DataActionRequest struct {
  Action     *map[string]interface{} `json:"action,omitempty"`       // The JSON describing the data action. This JSON should be considered opaque and should be passed through unmodified from the query result it came from.
  FormValues *map[string]interface{} `json:"form_values,omitempty"`  // User input for any form values the data action might use.
}


type DataActionResponse struct {
  WebhookId        *string          `json:"webhook_id,omitempty"`         // ID of the webhook event that sent this data action. In some error conditions, this may be null.
  Success          *bool            `json:"success,omitempty"`            // Whether the data action was successful.
  RefreshQuery     *bool            `json:"refresh_query,omitempty"`      // When true, indicates that the client should refresh (rerun) the source query because the data may have been changed by the action.
  ValidationErrors *ValidationError `json:"validation_errors,omitempty"` 
  Message          *string          `json:"message,omitempty"`            // Optional message returned by the data action server describing the state of the action that took place. This can be used to implement custom failure messages. If a failure is related to a particular form field, the server should send back a validation error instead. The Looker web UI does not currently display any message if the action indicates 'success', but may do so in the future.
}


type DataActionUserState struct {
  Data        *string `json:"data,omitempty"`          // User state data
  RefreshTime *int64  `json:"refresh_time,omitempty"`  // Time in seconds until the state needs to be refreshed
}


type Datagroup struct {
  Can            *map[string]bool `json:"can,omitempty"`               // Operations the current user is able to perform on this object
  CreatedAt      *int64           `json:"created_at,omitempty"`        // UNIX timestamp at which this entry was created.
  Id             *int64           `json:"id,omitempty"`                // Unique ID of the datagroup
  ModelName      *string          `json:"model_name,omitempty"`        // Name of the model containing the datagroup. Unique when combined with name.
  Name           *string          `json:"name,omitempty"`              // Name of the datagroup. Unique when combined with model_name.
  StaleBefore    *int64           `json:"stale_before,omitempty"`      // UNIX timestamp before which cache entries are considered stale. Cannot be in the future.
  TriggerCheckAt *int64           `json:"trigger_check_at,omitempty"`  // UNIX timestamp at which this entry trigger was last checked.
  TriggerError   *string          `json:"trigger_error,omitempty"`     // The message returned with the error of the last trigger check.
  TriggerValue   *string          `json:"trigger_value,omitempty"`     // The value of the trigger when last checked.
  TriggeredAt    *int64           `json:"triggered_at,omitempty"`      // UNIX timestamp at which this entry became triggered. Cannot be in the future.
}


type DBConnection struct {
  Can                     *map[string]bool      `json:"can,omitempty"`                         // Operations the current user is able to perform on this object
  Name                    *string               `json:"name,omitempty"`                        // Name of the connection. Also used as the unique identifier
  Dialect                 *Dialect              `json:"dialect,omitempty"`                    
  Snippets                *[]Snippet            `json:"snippets,omitempty"`                    // SQL Runner snippets for this connection
  Host                    *string               `json:"host,omitempty"`                        // Host name/address of server
  Port                    *int64                `json:"port,omitempty"`                        // Port number on server
  Username                *string               `json:"username,omitempty"`                    // Username for server authentication
  Password                *string               `json:"password,omitempty"`                    // (Write-Only) Password for server authentication
  UsesOauth               *bool                 `json:"uses_oauth,omitempty"`                  // Whether the connection uses OAuth for authentication.
  Certificate             *string               `json:"certificate,omitempty"`                 // (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
  FileType                *string               `json:"file_type,omitempty"`                   // (Write-Only) Certificate keyfile type - .json or .p12
  Database                *string               `json:"database,omitempty"`                    // Database name
  DbTimezone              *string               `json:"db_timezone,omitempty"`                 // Time zone of database
  QueryTimezone           *string               `json:"query_timezone,omitempty"`              // Timezone to use in queries
  Schema                  *string               `json:"schema,omitempty"`                      // Scheme name
  MaxConnections          *int64                `json:"max_connections,omitempty"`             // Maximum number of concurrent connection to use
  MaxBillingGigabytes     *string               `json:"max_billing_gigabytes,omitempty"`       // Maximum size of query in GBs (BigQuery only, can be a user_attribute name)
  Ssl                     *bool                 `json:"ssl,omitempty"`                         // Use SSL/TLS when connecting to server
  VerifySsl               *bool                 `json:"verify_ssl,omitempty"`                  // Verify the SSL
  TmpDbName               *string               `json:"tmp_db_name,omitempty"`                 // Name of temporary database (if used)
  JdbcAdditionalParams    *string               `json:"jdbc_additional_params,omitempty"`      // Additional params to add to JDBC connection string
  PoolTimeout             *int64                `json:"pool_timeout,omitempty"`                // Connection Pool Timeout, in seconds
  DialectName             *string               `json:"dialect_name,omitempty"`                // (Read/Write) SQL Dialect name
  CreatedAt               *string               `json:"created_at,omitempty"`                  // Creation date for this connection
  UserId                  *string               `json:"user_id,omitempty"`                     // Id of user who last modified this connection configuration
  Example                 *bool                 `json:"example,omitempty"`                     // Is this an example connection?
  UserDbCredentials       *bool                 `json:"user_db_credentials,omitempty"`         // (Limited access feature) Are per user db credentials enabled. Enabling will remove previously set username and password
  UserAttributeFields     *[]string             `json:"user_attribute_fields,omitempty"`       // Fields whose values map to user attribute names
  MaintenanceCron         *string               `json:"maintenance_cron,omitempty"`            // Cron string specifying when maintenance such as PDT trigger checks and drops should be performed
  LastRegenAt             *string               `json:"last_regen_at,omitempty"`               // Unix timestamp at start of last completed PDT trigger check process
  LastReapAt              *string               `json:"last_reap_at,omitempty"`                // Unix timestamp at start of last completed PDT reap process
  SqlRunnerPrecacheTables *bool                 `json:"sql_runner_precache_tables,omitempty"`  // Precache tables in the SQL Runner
  AfterConnectStatements  *string               `json:"after_connect_statements,omitempty"`    // SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
  PdtContextOverride      *DBConnectionOverride `json:"pdt_context_override,omitempty"`       
  Managed                 *bool                 `json:"managed,omitempty"`                     // Is this connection created and managed by Looker
}


type DBConnectionBase struct {
  Can      *map[string]bool `json:"can,omitempty"`       // Operations the current user is able to perform on this object
  Name     *string          `json:"name,omitempty"`      // Name of the connection. Also used as the unique identifier
  Dialect  *Dialect         `json:"dialect,omitempty"`  
  Snippets *[]Snippet       `json:"snippets,omitempty"`  // SQL Runner snippets for this connection
}


type DBConnectionOverride struct {
  Context                *string `json:"context,omitempty"`                   // Context in which to override (`pdt` is the only allowed value)
  Host                   *string `json:"host,omitempty"`                      // Host name/address of server
  Port                   *string `json:"port,omitempty"`                      // Port number on server
  Username               *string `json:"username,omitempty"`                  // Username for server authentication
  Password               *string `json:"password,omitempty"`                  // (Write-Only) Password for server authentication
  HasPassword            *bool   `json:"has_password,omitempty"`              // Whether or not the password is overridden in this context
  Certificate            *string `json:"certificate,omitempty"`               // (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
  FileType               *string `json:"file_type,omitempty"`                 // (Write-Only) Certificate keyfile type - .json or .p12
  Database               *string `json:"database,omitempty"`                  // Database name
  Schema                 *string `json:"schema,omitempty"`                    // Scheme name
  JdbcAdditionalParams   *string `json:"jdbc_additional_params,omitempty"`    // Additional params to add to JDBC connection string
  AfterConnectStatements *string `json:"after_connect_statements,omitempty"`  // SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
}


type DBConnectionTestResult struct {
  Can              *map[string]bool `json:"can,omitempty"`                // Operations the current user is able to perform on this object
  ConnectionString *string          `json:"connection_string,omitempty"`  // JDBC connection string. (only populated in the 'connect' test)
  Message          *string          `json:"message,omitempty"`            // Result message of test
  Name             *string          `json:"name,omitempty"`               // Name of test
  Status           *string          `json:"status,omitempty"`             // Result code of test
}


type DelegateOauthTest struct {
  Name                 *string `json:"name,omitempty"`                    // Delegate Oauth Connection Name
  InstallationTargetId *string `json:"installation_target_id,omitempty"`  // The ID of the installation target. For Slack, this would be workspace id.
  InstallationId       *int64  `json:"installation_id,omitempty"`         // Installation ID
  Success              *bool   `json:"success,omitempty"`                 // Whether or not the test was successful
}


type Dialect struct {
  Name                              *string   `json:"name,omitempty"`                                   // The name of the dialect
  Label                             *string   `json:"label,omitempty"`                                  // The human-readable label of the connection
  SupportsCostEstimate              *bool     `json:"supports_cost_estimate,omitempty"`                 // Whether the dialect supports query cost estimates
  PersistentTableIndexes            *string   `json:"persistent_table_indexes,omitempty"`               // PDT index columns
  PersistentTableSortkeys           *string   `json:"persistent_table_sortkeys,omitempty"`              // PDT sortkey columns
  PersistentTableDistkey            *string   `json:"persistent_table_distkey,omitempty"`               // PDT distkey column
  SupportsStreaming                 *bool     `json:"supports_streaming,omitempty"`                     // Suports streaming results
  AutomaticallyRunSqlRunnerSnippets *bool     `json:"automatically_run_sql_runner_snippets,omitempty"`  // Should SQL Runner snippets automatically be run
  ConnectionTests                   *[]string `json:"connection_tests,omitempty"`                       // Array of names of the tests that can be run on a connection using this dialect
  SupportsInducer                   *bool     `json:"supports_inducer,omitempty"`                       // Is supported with the inducer (i.e. generate from sql)
  SupportsMultipleDatabases         *bool     `json:"supports_multiple_databases,omitempty"`            // Can multiple databases be accessed from a connection using this dialect
  SupportsPersistentDerivedTables   *bool     `json:"supports_persistent_derived_tables,omitempty"`     // Whether the dialect supports allowing Looker to build persistent derived tables
  HasSslSupport                     *bool     `json:"has_ssl_support,omitempty"`                        // Does the database have client SSL support settable through the JDBC string explicitly?
}


type DialectInfo struct {
  Can                        *map[string]bool    `json:"can,omitempty"`                            // Operations the current user is able to perform on this object
  DefaultMaxConnections      *string             `json:"default_max_connections,omitempty"`        // Default number max connections
  DefaultPort                *string             `json:"default_port,omitempty"`                   // Default port number
  Installed                  *bool               `json:"installed,omitempty"`                      // Is the supporting driver installed
  Label                      *string             `json:"label,omitempty"`                          // The human-readable label of the connection
  LabelForDatabaseEquivalent *string             `json:"label_for_database_equivalent,omitempty"`  // What the dialect calls the equivalent of a normal SQL table
  Name                       *string             `json:"name,omitempty"`                           // The name of the dialect
  SupportedOptions           *DialectInfoOptions `json:"supported_options,omitempty"`             
}


type DialectInfoOptions struct {
  AdditionalParams *bool `json:"additional_params,omitempty"`  // Has additional params support
  Auth             *bool `json:"auth,omitempty"`               // Has auth support
  Host             *bool `json:"host,omitempty"`               // Has host support
  OauthCredentials *bool `json:"oauth_credentials,omitempty"`  // Has support for a service account
  ProjectName      *bool `json:"project_name,omitempty"`       // Has project name support
  Schema           *bool `json:"schema,omitempty"`             // Has schema support
  Ssl              *bool `json:"ssl,omitempty"`                // Has SSL support
  Timezone         *bool `json:"timezone,omitempty"`           // Has timezone support
  TmpTable         *bool `json:"tmp_table,omitempty"`          // Has tmp table support
  UsernameRequired *bool `json:"username_required,omitempty"`  // Username is required
}


type DigestEmails struct {
  IsEnabled *bool `json:"is_enabled,omitempty"`  // Whether or not digest emails are enabled
}


type DigestEmailSend struct {
  ConfigurationDelivered *bool `json:"configuration_delivered,omitempty"`  // True if content was successfully generated and delivered
}


type DiscretePalette struct {
  Id     *string   `json:"id,omitempty"`      // Unique identity string
  Label  *string   `json:"label,omitempty"`   // Label for palette
  Type   *string   `json:"type,omitempty"`    // Type of palette
  Colors *[]string `json:"colors,omitempty"`  // Array of colors in the palette
}


type EmbedSsoUrl struct {
  Url *url.URL `json:"url,omitempty"`  // The signed embed URL. Any modification to this string will invalidate the signature and make the URL unusable.
}


type EmbedSsoUrlParams struct {
  TargetUrl        url.URL                 `json:"target_url"`                    // The complete URL of the Looker UI page to display in the embed context. For example, to display the dashboard with id 34, `target_url` would look like: `https://mycompany.looker.com:9999/dashboards/34`. `target_uri` MUST contain a scheme (HTTPS), domain name, and URL path. Port must be included if it is required to reach the Looker server from browser clients. If the Looker instance is behind a load balancer or other proxy, `target_uri` must be the public-facing domain name and port required to reach the Looker instance, not the actual internal network machine name of the Looker instance.
  SessionLength    *int64                  `json:"session_length,omitempty"`      // Number of seconds the SSO embed session will be valid after the embed session is started. Defaults to 300 seconds. Maximum session length accepted is 2592000 seconds (30 days).
  ExternalUserId   *string                 `json:"external_user_id,omitempty"`    // A value from an external system that uniquely identifies the embed user. Since the user_ids of Looker embed users may change with every embed session, external_user_id provides a way to assign a known, stable user identifier across multiple embed sessions.
  ForceLogoutLogin *bool                   `json:"force_logout_login,omitempty"`  // When true, the embed session will purge any residual Looker login state (such as in browser cookies) before creating a new login state with the given embed user info. Defaults to true.
  FirstName        *string                 `json:"first_name,omitempty"`          // First name of the embed user. Defaults to 'Embed' if not specified
  LastName         *string                 `json:"last_name,omitempty"`           // Last name of the embed user. Defaults to 'User' if not specified
  UserTimezone     *string                 `json:"user_timezone,omitempty"`       // Sets the user timezone for the embed user session, if the User Specific Timezones setting is enabled in the Looker admin settings. A value of `null` forces the embed user to use the Looker Application Default Timezone. You MUST omit this property from the request if the User Specific Timezones setting is disabled. Timezone values are validated against the IANA Timezone standard and can be seen in the Application Time Zone dropdown list on the Looker General Settings admin page.
  Permissions      *[]string               `json:"permissions,omitempty"`         // List of Looker permission names to grant to the embed user. Requested permissions will be filtered to permissions allowed for embed sessions.
  Models           *[]string               `json:"models,omitempty"`              // List of model names that the embed user may access
  GroupIds         *[]int64                `json:"group_ids,omitempty"`           // List of Looker group ids in which to enroll the embed user
  ExternalGroupId  *int64                  `json:"external_group_id,omitempty"`   // A unique value identifying an embed-exclusive group. Multiple embed users using the same `external_group_id` value will be able to share Looker content with each other. Content and embed users associated with the `external_group_id` will not be accessible to normal Looker users or embed users not associated with this `external_group_id`.
  UserAttributes   *map[string]interface{} `json:"user_attributes,omitempty"`     // A dictionary of name-value pairs associating a Looker user attribute name with a value.
  SecretId         *int64                  `json:"secret_id,omitempty"`           // Id of the embed secret to use to sign this SSO url. If specified, the value must be an id of a valid (active) secret defined in the Looker instance. If not specified, the URL will be signed with the newest active embed secret defined in the Looker instance.
}


type Error struct {
  Message          string  `json:"message"`            // Error details
  DocumentationUrl url.URL `json:"documentation_url"`  // Documentation link
}

type FillStyleType string
const FillStyleType_Enumeration FillStyleType = "enumeration"
const FillStyleType_Range       FillStyleType = "range"



type Folder struct {
  Name                 string                `json:"name"`                              // Unique Name
  ParentId             *string               `json:"parent_id,omitempty"`               // Id of Parent. If the parent id is null, this is a root-level entry
  Id                   *string               `json:"id,omitempty"`                      // Unique Id
  ContentMetadataId    *int64                `json:"content_metadata_id,omitempty"`     // Id of content metadata
  CreatedAt            *time.Time            `json:"created_at,omitempty"`              // Time the space was created
  CreatorId            *int64                `json:"creator_id,omitempty"`              // User Id of Creator
  ChildCount           *int64                `json:"child_count,omitempty"`             // Children Count
  ExternalId           *string               `json:"external_id,omitempty"`             // Embedder's Id if this folder was autogenerated as an embedding shared folder via 'external_group_id' in an SSO embed login
  IsEmbed              *bool                 `json:"is_embed,omitempty"`                // Folder is an embed folder
  IsEmbedSharedRoot    *bool                 `json:"is_embed_shared_root,omitempty"`    // Folder is the root embed shared folder
  IsEmbedUsersRoot     *bool                 `json:"is_embed_users_root,omitempty"`     // Folder is the root embed users folder
  IsPersonal           *bool                 `json:"is_personal,omitempty"`             // Folder is a user's personal folder
  IsPersonalDescendant *bool                 `json:"is_personal_descendant,omitempty"`  // Folder is descendant of a user's personal folder
  IsSharedRoot         *bool                 `json:"is_shared_root,omitempty"`          // Folder is the root shared folder
  IsUsersRoot          *bool                 `json:"is_users_root,omitempty"`           // Folder is the root user folder
  Can                  *map[string]bool      `json:"can,omitempty"`                     // Operations the current user is able to perform on this object
  Dashboards           *[]DashboardBase      `json:"dashboards,omitempty"`              // Dashboards
  Looks                *[]LookWithDashboards `json:"looks,omitempty"`                   // Looks
}


type FolderBase struct {
  Name                 string           `json:"name"`                              // Unique Name
  ParentId             *string          `json:"parent_id,omitempty"`               // Id of Parent. If the parent id is null, this is a root-level entry
  Id                   *string          `json:"id,omitempty"`                      // Unique Id
  ContentMetadataId    *int64           `json:"content_metadata_id,omitempty"`     // Id of content metadata
  CreatedAt            *time.Time       `json:"created_at,omitempty"`              // Time the folder was created
  CreatorId            *int64           `json:"creator_id,omitempty"`              // User Id of Creator
  ChildCount           *int64           `json:"child_count,omitempty"`             // Children Count
  ExternalId           *string          `json:"external_id,omitempty"`             // Embedder's Id if this folder was autogenerated as an embedding shared folder via 'external_group_id' in an SSO embed login
  IsEmbed              *bool            `json:"is_embed,omitempty"`                // Folder is an embed folder
  IsEmbedSharedRoot    *bool            `json:"is_embed_shared_root,omitempty"`    // Folder is the root embed shared folder
  IsEmbedUsersRoot     *bool            `json:"is_embed_users_root,omitempty"`     // Folder is the root embed users folder
  IsPersonal           *bool            `json:"is_personal,omitempty"`             // Folder is a user's personal folder
  IsPersonalDescendant *bool            `json:"is_personal_descendant,omitempty"`  // Folder is descendant of a user's personal folder
  IsSharedRoot         *bool            `json:"is_shared_root,omitempty"`          // Folder is the root shared folder
  IsUsersRoot          *bool            `json:"is_users_root,omitempty"`           // Folder is the root user folder
  Can                  *map[string]bool `json:"can,omitempty"`                     // Operations the current user is able to perform on this object
}

type FormatType string
const FormatType_Topojson         FormatType = "topojson"
const FormatType_VectorTileRegion FormatType = "vector_tile_region"



type GitBranch struct {
  Can          *map[string]bool `json:"can,omitempty"`            // Operations the current user is able to perform on this object
  Name         *string          `json:"name,omitempty"`           // The short name on the local. Updating `name` results in `git checkout <new_name>`
  Remote       *string          `json:"remote,omitempty"`         // The name of the remote
  RemoteName   *string          `json:"remote_name,omitempty"`    // The short name on the remote
  Error        *string          `json:"error,omitempty"`          // Name of error
  Message      *string          `json:"message,omitempty"`        // Message describing an error if present
  OwnerName    *string          `json:"owner_name,omitempty"`     // Name of the owner of a personal branch
  Readonly     *bool            `json:"readonly,omitempty"`       // Whether or not this branch is readonly
  Personal     *bool            `json:"personal,omitempty"`       // Whether or not this branch is a personal branch - readonly for all developers except the owner
  IsLocal      *bool            `json:"is_local,omitempty"`       // Whether or not a local ref exists for the branch
  IsRemote     *bool            `json:"is_remote,omitempty"`      // Whether or not a remote ref exists for the branch
  IsProduction *bool            `json:"is_production,omitempty"`  // Whether or not this is the production branch
  AheadCount   *int64           `json:"ahead_count,omitempty"`    // Number of commits the local branch is ahead of the remote
  BehindCount  *int64           `json:"behind_count,omitempty"`   // Number of commits the local branch is behind the remote
  CommitAt     *int64           `json:"commit_at,omitempty"`      // UNIX timestamp at which this branch was last committed.
  Ref          *string          `json:"ref,omitempty"`            // The resolved ref of this branch. Updating `ref` results in `git reset --hard <new_ref>``.
  RemoteRef    *string          `json:"remote_ref,omitempty"`     // The resolved ref of this branch remote.
}


type GitConnectionTest struct {
  Can         *map[string]bool `json:"can,omitempty"`          // Operations the current user is able to perform on this object
  Description *string          `json:"description,omitempty"`  // Human readable string describing the test
  Id          *string          `json:"id,omitempty"`           // A short string, uniquely naming this test
}


type GitConnectionTestResult struct {
  Can     *map[string]bool `json:"can,omitempty"`      // Operations the current user is able to perform on this object
  Id      *string          `json:"id,omitempty"`       // A short string, uniquely naming this test
  Message *string          `json:"message,omitempty"`  // Additional data from the test
  Status  *string          `json:"status,omitempty"`   // Either 'pass' or 'fail'
}


type GitStatus struct {
  Action     *string `json:"action,omitempty"`      // Git action: add, delete, etc
  Conflict   *bool   `json:"conflict,omitempty"`    // When true, changes to the local file conflict with the remote repository
  Revertable *bool   `json:"revertable,omitempty"`  // When true, the file can be reverted to an earlier state
  Text       *string `json:"text,omitempty"`        // Git description of the action
}


type Group struct {
  Can                     *map[string]bool `json:"can,omitempty"`                          // Operations the current user is able to perform on this object
  CanAddToContentMetadata *bool            `json:"can_add_to_content_metadata,omitempty"`  // Group can be used in content access controls
  ContainsCurrentUser     *bool            `json:"contains_current_user,omitempty"`        // Currently logged in user is group member
  ExternalGroupId         *string          `json:"external_group_id,omitempty"`            // External Id group if embed group
  ExternallyManaged       *bool            `json:"externally_managed,omitempty"`           // Group membership controlled outside of Looker
  Id                      *int64           `json:"id,omitempty"`                           // Unique Id
  IncludeByDefault        *bool            `json:"include_by_default,omitempty"`           // New users are added to this group by default
  Name                    *string          `json:"name,omitempty"`                         // Name of group
  UserCount               *int64           `json:"user_count,omitempty"`                   // Number of users included in this group
}


type GroupIdForGroupInclusion struct {
  GroupId *int64 `json:"group_id,omitempty"`  // Id of group
}


type GroupIdForGroupUserInclusion struct {
  UserId *int64 `json:"user_id,omitempty"`  // Id of user
}


type Homepage struct {
  Can               *map[string]bool   `json:"can,omitempty"`                  // Operations the current user is able to perform on this object
  ContentMetadataId *int64             `json:"content_metadata_id,omitempty"`  // Id of associated content_metadata record
  CreatedAt         *time.Time         `json:"created_at,omitempty"`           // Date of homepage creatopm
  DeletedAt         *time.Time         `json:"deleted_at,omitempty"`           // Date of homepage deletion
  Description       *string            `json:"description,omitempty"`          // Description of homepage
  HomepageSections  *[]HomepageSection `json:"homepage_sections,omitempty"`    // Sections of the homepage
  Id                *int64             `json:"id,omitempty"`                   // Unique Id
  SectionOrder      *[]int64           `json:"section_order,omitempty"`        // ids of the homepage sections in the order they should be displayed
  Title             *string            `json:"title,omitempty"`                // Title of homepage
  UpdatedAt         *time.Time         `json:"updated_at,omitempty"`           // Date of last homepage update
  UserId            *int64             `json:"user_id,omitempty"`              // User id of homepage creator
  PrimaryHomepage   *bool              `json:"primary_homepage,omitempty"`     // Whether the homepage is the primary homepage or not
}


type HomepageItem struct {
  Can                   *map[string]bool `json:"can,omitempty"`                       // Operations the current user is able to perform on this object
  ContentCreatedBy      *string          `json:"content_created_by,omitempty"`        // Name of user who created the content this item is based on
  ContentFavoriteId     *int64           `json:"content_favorite_id,omitempty"`       // Content favorite id associated with the item this content is based on
  ContentMetadataId     *int64           `json:"content_metadata_id,omitempty"`       // Content metadata id associated with the item this content is based on
  ContentUpdatedAt      *string          `json:"content_updated_at,omitempty"`        // Last time the content that this item is based on was updated
  CustomDescription     *string          `json:"custom_description,omitempty"`        // Custom description entered by the user, if present
  CustomImageDataBase64 *string          `json:"custom_image_data_base64,omitempty"`  // (Write-Only) base64 encoded image data
  CustomImageUrl        *string          `json:"custom_image_url,omitempty"`          // Custom image_url entered by the user, if present
  CustomTitle           *string          `json:"custom_title,omitempty"`              // Custom title entered by the user, if present
  CustomUrl             *string          `json:"custom_url,omitempty"`                // Custom url entered by the user, if present
  DashboardId           *int64           `json:"dashboard_id,omitempty"`              // Dashboard to base this item on
  Description           *string          `json:"description,omitempty"`               // The actual description for display
  FavoriteCount         *int64           `json:"favorite_count,omitempty"`            // Number of times content has been favorited, if present
  HomepageSectionId     *int64           `json:"homepage_section_id,omitempty"`       // Associated Homepage Section
  Id                    *int64           `json:"id,omitempty"`                        // Unique Id
  ImageUrl              *string          `json:"image_url,omitempty"`                 // The actual image_url for display
  Location              *string          `json:"location,omitempty"`                  // The container folder name of the content
  LookId                *int64           `json:"look_id,omitempty"`                   // Look to base this item on
  LookmlDashboardId     *string          `json:"lookml_dashboard_id,omitempty"`       // LookML Dashboard to base this item on
  Order                 *int64           `json:"order,omitempty"`                     // An arbitrary integer representing the sort order within the section
  SectionFetchTime      *float32         `json:"section_fetch_time,omitempty"`        // Number of seconds it took to fetch the section this item is in
  Title                 *string          `json:"title,omitempty"`                     // The actual title for display
  Url                   *string          `json:"url,omitempty"`                       // The actual url for display
  UseCustomDescription  *bool            `json:"use_custom_description,omitempty"`    // Whether the custom description should be used instead of the content description, if the item is associated with content
  UseCustomImage        *bool            `json:"use_custom_image,omitempty"`          // Whether the custom image should be used instead of the content image, if the item is associated with content
  UseCustomTitle        *bool            `json:"use_custom_title,omitempty"`          // Whether the custom title should be used instead of the content title, if the item is associated with content
  UseCustomUrl          *bool            `json:"use_custom_url,omitempty"`            // Whether the custom url should be used instead of the content url, if the item is associated with content
  ViewCount             *int64           `json:"view_count,omitempty"`                // Number of times content has been viewed, if present
}


type HomepageSection struct {
  Can           *map[string]bool `json:"can,omitempty"`             // Operations the current user is able to perform on this object
  CreatedAt     *time.Time       `json:"created_at,omitempty"`      // Time at which this section was created.
  DeletedAt     *time.Time       `json:"deleted_at,omitempty"`      // Time at which this section was deleted.
  DetailUrl     *string          `json:"detail_url,omitempty"`      // A URL pointing to a page showing further information about the content in the section.
  HomepageId    *int64           `json:"homepage_id,omitempty"`     // Id reference to parent homepage
  HomepageItems *[]HomepageItem  `json:"homepage_items,omitempty"`  // Items in the homepage section
  Id            *int64           `json:"id,omitempty"`              // Unique Id
  IsHeader      *bool            `json:"is_header,omitempty"`       // Is this a header section (has no items)
  ItemOrder     *[]int64         `json:"item_order,omitempty"`      // ids of the homepage items in the order they should be displayed
  Title         *string          `json:"title,omitempty"`           // Name of row
  UpdatedAt     *time.Time       `json:"updated_at,omitempty"`      // Time at which this section was last updated.
  Description   *string          `json:"description,omitempty"`     // Description of the content found in this section.
}


type ImportedProject struct {
  Name     *string `json:"name,omitempty"`       // Dependency name
  Url      *string `json:"url,omitempty"`        // Url for a remote dependency
  Ref      *string `json:"ref,omitempty"`        // Ref for a remote dependency
  IsRemote *bool   `json:"is_remote,omitempty"`  // Flag signifying if a dependency is remote or local
}


type Integration struct {
  Can                               *map[string]bool                       `json:"can,omitempty"`                                  // Operations the current user is able to perform on this object
  Id                                *string                                `json:"id,omitempty"`                                   // ID of the integration.
  IntegrationHubId                  *int64                                 `json:"integration_hub_id,omitempty"`                   // ID of the integration hub.
  Label                             *string                                `json:"label,omitempty"`                                // Label for the integration.
  Description                       *string                                `json:"description,omitempty"`                          // Description of the integration.
  Enabled                           *bool                                  `json:"enabled,omitempty"`                              // Whether the integration is available to users.
  Params                            *[]IntegrationParam                    `json:"params,omitempty"`                               // Array of params for the integration.
  SupportedFormats                  *SupportedFormatsType                  `json:"supported_formats,omitempty"`                    // A list of data formats the integration supports. If unspecified, the default is all data formats. Valid values are: "txt", "csv", "inline_json", "json", "json_label", "json_detail", "json_detail_lite_stream", "xlsx", "html", "wysiwyg_pdf", "assembled_pdf", "wysiwyg_png", "csv_zip".
  SupportedActionTypes              *SupportedActionTypesType              `json:"supported_action_types,omitempty"`               // A list of action types the integration supports. Valid values are: "cell", "query", "dashboard".
  SupportedFormattings              *SupportedFormattingsType              `json:"supported_formattings,omitempty"`                // A list of formatting options the integration supports. If unspecified, defaults to all formats. Valid values are: "formatted", "unformatted".
  SupportedVisualizationFormattings *SupportedVisualizationFormattingsType `json:"supported_visualization_formattings,omitempty"`  // A list of visualization formatting options the integration supports. If unspecified, defaults to all formats. Valid values are: "apply", "noapply".
  SupportedDownloadSettings         *SupportedDownloadSettingsType         `json:"supported_download_settings,omitempty"`          // A list of all the download mechanisms the integration supports. The order of values is not significant: Looker will select the most appropriate supported download mechanism for a given query. The integration must ensure it can handle any of the mechanisms it claims to support. If unspecified, this defaults to all download setting values. Valid values are: "push", "url".
  IconUrl                           *string                                `json:"icon_url,omitempty"`                             // URL to an icon for the integration.
  UsesOauth                         *bool                                  `json:"uses_oauth,omitempty"`                           // Whether the integration uses oauth.
  RequiredFields                    *[]IntegrationRequiredField            `json:"required_fields,omitempty"`                      // A list of descriptions of required fields that this integration is compatible with. If there are multiple entries in this list, the integration requires more than one field. If unspecified, no fields will be required.
  DelegateOauth                     *bool                                  `json:"delegate_oauth,omitempty"`                       // Whether the integration uses delegate oauth, which allows federation between an integration installation scope specific entity (like org, group, and team, etc.) and Looker.
  InstalledDelegateOauthTargets     *[]int64                               `json:"installed_delegate_oauth_targets,omitempty"`     // Whether the integration is available to users.
}


type IntegrationHub struct {
  Can                    *map[string]bool `json:"can,omitempty"`                       // Operations the current user is able to perform on this object
  Id                     *int64           `json:"id,omitempty"`                        // ID of the hub.
  Url                    *string          `json:"url,omitempty"`                       // URL of the hub.
  Label                  *string          `json:"label,omitempty"`                     // Label of the hub.
  Official               *bool            `json:"official,omitempty"`                  // Whether this hub is a first-party integration hub operated by Looker.
  FetchErrorMessage      *string          `json:"fetch_error_message,omitempty"`       // An error message, present if the integration hub metadata could not be fetched. If this is present, the integration hub is unusable.
  AuthorizationToken     *string          `json:"authorization_token,omitempty"`       // (Write-Only) An authorization key that will be sent to the integration hub on every request.
  HasAuthorizationToken  *bool            `json:"has_authorization_token,omitempty"`   // Whether the authorization_token is set for the hub.
  LegalAgreementSigned   *bool            `json:"legal_agreement_signed,omitempty"`    // Whether the legal agreement message has been signed by the user. This only matters if legal_agreement_required is true.
  LegalAgreementRequired *bool            `json:"legal_agreement_required,omitempty"`  // Whether the legal terms for the integration hub are required before use.
  LegalAgreementText     *string          `json:"legal_agreement_text,omitempty"`      // The legal agreement text for this integration hub.
}


type IntegrationParam struct {
  Name              *string `json:"name,omitempty"`                 // Name of the parameter.
  Label             *string `json:"label,omitempty"`                // Label of the parameter.
  Description       *string `json:"description,omitempty"`          // Short description of the parameter.
  Required          *bool   `json:"required,omitempty"`             // Whether the parameter is required to be set to use the destination. If unspecified, this defaults to false.
  HasValue          *bool   `json:"has_value,omitempty"`            // Whether the parameter has a value set.
  Value             *string `json:"value,omitempty"`                // The current value of the parameter. Always null if the value is sensitive. When writing, null values will be ignored. Set the value to an empty string to clear it.
  UserAttributeName *string `json:"user_attribute_name,omitempty"`  // When present, the param's value comes from this user attribute instead of the 'value' parameter. Set to null to use the 'value'.
  Sensitive         *bool   `json:"sensitive,omitempty"`            // Whether the parameter contains sensitive data like API credentials. If unspecified, this defaults to true.
  PerUser           *bool   `json:"per_user,omitempty"`             // When true, this parameter must be assigned to a user attribute in the admin panel (instead of a constant value), and that value may be updated by the user as part of the integration flow.
  DelegateOauthUrl  *string `json:"delegate_oauth_url,omitempty"`   // When present, the param represents the oauth url the user will be taken to.
}


type IntegrationRequiredField struct {
  Tag     *string   `json:"tag,omitempty"`       // Matches a field that has this tag.
  AnyTag  *[]string `json:"any_tag,omitempty"`   // If present, supercedes 'tag' and matches a field that has any of the provided tags.
  AllTags *[]string `json:"all_tags,omitempty"`  // If present, supercedes 'tag' and matches a field that has all of the provided tags.
}


type IntegrationTestResult struct {
  Success             *bool                `json:"success,omitempty"`                // Whether or not the test was successful
  Message             *string              `json:"message,omitempty"`                // A message representing the results of the test.
  DelegateOauthResult *[]DelegateOauthTest `json:"delegate_oauth_result,omitempty"`  // An array of connection test result for delegate oauth actions.
}


type InternalHelpResources struct {
  Can     *map[string]bool `json:"can,omitempty"`      // Operations the current user is able to perform on this object
  Enabled *bool            `json:"enabled,omitempty"`  // If true and internal help resources content is not blank then the link for internal help resources will be shown in the help menu and the content displayed within Looker
}


type InternalHelpResourcesContent struct {
  Can              *map[string]bool `json:"can,omitempty"`                // Operations the current user is able to perform on this object
  OrganizationName *string          `json:"organization_name,omitempty"`  // Text to display in the help menu item which will display the internal help resources
  MarkdownContent  *string          `json:"markdown_content,omitempty"`   // Content to be displayed in the internal help resources page/modal
}


type LDAPConfig struct {
  Can                        *map[string]bool          `json:"can,omitempty"`                            // Operations the current user is able to perform on this object
  AlternateEmailLoginAllowed *bool                     `json:"alternate_email_login_allowed,omitempty"`  // Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
  AuthPassword               *string                   `json:"auth_password,omitempty"`                  // (Write-Only)  Password for the LDAP account used to access the LDAP server
  AuthRequiresRole           *bool                     `json:"auth_requires_role,omitempty"`             // Users will not be allowed to login at all unless a role for them is found in LDAP if set to true
  AuthUsername               *string                   `json:"auth_username,omitempty"`                  // Distinguished name of LDAP account used to access the LDAP server
  ConnectionHost             *string                   `json:"connection_host,omitempty"`                // LDAP server hostname
  ConnectionPort             *string                   `json:"connection_port,omitempty"`                // LDAP host port
  ConnectionTls              *bool                     `json:"connection_tls,omitempty"`                 // Use Transport Layer Security
  ConnectionTlsNoVerify      *bool                     `json:"connection_tls_no_verify,omitempty"`       // Do not verify peer when using TLS
  DefaultNewUserGroupIds     *[]int64                  `json:"default_new_user_group_ids,omitempty"`     // (Write-Only)  Array of ids of groups that will be applied to new users the first time they login via LDAP
  DefaultNewUserGroups       *[]Group                  `json:"default_new_user_groups,omitempty"`        // (Read-only) Groups that will be applied to new users the first time they login via LDAP
  DefaultNewUserRoleIds      *[]int64                  `json:"default_new_user_role_ids,omitempty"`      // (Write-Only)  Array of ids of roles that will be applied to new users the first time they login via LDAP
  DefaultNewUserRoles        *[]Role                   `json:"default_new_user_roles,omitempty"`         // (Read-only) Roles that will be applied to new users the first time they login via LDAP
  Enabled                    *bool                     `json:"enabled,omitempty"`                        // Enable/Disable LDAP authentication for the server
  ForceNoPage                *bool                     `json:"force_no_page,omitempty"`                  // Don't attempt to do LDAP search result paging (RFC 2696) even if the LDAP server claims to support it.
  Groups                     *[]LDAPGroupRead          `json:"groups,omitempty"`                         // (Read-only) Array of mappings between LDAP Groups and Looker Roles
  GroupsBaseDn               *string                   `json:"groups_base_dn,omitempty"`                 // Base dn for finding groups in LDAP searches
  GroupsFinderType           *string                   `json:"groups_finder_type,omitempty"`             // Identifier for a strategy for how Looker will search for groups in the LDAP server
  GroupsMemberAttribute      *string                   `json:"groups_member_attribute,omitempty"`        // LDAP Group attribute that signifies the members of the groups. Most commonly 'member'
  GroupsObjectclasses        *string                   `json:"groups_objectclasses,omitempty"`           // Optional comma-separated list of supported LDAP objectclass for groups when doing groups searches
  GroupsUserAttribute        *string                   `json:"groups_user_attribute,omitempty"`          // LDAP Group attribute that signifies the user in a group. Most commonly 'dn'
  GroupsWithRoleIds          *[]LDAPGroupWrite         `json:"groups_with_role_ids,omitempty"`           // (Read/Write) Array of mappings between LDAP Groups and arrays of Looker Role ids
  HasAuthPassword            *bool                     `json:"has_auth_password,omitempty"`              // (Read-only) Has the password been set for the LDAP account used to access the LDAP server
  MergeNewUsersByEmail       *bool                     `json:"merge_new_users_by_email,omitempty"`       // Merge first-time ldap login to existing user account by email addresses. When a user logs in for the first time via ldap this option will connect this user into their existing account by finding the account with a matching email address. Otherwise a new user account will be created for the user.
  ModifiedAt                 *string                   `json:"modified_at,omitempty"`                    // When this config was last modified
  ModifiedBy                 *string                   `json:"modified_by,omitempty"`                    // User id of user who last modified this config
  SetRolesFromGroups         *bool                     `json:"set_roles_from_groups,omitempty"`          // Set user roles in Looker based on groups from LDAP
  TestLdapPassword           *string                   `json:"test_ldap_password,omitempty"`             // (Write-Only)  Test LDAP user password. For ldap tests only.
  TestLdapUser               *string                   `json:"test_ldap_user,omitempty"`                 // (Write-Only)  Test LDAP user login id. For ldap tests only.
  UserAttributeMapEmail      *string                   `json:"user_attribute_map_email,omitempty"`       // Name of user record attributes used to indicate email address field
  UserAttributeMapFirstName  *string                   `json:"user_attribute_map_first_name,omitempty"`  // Name of user record attributes used to indicate first name
  UserAttributeMapLastName   *string                   `json:"user_attribute_map_last_name,omitempty"`   // Name of user record attributes used to indicate last name
  UserAttributeMapLdapId     *string                   `json:"user_attribute_map_ldap_id,omitempty"`     // Name of user record attributes used to indicate unique record id
  UserAttributes             *[]LDAPUserAttributeRead  `json:"user_attributes,omitempty"`                // (Read-only) Array of mappings between LDAP User Attributes and Looker User Attributes
  UserAttributesWithIds      *[]LDAPUserAttributeWrite `json:"user_attributes_with_ids,omitempty"`       // (Read/Write) Array of mappings between LDAP User Attributes and arrays of Looker User Attribute ids
  UserBindBaseDn             *string                   `json:"user_bind_base_dn,omitempty"`              // Distinguished name of LDAP node used as the base for user searches
  UserCustomFilter           *string                   `json:"user_custom_filter,omitempty"`             // (Optional) Custom RFC-2254 filter clause for use in finding user during login. Combined via 'and' with the other generated filter clauses.
  UserIdAttributeNames       *string                   `json:"user_id_attribute_names,omitempty"`        // Name(s) of user record attributes used for matching user login id (comma separated list)
  UserObjectclass            *string                   `json:"user_objectclass,omitempty"`               // (Optional) Name of user record objectclass used for finding user during login id
  Url                        *url.URL                  `json:"url,omitempty"`                            // Link to get this item
}


type LDAPConfigTestIssue struct {
  Severity *string `json:"severity,omitempty"`  // Severity of the issue. Error or Warning
  Message  *string `json:"message,omitempty"`   // Message describing the issue
}


type LDAPConfigTestResult struct {
  Details *string                `json:"details,omitempty"`  // Additional details for error cases
  Issues  *[]LDAPConfigTestIssue `json:"issues,omitempty"`   // Array of issues/considerations about the result
  Message *string                `json:"message,omitempty"`  // Short human readable test about the result
  Status  *string                `json:"status,omitempty"`   // Test status code: always 'success' or 'error'
  Trace   *string                `json:"trace,omitempty"`    // A more detailed trace of incremental results during auth tests
  User    *LDAPUser              `json:"user,omitempty"`    
  Url     *url.URL               `json:"url,omitempty"`      // Link to ldap config
}


type LDAPGroupRead struct {
  Id              *int64   `json:"id,omitempty"`                 // Unique Id
  LookerGroupId   *int64   `json:"looker_group_id,omitempty"`    // Unique Id of group in Looker
  LookerGroupName *string  `json:"looker_group_name,omitempty"`  // Name of group in Looker
  Name            *string  `json:"name,omitempty"`               // Name of group in LDAP
  Roles           *[]Role  `json:"roles,omitempty"`              // Looker Roles
  Url             *url.URL `json:"url,omitempty"`                // Link to ldap config
}


type LDAPGroupWrite struct {
  Id              *int64   `json:"id,omitempty"`                 // Unique Id
  LookerGroupId   *int64   `json:"looker_group_id,omitempty"`    // Unique Id of group in Looker
  LookerGroupName *string  `json:"looker_group_name,omitempty"`  // Name of group in Looker
  Name            *string  `json:"name,omitempty"`               // Name of group in LDAP
  RoleIds         *[]int64 `json:"role_ids,omitempty"`           // Looker Role Ids
  Url             *url.URL `json:"url,omitempty"`                // Link to ldap config
}


type LDAPUser struct {
  AllEmails  *[]string               `json:"all_emails,omitempty"`  // Array of user's email addresses and aliases for use in migration
  Attributes *map[string]interface{} `json:"attributes,omitempty"`  // Dictionary of user's attributes (name/value)
  Email      *string                 `json:"email,omitempty"`       // Primary email address
  FirstName  *string                 `json:"first_name,omitempty"`  // First name
  Groups     *[]string               `json:"groups,omitempty"`      // Array of user's groups (group names only)
  LastName   *string                 `json:"last_name,omitempty"`   // Last Name
  LdapDn     *string                 `json:"ldap_dn,omitempty"`     // LDAP's distinguished name for the user record
  LdapId     *string                 `json:"ldap_id,omitempty"`     // LDAP's Unique ID for the user
  Roles      *[]string               `json:"roles,omitempty"`       // Array of user's roles (role names only)
  Url        *url.URL                `json:"url,omitempty"`         // Link to ldap config
}


type LDAPUserAttributeRead struct {
  Name           *string          `json:"name,omitempty"`             // Name of User Attribute in LDAP
  Required       *bool            `json:"required,omitempty"`         // Required to be in LDAP assertion for login to be allowed to succeed
  UserAttributes *[]UserAttribute `json:"user_attributes,omitempty"`  // Looker User Attributes
  Url            *url.URL         `json:"url,omitempty"`              // Link to ldap config
}


type LDAPUserAttributeWrite struct {
  Name             *string  `json:"name,omitempty"`                // Name of User Attribute in LDAP
  Required         *bool    `json:"required,omitempty"`            // Required to be in LDAP assertion for login to be allowed to succeed
  UserAttributeIds *[]int64 `json:"user_attribute_ids,omitempty"`  // Looker User Attribute Ids
  Url              *url.URL `json:"url,omitempty"`                 // Link to ldap config
}


type LegacyFeature struct {
  Can                       *map[string]bool `json:"can,omitempty"`                            // Operations the current user is able to perform on this object
  Id                        *string          `json:"id,omitempty"`                             // Unique Id
  Name                      *string          `json:"name,omitempty"`                           // Name
  Description               *string          `json:"description,omitempty"`                    // Description
  EnabledLocally            *bool            `json:"enabled_locally,omitempty"`                // Whether this feature has been enabled by a user
  Enabled                   *bool            `json:"enabled,omitempty"`                        // Whether this feature is currently enabled
  DisallowedAsOfVersion     *string          `json:"disallowed_as_of_version,omitempty"`       // Looker version where this feature became a legacy feature
  DisableOnUpgradeToVersion *string          `json:"disable_on_upgrade_to_version,omitempty"`  // Looker version where this feature will be automatically disabled
  EndOfLifeVersion          *string          `json:"end_of_life_version,omitempty"`            // Future Looker version where this feature will be removed
  DocumentationUrl          *string          `json:"documentation_url,omitempty"`              // URL for documentation about this feature
  ApproximateDisableDate    *time.Time       `json:"approximate_disable_date,omitempty"`       // Approximate date that this feature will be automatically disabled.
  ApproximateEndOfLifeDate  *time.Time       `json:"approximate_end_of_life_date,omitempty"`   // Approximate date that this feature will be removed.
  HasDisabledOnUpgrade      *bool            `json:"has_disabled_on_upgrade,omitempty"`        // Whether this legacy feature may have been automatically disabled when upgrading to the current version.
}


type Locale struct {
  Code        *string `json:"code,omitempty"`          // Code for Locale
  NativeName  *string `json:"native_name,omitempty"`   // Name of Locale in its own language
  EnglishName *string `json:"english_name,omitempty"`  // Name of Locale in English
}


type LocalizationSettings struct {
  DefaultLocale     *string `json:"default_locale,omitempty"`      // Default locale for localization
  LocalizationLevel *string `json:"localization_level,omitempty"`  // Localization level - strict or permissive
}


type Look struct {
  Can                      *map[string]bool `json:"can,omitempty"`                         // Operations the current user is able to perform on this object
  ContentMetadataId        *int64           `json:"content_metadata_id,omitempty"`         // Id of content metadata
  Id                       *int64           `json:"id,omitempty"`                          // Unique Id
  Title                    *string          `json:"title,omitempty"`                       // Look Title
  ContentFavoriteId        *int64           `json:"content_favorite_id,omitempty"`         // Content Favorite Id
  CreatedAt                *time.Time       `json:"created_at,omitempty"`                  // Time that the Look was created.
  Deleted                  *bool            `json:"deleted,omitempty"`                     // Whether or not a look is 'soft' deleted.
  DeletedAt                *time.Time       `json:"deleted_at,omitempty"`                  // Time that the Look was deleted.
  DeleterId                *int64           `json:"deleter_id,omitempty"`                  // Id of User that deleted the look.
  Description              *string          `json:"description,omitempty"`                 // Description
  EmbedUrl                 *string          `json:"embed_url,omitempty"`                   // Embed Url
  ExcelFileUrl             *string          `json:"excel_file_url,omitempty"`              // Excel File Url
  FavoriteCount            *int64           `json:"favorite_count,omitempty"`              // Number of times favorited
  GoogleSpreadsheetFormula *string          `json:"google_spreadsheet_formula,omitempty"`  // Google Spreadsheet Formula
  ImageEmbedUrl            *string          `json:"image_embed_url,omitempty"`             // Image Embed Url
  IsRunOnLoad              *bool            `json:"is_run_on_load,omitempty"`              // auto-run query when Look viewed
  LastAccessedAt           *time.Time       `json:"last_accessed_at,omitempty"`            // Time that the Look was last accessed by any user
  LastUpdaterId            *int64           `json:"last_updater_id,omitempty"`             // Id of User that last updated the look.
  LastViewedAt             *time.Time       `json:"last_viewed_at,omitempty"`              // Time last viewed in the Looker web UI
  Model                    *LookModel       `json:"model,omitempty"`                      
  Public                   *bool            `json:"public,omitempty"`                      // Is Public
  PublicSlug               *string          `json:"public_slug,omitempty"`                 // Public Slug
  PublicUrl                *string          `json:"public_url,omitempty"`                  // Public Url
  QueryId                  *int64           `json:"query_id,omitempty"`                    // Query Id
  ShortUrl                 *string          `json:"short_url,omitempty"`                   // Short Url
  Space                    *SpaceBase       `json:"space,omitempty"`                      
  Folder                   *FolderBase      `json:"folder,omitempty"`                     
  SpaceId                  *string          `json:"space_id,omitempty"`                    // Space Id
  FolderId                 *string          `json:"folder_id,omitempty"`                   // Folder Id
  UpdatedAt                *time.Time       `json:"updated_at,omitempty"`                  // Time that the Look was updated.
  UserId                   *int64           `json:"user_id,omitempty"`                     // User Id
  ViewCount                *int64           `json:"view_count,omitempty"`                  // Number of times viewed in the Looker web UI
}


type LookBasic struct {
  Can               *map[string]bool `json:"can,omitempty"`                  // Operations the current user is able to perform on this object
  ContentMetadataId *int64           `json:"content_metadata_id,omitempty"`  // Id of content metadata
  Id                *int64           `json:"id,omitempty"`                   // Unique Id
  Title             *string          `json:"title,omitempty"`                // Look Title
}


type LookmlModel struct {
  Can                      *map[string]bool         `json:"can,omitempty"`                          // Operations the current user is able to perform on this object
  AllowedDbConnectionNames *[]string                `json:"allowed_db_connection_names,omitempty"`  // Array of names of connections this model is allowed to use
  Explores                 *[]LookmlModelNavExplore `json:"explores,omitempty"`                     // Array of explores (if has_content)
  HasContent               *bool                    `json:"has_content,omitempty"`                  // Does this model declaration have have lookml content?
  Label                    *string                  `json:"label,omitempty"`                        // UI-friendly name for this model
  Name                     *string                  `json:"name,omitempty"`                         // Name of the model. Also used as the unique identifier
  ProjectName              *string                  `json:"project_name,omitempty"`                 // Name of project containing the model
  UnlimitedDbConnections   *bool                    `json:"unlimited_db_connections,omitempty"`     // Is this model allowed to use all current and future connections
}


type LookmlModelExplore struct {
  Id                    *string                                   `json:"id,omitempty"`                       // Fully qualified name model plus explore name
  Name                  *string                                   `json:"name,omitempty"`                     // Explore name
  Description           *string                                   `json:"description,omitempty"`              // Description
  Label                 *string                                   `json:"label,omitempty"`                    // Label
  Scopes                *[]string                                 `json:"scopes,omitempty"`                   // Scopes
  CanTotal              *bool                                     `json:"can_total,omitempty"`                // Can Total
  CanSave               *bool                                     `json:"can_save,omitempty"`                 // Can Save
  CanExplain            *bool                                     `json:"can_explain,omitempty"`              // Can Explain
  CanPivotInDb          *bool                                     `json:"can_pivot_in_db,omitempty"`          // Can pivot in the DB
  CanSubtotal           *bool                                     `json:"can_subtotal,omitempty"`             // Can use subtotals
  HasTimezoneSupport    *bool                                     `json:"has_timezone_support,omitempty"`     // Has timezone support
  SupportsCostEstimate  *bool                                     `json:"supports_cost_estimate,omitempty"`   // Cost estimates supported
  ConnectionName        *string                                   `json:"connection_name,omitempty"`          // Connection name
  NullSortTreatment     *string                                   `json:"null_sort_treatment,omitempty"`      // How nulls are sorted, possible values are "low", "high", "first" and "last"
  Files                 *[]string                                 `json:"files,omitempty"`                    // List of model source files
  SourceFile            *string                                   `json:"source_file,omitempty"`              // Primary source_file file
  ProjectName           *string                                   `json:"project_name,omitempty"`             // Name of project
  ModelName             *string                                   `json:"model_name,omitempty"`               // Name of model
  ViewName              *string                                   `json:"view_name,omitempty"`                // Name of view
  Hidden                *bool                                     `json:"hidden,omitempty"`                   // Is hidden
  SqlTableName          *string                                   `json:"sql_table_name,omitempty"`           // A sql_table_name expression that defines what sql table the view/explore maps onto. Example: "prod_orders2 AS orders" in a view named orders.
  AccessFilterFields    *[]string                                 `json:"access_filter_fields,omitempty"`     // (DEPRECATED) Array of access filter field names
  AccessFilters         *[]LookmlModelExploreAccessFilter         `json:"access_filters,omitempty"`           // Access filters
  Aliases               *[]LookmlModelExploreAlias                `json:"aliases,omitempty"`                  // Aliases
  AlwaysFilter          *[]LookmlModelExploreAlwaysFilter         `json:"always_filter,omitempty"`            // Always filter
  ConditionallyFilter   *[]LookmlModelExploreConditionallyFilter  `json:"conditionally_filter,omitempty"`     // Conditionally filter
  IndexFields           *[]string                                 `json:"index_fields,omitempty"`             // Array of index fields
  Sets                  *[]LookmlModelExploreSet                  `json:"sets,omitempty"`                     // Sets
  Tags                  *[]string                                 `json:"tags,omitempty"`                     // An array of arbitrary string tags provided in the model for this explore.
  Errors                *[]LookmlModelExploreError                `json:"errors,omitempty"`                   // Errors
  Fields                *LookmlModelExploreFieldset               `json:"fields,omitempty"`                  
  Joins                 *[]LookmlModelExploreJoins                `json:"joins,omitempty"`                    // Views joined into this explore
  GroupLabel            *string                                   `json:"group_label,omitempty"`              // Label used to group explores in the navigation menus
  SupportedMeasureTypes *[]LookmlModelExploreSupportedMeasureType `json:"supported_measure_types,omitempty"`  // An array of items describing which custom measure types are supported for creating a custom measure 'baed_on' each possible dimension type.
}


type LookmlModelExploreAccessFilter struct {
  Field         *string `json:"field,omitempty"`           // Field to be filtered
  UserAttribute *string `json:"user_attribute,omitempty"`  // User attribute name
}


type LookmlModelExploreAlias struct {
  Name  *string `json:"name,omitempty"`   // Name
  Value *string `json:"value,omitempty"`  // Value
}


type LookmlModelExploreAlwaysFilter struct {
  Name  *string `json:"name,omitempty"`   // Name
  Value *string `json:"value,omitempty"`  // Value
}


type LookmlModelExploreConditionallyFilter struct {
  Name  *string `json:"name,omitempty"`   // Name
  Value *string `json:"value,omitempty"`  // Value
}


type LookmlModelExploreError struct {
  Message    *string      `json:"message,omitempty"`      // Error Message
  Details    *interface{} `json:"details,omitempty"`      // Details
  ErrorPos   *string      `json:"error_pos,omitempty"`    // Error source location
  FieldError *bool        `json:"field_error,omitempty"`  // Is this a field error
}


type LookmlModelExploreField struct {
  Align                    *AlignType                            `json:"align,omitempty"`                        // The appropriate horizontal text alignment the values of this field shoud be displayed in. Valid values are: "left", "right".
  CanFilter                *bool                                 `json:"can_filter,omitempty"`                   // Whether it's possible to filter on this field.
  Category                 *CategoryType                         `json:"category,omitempty"`                     // Field category Valid values are: "parameter", "filter", "measure", "dimension".
  DefaultFilterValue       *string                               `json:"default_filter_value,omitempty"`         // The default value that this field uses when filtering. Null if there is no default value.
  Description              *string                               `json:"description,omitempty"`                  // Description
  Enumerations             *[]LookmlModelExploreFieldEnumeration `json:"enumerations,omitempty"`                 // An array enumerating all the possible values that this field can contain. When null, there is no limit to the set of possible values this field can contain.
  Error                    *string                               `json:"error,omitempty"`                        // An error message indicating a problem with the definition of this field. If there are no errors, this will be null.
  FieldGroupLabel          *string                               `json:"field_group_label,omitempty"`            // A label creating a grouping of fields. All fields with this label should be presented together when displayed in a UI.
  FieldGroupVariant        *string                               `json:"field_group_variant,omitempty"`          // When presented in a field group via field_group_label, a shorter name of the field to be displayed in that context.
  FillStyle                *FillStyleType                        `json:"fill_style,omitempty"`                   // The style of dimension fill that is possible for this field. Null if no dimension fill is possible. Valid values are: "enumeration", "range".
  FiscalMonthOffset        *int64                                `json:"fiscal_month_offset,omitempty"`          // An offset (in months) from the calendar start month to the fiscal start month defined in the LookML model this field belongs to.
  HasAllowedValues         *bool                                 `json:"has_allowed_values,omitempty"`           // Whether this field has a set of allowed_values specified in LookML.
  Hidden                   *bool                                 `json:"hidden,omitempty"`                       // Whether this field should be hidden from the user interface.
  IsFilter                 *bool                                 `json:"is_filter,omitempty"`                    // Whether this field is a filter.
  IsFiscal                 *bool                                 `json:"is_fiscal,omitempty"`                    // Whether this field represents a fiscal time value.
  IsNumeric                *bool                                 `json:"is_numeric,omitempty"`                   // Whether this field is of a type that represents a numeric value.
  IsTimeframe              *bool                                 `json:"is_timeframe,omitempty"`                 // Whether this field is of a type that represents a time value.
  CanTimeFilter            *bool                                 `json:"can_time_filter,omitempty"`              // Whether this field can be time filtered.
  TimeInterval             *LookmlModelExploreFieldTimeInterval  `json:"time_interval,omitempty"`               
  Label                    *string                               `json:"label,omitempty"`                        // Fully-qualified human-readable label of the field.
  LabelFromParameter       *string                               `json:"label_from_parameter,omitempty"`         // The name of the parameter that will provide a parameterized label for this field, if available in the current context.
  LabelShort               *string                               `json:"label_short,omitempty"`                  // The human-readable label of the field, without the view label.
  LookmlLink               *string                               `json:"lookml_link,omitempty"`                  // A URL linking to the definition of this field in the LookML IDE.
  MapLayer                 *LookmlModelExploreFieldMapLayer      `json:"map_layer,omitempty"`                   
  Measure                  *bool                                 `json:"measure,omitempty"`                      // Whether this field is a measure.
  Name                     *string                               `json:"name,omitempty"`                         // Fully-qualified name of the field.
  StrictValueFormat        *bool                                 `json:"strict_value_format,omitempty"`          // If yes, the field will not be localized with the user attribute number_format. Defaults to no
  Parameter                *bool                                 `json:"parameter,omitempty"`                    // Whether this field is a parameter.
  Permanent                *bool                                 `json:"permanent,omitempty"`                    // Whether this field can be removed from a query.
  PrimaryKey               *bool                                 `json:"primary_key,omitempty"`                  // Whether or not the field represents a primary key.
  ProjectName              *string                               `json:"project_name,omitempty"`                 // The name of the project this field is defined in.
  RequiresRefreshOnSort    *bool                                 `json:"requires_refresh_on_sort,omitempty"`     // When true, it's not possible to re-sort this field's values without re-running the SQL query, due to database logic that affects the sort.
  Scope                    *string                               `json:"scope,omitempty"`                        // The LookML scope this field belongs to. The scope is typically the field's view.
  Sortable                 *bool                                 `json:"sortable,omitempty"`                     // Whether this field can be sorted.
  SourceFile               *string                               `json:"source_file,omitempty"`                  // The path portion of source_file_path.
  SourceFilePath           *string                               `json:"source_file_path,omitempty"`             // The fully-qualified path of the project file this field is defined in.
  Sql                      *string                               `json:"sql,omitempty"`                          // SQL expression as defined in the LookML model. The SQL syntax shown here is a representation intended for auditability, and is not neccessarily an exact match for what will ultimately be run in the database. It may contain special LookML syntax or annotations that are not valid SQL. This will be null if the current user does not have the see_lookml permission for the field's model.
  SqlCase                  *[]LookmlModelExploreFieldSqlCase     `json:"sql_case,omitempty"`                     // An array of conditions and values that make up a SQL Case expression, as defined in the LookML model. The SQL syntax shown here is a representation intended for auditability, and is not neccessarily an exact match for what will ultimately be run in the database. It may contain special LookML syntax or annotations that are not valid SQL. This will be null if the current user does not have the see_lookml permission for the field's model.
  SuggestDimension         *string                               `json:"suggest_dimension,omitempty"`            // The name of the dimension to base suggest queries from.
  SuggestExplore           *string                               `json:"suggest_explore,omitempty"`              // The name of the explore to base suggest queries from.
  Suggestable              *bool                                 `json:"suggestable,omitempty"`                  // Whether or not suggestions are possible for this field.
  Suggestions              *[]string                             `json:"suggestions,omitempty"`                  // If available, a list of suggestions for this field. For most fields, a suggest query is a more appropriate way to get an up-to-date list of suggestions. Or use enumerations to list all the possible values.
  Tags                     *[]string                             `json:"tags,omitempty"`                         // An array of arbitrary string tags provided in the model for this field.
  Type                     *string                               `json:"type,omitempty"`                         // The LookML type of the field.
  UserAttributeFilterTypes *UserAttributeFilterTypesType         `json:"user_attribute_filter_types,omitempty"`  // An array of user attribute types that are allowed to be used in filters on this field. Valid values are: "advanced_filter_string", "advanced_filter_number", "advanced_filter_datetime", "string", "number", "datetime", "relative_url", "yesno", "zipcode".
  ValueFormat              *string                               `json:"value_format,omitempty"`                 // If specified, the LookML value format string for formatting values of this field.
  View                     *string                               `json:"view,omitempty"`                         // The name of the view this field belongs to.
  ViewLabel                *string                               `json:"view_label,omitempty"`                   // The human-readable label of the view the field belongs to.
  Dynamic                  *bool                                 `json:"dynamic,omitempty"`                      // Whether this field was specified in "dynamic_fields" and is not part of the model.
  WeekStartDay             *WeekStartDayType                     `json:"week_start_day,omitempty"`               // The name of the starting day of the week. Valid values are: "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday".
  TimesUsed                *int64                                `json:"times_used,omitempty"`                   // The number of times this field has been used in queries
}


type LookmlModelExploreFieldEnumeration struct {
  Label *string      `json:"label,omitempty"`  // Label
  Value *interface{} `json:"value,omitempty"`  // Value
}


type LookmlModelExploreFieldMapLayer struct {
  Url              *string     `json:"url,omitempty"`                 // URL to the map layer resource.
  Name             *string     `json:"name,omitempty"`                // Name of the map layer, as defined in LookML.
  FeatureKey       *string     `json:"feature_key,omitempty"`         // Specifies the name of the TopoJSON object that the map layer references. If not specified, use the first object..
  PropertyKey      *string     `json:"property_key,omitempty"`        // Selects which property from the TopoJSON data to plot against. TopoJSON supports arbitrary metadata for each region. When null, the first matching property should be used.
  PropertyLabelKey *string     `json:"property_label_key,omitempty"`  // Which property from the TopoJSON data to use to label the region. When null, property_key should be used.
  Projection       *string     `json:"projection,omitempty"`          // The preferred geographic projection of the map layer when displayed in a visualization that supports multiple geographic projections.
  Format           *FormatType `json:"format,omitempty"`              // Specifies the data format of the region information. Valid values are: "topojson", "vector_tile_region".
  ExtentsJsonUrl   *string     `json:"extents_json_url,omitempty"`    // Specifies the URL to a JSON file that defines the geographic extents of each region available in the map layer. This data is used to automatically center the map on the available data for visualization purposes. The JSON file must be a JSON object where the keys are the mapping value of the feature (as specified by property_key) and the values are arrays of four numbers representing the west longitude, south latitude, east longitude, and north latitude extents of the region. The object must include a key for every possible value of property_key.
  MaxZoomLevel     *int64      `json:"max_zoom_level,omitempty"`      // The minimum zoom level that the map layer may be displayed at, for visualizations that support zooming.
  MinZoomLevel     *int64      `json:"min_zoom_level,omitempty"`      // The maximum zoom level that the map layer may be displayed at, for visualizations that support zooming.
}


type LookmlModelExploreFieldset struct {
  Dimensions *[]LookmlModelExploreField `json:"dimensions,omitempty"`  // Array of dimensions
  Measures   *[]LookmlModelExploreField `json:"measures,omitempty"`    // Array of measures
  Filters    *[]LookmlModelExploreField `json:"filters,omitempty"`     // Array of filters
  Parameters *[]LookmlModelExploreField `json:"parameters,omitempty"`  // Array of parameters
}


type LookmlModelExploreFieldSqlCase struct {
  Value     *string `json:"value,omitempty"`      // SQL Case label value
  Condition *string `json:"condition,omitempty"`  // SQL Case condition expression
}


type LookmlModelExploreFieldTimeInterval struct {
  Name  *NameType `json:"name,omitempty"`   // The type of time interval this field represents a grouping of. Valid values are: "day", "hour", "minute", "second", "millisecond", "microsecond", "month", "year".
  Count *int64    `json:"count,omitempty"`  // The number of intervals this field represents a grouping of.
}


type LookmlModelExploreJoins struct {
  Name            *string   `json:"name,omitempty"`              // Name of this join (and name of the view to join)
  DependentFields *[]string `json:"dependent_fields,omitempty"`  // Fields referenced by the join
  Fields          *[]string `json:"fields,omitempty"`            // Fields of the joined view to pull into this explore
  ForeignKey      *string   `json:"foreign_key,omitempty"`       // Name of the dimension in this explore whose value is in the primary key of the joined view
  From            *string   `json:"from,omitempty"`              // Name of view to join
  OuterOnly       *bool     `json:"outer_only,omitempty"`        // Specifies whether all queries must use an outer join
  Relationship    *string   `json:"relationship,omitempty"`      // many_to_one, one_to_one, one_to_many, many_to_many
  RequiredJoins   *[]string `json:"required_joins,omitempty"`    // Names of joins that must always be included in SQL queries
  SqlForeignKey   *string   `json:"sql_foreign_key,omitempty"`   // SQL expression that produces a foreign key
  SqlOn           *string   `json:"sql_on,omitempty"`            // SQL ON expression describing the join condition
  SqlTableName    *string   `json:"sql_table_name,omitempty"`    // SQL table name to join
  Type            *string   `json:"type,omitempty"`              // The join type: left_outer, full_outer, inner, or cross
  ViewLabel       *string   `json:"view_label,omitempty"`        // Label to display in UI selectors
}


type LookmlModelExploreSet struct {
  Name  *string   `json:"name,omitempty"`   // Name
  Value *[]string `json:"value,omitempty"`  // Value set
}


type LookmlModelExploreSupportedMeasureType struct {
  DimensionType *string   `json:"dimension_type,omitempty"` 
  MeasureTypes  *[]string `json:"measure_types,omitempty"`  
}


type LookmlModelNavExplore struct {
  Name        *string `json:"name,omitempty"`         // Name of the explore
  Description *string `json:"description,omitempty"`  // Description for the explore
  Label       *string `json:"label,omitempty"`        // Label for the explore
  Hidden      *bool   `json:"hidden,omitempty"`       // Is this explore marked as hidden
  GroupLabel  *string `json:"group_label,omitempty"`  // Label used to group explores in the navigation menus
}


type LookmlTest struct {
  Can            *map[string]bool `json:"can,omitempty"`               // Operations the current user is able to perform on this object
  ModelName      *string          `json:"model_name,omitempty"`        // Name of model containing this test.
  Name           *string          `json:"name,omitempty"`              // Name of this test.
  ExploreName    *string          `json:"explore_name,omitempty"`      // Name of the explore this test runs a query against
  QueryUrlParams *string          `json:"query_url_params,omitempty"`  // The url parameters that can be used to reproduce this test's query on an explore.
  File           *string          `json:"file,omitempty"`              // Name of the LookML file containing this test.
  Line           *int64           `json:"line,omitempty"`              // Line number of this test in LookML.
}


type LookmlTestResult struct {
  Can              *map[string]bool `json:"can,omitempty"`                // Operations the current user is able to perform on this object
  ModelName        *string          `json:"model_name,omitempty"`         // Name of model containing this test.
  TestName         *string          `json:"test_name,omitempty"`          // Name of this test.
  AssertionsCount  *int64           `json:"assertions_count,omitempty"`   // Number of assertions in this test
  AssertionsFailed *int64           `json:"assertions_failed,omitempty"`  // Number of assertions passed in this test
  Errors           *[]ProjectError  `json:"errors,omitempty"`             // A list of any errors encountered by the test.
  Warnings         *[]ProjectError  `json:"warnings,omitempty"`           // A list of any warnings encountered by the test.
  Success          *bool            `json:"success,omitempty"`            // True if this test passsed without errors.
}


type LookModel struct {
  Id    *string `json:"id,omitempty"`     // Model Id
  Label *string `json:"label,omitempty"`  // Model Label
}


type LookWithDashboards struct {
  Can                      *map[string]bool `json:"can,omitempty"`                         // Operations the current user is able to perform on this object
  ContentMetadataId        *int64           `json:"content_metadata_id,omitempty"`         // Id of content metadata
  Id                       *int64           `json:"id,omitempty"`                          // Unique Id
  Title                    *string          `json:"title,omitempty"`                       // Look Title
  ContentFavoriteId        *int64           `json:"content_favorite_id,omitempty"`         // Content Favorite Id
  CreatedAt                *time.Time       `json:"created_at,omitempty"`                  // Time that the Look was created.
  Deleted                  *bool            `json:"deleted,omitempty"`                     // Whether or not a look is 'soft' deleted.
  DeletedAt                *time.Time       `json:"deleted_at,omitempty"`                  // Time that the Look was deleted.
  DeleterId                *int64           `json:"deleter_id,omitempty"`                  // Id of User that deleted the look.
  Description              *string          `json:"description,omitempty"`                 // Description
  EmbedUrl                 *string          `json:"embed_url,omitempty"`                   // Embed Url
  ExcelFileUrl             *string          `json:"excel_file_url,omitempty"`              // Excel File Url
  FavoriteCount            *int64           `json:"favorite_count,omitempty"`              // Number of times favorited
  GoogleSpreadsheetFormula *string          `json:"google_spreadsheet_formula,omitempty"`  // Google Spreadsheet Formula
  ImageEmbedUrl            *string          `json:"image_embed_url,omitempty"`             // Image Embed Url
  IsRunOnLoad              *bool            `json:"is_run_on_load,omitempty"`              // auto-run query when Look viewed
  LastAccessedAt           *time.Time       `json:"last_accessed_at,omitempty"`            // Time that the Look was last accessed by any user
  LastUpdaterId            *int64           `json:"last_updater_id,omitempty"`             // Id of User that last updated the look.
  LastViewedAt             *time.Time       `json:"last_viewed_at,omitempty"`              // Time last viewed in the Looker web UI
  Model                    *LookModel       `json:"model,omitempty"`                      
  Public                   *bool            `json:"public,omitempty"`                      // Is Public
  PublicSlug               *string          `json:"public_slug,omitempty"`                 // Public Slug
  PublicUrl                *string          `json:"public_url,omitempty"`                  // Public Url
  QueryId                  *int64           `json:"query_id,omitempty"`                    // Query Id
  ShortUrl                 *string          `json:"short_url,omitempty"`                   // Short Url
  Space                    *SpaceBase       `json:"space,omitempty"`                      
  Folder                   *FolderBase      `json:"folder,omitempty"`                     
  SpaceId                  *string          `json:"space_id,omitempty"`                    // Space Id
  FolderId                 *string          `json:"folder_id,omitempty"`                   // Folder Id
  UpdatedAt                *time.Time       `json:"updated_at,omitempty"`                  // Time that the Look was updated.
  UserId                   *int64           `json:"user_id,omitempty"`                     // User Id
  ViewCount                *int64           `json:"view_count,omitempty"`                  // Number of times viewed in the Looker web UI
  Dashboards               *[]DashboardBase `json:"dashboards,omitempty"`                  // Dashboards
}


type LookWithQuery struct {
  Can                      *map[string]bool `json:"can,omitempty"`                         // Operations the current user is able to perform on this object
  ContentMetadataId        *int64           `json:"content_metadata_id,omitempty"`         // Id of content metadata
  Id                       *int64           `json:"id,omitempty"`                          // Unique Id
  Title                    *string          `json:"title,omitempty"`                       // Look Title
  ContentFavoriteId        *int64           `json:"content_favorite_id,omitempty"`         // Content Favorite Id
  CreatedAt                *time.Time       `json:"created_at,omitempty"`                  // Time that the Look was created.
  Deleted                  *bool            `json:"deleted,omitempty"`                     // Whether or not a look is 'soft' deleted.
  DeletedAt                *time.Time       `json:"deleted_at,omitempty"`                  // Time that the Look was deleted.
  DeleterId                *int64           `json:"deleter_id,omitempty"`                  // Id of User that deleted the look.
  Description              *string          `json:"description,omitempty"`                 // Description
  EmbedUrl                 *string          `json:"embed_url,omitempty"`                   // Embed Url
  ExcelFileUrl             *string          `json:"excel_file_url,omitempty"`              // Excel File Url
  FavoriteCount            *int64           `json:"favorite_count,omitempty"`              // Number of times favorited
  GoogleSpreadsheetFormula *string          `json:"google_spreadsheet_formula,omitempty"`  // Google Spreadsheet Formula
  ImageEmbedUrl            *string          `json:"image_embed_url,omitempty"`             // Image Embed Url
  IsRunOnLoad              *bool            `json:"is_run_on_load,omitempty"`              // auto-run query when Look viewed
  LastAccessedAt           *time.Time       `json:"last_accessed_at,omitempty"`            // Time that the Look was last accessed by any user
  LastUpdaterId            *int64           `json:"last_updater_id,omitempty"`             // Id of User that last updated the look.
  LastViewedAt             *time.Time       `json:"last_viewed_at,omitempty"`              // Time last viewed in the Looker web UI
  Model                    *LookModel       `json:"model,omitempty"`                      
  Public                   *bool            `json:"public,omitempty"`                      // Is Public
  PublicSlug               *string          `json:"public_slug,omitempty"`                 // Public Slug
  PublicUrl                *string          `json:"public_url,omitempty"`                  // Public Url
  QueryId                  *int64           `json:"query_id,omitempty"`                    // Query Id
  ShortUrl                 *string          `json:"short_url,omitempty"`                   // Short Url
  Space                    *SpaceBase       `json:"space,omitempty"`                      
  Folder                   *FolderBase      `json:"folder,omitempty"`                     
  SpaceId                  *string          `json:"space_id,omitempty"`                    // Space Id
  FolderId                 *string          `json:"folder_id,omitempty"`                   // Folder Id
  UpdatedAt                *time.Time       `json:"updated_at,omitempty"`                  // Time that the Look was updated.
  UserId                   *int64           `json:"user_id,omitempty"`                     // User Id
  ViewCount                *int64           `json:"view_count,omitempty"`                  // Number of times viewed in the Looker web UI
  Query                    *Query           `json:"query,omitempty"`                      
  Url                      *string          `json:"url,omitempty"`                         // Url
}


type Manifest struct {
  Can                  *map[string]bool      `json:"can,omitempty"`                    // Operations the current user is able to perform on this object
  Name                 *string               `json:"name,omitempty"`                   // Manifest project name
  Imports              *[]ImportedProject    `json:"imports,omitempty"`                // Imports for a project
  LocalizationSettings *LocalizationSettings `json:"localization_settings,omitempty"` 
}


type MergeFields struct {
  FieldName       *string `json:"field_name,omitempty"`         // Field name to map onto in the merged results
  SourceFieldName *string `json:"source_field_name,omitempty"`  // Field name from the source query
}


type MergeQuery struct {
  Can           *map[string]bool         `json:"can,omitempty"`              // Operations the current user is able to perform on this object
  ColumnLimit   *string                  `json:"column_limit,omitempty"`     // Column Limit
  DynamicFields *string                  `json:"dynamic_fields,omitempty"`   // Dynamic Fields
  Id            *string                  `json:"id,omitempty"`               // Unique Id
  Pivots        *[]string                `json:"pivots,omitempty"`           // Pivots
  ResultMakerId *int64                   `json:"result_maker_id,omitempty"`  // Unique to get results
  Sorts         *[]string                `json:"sorts,omitempty"`            // Sorts
  SourceQueries *[]MergeQuerySourceQuery `json:"source_queries,omitempty"`   // Source Queries defining the results to be merged.
  Total         *bool                    `json:"total,omitempty"`            // Total
  VisConfig     *map[string]interface{}  `json:"vis_config,omitempty"`       // Visualization Config
}


type MergeQuerySourceQuery struct {
  MergeFields *[]MergeFields `json:"merge_fields,omitempty"`  // An array defining which fields of the source query are mapped onto fields of the merge query
  Name        *string        `json:"name,omitempty"`          // Display name
  QueryId     *int64         `json:"query_id,omitempty"`      // Id of the query to merge
}


type ModelSet struct {
  Can       *map[string]bool `json:"can,omitempty"`         // Operations the current user is able to perform on this object
  AllAccess *bool            `json:"all_access,omitempty"` 
  BuiltIn   *bool            `json:"built_in,omitempty"`   
  Id        *int64           `json:"id,omitempty"`          // Unique Id
  Models    *[]string        `json:"models,omitempty"`     
  Name      *string          `json:"name,omitempty"`        // Name of ModelSet
  Url       *url.URL         `json:"url,omitempty"`         // Link to get this item
}


type ModelsNotValidated struct {
  Name          *string `json:"name,omitempty"`             // Model name
  ProjectFileId *string `json:"project_file_id,omitempty"`  // Project file
}

type NameType string
const NameType_Day         NameType = "day"
const NameType_Hour        NameType = "hour"
const NameType_Minute      NameType = "minute"
const NameType_Second      NameType = "second"
const NameType_Millisecond NameType = "millisecond"
const NameType_Microsecond NameType = "microsecond"
const NameType_Month       NameType = "month"
const NameType_Year        NameType = "year"



type OIDCConfig struct {
  Can                        *map[string]bool          `json:"can,omitempty"`                            // Operations the current user is able to perform on this object
  AlternateEmailLoginAllowed *bool                     `json:"alternate_email_login_allowed,omitempty"`  // Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
  Audience                   *string                   `json:"audience,omitempty"`                       // OpenID Provider Audience
  AuthRequiresRole           *bool                     `json:"auth_requires_role,omitempty"`             // Users will not be allowed to login at all unless a role for them is found in OIDC if set to true
  AuthorizationEndpoint      *url.URL                  `json:"authorization_endpoint,omitempty"`         // OpenID Provider Authorization Url
  DefaultNewUserGroupIds     *[]int64                  `json:"default_new_user_group_ids,omitempty"`     // (Write-Only) Array of ids of groups that will be applied to new users the first time they login via OIDC
  DefaultNewUserGroups       *[]Group                  `json:"default_new_user_groups,omitempty"`        // (Read-only) Groups that will be applied to new users the first time they login via OIDC
  DefaultNewUserRoleIds      *[]int64                  `json:"default_new_user_role_ids,omitempty"`      // (Write-Only) Array of ids of roles that will be applied to new users the first time they login via OIDC
  DefaultNewUserRoles        *[]Role                   `json:"default_new_user_roles,omitempty"`         // (Read-only) Roles that will be applied to new users the first time they login via OIDC
  Enabled                    *bool                     `json:"enabled,omitempty"`                        // Enable/Disable OIDC authentication for the server
  Groups                     *[]OIDCGroupRead          `json:"groups,omitempty"`                         // (Read-only) Array of mappings between OIDC Groups and Looker Roles
  GroupsAttribute            *string                   `json:"groups_attribute,omitempty"`               // Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
  GroupsWithRoleIds          *[]OIDCGroupWrite         `json:"groups_with_role_ids,omitempty"`           // (Read/Write) Array of mappings between OIDC Groups and arrays of Looker Role ids
  Identifier                 *string                   `json:"identifier,omitempty"`                     // Relying Party Identifier (provided by OpenID Provider)
  Issuer                     *string                   `json:"issuer,omitempty"`                         // OpenID Provider Issuer
  ModifiedAt                 *time.Time                `json:"modified_at,omitempty"`                    // When this config was last modified
  ModifiedBy                 *int64                    `json:"modified_by,omitempty"`                    // User id of user who last modified this config
  NewUserMigrationTypes      *string                   `json:"new_user_migration_types,omitempty"`       // Merge first-time oidc login to existing user account by email addresses. When a user logs in for the first time via oidc this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
  Scopes                     *[]string                 `json:"scopes,omitempty"`                         // Array of scopes to request.
  Secret                     *string                   `json:"secret,omitempty"`                         // (Write-Only) Relying Party Secret (provided by OpenID Provider)
  SetRolesFromGroups         *bool                     `json:"set_roles_from_groups,omitempty"`          // Set user roles in Looker based on groups from OIDC
  TestSlug                   *string                   `json:"test_slug,omitempty"`                      // Slug to identify configurations that are created in order to run a OIDC config test
  TokenEndpoint              *string                   `json:"token_endpoint,omitempty"`                 // OpenID Provider Token Url
  UserAttributeMapEmail      *string                   `json:"user_attribute_map_email,omitempty"`       // Name of user record attributes used to indicate email address field
  UserAttributeMapFirstName  *string                   `json:"user_attribute_map_first_name,omitempty"`  // Name of user record attributes used to indicate first name
  UserAttributeMapLastName   *string                   `json:"user_attribute_map_last_name,omitempty"`   // Name of user record attributes used to indicate last name
  UserAttributes             *[]OIDCUserAttributeRead  `json:"user_attributes,omitempty"`                // (Read-only) Array of mappings between OIDC User Attributes and Looker User Attributes
  UserAttributesWithIds      *[]OIDCUserAttributeWrite `json:"user_attributes_with_ids,omitempty"`       // (Read/Write) Array of mappings between OIDC User Attributes and arrays of Looker User Attribute ids
  UserinfoEndpoint           *url.URL                  `json:"userinfo_endpoint,omitempty"`              // OpenID Provider User Information Url
  Url                        *url.URL                  `json:"url,omitempty"`                            // Link to get this item
}


type OIDCGroupRead struct {
  Id              *int64  `json:"id,omitempty"`                 // Unique Id
  LookerGroupId   *int64  `json:"looker_group_id,omitempty"`    // Unique Id of group in Looker
  LookerGroupName *string `json:"looker_group_name,omitempty"`  // Name of group in Looker
  Name            *string `json:"name,omitempty"`               // Name of group in OIDC
  Roles           *[]Role `json:"roles,omitempty"`              // Looker Roles
}


type OIDCGroupWrite struct {
  Id              *int64   `json:"id,omitempty"`                 // Unique Id
  LookerGroupId   *int64   `json:"looker_group_id,omitempty"`    // Unique Id of group in Looker
  LookerGroupName *string  `json:"looker_group_name,omitempty"`  // Name of group in Looker
  Name            *string  `json:"name,omitempty"`               // Name of group in OIDC
  RoleIds         *[]int64 `json:"role_ids,omitempty"`           // Looker Role Ids
}


type OIDCUserAttributeRead struct {
  Name           *string          `json:"name,omitempty"`             // Name of User Attribute in OIDC
  Required       *bool            `json:"required,omitempty"`         // Required to be in OIDC assertion for login to be allowed to succeed
  UserAttributes *[]UserAttribute `json:"user_attributes,omitempty"`  // Looker User Attributes
}


type OIDCUserAttributeWrite struct {
  Name             *string  `json:"name,omitempty"`                // Name of User Attribute in OIDC
  Required         *bool    `json:"required,omitempty"`            // Required to be in OIDC assertion for login to be allowed to succeed
  UserAttributeIds *[]int64 `json:"user_attribute_ids,omitempty"`  // Looker User Attribute Ids
}


type PasswordConfig struct {
  Can               *map[string]bool `json:"can,omitempty"`                 // Operations the current user is able to perform on this object
  MinLength         *int64           `json:"min_length,omitempty"`          // Minimum number of characters required for a new password.  Must be between 7 and 100
  RequireNumeric    *bool            `json:"require_numeric,omitempty"`     // Require at least one numeric character
  RequireUpperlower *bool            `json:"require_upperlower,omitempty"`  // Require at least one uppercase and one lowercase letter
  RequireSpecial    *bool            `json:"require_special,omitempty"`     // Require at least one special character
}


type Permission struct {
  Can         *map[string]bool `json:"can,omitempty"`          // Operations the current user is able to perform on this object
  Permission  *string          `json:"permission,omitempty"`   // Permission symbol
  Parent      *string          `json:"parent,omitempty"`       // Dependency parent symbol
  Description *string          `json:"description,omitempty"`  // Description
}


type PermissionSet struct {
  Can         *map[string]bool `json:"can,omitempty"`          // Operations the current user is able to perform on this object
  AllAccess   *bool            `json:"all_access,omitempty"`  
  BuiltIn     *bool            `json:"built_in,omitempty"`    
  Id          *int64           `json:"id,omitempty"`           // Unique Id
  Name        *string          `json:"name,omitempty"`         // Name of PermissionSet
  Permissions *[]string        `json:"permissions,omitempty"` 
  Url         *url.URL         `json:"url,omitempty"`          // Link to get this item
}

type PermissionTypeType string
const PermissionTypeType_View PermissionTypeType = "view"
const PermissionTypeType_Edit PermissionTypeType = "edit"



type Project struct {
  Can                      *map[string]bool     `json:"can,omitempty"`                          // Operations the current user is able to perform on this object
  Id                       *string              `json:"id,omitempty"`                           // Project Id
  Name                     *string              `json:"name,omitempty"`                         // Project display name
  UsesGit                  *bool                `json:"uses_git,omitempty"`                     // If true the project is configured with a git repository
  GitRemoteUrl             *string              `json:"git_remote_url,omitempty"`               // Git remote repository url
  GitUsername              *string              `json:"git_username,omitempty"`                 // Git username for HTTPS authentication. (For production only, if using user attributes.)
  GitPassword              *string              `json:"git_password,omitempty"`                 // (Write-Only) Git password for HTTPS authentication. (For production only, if using user attributes.)
  GitUsernameUserAttribute *string              `json:"git_username_user_attribute,omitempty"`  // User attribute name for username in per-user HTTPS authentication.
  GitPasswordUserAttribute *string              `json:"git_password_user_attribute,omitempty"`  // User attribute name for password in per-user HTTPS authentication.
  GitServiceName           *string              `json:"git_service_name,omitempty"`             // Name of the git service provider
  DeploySecret             *string              `json:"deploy_secret,omitempty"`                // (Write-Only) Optional secret token with which to authenticate requests to the webhook deploy endpoint. If not set, endpoint is unauthenticated.
  UnsetDeploySecret        *bool                `json:"unset_deploy_secret,omitempty"`          // (Write-Only) When true, unsets the deploy secret to allow unauthenticated access to the webhook deploy endpoint.
  PullRequestMode          *PullRequestModeType `json:"pull_request_mode,omitempty"`            // The git pull request policy for this project. Valid values are: "off", "links", "recommended", "required".
  ValidationRequired       *bool                `json:"validation_required,omitempty"`          // Validation policy: If true, the project must pass validation checks before project changes can be committed to the git repository
  FoldersEnabled           *bool                `json:"folders_enabled,omitempty"`              // If true, folders are enabled for this project
  GitReleaseMgmtEnabled    *bool                `json:"git_release_mgmt_enabled,omitempty"`     // If true, advanced git release management is enabled for this project
  AllowWarnings            *bool                `json:"allow_warnings,omitempty"`               // Validation policy: If true, the project can be committed with warnings when `validation_required` is true. (`allow_warnings` does nothing if `validation_required` is false).
  IsExample                *bool                `json:"is_example,omitempty"`                   // If true the project is an example project and cannot be modified
}


type ProjectError struct {
  Code             *string                 `json:"code,omitempty"`               // A stable token that uniquely identifies this class of error, ignoring parameter values. Error message text may vary due to parameters or localization, but error codes do not. For example, a "File not found" error will have the same error code regardless of the filename in question or the user's display language
  Severity         *string                 `json:"severity,omitempty"`           // Severity: fatal, error, warning, info, success
  Kind             *string                 `json:"kind,omitempty"`               // Error classification: syntax, deprecation, model_configuration, etc
  Message          *string                 `json:"message,omitempty"`            // Error message which may contain information such as dashboard or model names that may be considered sensitive in some use cases. Avoid storing or sending this message outside of Looker
  FieldName        *string                 `json:"field_name,omitempty"`         // The field associated with this error
  FilePath         *string                 `json:"file_path,omitempty"`          // Name of the file containing this error
  LineNumber       *int64                  `json:"line_number,omitempty"`        // Line number in the file of this error
  ModelId          *string                 `json:"model_id,omitempty"`           // The model associated with this error
  Explore          *string                 `json:"explore,omitempty"`            // The explore associated with this error
  HelpUrl          *string                 `json:"help_url,omitempty"`           // A link to Looker documentation about this error
  Params           *map[string]interface{} `json:"params,omitempty"`             // Error parameters
  SanitizedMessage *string                 `json:"sanitized_message,omitempty"`  // A version of the error message that does not contain potentially sensitive information. Suitable for situations in which messages are stored or sent to consumers outside of Looker, such as external logs. Sanitized messages will display "(?)" where sensitive information would appear in the corresponding non-sanitized message
}


type ProjectFile struct {
  Can       *map[string]bool `json:"can,omitempty"`         // Operations the current user is able to perform on this object
  Id        *string          `json:"id,omitempty"`          // An opaque token uniquely identifying a file within a project. Avoid parsing or decomposing the text of this token. This token is stable within a Looker release but may change between Looker releases
  Path      *string          `json:"path,omitempty"`        // Path, file name, and extension of the file relative to the project root directory
  Title     *string          `json:"title,omitempty"`       // Display name
  Type      *string          `json:"type,omitempty"`        // File type: model, view, etc
  Extension *string          `json:"extension,omitempty"`   // The extension of the file: .view.lkml, .model.lkml, etc
  MimeType  *string          `json:"mime_type,omitempty"`   // File mime type
  Editable  *bool            `json:"editable,omitempty"`    // State of editability for the file.
  GitStatus *GitStatus       `json:"git_status,omitempty"` 
}


type ProjectValidation struct {
  Errors             *[]ProjectError       `json:"errors,omitempty"`                // A list of project errors
  ProjectDigest      *string               `json:"project_digest,omitempty"`        // A hash value computed from the project's current state
  ModelsNotValidated *[]ModelsNotValidated `json:"models_not_validated,omitempty"`  // A list of models which were not fully validated
  ComputationTime    *float32              `json:"computation_time,omitempty"`      // Duration of project validation in seconds
}


type ProjectValidationCache struct {
  Errors             *[]ProjectError       `json:"errors,omitempty"`                // A list of project errors
  ProjectDigest      *string               `json:"project_digest,omitempty"`        // A hash value computed from the project's current state
  ModelsNotValidated *[]ModelsNotValidated `json:"models_not_validated,omitempty"`  // A list of models which were not fully validated
  ComputationTime    *float32              `json:"computation_time,omitempty"`      // Duration of project validation in seconds
  Stale              *bool                 `json:"stale,omitempty"`                 // If true, the cached project validation results are no longer accurate because the project has changed since the cached results were calculated
}


type ProjectWorkspace struct {
  Can         *map[string]bool `json:"can,omitempty"`           // Operations the current user is able to perform on this object
  ProjectId   *string          `json:"project_id,omitempty"`    // The id of the project
  WorkspaceId *string          `json:"workspace_id,omitempty"`  // The id of the local workspace containing the project files
  GitStatus   *string          `json:"git_status,omitempty"`    // The status of the local git directory
  GitHead     *string          `json:"git_head,omitempty"`      // Git head revision name
  GitBranch   *GitBranch       `json:"git_branch,omitempty"`   
  LookmlType  *string          `json:"lookml_type,omitempty"`   // The lookml syntax used by all files in this project
}

type PullRequestModeType string
const PullRequestModeType_Off         PullRequestModeType = "off"
const PullRequestModeType_Links       PullRequestModeType = "links"
const PullRequestModeType_Recommended PullRequestModeType = "recommended"
const PullRequestModeType_Required    PullRequestModeType = "required"



type Query struct {
  Can                  *map[string]bool        `json:"can,omitempty"`                     // Operations the current user is able to perform on this object
  Id                   *int64                  `json:"id,omitempty"`                      // Unique Id
  Model                string                  `json:"model"`                             // Model
  View                 string                  `json:"view"`                              // Explore Name
  Fields               *[]string               `json:"fields,omitempty"`                  // Fields
  Pivots               *[]string               `json:"pivots,omitempty"`                  // Pivots
  FillFields           *[]string               `json:"fill_fields,omitempty"`             // Fill Fields
  Filters              *map[string]interface{} `json:"filters,omitempty"`                 // Filters
  FilterExpression     *string                 `json:"filter_expression,omitempty"`       // Filter Expression
  Sorts                *[]string               `json:"sorts,omitempty"`                   // Sorting for the query results. Use the format `["view.field", ...]` to sort on fields in ascending order. Use the format `["view.field desc", ...]` to sort on fields in descending order. Use `["__UNSORTED__"]` (2 underscores before and after) to disable sorting entirely. Empty sorts `[]` will trigger a default sort.
  Limit                *string                 `json:"limit,omitempty"`                   // Limit
  ColumnLimit          *string                 `json:"column_limit,omitempty"`            // Column Limit
  Total                *bool                   `json:"total,omitempty"`                   // Total
  RowTotal             *string                 `json:"row_total,omitempty"`               // Raw Total
  Subtotals            *[]string               `json:"subtotals,omitempty"`               // Fields on which to run subtotals
  Runtime              *float64                `json:"runtime,omitempty"`                 // Runtime
  VisConfig            *map[string]interface{} `json:"vis_config,omitempty"`              // Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
  FilterConfig         *map[string]interface{} `json:"filter_config,omitempty"`           // The filter_config represents the state of the filter UI on the explore page for a given query. When running a query via the Looker UI, this parameter takes precedence over "filters". When creating a query or modifying an existing query, "filter_config" should be set to null. Setting it to any other value could cause unexpected filtering behavior. The format should be considered opaque.
  VisibleUiSections    *string                 `json:"visible_ui_sections,omitempty"`     // Visible UI Sections
  Slug                 *string                 `json:"slug,omitempty"`                    // Slug
  DynamicFields        *string                 `json:"dynamic_fields,omitempty"`          // Dynamic Fields
  ClientId             *string                 `json:"client_id,omitempty"`               // Client Id: used to generate shortened explore URLs. If set by client, must be a unique 22 character alphanumeric string. Otherwise one will be generated.
  ShareUrl             *string                 `json:"share_url,omitempty"`               // Share Url
  ExpandedShareUrl     *string                 `json:"expanded_share_url,omitempty"`      // Expanded Share Url
  Url                  *string                 `json:"url,omitempty"`                     // Expanded Url
  QueryTimezone        *string                 `json:"query_timezone,omitempty"`          // Query Timezone
  HasTableCalculations *bool                   `json:"has_table_calculations,omitempty"`  // Has Table Calculations
}


type QueryTask struct {
  Can              *map[string]bool `json:"can,omitempty"`                 // Operations the current user is able to perform on this object
  Id               *string          `json:"id,omitempty"`                  // Unique Id
  QueryId          *int64           `json:"query_id,omitempty"`            // Id of query
  Query            *Query           `json:"query,omitempty"`              
  GenerateLinks    *bool            `json:"generate_links,omitempty"`      // whether or not to generate links in the query response.
  ForceProduction  *bool            `json:"force_production,omitempty"`    // Use production models to run query (even is user is in dev mode).
  PathPrefix       *string          `json:"path_prefix,omitempty"`         // Prefix to use for drill links.
  Cache            *bool            `json:"cache,omitempty"`               // Whether or not to use the cache
  ServerTableCalcs *bool            `json:"server_table_calcs,omitempty"`  // Whether or not to run table calculations on the server
  CacheOnly        *bool            `json:"cache_only,omitempty"`          // Retrieve any results from cache even if the results have expired.
  CacheKey         *string          `json:"cache_key,omitempty"`           // cache key used to cache query.
  Status           *string          `json:"status,omitempty"`              // Status of query task.
  Source           *string          `json:"source,omitempty"`              // Source of query task.
  Runtime          *float32         `json:"runtime,omitempty"`             // Runtime of prior queries.
  RebuildPdts      *bool            `json:"rebuild_pdts,omitempty"`        // Rebuild PDTS used in query.
  ResultSource     *string          `json:"result_source,omitempty"`       // Source of the results of the query.
  LookId           *int64           `json:"look_id,omitempty"`             // Id of look associated with query.
  DashboardId      *string          `json:"dashboard_id,omitempty"`        // Id of dashboard associated with query.
  ResultFormat     *string          `json:"result_format,omitempty"`       // The data format of the query results.
}


type RenderTask struct {
  Can               *map[string]bool `json:"can,omitempty"`                  // Operations the current user is able to perform on this object
  CreatedAt         *string          `json:"created_at,omitempty"`           // Date/Time render task was created
  DashboardFilters  *string          `json:"dashboard_filters,omitempty"`    // Filter values to apply to the dashboard queries, in URL query format
  DashboardId       *int64           `json:"dashboard_id,omitempty"`         // Id of dashboard to render
  DashboardStyle    *string          `json:"dashboard_style,omitempty"`      // Dashboard layout style: single_column or tiled
  FinalizedAt       *string          `json:"finalized_at,omitempty"`         // Date/Time render task was completed
  Height            *int64           `json:"height,omitempty"`               // Output height in pixels. Flowed layouts may ignore this value.
  Id                *string          `json:"id,omitempty"`                   // Id of this render task
  LookId            *int64           `json:"look_id,omitempty"`              // Id of look to render
  LookmlDashboardId *string          `json:"lookml_dashboard_id,omitempty"`  // Id of lookml dashboard to render
  QueryId           *int64           `json:"query_id,omitempty"`             // Id of query to render
  QueryRuntime      *float64         `json:"query_runtime,omitempty"`        // Number of seconds elapsed running queries
  RenderRuntime     *float64         `json:"render_runtime,omitempty"`       // Number of seconds elapsed rendering data
  ResultFormat      *string          `json:"result_format,omitempty"`        // Output format: pdf, png, or jpg
  Runtime           *float64         `json:"runtime,omitempty"`              // Total seconds elapsed for render task
  Status            *string          `json:"status,omitempty"`               // Render task status: enqueued_for_query, querying, enqueued_for_render, rendering, success, failure
  StatusDetail      *string          `json:"status_detail,omitempty"`        // Additional information about the current status
  UserId            *int64           `json:"user_id,omitempty"`              // The user account permissions in which the render task will execute
  Width             *int64           `json:"width,omitempty"`                // Output width in pixels
}


type RepositoryCredential struct {
  Can           *map[string]bool `json:"can,omitempty"`              // Operations the current user is able to perform on this object
  Id            *string          `json:"id,omitempty"`               // Unique Id
  RootProjectId *string          `json:"root_project_id,omitempty"`  // Root project Id
  RemoteUrl     *string          `json:"remote_url,omitempty"`       // Git remote repository url
  GitUsername   *string          `json:"git_username,omitempty"`     // Git username for HTTPS authentication.
  GitPassword   *string          `json:"git_password,omitempty"`     // (Write-Only) Git password for HTTPS authentication.
  SshPublicKey  *string          `json:"ssh_public_key,omitempty"`   // Public deploy key for SSH authentication.
  IsConfigured  *bool            `json:"is_configured,omitempty"`    // Whether the credentials have been configured for the Git Repository.
}

// Dynamically generated request type for active_themes
type RequestActiveThemes struct {
  Name   *string    `json:"name,omitempty"`    // Name of theme
  Ts     *time.Time `json:"ts,omitempty"`      // Timestamp representing the target datetime for the active period. Defaults to 'now'
  Fields *string    `json:"fields,omitempty"`  // Requested fields.
}

// Dynamically generated request type for all_groups
type RequestAllGroups struct {
  Fields                  *string         `json:"fields,omitempty"`                       // Requested fields.
  Page                    *int64          `json:"page,omitempty"`                         // Requested page.
  PerPage                 *int64          `json:"per_page,omitempty"`                     // Results per page.
  Sorts                   *string         `json:"sorts,omitempty"`                        // Fields to sort by.
  Ids                     *rtl.DelimInt64 `json:"ids,omitempty"`                          // Optional of ids to get specific groups.
  ContentMetadataId       *int64          `json:"content_metadata_id,omitempty"`          // Id of content metadata to which groups must have access.
  CanAddToContentMetadata *bool           `json:"can_add_to_content_metadata,omitempty"`  // Select only groups that either can/cannot be given access to content.
}

// Dynamically generated request type for all_group_users
type RequestAllGroupUsers struct {
  GroupId int64   `json:"group_id"`            // Id of group
  Fields  *string `json:"fields,omitempty"`    // Requested fields.
  Page    *int64  `json:"page,omitempty"`      // Requested page.
  PerPage *int64  `json:"per_page,omitempty"`  // Results per page.
  Sorts   *string `json:"sorts,omitempty"`     // Fields to sort by.
}

// Dynamically generated request type for all_homepage_items
type RequestAllHomepageItems struct {
  Fields            *string `json:"fields,omitempty"`               // Requested fields.
  Sorts             *string `json:"sorts,omitempty"`                // Fields to sort by.
  HomepageSectionId *string `json:"homepage_section_id,omitempty"`  // Filter to a specific homepage section
}

// Dynamically generated request type for all_homepage_sections
type RequestAllHomepageSections struct {
  Fields *string `json:"fields,omitempty"`  // Requested fields.
  Sorts  *string `json:"sorts,omitempty"`   // Fields to sort by.
}

// Dynamically generated request type for all_integrations
type RequestAllIntegrations struct {
  Fields           *string `json:"fields,omitempty"`              // Requested fields.
  IntegrationHubId *string `json:"integration_hub_id,omitempty"`  // Filter to a specific provider
}

// Dynamically generated request type for all_roles
type RequestAllRoles struct {
  Fields *string         `json:"fields,omitempty"`  // Requested fields.
  Ids    *rtl.DelimInt64 `json:"ids,omitempty"`     // Optional list of ids to get specific roles.
}

// Dynamically generated request type for all_scheduled_plans
type RequestAllScheduledPlans struct {
  UserId   *int64  `json:"user_id,omitempty"`    // Return scheduled plans belonging to this user_id. If not provided, returns scheduled plans owned by the caller.
  Fields   *string `json:"fields,omitempty"`     // Comma delimited list of field names. If provided, only the fields specified will be included in the response
  AllUsers *bool   `json:"all_users,omitempty"`  // Return scheduled plans belonging to all users (caller needs see_schedules permission)
}

// Dynamically generated request type for all_users
type RequestAllUsers struct {
  Fields  *string         `json:"fields,omitempty"`    // Requested fields.
  Page    *int64          `json:"page,omitempty"`      // Requested page.
  PerPage *int64          `json:"per_page,omitempty"`  // Results per page.
  Sorts   *string         `json:"sorts,omitempty"`     // Fields to sort by.
  Ids     *rtl.DelimInt64 `json:"ids,omitempty"`       // Optional list of ids to get specific users.
}

// Dynamically generated request type for create_dashboard_render_task
type RequestCreateDashboardRenderTask struct {
  DashboardId  int64                     `json:"dashboard_id"`              // Id of dashboard to render
  ResultFormat string                    `json:"result_format"`             // Output type: pdf, png, or jpg
  Body         CreateDashboardRenderTask `json:"body"`                     
  Width        int64                     `json:"width"`                     // Output width in pixels
  Height       int64                     `json:"height"`                    // Output height in pixels
  Fields       *string                   `json:"fields,omitempty"`          // Requested fields.
  PdfPaperSize *string                   `json:"pdf_paper_size,omitempty"`  // Paper size for pdf
  PdfLandscape *bool                     `json:"pdf_landscape,omitempty"`   // Whether to render pdf in landscape
}

// Dynamically generated request type for create_lookml_dashboard_render_task
type RequestCreateLookmlDashboardRenderTask struct {
  DashboardId  string                    `json:"dashboard_id"`              // Id of lookml dashboard to render
  ResultFormat string                    `json:"result_format"`             // Output type: pdf, png, or jpg
  Body         CreateDashboardRenderTask `json:"body"`                     
  Width        int64                     `json:"width"`                     // Output width in pixels
  Height       int64                     `json:"height"`                    // Output height in pixels
  Fields       *string                   `json:"fields,omitempty"`          // Requested fields.
  PdfPaperSize *string                   `json:"pdf_paper_size,omitempty"`  // Paper size for pdf
  PdfLandscape *bool                     `json:"pdf_landscape,omitempty"`   // Whether to render pdf in landscape
}

// Dynamically generated request type for create_query_task
type RequestCreateQueryTask struct {
  Body               WriteCreateQueryTask `json:"body"`                           
  Limit              *int64               `json:"limit,omitempty"`                 // Row limit (may override the limit in the saved query).
  ApplyFormatting    *bool                `json:"apply_formatting,omitempty"`      // Apply model-specified formatting to each result.
  ApplyVis           *bool                `json:"apply_vis,omitempty"`             // Apply visualization options to results.
  Cache              *bool                `json:"cache,omitempty"`                 // Get results from cache if available.
  ImageWidth         *int64               `json:"image_width,omitempty"`           // Render width for image formats.
  ImageHeight        *int64               `json:"image_height,omitempty"`          // Render height for image formats.
  GenerateDrillLinks *bool                `json:"generate_drill_links,omitempty"`  // Generate drill links (only applicable to 'json_detail' format.
  ForceProduction    *bool                `json:"force_production,omitempty"`      // Force use of production models even if the user is in development mode.
  CacheOnly          *bool                `json:"cache_only,omitempty"`            // Retrieve any results from cache even if the results have expired.
  PathPrefix         *string              `json:"path_prefix,omitempty"`           // Prefix to use for drill links (url encoded).
  RebuildPdts        *bool                `json:"rebuild_pdts,omitempty"`          // Rebuild PDTS used in query.
  ServerTableCalcs   *bool                `json:"server_table_calcs,omitempty"`    // Perform table calculations on query results
  Fields             *string              `json:"fields,omitempty"`                // Requested fields
}

// Dynamically generated request type for create_user_credentials_email_password_reset
type RequestCreateUserCredentialsEmailPasswordReset struct {
  UserId  int64   `json:"user_id"`            // Id of user
  Expires *bool   `json:"expires,omitempty"`  // Expiring token.
  Fields  *string `json:"fields,omitempty"`   // Requested fields.
}

// Dynamically generated request type for folder_children
type RequestFolderChildren struct {
  FolderId string  `json:"folder_id"`           // Id of folder
  Fields   *string `json:"fields,omitempty"`    // Requested fields.
  Page     *int64  `json:"page,omitempty"`      // Requested page.
  PerPage  *int64  `json:"per_page,omitempty"`  // Results per page.
  Sorts    *string `json:"sorts,omitempty"`     // Fields to sort by.
}

// Dynamically generated request type for folder_children_search
type RequestFolderChildrenSearch struct {
  FolderId string  `json:"folder_id"`         // Id of folder
  Fields   *string `json:"fields,omitempty"`  // Requested fields.
  Sorts    *string `json:"sorts,omitempty"`   // Fields to sort by.
  Name     *string `json:"name,omitempty"`    // Match folder name.
}

// Dynamically generated request type for login
type RequestLogin struct {
  ClientId     *string `json:"client_id,omitempty"`      // client_id part of API3 Key.
  ClientSecret *string `json:"client_secret,omitempty"`  // client_secret part of API3 Key.
}

// Dynamically generated request type for role_users
type RequestRoleUsers struct {
  RoleId                int64   `json:"role_id"`                            // id of user
  Fields                *string `json:"fields,omitempty"`                   // Requested fields.
  DirectAssociationOnly *bool   `json:"direct_association_only,omitempty"`  // Get only users associated directly with the role: exclude those only associated through groups.
}

// Dynamically generated request type for run_inline_query
type RequestRunInlineQuery struct {
  ResultFormat       string     `json:"result_format"`                   // Format of result
  Body               WriteQuery `json:"body"`                           
  Limit              *int64     `json:"limit,omitempty"`                 // Row limit (may override the limit in the saved query).
  ApplyFormatting    *bool      `json:"apply_formatting,omitempty"`      // Apply model-specified formatting to each result.
  ApplyVis           *bool      `json:"apply_vis,omitempty"`             // Apply visualization options to results.
  Cache              *bool      `json:"cache,omitempty"`                 // Get results from cache if available.
  ImageWidth         *int64     `json:"image_width,omitempty"`           // Render width for image formats.
  ImageHeight        *int64     `json:"image_height,omitempty"`          // Render height for image formats.
  GenerateDrillLinks *bool      `json:"generate_drill_links,omitempty"`  // Generate drill links (only applicable to 'json_detail' format.
  ForceProduction    *bool      `json:"force_production,omitempty"`      // Force use of production models even if the user is in development mode.
  CacheOnly          *bool      `json:"cache_only,omitempty"`            // Retrieve any results from cache even if the results have expired.
  PathPrefix         *string    `json:"path_prefix,omitempty"`           // Prefix to use for drill links (url encoded).
  RebuildPdts        *bool      `json:"rebuild_pdts,omitempty"`          // Rebuild PDTS used in query.
  ServerTableCalcs   *bool      `json:"server_table_calcs,omitempty"`    // Perform table calculations on query results
}

// Dynamically generated request type for run_look
type RequestRunLook struct {
  LookId             int64   `json:"look_id"`                         // Id of look
  ResultFormat       string  `json:"result_format"`                   // Format of result
  Limit              *int64  `json:"limit,omitempty"`                 // Row limit (may override the limit in the saved query).
  ApplyFormatting    *bool   `json:"apply_formatting,omitempty"`      // Apply model-specified formatting to each result.
  ApplyVis           *bool   `json:"apply_vis,omitempty"`             // Apply visualization options to results.
  Cache              *bool   `json:"cache,omitempty"`                 // Get results from cache if available.
  ImageWidth         *int64  `json:"image_width,omitempty"`           // Render width for image formats.
  ImageHeight        *int64  `json:"image_height,omitempty"`          // Render height for image formats.
  GenerateDrillLinks *bool   `json:"generate_drill_links,omitempty"`  // Generate drill links (only applicable to 'json_detail' format.
  ForceProduction    *bool   `json:"force_production,omitempty"`      // Force use of production models even if the user is in development mode.
  CacheOnly          *bool   `json:"cache_only,omitempty"`            // Retrieve any results from cache even if the results have expired.
  PathPrefix         *string `json:"path_prefix,omitempty"`           // Prefix to use for drill links (url encoded).
  RebuildPdts        *bool   `json:"rebuild_pdts,omitempty"`          // Rebuild PDTS used in query.
  ServerTableCalcs   *bool   `json:"server_table_calcs,omitempty"`    // Perform table calculations on query results
}

// Dynamically generated request type for run_lookml_test
type RequestRunLookmlTest struct {
  ProjectId string  `json:"project_id"`         // Project Id
  FileId    *string `json:"file_id,omitempty"`  // File Name
  Test      *string `json:"test,omitempty"`     // Test Name
  Model     *string `json:"model,omitempty"`    // Model Name
}

// Dynamically generated request type for run_query
type RequestRunQuery struct {
  QueryId            int64   `json:"query_id"`                        // Id of query
  ResultFormat       string  `json:"result_format"`                   // Format of result
  Limit              *int64  `json:"limit,omitempty"`                 // Row limit (may override the limit in the saved query).
  ApplyFormatting    *bool   `json:"apply_formatting,omitempty"`      // Apply model-specified formatting to each result.
  ApplyVis           *bool   `json:"apply_vis,omitempty"`             // Apply visualization options to results.
  Cache              *bool   `json:"cache,omitempty"`                 // Get results from cache if available.
  ImageWidth         *int64  `json:"image_width,omitempty"`           // Render width for image formats.
  ImageHeight        *int64  `json:"image_height,omitempty"`          // Render height for image formats.
  GenerateDrillLinks *bool   `json:"generate_drill_links,omitempty"`  // Generate drill links (only applicable to 'json_detail' format.
  ForceProduction    *bool   `json:"force_production,omitempty"`      // Force use of production models even if the user is in development mode.
  CacheOnly          *bool   `json:"cache_only,omitempty"`            // Retrieve any results from cache even if the results have expired.
  PathPrefix         *string `json:"path_prefix,omitempty"`           // Prefix to use for drill links (url encoded).
  RebuildPdts        *bool   `json:"rebuild_pdts,omitempty"`          // Rebuild PDTS used in query.
  ServerTableCalcs   *bool   `json:"server_table_calcs,omitempty"`    // Perform table calculations on query results
}

// Dynamically generated request type for scheduled_plans_for_dashboard
type RequestScheduledPlansForDashboard struct {
  DashboardId int64   `json:"dashboard_id"`         // Dashboard Id
  UserId      *int64  `json:"user_id,omitempty"`    // User Id (default is requesting user if not specified)
  AllUsers    *bool   `json:"all_users,omitempty"`  // Return scheduled plans belonging to all users for the dashboard
  Fields      *string `json:"fields,omitempty"`     // Requested fields.
}

// Dynamically generated request type for scheduled_plans_for_look
type RequestScheduledPlansForLook struct {
  LookId   int64   `json:"look_id"`              // Look Id
  UserId   *int64  `json:"user_id,omitempty"`    // User Id (default is requesting user if not specified)
  Fields   *string `json:"fields,omitempty"`     // Requested fields.
  AllUsers *bool   `json:"all_users,omitempty"`  // Return scheduled plans belonging to all users for the look
}

// Dynamically generated request type for scheduled_plans_for_lookml_dashboard
type RequestScheduledPlansForLookmlDashboard struct {
  LookmlDashboardId int64   `json:"lookml_dashboard_id"`  // LookML Dashboard Id
  UserId            *int64  `json:"user_id,omitempty"`    // User Id (default is requesting user if not specified)
  Fields            *string `json:"fields,omitempty"`     // Requested fields.
  AllUsers          *bool   `json:"all_users,omitempty"`  // Return scheduled plans belonging to all users for the dashboard
}

// Dynamically generated request type for search_content_favorites
type RequestSearchContentFavorites struct {
  Id                *int64  `json:"id,omitempty"`                   // Match content favorite id(s)
  UserId            *string `json:"user_id,omitempty"`              // Match user id(s).To create a list of multiple ids, use commas as separators
  ContentMetadataId *string `json:"content_metadata_id,omitempty"`  // Match content metadata id(s).To create a list of multiple ids, use commas as separators
  DashboardId       *string `json:"dashboard_id,omitempty"`         // Match dashboard id(s).To create a list of multiple ids, use commas as separators
  LookId            *string `json:"look_id,omitempty"`              // Match look id(s).To create a list of multiple ids, use commas as separators
  BoardId           *string `json:"board_id,omitempty"`             // Match board id(s).To create a list of multiple ids, use commas as separators
  Limit             *int64  `json:"limit,omitempty"`                // Number of results to return. (used with offset)
  Offset            *int64  `json:"offset,omitempty"`               // Number of results to skip before returning any. (used with limit)
  Sorts             *string `json:"sorts,omitempty"`                // Fields to sort by.
  Fields            *string `json:"fields,omitempty"`               // Requested fields.
  FilterOr          *bool   `json:"filter_or,omitempty"`            // Combine given search criteria in a boolean OR expression
}

// Dynamically generated request type for search_content_views
type RequestSearchContentViews struct {
  ViewCount         *string `json:"view_count,omitempty"`           // Match view count
  GroupId           *string `json:"group_id,omitempty"`             // Match Group Id
  LookId            *string `json:"look_id,omitempty"`              // Match look_id
  DashboardId       *string `json:"dashboard_id,omitempty"`         // Match dashboard_id
  ContentMetadataId *string `json:"content_metadata_id,omitempty"`  // Match content metadata id
  StartOfWeekDate   *string `json:"start_of_week_date,omitempty"`   // Match start of week date
  AllTime           *bool   `json:"all_time,omitempty"`             // True if only all time view records should be returned
  UserId            *string `json:"user_id,omitempty"`              // Match user id
  Fields            *string `json:"fields,omitempty"`               // Requested fields
  Limit             *int64  `json:"limit,omitempty"`                // Number of results to return. Use with `offset` to manage pagination of results
  Offset            *int64  `json:"offset,omitempty"`               // Number of results to skip before returning data
  Sorts             *string `json:"sorts,omitempty"`                // Fields to sort by
  FilterOr          *bool   `json:"filter_or,omitempty"`            // Combine given search criteria in a boolean OR expression
}

// Dynamically generated request type for search_dashboard_elements
type RequestSearchDashboardElements struct {
  DashboardId *int64  `json:"dashboard_id,omitempty"`  // Select elements that refer to a given dashboard id
  LookId      *int64  `json:"look_id,omitempty"`       // Select elements that refer to a given look id
  Title       *string `json:"title,omitempty"`         // Match the title of element
  Deleted     *bool   `json:"deleted,omitempty"`       // Select soft-deleted dashboard elements
  Fields      *string `json:"fields,omitempty"`        // Requested fields.
  FilterOr    *bool   `json:"filter_or,omitempty"`     // Combine given search criteria in a boolean OR expression
  Sorts       *string `json:"sorts,omitempty"`         // Fields to sort by. Sortable fields: [:look_id, :dashboard_id, :deleted, :title]
}

// Dynamically generated request type for search_dashboards
type RequestSearchDashboards struct {
  Id                *string `json:"id,omitempty"`                   // Match dashboard id.
  Slug              *string `json:"slug,omitempty"`                 // Match dashboard slug.
  Title             *string `json:"title,omitempty"`                // Match Dashboard title.
  Description       *string `json:"description,omitempty"`          // Match Dashboard description.
  ContentFavoriteId *string `json:"content_favorite_id,omitempty"`  // Filter on a content favorite id.
  SpaceId           *string `json:"space_id,omitempty"`             // Filter on a particular space.
  Deleted           *string `json:"deleted,omitempty"`              // Filter on dashboards deleted status.
  UserId            *string `json:"user_id,omitempty"`              // Filter on dashboards created by a particular user.
  ViewCount         *string `json:"view_count,omitempty"`           // Filter on a particular value of view_count
  ContentMetadataId *string `json:"content_metadata_id,omitempty"`  // Filter on a content favorite id.
  Curate            *bool   `json:"curate,omitempty"`               // Exclude items that exist only in personal spaces other than the users
  LastViewedAt      *string `json:"last_viewed_at,omitempty"`       // Select dashboards based on when they were last viewed
  Fields            *string `json:"fields,omitempty"`               // Requested fields.
  Page              *int64  `json:"page,omitempty"`                 // Requested page.
  PerPage           *int64  `json:"per_page,omitempty"`             // Results per page.
  Limit             *int64  `json:"limit,omitempty"`                // Number of results to return. (used with offset and takes priority over page and per_page)
  Offset            *int64  `json:"offset,omitempty"`               // Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
  Sorts             *string `json:"sorts,omitempty"`                // One or more fields to sort by. Sortable fields: [:title, :user_id, :id, :created_at, :space_id, :description, :view_count, :favorite_count, :slug, :content_favorite_id, :content_metadata_id, :deleted, :deleted_at, :last_viewed_at, :last_accessed_at]
  FilterOr          *bool   `json:"filter_or,omitempty"`            // Combine given search criteria in a boolean OR expression
}

// Dynamically generated request type for search_groups
type RequestSearchGroups struct {
  Fields             *string `json:"fields,omitempty"`               // Requested fields.
  Limit              *int64  `json:"limit,omitempty"`                // Number of results to return (used with `offset`).
  Offset             *int64  `json:"offset,omitempty"`               // Number of results to skip before returning any (used with `limit`).
  Sorts              *string `json:"sorts,omitempty"`                // Fields to sort by.
  FilterOr           *bool   `json:"filter_or,omitempty"`            // Combine given search criteria in a boolean OR expression
  Id                 *int64  `json:"id,omitempty"`                   // Match group id.
  Name               *string `json:"name,omitempty"`                 // Match group name.
  ExternalGroupId    *bool   `json:"external_group_id,omitempty"`    // Match group external_group_id.
  ExternallyManaged  *bool   `json:"externally_managed,omitempty"`   // Match group externally_managed.
  ExternallyOrphaned *bool   `json:"externally_orphaned,omitempty"`  // Match group externally_orphaned.
}

// Dynamically generated request type for search_homepages
type RequestSearchHomepages struct {
  Title     *string `json:"title,omitempty"`       // Matches homepage title.
  CreatedAt *string `json:"created_at,omitempty"`  // Matches the timestamp for when the homepage was created.
  FirstName *string `json:"first_name,omitempty"`  // The first name of the user who created this homepage.
  LastName  *string `json:"last_name,omitempty"`   // The last name of the user who created this homepage.
  Fields    *string `json:"fields,omitempty"`      // Requested fields.
  Favorited *bool   `json:"favorited,omitempty"`   // Return favorited homepages when true.
  CreatorId *string `json:"creator_id,omitempty"`  // Filter on homepages created by a particular user.
  Sorts     *string `json:"sorts,omitempty"`       // The fields to sort the results by
  Page      *int64  `json:"page,omitempty"`        // The page to return.
  PerPage   *int64  `json:"per_page,omitempty"`    // The number of items in the returned page.
  Offset    *int64  `json:"offset,omitempty"`      // The number of items to skip before returning any. (used with limit and takes priority over page and per_page)
  Limit     *int64  `json:"limit,omitempty"`       // The maximum number of items to return. (used with offset and takes priority over page and per_page)
  FilterOr  *bool   `json:"filter_or,omitempty"`   // Combine given search criteria in a boolean OR expression
}

// Dynamically generated request type for search_looks
type RequestSearchLooks struct {
  Id                *string `json:"id,omitempty"`                   // Match look id.
  Title             *string `json:"title,omitempty"`                // Match Look title.
  Description       *string `json:"description,omitempty"`          // Match Look description.
  ContentFavoriteId *string `json:"content_favorite_id,omitempty"`  // Select looks with a particular content favorite id
  SpaceId           *string `json:"space_id,omitempty"`             // Select looks in a particular space.
  UserId            *string `json:"user_id,omitempty"`              // Select looks created by a particular user.
  ViewCount         *string `json:"view_count,omitempty"`           // Select looks with particular view_count value
  Deleted           *bool   `json:"deleted,omitempty"`              // Select soft-deleted looks
  QueryId           *int64  `json:"query_id,omitempty"`             // Select looks that reference a particular query by query_id
  Curate            *bool   `json:"curate,omitempty"`               // Exclude items that exist only in personal spaces other than the users
  LastViewedAt      *string `json:"last_viewed_at,omitempty"`       // Select looks based on when they were last viewed
  Fields            *string `json:"fields,omitempty"`               // Requested fields.
  Page              *int64  `json:"page,omitempty"`                 // Requested page.
  PerPage           *int64  `json:"per_page,omitempty"`             // Results per page.
  Limit             *int64  `json:"limit,omitempty"`                // Number of results to return. (used with offset and takes priority over page and per_page)
  Offset            *int64  `json:"offset,omitempty"`               // Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
  Sorts             *string `json:"sorts,omitempty"`                // One or more fields to sort results by. Sortable fields: [:title, :user_id, :id, :created_at, :space_id, :description, :updated_at, :last_updater_id, :view_count, :favorite_count, :content_favorite_id, :deleted, :deleted_at, :last_viewed_at, :last_accessed_at, :query_id]
  FilterOr          *bool   `json:"filter_or,omitempty"`            // Combine given search criteria in a boolean OR expression
}

// Dynamically generated request type for search_model_sets
type RequestSearchModelSets struct {
  Fields    *string `json:"fields,omitempty"`      // Requested fields.
  Limit     *int64  `json:"limit,omitempty"`       // Number of results to return (used with `offset`).
  Offset    *int64  `json:"offset,omitempty"`      // Number of results to skip before returning any (used with `limit`).
  Sorts     *string `json:"sorts,omitempty"`       // Fields to sort by.
  Id        *int64  `json:"id,omitempty"`          // Match model set id.
  Name      *string `json:"name,omitempty"`        // Match model set name.
  AllAccess *bool   `json:"all_access,omitempty"`  // Match model sets by all_access status.
  BuiltIn   *bool   `json:"built_in,omitempty"`    // Match model sets by built_in status.
  FilterOr  *bool   `json:"filter_or,omitempty"`   // Combine given search criteria in a boolean OR expression.
}

// Dynamically generated request type for search_roles
type RequestSearchRoles struct {
  Fields   *string `json:"fields,omitempty"`     // Requested fields.
  Limit    *int64  `json:"limit,omitempty"`      // Number of results to return (used with `offset`).
  Offset   *int64  `json:"offset,omitempty"`     // Number of results to skip before returning any (used with `limit`).
  Sorts    *string `json:"sorts,omitempty"`      // Fields to sort by.
  Id       *int64  `json:"id,omitempty"`         // Match role id.
  Name     *string `json:"name,omitempty"`       // Match role name.
  BuiltIn  *bool   `json:"built_in,omitempty"`   // Match roles by built_in status.
  FilterOr *bool   `json:"filter_or,omitempty"`  // Combine given search criteria in a boolean OR expression.
}

// Dynamically generated request type for search_spaces
type RequestSearchSpaces struct {
  Fields    *string `json:"fields,omitempty"`      // Requested fields.
  Page      *int64  `json:"page,omitempty"`        // Requested page.
  PerPage   *int64  `json:"per_page,omitempty"`    // Results per page.
  Limit     *int64  `json:"limit,omitempty"`       // Number of results to return. (used with offset and takes priority over page and per_page)
  Offset    *int64  `json:"offset,omitempty"`      // Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
  Sorts     *string `json:"sorts,omitempty"`       // Fields to sort by.
  Name      *string `json:"name,omitempty"`        // Match Space title.
  Id        *int64  `json:"id,omitempty"`          // Match Space id
  ParentId  *string `json:"parent_id,omitempty"`   // Filter on a children of a particular space.
  CreatorId *string `json:"creator_id,omitempty"`  // Filter on spaces created by a particular user.
  FilterOr  *bool   `json:"filter_or,omitempty"`   // Combine given search criteria in a boolean OR expression
}

// Dynamically generated request type for search_themes
type RequestSearchThemes struct {
  Id       *int64     `json:"id,omitempty"`         // Match theme id.
  Name     *string    `json:"name,omitempty"`       // Match theme name.
  BeginAt  *time.Time `json:"begin_at,omitempty"`   // Timestamp for activation.
  EndAt    *time.Time `json:"end_at,omitempty"`     // Timestamp for expiration.
  Limit    *int64     `json:"limit,omitempty"`      // Number of results to return (used with `offset`).
  Offset   *int64     `json:"offset,omitempty"`     // Number of results to skip before returning any (used with `limit`).
  Sorts    *string    `json:"sorts,omitempty"`      // Fields to sort by.
  Fields   *string    `json:"fields,omitempty"`     // Requested fields.
  FilterOr *bool      `json:"filter_or,omitempty"`  // Combine given search criteria in a boolean OR expression
}

// Dynamically generated request type for search_user_login_lockouts
type RequestSearchUserLoginLockouts struct {
  Fields   *string `json:"fields,omitempty"`     // Include only these fields in the response
  Page     *int64  `json:"page,omitempty"`       // Return only page N of paginated results
  PerPage  *int64  `json:"per_page,omitempty"`   // Return N rows of data per page
  Sorts    *string `json:"sorts,omitempty"`      // Fields to sort by.
  AuthType *string `json:"auth_type,omitempty"`  // Auth type user is locked out for (email, ldap, totp, api)
  FullName *string `json:"full_name,omitempty"`  // Match name
  Email    *string `json:"email,omitempty"`      // Match email
  RemoteId *string `json:"remote_id,omitempty"`  // Match remote LDAP ID
  FilterOr *bool   `json:"filter_or,omitempty"`  // Combine given search criteria in a boolean OR expression
}

// Dynamically generated request type for search_users
type RequestSearchUsers struct {
  Fields                 *string `json:"fields,omitempty"`                    // Include only these fields in the response
  Page                   *int64  `json:"page,omitempty"`                      // Return only page N of paginated results
  PerPage                *int64  `json:"per_page,omitempty"`                  // Return N rows of data per page
  Sorts                  *string `json:"sorts,omitempty"`                     // Fields to sort by.
  Id                     *string `json:"id,omitempty"`                        // Match User Id.
  FirstName              *string `json:"first_name,omitempty"`                // Match First name.
  LastName               *string `json:"last_name,omitempty"`                 // Match Last name.
  VerifiedLookerEmployee *bool   `json:"verified_looker_employee,omitempty"`  // Search for user accounts associated with Looker employees
  Email                  *string `json:"email,omitempty"`                     // Search for the user with this email address
  IsDisabled             *bool   `json:"is_disabled,omitempty"`               // Search for disabled user accounts
  FilterOr               *bool   `json:"filter_or,omitempty"`                 // Combine given search criteria in a boolean OR expression
  ContentMetadataId      *string `json:"content_metadata_id,omitempty"`       // Search for users who have access to this content_metadata item
  GroupId                *string `json:"group_id,omitempty"`                  // Search for users who are direct members of this group
}

// Dynamically generated request type for search_users_names
type RequestSearchUsersNames struct {
  Pattern                string  `json:"pattern"`                             // Pattern to match
  Fields                 *string `json:"fields,omitempty"`                    // Include only these fields in the response
  Page                   *int64  `json:"page,omitempty"`                      // Return only page N of paginated results
  PerPage                *int64  `json:"per_page,omitempty"`                  // Return N rows of data per page
  Sorts                  *string `json:"sorts,omitempty"`                     // Fields to sort by
  Id                     *int64  `json:"id,omitempty"`                        // Match User Id
  FirstName              *string `json:"first_name,omitempty"`                // Match First name
  LastName               *string `json:"last_name,omitempty"`                 // Match Last name
  VerifiedLookerEmployee *bool   `json:"verified_looker_employee,omitempty"`  // Match Verified Looker employee
  Email                  *string `json:"email,omitempty"`                     // Match Email Address
  IsDisabled             *bool   `json:"is_disabled,omitempty"`               // Include or exclude disabled accounts in the results
}

// Dynamically generated request type for space_children
type RequestSpaceChildren struct {
  SpaceId string  `json:"space_id"`            // Id of space
  Fields  *string `json:"fields,omitempty"`    // Requested fields.
  Page    *int64  `json:"page,omitempty"`      // Requested page.
  PerPage *int64  `json:"per_page,omitempty"`  // Results per page.
  Sorts   *string `json:"sorts,omitempty"`     // Fields to sort by.
}

// Dynamically generated request type for space_children_search
type RequestSpaceChildrenSearch struct {
  SpaceId string  `json:"space_id"`          // Id of space
  Fields  *string `json:"fields,omitempty"`  // Requested fields.
  Sorts   *string `json:"sorts,omitempty"`   // Fields to sort by.
  Name    *string `json:"name,omitempty"`    // Match Space name.
}

// Dynamically generated request type for user_attribute_user_values
type RequestUserAttributeUserValues struct {
  UserId           int64           `json:"user_id"`                       // Id of user
  Fields           *string         `json:"fields,omitempty"`              // Requested fields.
  UserAttributeIds *rtl.DelimInt64 `json:"user_attribute_ids,omitempty"`  // Specific user attributes to request. Omit or leave blank to request all user attributes.
  AllValues        *bool           `json:"all_values,omitempty"`          // If true, returns all values in the search path instead of just the first value found. Useful for debugging group precedence.
  IncludeUnset     *bool           `json:"include_unset,omitempty"`       // If true, returns an empty record for each requested attribute that has no user, group, or default value.
}

// Dynamically generated request type for user_roles
type RequestUserRoles struct {
  UserId                int64   `json:"user_id"`                            // id of user
  Fields                *string `json:"fields,omitempty"`                   // Requested fields.
  DirectAssociationOnly *bool   `json:"direct_association_only,omitempty"`  // Get only roles associated directly with the user: exclude those only associated through groups.
}

type ResultFormatType string
const ResultFormatType_Json       ResultFormatType = "json"
const ResultFormatType_JsonDetail ResultFormatType = "json_detail"
const ResultFormatType_JsonFe     ResultFormatType = "json_fe"
const ResultFormatType_Csv        ResultFormatType = "csv"
const ResultFormatType_Html       ResultFormatType = "html"
const ResultFormatType_Md         ResultFormatType = "md"
const ResultFormatType_Txt        ResultFormatType = "txt"
const ResultFormatType_Xlsx       ResultFormatType = "xlsx"
const ResultFormatType_Gsxml      ResultFormatType = "gsxml"



type ResultMakerFilterables struct {
  Model  *string                         `json:"model,omitempty"`   // The model this filterable comes from (used for field suggestions).
  View   *string                         `json:"view,omitempty"`    // The view this filterable comes from (used for field suggestions).
  Name   *string                         `json:"name,omitempty"`    // The name of the filterable thing (Query or Merged Results).
  Listen *[]ResultMakerFilterablesListen `json:"listen,omitempty"`  // array of dashboard_filter_name: and field: objects.
}


type ResultMakerFilterablesListen struct {
  DashboardFilterName *string `json:"dashboard_filter_name,omitempty"`  // The name of a dashboard filter to listen to.
  Field               *string `json:"field,omitempty"`                  // The name of the field in the filterable to filter with the value of the dashboard filter.
}


type ResultMakerWithIdVisConfigAndDynamicFields struct {
  Id            *int64                    `json:"id,omitempty"`               // Unique Id.
  DynamicFields *string                   `json:"dynamic_fields,omitempty"`   // JSON string of dynamic field information.
  Filterables   *[]ResultMakerFilterables `json:"filterables,omitempty"`      // array of items that can be filtered and information about them.
  Sorts         *[]string                 `json:"sorts,omitempty"`            // Sorts of the constituent Look, Query, or Merge Query
  MergeResultId *string                   `json:"merge_result_id,omitempty"`  // ID of merge result if this is a merge_result.
  Total         *bool                     `json:"total,omitempty"`            // Total of the constituent Look, Query, or Merge Query
  QueryId       *int64                    `json:"query_id,omitempty"`         // ID of query if this is a query.
  SqlQueryId    *string                   `json:"sql_query_id,omitempty"`     // ID of SQL Query if this is a SQL Runner Query
  Query         *Query                    `json:"query,omitempty"`           
  VisConfig     *map[string]interface{}   `json:"vis_config,omitempty"`       // Vis config of the constituent Query, or Merge Query.
}


type Role struct {
  Can             *map[string]bool `json:"can,omitempty"`                // Operations the current user is able to perform on this object
  Id              *int64           `json:"id,omitempty"`                 // Unique Id
  Name            *string          `json:"name,omitempty"`               // Name of Role
  PermissionSet   *PermissionSet   `json:"permission_set,omitempty"`    
  PermissionSetId *int64           `json:"permission_set_id,omitempty"`  // (Write-Only) Id of permission set
  ModelSet        *ModelSet        `json:"model_set,omitempty"`         
  ModelSetId      *int64           `json:"model_set_id,omitempty"`       // (Write-Only) Id of model set
  Url             *url.URL         `json:"url,omitempty"`                // Link to get this item
  UsersUrl        *url.URL         `json:"users_url,omitempty"`          // Link to get list of users with this role
}


type RunningQueries struct {
  Can            *map[string]bool `json:"can,omitempty"`              // Operations the current user is able to perform on this object
  Id             *int64           `json:"id,omitempty"`               // Unique Id
  User           *UserPublic      `json:"user,omitempty"`            
  Query          *Query           `json:"query,omitempty"`           
  SqlQuery       *SqlQuery        `json:"sql_query,omitempty"`       
  Look           *LookBasic       `json:"look,omitempty"`            
  CreatedAt      *string          `json:"created_at,omitempty"`       // Date/Time Query was initiated
  CompletedAt    *string          `json:"completed_at,omitempty"`     // Date/Time Query was completed
  QueryId        *string          `json:"query_id,omitempty"`         // Query Id
  Source         *string          `json:"source,omitempty"`           // Source (look, dashboard, queryrunner, explore, etc.)
  NodeId         *string          `json:"node_id,omitempty"`          // Node Id
  Slug           *string          `json:"slug,omitempty"`             // Slug
  QueryTaskId    *string          `json:"query_task_id,omitempty"`    // ID of a Query Task
  CacheKey       *string          `json:"cache_key,omitempty"`        // Cache Key
  ConnectionName *string          `json:"connection_name,omitempty"`  // Connection
  Dialect        *string          `json:"dialect,omitempty"`          // Dialect
  ConnectionId   *string          `json:"connection_id,omitempty"`    // Connection ID
  Message        *string          `json:"message,omitempty"`          // Additional Information(Error message or verbose status)
  Status         *string          `json:"status,omitempty"`           // Status description
  Runtime        *float64         `json:"runtime,omitempty"`          // Number of seconds elapsed running the Query
  Sql            *string          `json:"sql,omitempty"`              // SQL text of the query as run
}


type SamlConfig struct {
  Can                        *map[string]bool          `json:"can,omitempty"`                            // Operations the current user is able to perform on this object
  Enabled                    *bool                     `json:"enabled,omitempty"`                        // Enable/Disable Saml authentication for the server
  IdpCert                    *string                   `json:"idp_cert,omitempty"`                       // Identity Provider Certificate (provided by IdP)
  IdpUrl                     *string                   `json:"idp_url,omitempty"`                        // Identity Provider Url (provided by IdP)
  IdpIssuer                  *string                   `json:"idp_issuer,omitempty"`                     // Identity Provider Issuer (provided by IdP)
  IdpAudience                *string                   `json:"idp_audience,omitempty"`                   // Identity Provider Audience (set in IdP config). Optional in Looker. Set this only if you want Looker to validate the audience value returned by the IdP.
  AllowedClockDrift          *int64                    `json:"allowed_clock_drift,omitempty"`            // Count of seconds of clock drift to allow when validating timestamps of assertions.
  UserAttributeMapEmail      *string                   `json:"user_attribute_map_email,omitempty"`       // Name of user record attributes used to indicate email address field
  UserAttributeMapFirstName  *string                   `json:"user_attribute_map_first_name,omitempty"`  // Name of user record attributes used to indicate first name
  UserAttributeMapLastName   *string                   `json:"user_attribute_map_last_name,omitempty"`   // Name of user record attributes used to indicate last name
  NewUserMigrationTypes      *string                   `json:"new_user_migration_types,omitempty"`       // Merge first-time saml login to existing user account by email addresses. When a user logs in for the first time via saml this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
  AlternateEmailLoginAllowed *bool                     `json:"alternate_email_login_allowed,omitempty"`  // Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
  TestSlug                   *string                   `json:"test_slug,omitempty"`                      // Slug to identify configurations that are created in order to run a Saml config test
  ModifiedAt                 *string                   `json:"modified_at,omitempty"`                    // When this config was last modified
  ModifiedBy                 *string                   `json:"modified_by,omitempty"`                    // User id of user who last modified this config
  DefaultNewUserRoles        *[]Role                   `json:"default_new_user_roles,omitempty"`         // (Read-only) Roles that will be applied to new users the first time they login via Saml
  DefaultNewUserGroups       *[]Group                  `json:"default_new_user_groups,omitempty"`        // (Read-only) Groups that will be applied to new users the first time they login via Saml
  DefaultNewUserRoleIds      *[]int64                  `json:"default_new_user_role_ids,omitempty"`      // (Write-Only) Array of ids of roles that will be applied to new users the first time they login via Saml
  DefaultNewUserGroupIds     *[]int64                  `json:"default_new_user_group_ids,omitempty"`     // (Write-Only) Array of ids of groups that will be applied to new users the first time they login via Saml
  SetRolesFromGroups         *bool                     `json:"set_roles_from_groups,omitempty"`          // Set user roles in Looker based on groups from Saml
  GroupsAttribute            *string                   `json:"groups_attribute,omitempty"`               // Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
  Groups                     *[]SamlGroupRead          `json:"groups,omitempty"`                         // (Read-only) Array of mappings between Saml Groups and Looker Roles
  GroupsWithRoleIds          *[]SamlGroupWrite         `json:"groups_with_role_ids,omitempty"`           // (Read/Write) Array of mappings between Saml Groups and arrays of Looker Role ids
  AuthRequiresRole           *bool                     `json:"auth_requires_role,omitempty"`             // Users will not be allowed to login at all unless a role for them is found in Saml if set to true
  UserAttributes             *[]SamlUserAttributeRead  `json:"user_attributes,omitempty"`                // (Read-only) Array of mappings between Saml User Attributes and Looker User Attributes
  UserAttributesWithIds      *[]SamlUserAttributeWrite `json:"user_attributes_with_ids,omitempty"`       // (Read/Write) Array of mappings between Saml User Attributes and arrays of Looker User Attribute ids
  GroupsFinderType           *string                   `json:"groups_finder_type,omitempty"`             // Identifier for a strategy for how Looker will find groups in the SAML response. One of ['grouped_attribute_values', 'individual_attributes']
  GroupsMemberValue          *string                   `json:"groups_member_value,omitempty"`            // Value for group attribute used to indicate membership. Used when 'groups_finder_type' is set to 'individual_attributes'
  BypassLoginPage            *bool                     `json:"bypass_login_page,omitempty"`              // Bypass the login page when user authentication is required. Redirect to IdP immediately instead.
  Url                        *url.URL                  `json:"url,omitempty"`                            // Link to get this item
}


type SamlGroupRead struct {
  Id              *int64   `json:"id,omitempty"`                 // Unique Id
  LookerGroupId   *int64   `json:"looker_group_id,omitempty"`    // Unique Id of group in Looker
  LookerGroupName *string  `json:"looker_group_name,omitempty"`  // Name of group in Looker
  Name            *string  `json:"name,omitempty"`               // Name of group in Saml
  Roles           *[]Role  `json:"roles,omitempty"`              // Looker Roles
  Url             *url.URL `json:"url,omitempty"`                // Link to saml config
}


type SamlGroupWrite struct {
  Id              *int64   `json:"id,omitempty"`                 // Unique Id
  LookerGroupId   *int64   `json:"looker_group_id,omitempty"`    // Unique Id of group in Looker
  LookerGroupName *string  `json:"looker_group_name,omitempty"`  // Name of group in Looker
  Name            *string  `json:"name,omitempty"`               // Name of group in Saml
  RoleIds         *[]int64 `json:"role_ids,omitempty"`           // Looker Role Ids
  Url             *url.URL `json:"url,omitempty"`                // Link to saml config
}


type SamlMetadataParseResult struct {
  Can       *map[string]bool `json:"can,omitempty"`         // Operations the current user is able to perform on this object
  IdpIssuer *string          `json:"idp_issuer,omitempty"`  // Identify Provider Issuer
  IdpUrl    *string          `json:"idp_url,omitempty"`     // Identify Provider Url
  IdpCert   *string          `json:"idp_cert,omitempty"`    // Identify Provider Certificate
}


type SamlUserAttributeRead struct {
  Name           *string          `json:"name,omitempty"`             // Name of User Attribute in Saml
  Required       *bool            `json:"required,omitempty"`         // Required to be in Saml assertion for login to be allowed to succeed
  UserAttributes *[]UserAttribute `json:"user_attributes,omitempty"`  // Looker User Attributes
  Url            *url.URL         `json:"url,omitempty"`              // Link to saml config
}


type SamlUserAttributeWrite struct {
  Name             *string  `json:"name,omitempty"`                // Name of User Attribute in Saml
  Required         *bool    `json:"required,omitempty"`            // Required to be in Saml assertion for login to be allowed to succeed
  UserAttributeIds *[]int64 `json:"user_attribute_ids,omitempty"`  // Looker User Attribute Ids
  Url              *url.URL `json:"url,omitempty"`                 // Link to saml config
}


type ScheduledPlan struct {
  Name                     *string                     `json:"name,omitempty"`                        // Name of this scheduled plan
  UserId                   *int64                      `json:"user_id,omitempty"`                     // User Id which owns this scheduled plan
  RunAsRecipient           *bool                       `json:"run_as_recipient,omitempty"`            // Whether schedule is run as recipient (only applicable for email recipients)
  Enabled                  *bool                       `json:"enabled,omitempty"`                     // Whether the ScheduledPlan is enabled
  LookId                   *int64                      `json:"look_id,omitempty"`                     // Id of a look
  DashboardId              *int64                      `json:"dashboard_id,omitempty"`                // Id of a dashboard
  LookmlDashboardId        *string                     `json:"lookml_dashboard_id,omitempty"`         // Id of a LookML dashboard
  FiltersString            *string                     `json:"filters_string,omitempty"`              // Query string to run look or dashboard with
  DashboardFilters         *string                     `json:"dashboard_filters,omitempty"`           // (DEPRECATED) Alias for filters_string field
  RequireResults           *bool                       `json:"require_results,omitempty"`             // Delivery should occur if running the dashboard or look returns results
  RequireNoResults         *bool                       `json:"require_no_results,omitempty"`          // Delivery should occur if the dashboard look does not return results
  RequireChange            *bool                       `json:"require_change,omitempty"`              // Delivery should occur if data have changed since the last run
  SendAllResults           *bool                       `json:"send_all_results,omitempty"`            // Will run an unlimited query and send all results.
  Crontab                  *string                     `json:"crontab,omitempty"`                     // Vixie-Style crontab specification when to run
  Datagroup                *string                     `json:"datagroup,omitempty"`                   // Name of a datagroup; if specified will run when datagroup triggered (can't be used with cron string)
  Timezone                 *string                     `json:"timezone,omitempty"`                    // Timezone for interpreting the specified crontab (default is Looker instance timezone)
  QueryId                  *string                     `json:"query_id,omitempty"`                    // Query id
  ScheduledPlanDestination *[]ScheduledPlanDestination `json:"scheduled_plan_destination,omitempty"`  // Scheduled plan destinations
  RunOnce                  *bool                       `json:"run_once,omitempty"`                    // Whether the plan in question should only be run once (usually for testing)
  IncludeLinks             *bool                       `json:"include_links,omitempty"`               // Whether links back to Looker should be included in this ScheduledPlan
  PdfPaperSize             *string                     `json:"pdf_paper_size,omitempty"`              // The size of paper a PDF should be rendered for
  PdfLandscape             *bool                       `json:"pdf_landscape,omitempty"`               // Whether the paper should be landscape
  Embed                    *bool                       `json:"embed,omitempty"`                       // Whether this schedule is in an embed context or not
  ColorTheme               *string                     `json:"color_theme,omitempty"`                 // Color scheme of the dashboard if applicable
  LongTables               *bool                       `json:"long_tables,omitempty"`                 // Whether or not to expand table vis to full length
  Id                       *int64                      `json:"id,omitempty"`                          // Unique Id
  CreatedAt                *time.Time                  `json:"created_at,omitempty"`                  // Date and time when ScheduledPlan was created
  UpdatedAt                *time.Time                  `json:"updated_at,omitempty"`                  // Date and time when ScheduledPlan was last updated
  Title                    *string                     `json:"title,omitempty"`                       // Title
  User                     *UserPublic                 `json:"user,omitempty"`                       
  NextRunAt                *time.Time                  `json:"next_run_at,omitempty"`                 // When the ScheduledPlan will next run (null if running once)
  LastRunAt                *time.Time                  `json:"last_run_at,omitempty"`                 // When the ScheduledPlan was last run
  Can                      *map[string]bool            `json:"can,omitempty"`                         // Operations the current user is able to perform on this object
}


type ScheduledPlanDestination struct {
  Id               *int64  `json:"id,omitempty"`                 // Unique Id
  ScheduledPlanId  *int64  `json:"scheduled_plan_id,omitempty"`  // Id of a scheduled plan you own
  Format           *string `json:"format,omitempty"`             // The data format to send to the given destination. Supported formats vary by destination, but include: "txt", "csv", "inline_json", "json", "json_detail", "xlsx", "html", "wysiwyg_pdf", "assembled_pdf", "wysiwyg_png"
  ApplyFormatting  *bool   `json:"apply_formatting,omitempty"`   // Are values formatted? (containing currency symbols, digit separators, etc.
  ApplyVis         *bool   `json:"apply_vis,omitempty"`          // Whether visualization options are applied to the results.
  Address          *string `json:"address,omitempty"`            // Address for recipient. For email e.g. 'user@example.com'. For webhooks e.g. 'https://domain/path'. For Amazon S3 e.g. 's3://bucket-name/path/'. For SFTP e.g. 'sftp://host-name/path/'.
  LookerRecipient  *bool   `json:"looker_recipient,omitempty"`   // Whether the recipient is a Looker user on the current instance (only applicable for email recipients)
  Type             *string `json:"type,omitempty"`               // Type of the address ('email', 'webhook', 's3', or 'sftp')
  Parameters       *string `json:"parameters,omitempty"`         // JSON object containing parameters for external scheduling. For Amazon S3, this requires keys and values for access_key_id and region. For SFTP, this requires a key and value for username.
  SecretParameters *string `json:"secret_parameters,omitempty"`  // (Write-Only) JSON object containing secret parameters for external scheduling. For Amazon S3, this requires a key and value for secret_access_key. For SFTP, this requires a key and value for password.
  Message          *string `json:"message,omitempty"`            // Optional message to be included in scheduled emails
}


type Session struct {
  Can             *map[string]bool `json:"can,omitempty"`               // Operations the current user is able to perform on this object
  Id              *int64           `json:"id,omitempty"`                // Unique Id
  IpAddress       *string          `json:"ip_address,omitempty"`        // IP address of user when this session was initiated
  Browser         *string          `json:"browser,omitempty"`           // User's browser type
  OperatingSystem *string          `json:"operating_system,omitempty"`  // User's Operating System
  City            *string          `json:"city,omitempty"`              // City component of user location (derived from IP address)
  State           *string          `json:"state,omitempty"`             // State component of user location (derived from IP address)
  Country         *string          `json:"country,omitempty"`           // Country component of user location (derived from IP address)
  CredentialsType *string          `json:"credentials_type,omitempty"`  // Type of credentials used for logging in this session
  ExtendedAt      *string          `json:"extended_at,omitempty"`       // Time when this session was last extended by the user
  ExtendedCount   *int64           `json:"extended_count,omitempty"`    // Number of times this session was extended
  SudoUserId      *int64           `json:"sudo_user_id,omitempty"`      // Actual user in the case when this session represents one user sudo'ing as another
  CreatedAt       *string          `json:"created_at,omitempty"`        // Time when this session was initiated
  ExpiresAt       *string          `json:"expires_at,omitempty"`        // Time when this session will expire
  Url             *url.URL         `json:"url,omitempty"`               // Link to get this item
}


type SessionConfig struct {
  Can                      *map[string]bool `json:"can,omitempty"`                          // Operations the current user is able to perform on this object
  AllowPersistentSessions  *bool            `json:"allow_persistent_sessions,omitempty"`    // Allow users to have persistent sessions when they login
  SessionMinutes           *int64           `json:"session_minutes,omitempty"`              // Number of minutes for user sessions.  Must be between 5 and 43200
  UnlimitedSessionsPerUser *bool            `json:"unlimited_sessions_per_user,omitempty"`  // Allow users to have an unbounded number of concurrent sessions (otherwise, users will be limited to only one session at a time).
  UseInactivityBasedLogout *bool            `json:"use_inactivity_based_logout,omitempty"`  // Enforce session logout for sessions that are inactive for 15 minutes.
  TrackSessionLocation     *bool            `json:"track_session_location,omitempty"`       // Track location of session when user logs in.
}


type Snippet struct {
  Name  *string `json:"name,omitempty"`   // Name of the snippet
  Label *string `json:"label,omitempty"`  // Label of the snippet
  Sql   *string `json:"sql,omitempty"`    // SQL text of the snippet
}


type Space struct {
  Name                 string                `json:"name"`                              // Unique Name
  ParentId             *string               `json:"parent_id,omitempty"`               // Id of Parent. If the parent id is null, this is a root-level entry
  Id                   *string               `json:"id,omitempty"`                      // Unique Id
  ContentMetadataId    *int64                `json:"content_metadata_id,omitempty"`     // Id of content metadata
  CreatedAt            *time.Time            `json:"created_at,omitempty"`              // Time the space was created
  CreatorId            *int64                `json:"creator_id,omitempty"`              // User Id of Creator
  ChildCount           *int64                `json:"child_count,omitempty"`             // Children Count
  ExternalId           *string               `json:"external_id,omitempty"`             // Embedder's Id if this space was autogenerated as an embedding shared space via 'external_group_id' in an SSO embed login
  IsEmbed              *bool                 `json:"is_embed,omitempty"`                // Space is an embed space
  IsEmbedSharedRoot    *bool                 `json:"is_embed_shared_root,omitempty"`    // Space is the root embed shared space
  IsEmbedUsersRoot     *bool                 `json:"is_embed_users_root,omitempty"`     // Space is the root embed users space
  IsPersonal           *bool                 `json:"is_personal,omitempty"`             // Space is a user's personal space
  IsPersonalDescendant *bool                 `json:"is_personal_descendant,omitempty"`  // Space is descendant of a user's personal space
  IsSharedRoot         *bool                 `json:"is_shared_root,omitempty"`          // Space is the root shared space
  IsUsersRoot          *bool                 `json:"is_users_root,omitempty"`           // Space is the root user space
  Can                  *map[string]bool      `json:"can,omitempty"`                     // Operations the current user is able to perform on this object
  Dashboards           *[]DashboardBase      `json:"dashboards,omitempty"`              // Dashboards
  Looks                *[]LookWithDashboards `json:"looks,omitempty"`                   // Looks
}


type SpaceBase struct {
  Name                 string           `json:"name"`                              // Unique Name
  ParentId             *string          `json:"parent_id,omitempty"`               // Id of Parent. If the parent id is null, this is a root-level entry
  Id                   *string          `json:"id,omitempty"`                      // Unique Id
  ContentMetadataId    *int64           `json:"content_metadata_id,omitempty"`     // Id of content metadata
  CreatedAt            *time.Time       `json:"created_at,omitempty"`              // Time the space was created
  CreatorId            *int64           `json:"creator_id,omitempty"`              // User Id of Creator
  ChildCount           *int64           `json:"child_count,omitempty"`             // Children Count
  ExternalId           *string          `json:"external_id,omitempty"`             // Embedder's Id if this space was autogenerated as an embedding shared space via 'external_group_id' in an SSO embed login
  IsEmbed              *bool            `json:"is_embed,omitempty"`                // Space is an embed space
  IsEmbedSharedRoot    *bool            `json:"is_embed_shared_root,omitempty"`    // Space is the root embed shared space
  IsEmbedUsersRoot     *bool            `json:"is_embed_users_root,omitempty"`     // Space is the root embed users space
  IsPersonal           *bool            `json:"is_personal,omitempty"`             // Space is a user's personal space
  IsPersonalDescendant *bool            `json:"is_personal_descendant,omitempty"`  // Space is descendant of a user's personal space
  IsSharedRoot         *bool            `json:"is_shared_root,omitempty"`          // Space is the root shared space
  IsUsersRoot          *bool            `json:"is_users_root,omitempty"`           // Space is the root user space
  Can                  *map[string]bool `json:"can,omitempty"`                     // Operations the current user is able to perform on this object
}


type SqlQuery struct {
  Can           *map[string]bool        `json:"can,omitempty"`              // Operations the current user is able to perform on this object
  Slug          *string                 `json:"slug,omitempty"`             // The identifier of the SQL query
  LastRuntime   *float32                `json:"last_runtime,omitempty"`     // Number of seconds this query took to run the most recent time it was run
  RunCount      *int64                  `json:"run_count,omitempty"`        // Number of times this query has been run
  BrowserLimit  *int64                  `json:"browser_limit,omitempty"`    // Maximum number of rows this query will display on the SQL Runner page
  Sql           *string                 `json:"sql,omitempty"`              // SQL query text
  LastRunAt     *string                 `json:"last_run_at,omitempty"`      // The most recent time this query was run
  Connection    *DBConnectionBase       `json:"connection,omitempty"`      
  ModelName     *string                 `json:"model_name,omitempty"`       // Model name this query uses
  Creator       *UserPublic             `json:"creator,omitempty"`         
  ExploreUrl    *string                 `json:"explore_url,omitempty"`      // Explore page URL for this SQL query
  Plaintext     *bool                   `json:"plaintext,omitempty"`        // Should this query be rendered as plain text
  VisConfig     *map[string]interface{} `json:"vis_config,omitempty"`       // Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
  ResultMakerId *int64                  `json:"result_maker_id,omitempty"`  // ID of the ResultMakerLookup entry.
}


type SqlQueryCreate struct {
  ConnectionName *string                 `json:"connection_name,omitempty"`  // Name of the db connection on which to run this query
  ConnectionId   *string                 `json:"connection_id,omitempty"`    // (DEPRECATED) Use `connection_name` instead
  ModelName      *string                 `json:"model_name,omitempty"`       // Name of LookML Model (this or `connection_id` required)
  Sql            *string                 `json:"sql,omitempty"`              // SQL query
  VisConfig      *map[string]interface{} `json:"vis_config,omitempty"`       // Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
}

type SupportedActionTypesType string
const SupportedActionTypesType_Cell      SupportedActionTypesType = "cell"
const SupportedActionTypesType_Query     SupportedActionTypesType = "query"
const SupportedActionTypesType_Dashboard SupportedActionTypesType = "dashboard"


type SupportedDownloadSettingsType string
const SupportedDownloadSettingsType_Push SupportedDownloadSettingsType = "push"
const SupportedDownloadSettingsType_Url  SupportedDownloadSettingsType = "url"


type SupportedFormatsType string
const SupportedFormatsType_Txt                  SupportedFormatsType = "txt"
const SupportedFormatsType_Csv                  SupportedFormatsType = "csv"
const SupportedFormatsType_InlineJson           SupportedFormatsType = "inline_json"
const SupportedFormatsType_Json                 SupportedFormatsType = "json"
const SupportedFormatsType_JsonLabel            SupportedFormatsType = "json_label"
const SupportedFormatsType_JsonDetail           SupportedFormatsType = "json_detail"
const SupportedFormatsType_JsonDetailLiteStream SupportedFormatsType = "json_detail_lite_stream"
const SupportedFormatsType_Xlsx                 SupportedFormatsType = "xlsx"
const SupportedFormatsType_Html                 SupportedFormatsType = "html"
const SupportedFormatsType_WysiwygPdf           SupportedFormatsType = "wysiwyg_pdf"
const SupportedFormatsType_AssembledPdf         SupportedFormatsType = "assembled_pdf"
const SupportedFormatsType_WysiwygPng           SupportedFormatsType = "wysiwyg_png"
const SupportedFormatsType_CsvZip               SupportedFormatsType = "csv_zip"


type SupportedFormattingsType string
const SupportedFormattingsType_Formatted   SupportedFormattingsType = "formatted"
const SupportedFormattingsType_Unformatted SupportedFormattingsType = "unformatted"


type SupportedVisualizationFormattingsType string
const SupportedVisualizationFormattingsType_Apply   SupportedVisualizationFormattingsType = "apply"
const SupportedVisualizationFormattingsType_Noapply SupportedVisualizationFormattingsType = "noapply"



type Theme struct {
  Can      *map[string]bool `json:"can,omitempty"`       // Operations the current user is able to perform on this object
  BeginAt  *time.Time       `json:"begin_at,omitempty"`  // Timestamp for when this theme becomes active. Null=always
  EndAt    *time.Time       `json:"end_at,omitempty"`    // Timestamp for when this theme expires. Null=never
  Id       *int64           `json:"id,omitempty"`        // Unique Id
  Name     *string          `json:"name,omitempty"`      // Name of theme. Can only be alphanumeric and underscores.
  Settings *ThemeSettings   `json:"settings,omitempty"` 
}


type ThemeSettings struct {
  BackgroundColor     *string `json:"background_color,omitempty"`       // Default background color
  BaseFontSize        *string `json:"base_font_size,omitempty"`         // Base font size for scaling fonts
  ColorCollectionId   *string `json:"color_collection_id,omitempty"`    // Optional. ID of color collection to use with the theme. Use an empty string for none.
  FontColor           *string `json:"font_color,omitempty"`             // Default font color
  FontFamily          *string `json:"font_family,omitempty"`            // Primary font family
  FontSource          *string `json:"font_source,omitempty"`            // Source specification for font
  InfoButtonColor     *string `json:"info_button_color,omitempty"`      // Info button color
  PrimaryButtonColor  *string `json:"primary_button_color,omitempty"`   // Primary button color
  ShowFiltersBar      *bool   `json:"show_filters_bar,omitempty"`       // Toggle to show filters. Defaults to true.
  ShowTitle           *bool   `json:"show_title,omitempty"`             // Toggle to show the title. Defaults to true.
  TextTileTextColor   *string `json:"text_tile_text_color,omitempty"`   // Text color for text tiles
  TileBackgroundColor *string `json:"tile_background_color,omitempty"`  // Background color for tiles
  TileTextColor       *string `json:"tile_text_color,omitempty"`        // Text color for tiles
  TitleColor          *string `json:"title_color,omitempty"`            // Color for titles
  WarnButtonColor     *string `json:"warn_button_color,omitempty"`      // Warning button color
  TileTitleAlignment  *string `json:"tile_title_alignment,omitempty"`   // The text alignment of tile titles (New Dashboards)
  TileShadow          *bool   `json:"tile_shadow,omitempty"`            // Toggles the tile shadow (New Dashboards)
}


type Timezone struct {
  Value *string `json:"value,omitempty"`  // Timezone
  Label *string `json:"label,omitempty"`  // Description of timezone
  Group *string `json:"group,omitempty"`  // Timezone group (e.g Common, Other, etc.)
}


type UpdateFolder struct {
  Name     *string `json:"name,omitempty"`       // Unique Name
  ParentId *string `json:"parent_id,omitempty"`  // Id of Parent. If the parent id is null, this is a root-level entry
}


type UpdateSpace struct {
  Name     *string `json:"name,omitempty"`       // Unique Name
  ParentId *string `json:"parent_id,omitempty"`  // Id of Parent. If the parent id is null, this is a root-level entry
}


type User struct {
  Can                     *map[string]bool         `json:"can,omitempty"`                        // Operations the current user is able to perform on this object
  AvatarUrl               *url.URL                 `json:"avatar_url,omitempty"`                 // URL for the avatar image (may be generic)
  AvatarUrlWithoutSizing  *url.URL                 `json:"avatar_url_without_sizing,omitempty"`  // URL for the avatar image (may be generic), does not specify size
  CredentialsApi3         *[]CredentialsApi3       `json:"credentials_api3,omitempty"`           // API 3 credentials
  CredentialsEmail        *CredentialsEmail        `json:"credentials_email,omitempty"`         
  CredentialsEmbed        *[]CredentialsEmbed      `json:"credentials_embed,omitempty"`          // Embed credentials
  CredentialsGoogle       *CredentialsGoogle       `json:"credentials_google,omitempty"`        
  CredentialsLdap         *CredentialsLDAP         `json:"credentials_ldap,omitempty"`          
  CredentialsLookerOpenid *CredentialsLookerOpenid `json:"credentials_looker_openid,omitempty"` 
  CredentialsOidc         *CredentialsOIDC         `json:"credentials_oidc,omitempty"`          
  CredentialsSaml         *CredentialsSaml         `json:"credentials_saml,omitempty"`          
  CredentialsTotp         *CredentialsTotp         `json:"credentials_totp,omitempty"`          
  DisplayName             *string                  `json:"display_name,omitempty"`               // Full name for display (available only if both first_name and last_name are set)
  Email                   *string                  `json:"email,omitempty"`                      // EMail address
  EmbedGroupSpaceId       *int64                   `json:"embed_group_space_id,omitempty"`       // (Embed only) ID of user's group space based on the external_group_id optionally specified during embed user login
  FirstName               *string                  `json:"first_name,omitempty"`                 // First name
  GroupIds                *[]int64                 `json:"group_ids,omitempty"`                  // Array of ids of the groups for this user
  HomeSpaceId             *string                  `json:"home_space_id,omitempty"`              // ID string for user's home space
  HomeFolderId            *string                  `json:"home_folder_id,omitempty"`             // ID string for user's home folder
  Id                      *int64                   `json:"id,omitempty"`                         // Unique Id
  IsDisabled              *bool                    `json:"is_disabled,omitempty"`                // Account has been disabled
  LastName                *string                  `json:"last_name,omitempty"`                  // Last name
  Locale                  *string                  `json:"locale,omitempty"`                     // User's preferred locale. User locale takes precedence over Looker's system-wide default locale. Locale determines language of display strings and date and numeric formatting in API responses. Locale string must be a 2 letter language code or a combination of language code and region code: 'en' or 'en-US', for example.
  LookerVersions          *[]string                `json:"looker_versions,omitempty"`            // Array of strings representing the Looker versions that this user has used (this only goes back as far as '3.54.0')
  ModelsDirValidated      *bool                    `json:"models_dir_validated,omitempty"`       // User's dev workspace has been checked for presence of applicable production projects
  PersonalSpaceId         *int64                   `json:"personal_space_id,omitempty"`          // ID of user's personal space
  PersonalFolderId        *int64                   `json:"personal_folder_id,omitempty"`         // ID of user's personal folder
  PresumedLookerEmployee  *bool                    `json:"presumed_looker_employee,omitempty"`   // User is identified as an employee of Looker
  RoleIds                 *[]int64                 `json:"role_ids,omitempty"`                   // Array of ids of the roles for this user
  Sessions                *[]Session               `json:"sessions,omitempty"`                   // Active sessions
  UiState                 *map[string]interface{}  `json:"ui_state,omitempty"`                   // Per user dictionary of undocumented state information owned by the Looker UI.
  VerifiedLookerEmployee  *bool                    `json:"verified_looker_employee,omitempty"`   // User is identified as an employee of Looker who has been verified via Looker corporate authentication
  RolesExternallyManaged  *bool                    `json:"roles_externally_managed,omitempty"`   // User's roles are managed by an external directory like SAML or LDAP and can not be changed directly.
  Url                     *url.URL                 `json:"url,omitempty"`                        // Link to get this item
}


type UserAttribute struct {
  Can                        *map[string]bool `json:"can,omitempty"`                            // Operations the current user is able to perform on this object
  Id                         *int64           `json:"id,omitempty"`                             // Unique Id
  Name                       *string          `json:"name,omitempty"`                           // Name of user attribute
  Label                      *string          `json:"label,omitempty"`                          // Human-friendly label for user attribute
  Type                       *string          `json:"type,omitempty"`                           // Type of user attribute ("string", "number", "datetime", "yesno", "zipcode")
  DefaultValue               *string          `json:"default_value,omitempty"`                  // Default value for when no value is set on the user
  IsSystem                   *bool            `json:"is_system,omitempty"`                      // Attribute is a system default
  IsPermanent                *bool            `json:"is_permanent,omitempty"`                   // Attribute is permanent and cannot be deleted
  ValueIsHidden              *bool            `json:"value_is_hidden,omitempty"`                // If true, users will not be able to view values of this attribute
  UserCanView                *bool            `json:"user_can_view,omitempty"`                  // Non-admin users can see the values of their attributes and use them in filters
  UserCanEdit                *bool            `json:"user_can_edit,omitempty"`                  // Users can change the value of this attribute for themselves
  HiddenValueDomainWhitelist *string          `json:"hidden_value_domain_whitelist,omitempty"`  // Destinations to which a hidden attribute may be sent. Once set, cannot be edited.
}

type UserAttributeFilterTypesType string
const UserAttributeFilterTypesType_AdvancedFilterString   UserAttributeFilterTypesType = "advanced_filter_string"
const UserAttributeFilterTypesType_AdvancedFilterNumber   UserAttributeFilterTypesType = "advanced_filter_number"
const UserAttributeFilterTypesType_AdvancedFilterDatetime UserAttributeFilterTypesType = "advanced_filter_datetime"
const UserAttributeFilterTypesType_String                 UserAttributeFilterTypesType = "string"
const UserAttributeFilterTypesType_Number                 UserAttributeFilterTypesType = "number"
const UserAttributeFilterTypesType_Datetime               UserAttributeFilterTypesType = "datetime"
const UserAttributeFilterTypesType_RelativeUrl            UserAttributeFilterTypesType = "relative_url"
const UserAttributeFilterTypesType_Yesno                  UserAttributeFilterTypesType = "yesno"
const UserAttributeFilterTypesType_Zipcode                UserAttributeFilterTypesType = "zipcode"



type UserAttributeGroupValue struct {
  Can             *map[string]bool `json:"can,omitempty"`                // Operations the current user is able to perform on this object
  Id              *int64           `json:"id,omitempty"`                 // Unique Id of this group-attribute relation
  GroupId         *int64           `json:"group_id,omitempty"`           // Id of group
  UserAttributeId *int64           `json:"user_attribute_id,omitempty"`  // Id of user attribute
  ValueIsHidden   *bool            `json:"value_is_hidden,omitempty"`    // If true, the "value" field will be null, because the attribute settings block access to this value
  Rank            *int64           `json:"rank,omitempty"`               // Precedence for resolving value for user
  Value           *string          `json:"value,omitempty"`              // Value of user attribute for group
}


type UserAttributeWithValue struct {
  Can                        *map[string]bool `json:"can,omitempty"`                            // Operations the current user is able to perform on this object
  Name                       *string          `json:"name,omitempty"`                           // Name of user attribute
  Label                      *string          `json:"label,omitempty"`                          // Human-friendly label for user attribute
  Rank                       *int64           `json:"rank,omitempty"`                           // Precedence for setting value on user (lowest wins)
  Value                      *string          `json:"value,omitempty"`                          // Value of attribute for user
  UserId                     *int64           `json:"user_id,omitempty"`                        // Id of User
  UserCanEdit                *bool            `json:"user_can_edit,omitempty"`                  // Can the user set this value
  ValueIsHidden              *bool            `json:"value_is_hidden,omitempty"`                // If true, the "value" field will be null, because the attribute settings block access to this value
  UserAttributeId            *int64           `json:"user_attribute_id,omitempty"`              // Id of User Attribute
  Source                     *string          `json:"source,omitempty"`                         // How user got this value for this attribute
  HiddenValueDomainWhitelist *string          `json:"hidden_value_domain_whitelist,omitempty"`  // If this user attribute is hidden, whitelist of destinations to which it may be sent.
}


type UserLoginLockout struct {
  Can       *map[string]bool `json:"can,omitempty"`         // Operations the current user is able to perform on this object
  Key       *string          `json:"key,omitempty"`         // Hash of user's client id
  AuthType  *string          `json:"auth_type,omitempty"`   // Authentication method for login failures
  Ip        *string          `json:"ip,omitempty"`          // IP address of most recent failed attempt
  UserId    *int64           `json:"user_id,omitempty"`     // User ID
  RemoteId  *string          `json:"remote_id,omitempty"`   // Remote ID of user if using LDAP
  FullName  *string          `json:"full_name,omitempty"`   // User's name
  Email     *string          `json:"email,omitempty"`       // Email address associated with the user's account
  FailCount *int64           `json:"fail_count,omitempty"`  // Number of failures that triggered the lockout
  LockoutAt *time.Time       `json:"lockout_at,omitempty"`  // Time when lockout was triggered
}


type UserPublic struct {
  Can         *map[string]bool `json:"can,omitempty"`           // Operations the current user is able to perform on this object
  Id          *int64           `json:"id,omitempty"`            // Unique Id
  FirstName   *string          `json:"first_name,omitempty"`    // First Name
  LastName    *string          `json:"last_name,omitempty"`     // Last Name
  DisplayName *string          `json:"display_name,omitempty"`  // Full name for display (available only if both first_name and last_name are set)
  AvatarUrl   *url.URL         `json:"avatar_url,omitempty"`    // URL for the avatar image (may be generic)
  Url         *url.URL         `json:"url,omitempty"`           // Link to get this item
}


type ValidationError struct {
  Message          string                   `json:"message"`            // Error details
  Errors           *[]ValidationErrorDetail `json:"errors,omitempty"`   // Error detail array
  DocumentationUrl url.URL                  `json:"documentation_url"`  // Documentation link
}


type ValidationErrorDetail struct {
  Field            *string `json:"field,omitempty"`    // Field with error
  Code             *string `json:"code,omitempty"`     // Error code
  Message          *string `json:"message,omitempty"`  // Error info message
  DocumentationUrl url.URL `json:"documentation_url"`  // Documentation link
}

type WeekStartDayType string
const WeekStartDayType_Monday    WeekStartDayType = "monday"
const WeekStartDayType_Tuesday   WeekStartDayType = "tuesday"
const WeekStartDayType_Wednesday WeekStartDayType = "wednesday"
const WeekStartDayType_Thursday  WeekStartDayType = "thursday"
const WeekStartDayType_Friday    WeekStartDayType = "friday"
const WeekStartDayType_Saturday  WeekStartDayType = "saturday"
const WeekStartDayType_Sunday    WeekStartDayType = "sunday"



type WelcomeEmailTest struct {
  Can     *map[string]bool `json:"can,omitempty"`      // Operations the current user is able to perform on this object
  Content *string          `json:"content,omitempty"`  // The content that will be sent as part of a custom welcome email
}


type WhitelabelConfiguration struct {
  Can                 *map[string]bool `json:"can,omitempty"`                     // Operations the current user is able to perform on this object
  Id                  *int64           `json:"id,omitempty"`                      // Unique Id
  LogoFile            *string          `json:"logo_file,omitempty"`               // Customer logo image. Expected base64 encoded data (write-only)
  LogoUrl             *string          `json:"logo_url,omitempty"`                // Logo image url (read-only)
  FaviconFile         *string          `json:"favicon_file,omitempty"`            // Custom favicon image. Expected base64 encoded data (write-only)
  FaviconUrl          *string          `json:"favicon_url,omitempty"`             // Favicon image url (read-only)
  DefaultTitle        *string          `json:"default_title,omitempty"`           // Default page title
  ShowHelpMenu        *bool            `json:"show_help_menu,omitempty"`          // Boolean to toggle showing help menus
  ShowDocs            *bool            `json:"show_docs,omitempty"`               // Boolean to toggle showing docs
  ShowEmailSubOptions *bool            `json:"show_email_sub_options,omitempty"`  // Boolean to toggle showing email subscription options.
  AllowLookerMentions *bool            `json:"allow_looker_mentions,omitempty"`   // Boolean to toggle mentions of Looker in emails
  AllowLookerLinks    *bool            `json:"allow_looker_links,omitempty"`      // Boolean to toggle links to Looker in emails
}


type Workspace struct {
  Can      *map[string]bool `json:"can,omitempty"`       // Operations the current user is able to perform on this object
  Id       *string          `json:"id,omitempty"`        // The unique id of this user workspace. Predefined workspace ids include "production" and "dev"
  Projects *[]Project       `json:"projects,omitempty"`  // The local state of each project in the workspace
}

// Dynamically generated writeable type for ApiSession removes properties:
// can, sudo_user_id
type WriteApiSession struct {
  WorkspaceId *string `json:"workspace_id,omitempty"`  // The id of active workspace for this session
}

// Dynamically generated writeable type for BackupConfiguration removes properties:
// can, url
type WriteBackupConfiguration struct {
  Type                 *string `json:"type,omitempty"`                     // Type of backup: looker-s3 or custom-s3
  CustomS3Bucket       *string `json:"custom_s3_bucket,omitempty"`         // Name of bucket for custom-s3 backups
  CustomS3BucketRegion *string `json:"custom_s3_bucket_region,omitempty"`  // Name of region where the bucket is located
  CustomS3Key          *string `json:"custom_s3_key,omitempty"`            // (Write-Only) AWS S3 key used for custom-s3 backups
  CustomS3Secret       *string `json:"custom_s3_secret,omitempty"`         // (Write-Only) AWS S3 secret used for custom-s3 backups
}

// Dynamically generated writeable type for ColorCollection removes properties:
// id
type WriteColorCollection struct {
  Label               *string              `json:"label,omitempty"`                // Label of color collection
  CategoricalPalettes *[]DiscretePalette   `json:"categoricalPalettes,omitempty"`  // Array of categorical palette definitions
  SequentialPalettes  *[]ContinuousPalette `json:"sequentialPalettes,omitempty"`   // Array of discrete palette definitions
  DivergingPalettes   *[]ContinuousPalette `json:"divergingPalettes,omitempty"`    // Array of diverging palette definitions
}

// Dynamically generated writeable type for ContentFavorite removes properties:
// id, look_id, dashboard_id, look, board_id
type WriteContentFavorite struct {
  UserId            *int64              `json:"user_id,omitempty"`              // User Id which owns this ContentFavorite
  ContentMetadataId *int64              `json:"content_metadata_id,omitempty"`  // Content Metadata Id associated with this ContentFavorite
  Dashboard         *WriteDashboardBase `json:"dashboard,omitempty"`           
}

// Dynamically generated writeable type for ContentMeta removes properties:
// can, id, name, parent_id, space_id, folder_id, dashboard_id, look_id, content_type, inheriting_id, slug
type WriteContentMeta struct {
  Inherits *bool `json:"inherits,omitempty"`  // Whether content inherits its access levels from parent
}

// Dynamically generated writeable type for CreateDashboardFilter removes properties:
// id, field
type WriteCreateDashboardFilter struct {
  DashboardId         string                  `json:"dashboard_id"`                     // Id of Dashboard
  Name                string                  `json:"name"`                             // Name of filter
  Title               string                  `json:"title"`                            // Title of filter
  Type                string                  `json:"type"`                             // Type of filter: one of date, number, string, or field
  DefaultValue        *string                 `json:"default_value,omitempty"`          // Default value of filter
  Model               *string                 `json:"model,omitempty"`                  // Model of filter (required if type = field)
  Explore             *string                 `json:"explore,omitempty"`                // Explore of filter (required if type = field)
  Dimension           *string                 `json:"dimension,omitempty"`              // Dimension of filter (required if type = field)
  Row                 *int64                  `json:"row,omitempty"`                    // Display order of this filter relative to other filters
  ListensToFilters    *[]string               `json:"listens_to_filters,omitempty"`     // Array of listeners for faceted filters
  AllowMultipleValues *bool                   `json:"allow_multiple_values,omitempty"`  // Whether the filter allows multiple filter values
  Required            *bool                   `json:"required,omitempty"`               // Whether the filter requires a value to run the dashboard
  UiConfig            *map[string]interface{} `json:"ui_config,omitempty"`              // The visual configuration for this filter. Used to set up how the UI for this filter should appear.
}

// Dynamically generated writeable type for CreateQueryTask removes properties:
// can
type WriteCreateQueryTask struct {
  QueryId      int64            `json:"query_id"`                // Id of query to run
  ResultFormat ResultFormatType `json:"result_format"`           // Desired async query result format. Valid values are: "json", "json_detail", "json_fe", "csv", "html", "md", "txt", "xlsx", "gsxml".
  Source       *string          `json:"source,omitempty"`        // Source of query task
  Deferred     *bool            `json:"deferred,omitempty"`      // Create the task but defer execution
  LookId       *int64           `json:"look_id,omitempty"`       // Id of look associated with query.
  DashboardId  *string          `json:"dashboard_id,omitempty"`  // Id of dashboard associated with query.
}

// Dynamically generated writeable type for CredentialsEmail removes properties:
// can, created_at, is_disabled, logged_in_at, password_reset_url, type, url, user_url
type WriteCredentialsEmail struct {
  Email                          *string `json:"email,omitempty"`                                // EMail address used for user login
  ForcedPasswordResetAtNextLogin *bool   `json:"forced_password_reset_at_next_login,omitempty"`  // Force the user to change their password upon their next login
}

// Dynamically generated writeable type for CustomWelcomeEmail removes properties:
// can
type WriteCustomWelcomeEmail struct {
  Enabled *bool   `json:"enabled,omitempty"`  // If true, custom email content will replace the default body of welcome emails
  Content *string `json:"content,omitempty"`  // The HTML to use as custom content for welcome emails. Script elements and other potentially dangerous markup will be removed.
}

// Dynamically generated writeable type for Dashboard removes properties:
// can, content_favorite_id, content_metadata_id, id, model, readonly, refresh_interval_to_i, user_id, created_at, dashboard_elements, dashboard_filters, dashboard_layouts, deleted_at, deleter_id, edit_uri, favorite_count, last_accessed_at, last_viewed_at, view_count
type WriteDashboard struct {
  Description         *string              `json:"description,omitempty"`            // Description
  Hidden              *bool                `json:"hidden,omitempty"`                 // Is Hidden
  QueryTimezone       *string              `json:"query_timezone,omitempty"`         // Timezone in which the Dashboard will run by default.
  RefreshInterval     *string              `json:"refresh_interval,omitempty"`       // Refresh Interval, as a time duration phrase like "2 hours 30 minutes". A number with no time units will be interpreted as whole seconds.
  Space               *WriteSpaceBase      `json:"space,omitempty"`                 
  Folder              *WriteFolderBase     `json:"folder,omitempty"`                
  Title               *string              `json:"title,omitempty"`                  // Dashboard Title
  BackgroundColor     *string              `json:"background_color,omitempty"`       // Background color
  CrossfilterEnabled  *bool                `json:"crossfilter_enabled,omitempty"`    // Enables crossfiltering in dashboards - only available in dashboards-next (beta)
  Deleted             *bool                `json:"deleted,omitempty"`                // Whether or not a dashboard is 'soft' deleted.
  LoadConfiguration   *string              `json:"load_configuration,omitempty"`     // configuration option that governs how dashboard loading will happen.
  LookmlLinkId        *string              `json:"lookml_link_id,omitempty"`         // Links this dashboard to a particular LookML dashboard such that calling a **sync** operation on that LookML dashboard will update this dashboard to match.
  ShowFiltersBar      *bool                `json:"show_filters_bar,omitempty"`       // Show filters bar.  **Security Note:** This property only affects the *cosmetic* appearance of the dashboard, not a user's ability to access data. Hiding the filters bar does **NOT** prevent users from changing filters by other means. For information on how to set up secure data access control policies, see [Control User Access to Data](https://looker.com/docs/r/api/control-access)
  ShowTitle           *bool                `json:"show_title,omitempty"`             // Show title
  Slug                *string              `json:"slug,omitempty"`                   // Content Metadata Slug
  SpaceId             *string              `json:"space_id,omitempty"`               // Id of Space
  FolderId            *string              `json:"folder_id,omitempty"`              // Id of folder
  TextTileTextColor   *string              `json:"text_tile_text_color,omitempty"`   // Color of text on text tiles
  TileBackgroundColor *string              `json:"tile_background_color,omitempty"`  // Tile background color
  TileTextColor       *string              `json:"tile_text_color,omitempty"`        // Tile text color
  TitleColor          *string              `json:"title_color,omitempty"`            // Title color
  Appearance          *DashboardAppearance `json:"appearance,omitempty"`            
  PreferredViewer     *string              `json:"preferred_viewer,omitempty"`       // The preferred route for viewing this dashboard (ie: dashboards or dashboards-next)
}

// Dynamically generated writeable type for DashboardBase removes properties:
// can, content_favorite_id, content_metadata_id, description, hidden, id, model, query_timezone, readonly, refresh_interval, refresh_interval_to_i, title, user_id
type WriteDashboardBase struct {
  Space  *WriteSpaceBase  `json:"space,omitempty"`  
  Folder *WriteFolderBase `json:"folder,omitempty"` 
}

// Dynamically generated writeable type for DashboardElement removes properties:
// can, body_text_as_html, edit_uri, id, lookml_link_id, note_text_as_html, refresh_interval_to_i, alert_count, title_text_as_html, subtitle_text_as_html
type WriteDashboardElement struct {
  BodyText        *string                                          `json:"body_text,omitempty"`         // Text tile body text
  DashboardId     *string                                          `json:"dashboard_id,omitempty"`      // Id of Dashboard
  Look            *WriteLookWithQuery                              `json:"look,omitempty"`             
  LookId          *string                                          `json:"look_id,omitempty"`           // Id Of Look
  MergeResultId   *string                                          `json:"merge_result_id,omitempty"`   // ID of merge result
  NoteDisplay     *string                                          `json:"note_display,omitempty"`      // Note Display
  NoteState       *string                                          `json:"note_state,omitempty"`        // Note State
  NoteText        *string                                          `json:"note_text,omitempty"`         // Note Text
  Query           *WriteQuery                                      `json:"query,omitempty"`            
  QueryId         *int64                                           `json:"query_id,omitempty"`          // Id Of Query
  RefreshInterval *string                                          `json:"refresh_interval,omitempty"`  // Refresh Interval
  ResultMaker     *WriteResultMakerWithIdVisConfigAndDynamicFields `json:"result_maker,omitempty"`     
  ResultMakerId   *int64                                           `json:"result_maker_id,omitempty"`   // ID of the ResultMakerLookup entry.
  SubtitleText    *string                                          `json:"subtitle_text,omitempty"`     // Text tile subtitle text
  Title           *string                                          `json:"title,omitempty"`             // Title of dashboard element
  TitleHidden     *bool                                            `json:"title_hidden,omitempty"`      // Whether title is hidden
  TitleText       *string                                          `json:"title_text,omitempty"`        // Text tile title
  Type            *string                                          `json:"type,omitempty"`              // Type
}

// Dynamically generated writeable type for DashboardFilter removes properties:
// can, id, dashboard_id, field
type WriteDashboardFilter struct {
  Name                *string                 `json:"name,omitempty"`                   // Name of filter
  Title               *string                 `json:"title,omitempty"`                  // Title of filter
  Type                *string                 `json:"type,omitempty"`                   // Type of filter: one of date, number, string, or field
  DefaultValue        *string                 `json:"default_value,omitempty"`          // Default value of filter
  Model               *string                 `json:"model,omitempty"`                  // Model of filter (required if type = field)
  Explore             *string                 `json:"explore,omitempty"`                // Explore of filter (required if type = field)
  Dimension           *string                 `json:"dimension,omitempty"`              // Dimension of filter (required if type = field)
  Row                 *int64                  `json:"row,omitempty"`                    // Display order of this filter relative to other filters
  ListensToFilters    *[]string               `json:"listens_to_filters,omitempty"`     // Array of listeners for faceted filters
  AllowMultipleValues *bool                   `json:"allow_multiple_values,omitempty"`  // Whether the filter allows multiple filter values
  Required            *bool                   `json:"required,omitempty"`               // Whether the filter requires a value to run the dashboard
  UiConfig            *map[string]interface{} `json:"ui_config,omitempty"`              // The visual configuration for this filter. Used to set up how the UI for this filter should appear.
}

// Dynamically generated writeable type for DashboardLayout removes properties:
// can, id, deleted, dashboard_title, dashboard_layout_components
type WriteDashboardLayout struct {
  DashboardId *string `json:"dashboard_id,omitempty"`  // Id of Dashboard
  Type        *string `json:"type,omitempty"`          // Type
  Active      *bool   `json:"active,omitempty"`        // Is Active
  ColumnWidth *int64  `json:"column_width,omitempty"`  // Column Width
  Width       *int64  `json:"width,omitempty"`         // Width
}

// Dynamically generated writeable type for DashboardLayoutComponent removes properties:
// can, id, deleted, element_title, element_title_hidden, vis_type
type WriteDashboardLayoutComponent struct {
  DashboardLayoutId  *string `json:"dashboard_layout_id,omitempty"`   // Id of Dashboard Layout
  DashboardElementId *string `json:"dashboard_element_id,omitempty"`  // Id Of Dashboard Element
  Row                *int64  `json:"row,omitempty"`                   // Row
  Column             *int64  `json:"column,omitempty"`                // Column
  Width              *int64  `json:"width,omitempty"`                 // Width
  Height             *int64  `json:"height,omitempty"`                // Height
}

// Dynamically generated writeable type for Datagroup removes properties:
// can, created_at, id, model_name, name, trigger_check_at, trigger_error, trigger_value
type WriteDatagroup struct {
  StaleBefore *int64 `json:"stale_before,omitempty"`  // UNIX timestamp before which cache entries are considered stale. Cannot be in the future.
  TriggeredAt *int64 `json:"triggered_at,omitempty"`  // UNIX timestamp at which this entry became triggered. Cannot be in the future.
}

// Dynamically generated writeable type for DBConnection removes properties:
// can, dialect, snippets, uses_oauth, created_at, user_id, example, last_regen_at, last_reap_at, managed
type WriteDBConnection struct {
  Name                    *string                    `json:"name,omitempty"`                        // Name of the connection. Also used as the unique identifier
  Host                    *string                    `json:"host,omitempty"`                        // Host name/address of server
  Port                    *int64                     `json:"port,omitempty"`                        // Port number on server
  Username                *string                    `json:"username,omitempty"`                    // Username for server authentication
  Password                *string                    `json:"password,omitempty"`                    // (Write-Only) Password for server authentication
  Certificate             *string                    `json:"certificate,omitempty"`                 // (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
  FileType                *string                    `json:"file_type,omitempty"`                   // (Write-Only) Certificate keyfile type - .json or .p12
  Database                *string                    `json:"database,omitempty"`                    // Database name
  DbTimezone              *string                    `json:"db_timezone,omitempty"`                 // Time zone of database
  QueryTimezone           *string                    `json:"query_timezone,omitempty"`              // Timezone to use in queries
  Schema                  *string                    `json:"schema,omitempty"`                      // Scheme name
  MaxConnections          *int64                     `json:"max_connections,omitempty"`             // Maximum number of concurrent connection to use
  MaxBillingGigabytes     *string                    `json:"max_billing_gigabytes,omitempty"`       // Maximum size of query in GBs (BigQuery only, can be a user_attribute name)
  Ssl                     *bool                      `json:"ssl,omitempty"`                         // Use SSL/TLS when connecting to server
  VerifySsl               *bool                      `json:"verify_ssl,omitempty"`                  // Verify the SSL
  TmpDbName               *string                    `json:"tmp_db_name,omitempty"`                 // Name of temporary database (if used)
  JdbcAdditionalParams    *string                    `json:"jdbc_additional_params,omitempty"`      // Additional params to add to JDBC connection string
  PoolTimeout             *int64                     `json:"pool_timeout,omitempty"`                // Connection Pool Timeout, in seconds
  DialectName             *string                    `json:"dialect_name,omitempty"`                // (Read/Write) SQL Dialect name
  UserDbCredentials       *bool                      `json:"user_db_credentials,omitempty"`         // (Limited access feature) Are per user db credentials enabled. Enabling will remove previously set username and password
  UserAttributeFields     *[]string                  `json:"user_attribute_fields,omitempty"`       // Fields whose values map to user attribute names
  MaintenanceCron         *string                    `json:"maintenance_cron,omitempty"`            // Cron string specifying when maintenance such as PDT trigger checks and drops should be performed
  SqlRunnerPrecacheTables *bool                      `json:"sql_runner_precache_tables,omitempty"`  // Precache tables in the SQL Runner
  AfterConnectStatements  *string                    `json:"after_connect_statements,omitempty"`    // SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
  PdtContextOverride      *WriteDBConnectionOverride `json:"pdt_context_override,omitempty"`       
}

// Dynamically generated writeable type for DBConnectionOverride removes properties:
// has_password
type WriteDBConnectionOverride struct {
  Context                *string `json:"context,omitempty"`                   // Context in which to override (`pdt` is the only allowed value)
  Host                   *string `json:"host,omitempty"`                      // Host name/address of server
  Port                   *string `json:"port,omitempty"`                      // Port number on server
  Username               *string `json:"username,omitempty"`                  // Username for server authentication
  Password               *string `json:"password,omitempty"`                  // (Write-Only) Password for server authentication
  Certificate            *string `json:"certificate,omitempty"`               // (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
  FileType               *string `json:"file_type,omitempty"`                 // (Write-Only) Certificate keyfile type - .json or .p12
  Database               *string `json:"database,omitempty"`                  // Database name
  Schema                 *string `json:"schema,omitempty"`                    // Scheme name
  JdbcAdditionalParams   *string `json:"jdbc_additional_params,omitempty"`    // Additional params to add to JDBC connection string
  AfterConnectStatements *string `json:"after_connect_statements,omitempty"`  // SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
}

// Dynamically generated writeable type for FolderBase removes properties:
// id, content_metadata_id, created_at, creator_id, child_count, external_id, is_embed, is_embed_shared_root, is_embed_users_root, is_personal, is_personal_descendant, is_shared_root, is_users_root, can
type WriteFolderBase struct {
  Name     string  `json:"name"`                 // Unique Name
  ParentId *string `json:"parent_id,omitempty"`  // Id of Parent. If the parent id is null, this is a root-level entry
}

// Dynamically generated writeable type for GitBranch removes properties:
// can, remote, remote_name, error, message, owner_name, readonly, personal, is_local, is_remote, is_production, ahead_count, behind_count, commit_at, remote_ref
type WriteGitBranch struct {
  Name *string `json:"name,omitempty"`  // The short name on the local. Updating `name` results in `git checkout <new_name>`
  Ref  *string `json:"ref,omitempty"`   // The resolved ref of this branch. Updating `ref` results in `git reset --hard <new_ref>``.
}

// Dynamically generated writeable type for Group removes properties:
// can, contains_current_user, external_group_id, externally_managed, id, include_by_default, user_count
type WriteGroup struct {
  CanAddToContentMetadata *bool   `json:"can_add_to_content_metadata,omitempty"`  // Group can be used in content access controls
  Name                    *string `json:"name,omitempty"`                         // Name of group
}

// Dynamically generated writeable type for Homepage removes properties:
// can, content_metadata_id, created_at, homepage_sections, id, updated_at, user_id, primary_homepage
type WriteHomepage struct {
  DeletedAt    *time.Time `json:"deleted_at,omitempty"`     // Date of homepage deletion
  Description  *string    `json:"description,omitempty"`    // Description of homepage
  SectionOrder *[]int64   `json:"section_order,omitempty"`  // ids of the homepage sections in the order they should be displayed
  Title        *string    `json:"title,omitempty"`          // Title of homepage
}

// Dynamically generated writeable type for HomepageItem removes properties:
// can, content_created_by, content_favorite_id, content_metadata_id, content_updated_at, custom_image_url, description, favorite_count, id, image_url, location, section_fetch_time, title, url, view_count
type WriteHomepageItem struct {
  CustomDescription     *string `json:"custom_description,omitempty"`        // Custom description entered by the user, if present
  CustomImageDataBase64 *string `json:"custom_image_data_base64,omitempty"`  // (Write-Only) base64 encoded image data
  CustomTitle           *string `json:"custom_title,omitempty"`              // Custom title entered by the user, if present
  CustomUrl             *string `json:"custom_url,omitempty"`                // Custom url entered by the user, if present
  DashboardId           *int64  `json:"dashboard_id,omitempty"`              // Dashboard to base this item on
  HomepageSectionId     *int64  `json:"homepage_section_id,omitempty"`       // Associated Homepage Section
  LookId                *int64  `json:"look_id,omitempty"`                   // Look to base this item on
  LookmlDashboardId     *string `json:"lookml_dashboard_id,omitempty"`       // LookML Dashboard to base this item on
  Order                 *int64  `json:"order,omitempty"`                     // An arbitrary integer representing the sort order within the section
  UseCustomDescription  *bool   `json:"use_custom_description,omitempty"`    // Whether the custom description should be used instead of the content description, if the item is associated with content
  UseCustomImage        *bool   `json:"use_custom_image,omitempty"`          // Whether the custom image should be used instead of the content image, if the item is associated with content
  UseCustomTitle        *bool   `json:"use_custom_title,omitempty"`          // Whether the custom title should be used instead of the content title, if the item is associated with content
  UseCustomUrl          *bool   `json:"use_custom_url,omitempty"`            // Whether the custom url should be used instead of the content url, if the item is associated with content
}

// Dynamically generated writeable type for HomepageSection removes properties:
// can, created_at, detail_url, homepage_items, id, is_header, updated_at
type WriteHomepageSection struct {
  DeletedAt   *time.Time `json:"deleted_at,omitempty"`   // Time at which this section was deleted.
  HomepageId  *int64     `json:"homepage_id,omitempty"`  // Id reference to parent homepage
  ItemOrder   *[]int64   `json:"item_order,omitempty"`   // ids of the homepage items in the order they should be displayed
  Title       *string    `json:"title,omitempty"`        // Name of row
  Description *string    `json:"description,omitempty"`  // Description of the content found in this section.
}

// Dynamically generated writeable type for Integration removes properties:
// can, id, integration_hub_id, label, description, supported_formats, supported_action_types, supported_formattings, supported_visualization_formattings, supported_download_settings, icon_url, uses_oauth, required_fields, delegate_oauth
type WriteIntegration struct {
  Enabled                       *bool               `json:"enabled,omitempty"`                           // Whether the integration is available to users.
  Params                        *[]IntegrationParam `json:"params,omitempty"`                            // Array of params for the integration.
  InstalledDelegateOauthTargets *[]int64            `json:"installed_delegate_oauth_targets,omitempty"`  // Whether the integration is available to users.
}

// Dynamically generated writeable type for IntegrationHub removes properties:
// can, id, label, official, fetch_error_message, has_authorization_token, legal_agreement_signed, legal_agreement_required, legal_agreement_text
type WriteIntegrationHub struct {
  Url                *string `json:"url,omitempty"`                  // URL of the hub.
  AuthorizationToken *string `json:"authorization_token,omitempty"`  // (Write-Only) An authorization key that will be sent to the integration hub on every request.
}

// Dynamically generated writeable type for InternalHelpResources removes properties:
// can
type WriteInternalHelpResources struct {
  Enabled *bool `json:"enabled,omitempty"`  // If true and internal help resources content is not blank then the link for internal help resources will be shown in the help menu and the content displayed within Looker
}

// Dynamically generated writeable type for InternalHelpResourcesContent removes properties:
// can
type WriteInternalHelpResourcesContent struct {
  OrganizationName *string `json:"organization_name,omitempty"`  // Text to display in the help menu item which will display the internal help resources
  MarkdownContent  *string `json:"markdown_content,omitempty"`   // Content to be displayed in the internal help resources page/modal
}

// Dynamically generated writeable type for LDAPConfig removes properties:
// can, default_new_user_groups, default_new_user_roles, groups, has_auth_password, modified_at, modified_by, user_attributes, url
type WriteLDAPConfig struct {
  AlternateEmailLoginAllowed *bool                     `json:"alternate_email_login_allowed,omitempty"`  // Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
  AuthPassword               *string                   `json:"auth_password,omitempty"`                  // (Write-Only)  Password for the LDAP account used to access the LDAP server
  AuthRequiresRole           *bool                     `json:"auth_requires_role,omitempty"`             // Users will not be allowed to login at all unless a role for them is found in LDAP if set to true
  AuthUsername               *string                   `json:"auth_username,omitempty"`                  // Distinguished name of LDAP account used to access the LDAP server
  ConnectionHost             *string                   `json:"connection_host,omitempty"`                // LDAP server hostname
  ConnectionPort             *string                   `json:"connection_port,omitempty"`                // LDAP host port
  ConnectionTls              *bool                     `json:"connection_tls,omitempty"`                 // Use Transport Layer Security
  ConnectionTlsNoVerify      *bool                     `json:"connection_tls_no_verify,omitempty"`       // Do not verify peer when using TLS
  DefaultNewUserGroupIds     *[]int64                  `json:"default_new_user_group_ids,omitempty"`     // (Write-Only)  Array of ids of groups that will be applied to new users the first time they login via LDAP
  DefaultNewUserRoleIds      *[]int64                  `json:"default_new_user_role_ids,omitempty"`      // (Write-Only)  Array of ids of roles that will be applied to new users the first time they login via LDAP
  Enabled                    *bool                     `json:"enabled,omitempty"`                        // Enable/Disable LDAP authentication for the server
  ForceNoPage                *bool                     `json:"force_no_page,omitempty"`                  // Don't attempt to do LDAP search result paging (RFC 2696) even if the LDAP server claims to support it.
  GroupsBaseDn               *string                   `json:"groups_base_dn,omitempty"`                 // Base dn for finding groups in LDAP searches
  GroupsFinderType           *string                   `json:"groups_finder_type,omitempty"`             // Identifier for a strategy for how Looker will search for groups in the LDAP server
  GroupsMemberAttribute      *string                   `json:"groups_member_attribute,omitempty"`        // LDAP Group attribute that signifies the members of the groups. Most commonly 'member'
  GroupsObjectclasses        *string                   `json:"groups_objectclasses,omitempty"`           // Optional comma-separated list of supported LDAP objectclass for groups when doing groups searches
  GroupsUserAttribute        *string                   `json:"groups_user_attribute,omitempty"`          // LDAP Group attribute that signifies the user in a group. Most commonly 'dn'
  GroupsWithRoleIds          *[]LDAPGroupWrite         `json:"groups_with_role_ids,omitempty"`           // (Read/Write) Array of mappings between LDAP Groups and arrays of Looker Role ids
  MergeNewUsersByEmail       *bool                     `json:"merge_new_users_by_email,omitempty"`       // Merge first-time ldap login to existing user account by email addresses. When a user logs in for the first time via ldap this option will connect this user into their existing account by finding the account with a matching email address. Otherwise a new user account will be created for the user.
  SetRolesFromGroups         *bool                     `json:"set_roles_from_groups,omitempty"`          // Set user roles in Looker based on groups from LDAP
  TestLdapPassword           *string                   `json:"test_ldap_password,omitempty"`             // (Write-Only)  Test LDAP user password. For ldap tests only.
  TestLdapUser               *string                   `json:"test_ldap_user,omitempty"`                 // (Write-Only)  Test LDAP user login id. For ldap tests only.
  UserAttributeMapEmail      *string                   `json:"user_attribute_map_email,omitempty"`       // Name of user record attributes used to indicate email address field
  UserAttributeMapFirstName  *string                   `json:"user_attribute_map_first_name,omitempty"`  // Name of user record attributes used to indicate first name
  UserAttributeMapLastName   *string                   `json:"user_attribute_map_last_name,omitempty"`   // Name of user record attributes used to indicate last name
  UserAttributeMapLdapId     *string                   `json:"user_attribute_map_ldap_id,omitempty"`     // Name of user record attributes used to indicate unique record id
  UserAttributesWithIds      *[]LDAPUserAttributeWrite `json:"user_attributes_with_ids,omitempty"`       // (Read/Write) Array of mappings between LDAP User Attributes and arrays of Looker User Attribute ids
  UserBindBaseDn             *string                   `json:"user_bind_base_dn,omitempty"`              // Distinguished name of LDAP node used as the base for user searches
  UserCustomFilter           *string                   `json:"user_custom_filter,omitempty"`             // (Optional) Custom RFC-2254 filter clause for use in finding user during login. Combined via 'and' with the other generated filter clauses.
  UserIdAttributeNames       *string                   `json:"user_id_attribute_names,omitempty"`        // Name(s) of user record attributes used for matching user login id (comma separated list)
  UserObjectclass            *string                   `json:"user_objectclass,omitempty"`               // (Optional) Name of user record objectclass used for finding user during login id
}

// Dynamically generated writeable type for LegacyFeature removes properties:
// can, id, name, description, enabled, disallowed_as_of_version, disable_on_upgrade_to_version, end_of_life_version, documentation_url, approximate_disable_date, approximate_end_of_life_date, has_disabled_on_upgrade
type WriteLegacyFeature struct {
  EnabledLocally *bool `json:"enabled_locally,omitempty"`  // Whether this feature has been enabled by a user
}

// Dynamically generated writeable type for LookmlModel removes properties:
// can, explores, has_content, label
type WriteLookmlModel struct {
  AllowedDbConnectionNames *[]string `json:"allowed_db_connection_names,omitempty"`  // Array of names of connections this model is allowed to use
  Name                     *string   `json:"name,omitempty"`                         // Name of the model. Also used as the unique identifier
  ProjectName              *string   `json:"project_name,omitempty"`                 // Name of project containing the model
  UnlimitedDbConnections   *bool     `json:"unlimited_db_connections,omitempty"`     // Is this model allowed to use all current and future connections
}

// Dynamically generated writeable type for LookWithQuery removes properties:
// can, content_metadata_id, id, content_favorite_id, created_at, deleted_at, deleter_id, embed_url, excel_file_url, favorite_count, google_spreadsheet_formula, image_embed_url, last_accessed_at, last_updater_id, last_viewed_at, model, public_slug, public_url, short_url, updated_at, view_count, url
type WriteLookWithQuery struct {
  Title       *string          `json:"title,omitempty"`           // Look Title
  Deleted     *bool            `json:"deleted,omitempty"`         // Whether or not a look is 'soft' deleted.
  Description *string          `json:"description,omitempty"`     // Description
  IsRunOnLoad *bool            `json:"is_run_on_load,omitempty"`  // auto-run query when Look viewed
  Public      *bool            `json:"public,omitempty"`          // Is Public
  QueryId     *int64           `json:"query_id,omitempty"`        // Query Id
  Space       *WriteSpaceBase  `json:"space,omitempty"`          
  Folder      *WriteFolderBase `json:"folder,omitempty"`         
  SpaceId     *string          `json:"space_id,omitempty"`        // Space Id
  FolderId    *string          `json:"folder_id,omitempty"`       // Folder Id
  UserId      *int64           `json:"user_id,omitempty"`         // User Id
  Query       *WriteQuery      `json:"query,omitempty"`          
}

// Dynamically generated writeable type for MergeQuery removes properties:
// can, id, result_maker_id
type WriteMergeQuery struct {
  ColumnLimit   *string                  `json:"column_limit,omitempty"`    // Column Limit
  DynamicFields *string                  `json:"dynamic_fields,omitempty"`  // Dynamic Fields
  Pivots        *[]string                `json:"pivots,omitempty"`          // Pivots
  Sorts         *[]string                `json:"sorts,omitempty"`           // Sorts
  SourceQueries *[]MergeQuerySourceQuery `json:"source_queries,omitempty"`  // Source Queries defining the results to be merged.
  Total         *bool                    `json:"total,omitempty"`           // Total
  VisConfig     *map[string]interface{}  `json:"vis_config,omitempty"`      // Visualization Config
}

// Dynamically generated writeable type for ModelSet removes properties:
// can, all_access, built_in, id, url
type WriteModelSet struct {
  Models *[]string `json:"models,omitempty"` 
  Name   *string   `json:"name,omitempty"`    // Name of ModelSet
}

// Dynamically generated writeable type for OIDCConfig removes properties:
// can, default_new_user_groups, default_new_user_roles, groups, modified_at, modified_by, test_slug, user_attributes, url
type WriteOIDCConfig struct {
  AlternateEmailLoginAllowed *bool                     `json:"alternate_email_login_allowed,omitempty"`  // Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
  Audience                   *string                   `json:"audience,omitempty"`                       // OpenID Provider Audience
  AuthRequiresRole           *bool                     `json:"auth_requires_role,omitempty"`             // Users will not be allowed to login at all unless a role for them is found in OIDC if set to true
  AuthorizationEndpoint      *url.URL                  `json:"authorization_endpoint,omitempty"`         // OpenID Provider Authorization Url
  DefaultNewUserGroupIds     *[]int64                  `json:"default_new_user_group_ids,omitempty"`     // (Write-Only) Array of ids of groups that will be applied to new users the first time they login via OIDC
  DefaultNewUserRoleIds      *[]int64                  `json:"default_new_user_role_ids,omitempty"`      // (Write-Only) Array of ids of roles that will be applied to new users the first time they login via OIDC
  Enabled                    *bool                     `json:"enabled,omitempty"`                        // Enable/Disable OIDC authentication for the server
  GroupsAttribute            *string                   `json:"groups_attribute,omitempty"`               // Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
  GroupsWithRoleIds          *[]OIDCGroupWrite         `json:"groups_with_role_ids,omitempty"`           // (Read/Write) Array of mappings between OIDC Groups and arrays of Looker Role ids
  Identifier                 *string                   `json:"identifier,omitempty"`                     // Relying Party Identifier (provided by OpenID Provider)
  Issuer                     *string                   `json:"issuer,omitempty"`                         // OpenID Provider Issuer
  NewUserMigrationTypes      *string                   `json:"new_user_migration_types,omitempty"`       // Merge first-time oidc login to existing user account by email addresses. When a user logs in for the first time via oidc this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
  Scopes                     *[]string                 `json:"scopes,omitempty"`                         // Array of scopes to request.
  Secret                     *string                   `json:"secret,omitempty"`                         // (Write-Only) Relying Party Secret (provided by OpenID Provider)
  SetRolesFromGroups         *bool                     `json:"set_roles_from_groups,omitempty"`          // Set user roles in Looker based on groups from OIDC
  TokenEndpoint              *string                   `json:"token_endpoint,omitempty"`                 // OpenID Provider Token Url
  UserAttributeMapEmail      *string                   `json:"user_attribute_map_email,omitempty"`       // Name of user record attributes used to indicate email address field
  UserAttributeMapFirstName  *string                   `json:"user_attribute_map_first_name,omitempty"`  // Name of user record attributes used to indicate first name
  UserAttributeMapLastName   *string                   `json:"user_attribute_map_last_name,omitempty"`   // Name of user record attributes used to indicate last name
  UserAttributesWithIds      *[]OIDCUserAttributeWrite `json:"user_attributes_with_ids,omitempty"`       // (Read/Write) Array of mappings between OIDC User Attributes and arrays of Looker User Attribute ids
  UserinfoEndpoint           *url.URL                  `json:"userinfo_endpoint,omitempty"`              // OpenID Provider User Information Url
}

// Dynamically generated writeable type for PasswordConfig removes properties:
// can
type WritePasswordConfig struct {
  MinLength         *int64 `json:"min_length,omitempty"`          // Minimum number of characters required for a new password.  Must be between 7 and 100
  RequireNumeric    *bool  `json:"require_numeric,omitempty"`     // Require at least one numeric character
  RequireUpperlower *bool  `json:"require_upperlower,omitempty"`  // Require at least one uppercase and one lowercase letter
  RequireSpecial    *bool  `json:"require_special,omitempty"`     // Require at least one special character
}

// Dynamically generated writeable type for PermissionSet removes properties:
// can, all_access, built_in, id, url
type WritePermissionSet struct {
  Name        *string   `json:"name,omitempty"`         // Name of PermissionSet
  Permissions *[]string `json:"permissions,omitempty"` 
}

// Dynamically generated writeable type for Project removes properties:
// can, id, uses_git, is_example
type WriteProject struct {
  Name                     *string              `json:"name,omitempty"`                         // Project display name
  GitRemoteUrl             *string              `json:"git_remote_url,omitempty"`               // Git remote repository url
  GitUsername              *string              `json:"git_username,omitempty"`                 // Git username for HTTPS authentication. (For production only, if using user attributes.)
  GitPassword              *string              `json:"git_password,omitempty"`                 // (Write-Only) Git password for HTTPS authentication. (For production only, if using user attributes.)
  GitUsernameUserAttribute *string              `json:"git_username_user_attribute,omitempty"`  // User attribute name for username in per-user HTTPS authentication.
  GitPasswordUserAttribute *string              `json:"git_password_user_attribute,omitempty"`  // User attribute name for password in per-user HTTPS authentication.
  GitServiceName           *string              `json:"git_service_name,omitempty"`             // Name of the git service provider
  DeploySecret             *string              `json:"deploy_secret,omitempty"`                // (Write-Only) Optional secret token with which to authenticate requests to the webhook deploy endpoint. If not set, endpoint is unauthenticated.
  UnsetDeploySecret        *bool                `json:"unset_deploy_secret,omitempty"`          // (Write-Only) When true, unsets the deploy secret to allow unauthenticated access to the webhook deploy endpoint.
  PullRequestMode          *PullRequestModeType `json:"pull_request_mode,omitempty"`            // The git pull request policy for this project. Valid values are: "off", "links", "recommended", "required".
  ValidationRequired       *bool                `json:"validation_required,omitempty"`          // Validation policy: If true, the project must pass validation checks before project changes can be committed to the git repository
  FoldersEnabled           *bool                `json:"folders_enabled,omitempty"`              // If true, folders are enabled for this project
  GitReleaseMgmtEnabled    *bool                `json:"git_release_mgmt_enabled,omitempty"`     // If true, advanced git release management is enabled for this project
  AllowWarnings            *bool                `json:"allow_warnings,omitempty"`               // Validation policy: If true, the project can be committed with warnings when `validation_required` is true. (`allow_warnings` does nothing if `validation_required` is false).
}

// Dynamically generated writeable type for Query removes properties:
// can, id, slug, share_url, expanded_share_url, url, has_table_calculations
type WriteQuery struct {
  Model             string                  `json:"model"`                          // Model
  View              string                  `json:"view"`                           // Explore Name
  Fields            *[]string               `json:"fields,omitempty"`               // Fields
  Pivots            *[]string               `json:"pivots,omitempty"`               // Pivots
  FillFields        *[]string               `json:"fill_fields,omitempty"`          // Fill Fields
  Filters           *map[string]interface{} `json:"filters,omitempty"`              // Filters
  FilterExpression  *string                 `json:"filter_expression,omitempty"`    // Filter Expression
  Sorts             *[]string               `json:"sorts,omitempty"`                // Sorting for the query results. Use the format `["view.field", ...]` to sort on fields in ascending order. Use the format `["view.field desc", ...]` to sort on fields in descending order. Use `["__UNSORTED__"]` (2 underscores before and after) to disable sorting entirely. Empty sorts `[]` will trigger a default sort.
  Limit             *string                 `json:"limit,omitempty"`                // Limit
  ColumnLimit       *string                 `json:"column_limit,omitempty"`         // Column Limit
  Total             *bool                   `json:"total,omitempty"`                // Total
  RowTotal          *string                 `json:"row_total,omitempty"`            // Raw Total
  Subtotals         *[]string               `json:"subtotals,omitempty"`            // Fields on which to run subtotals
  Runtime           *float64                `json:"runtime,omitempty"`              // Runtime
  VisConfig         *map[string]interface{} `json:"vis_config,omitempty"`           // Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
  FilterConfig      *map[string]interface{} `json:"filter_config,omitempty"`        // The filter_config represents the state of the filter UI on the explore page for a given query. When running a query via the Looker UI, this parameter takes precedence over "filters". When creating a query or modifying an existing query, "filter_config" should be set to null. Setting it to any other value could cause unexpected filtering behavior. The format should be considered opaque.
  VisibleUiSections *string                 `json:"visible_ui_sections,omitempty"`  // Visible UI Sections
  DynamicFields     *string                 `json:"dynamic_fields,omitempty"`       // Dynamic Fields
  ClientId          *string                 `json:"client_id,omitempty"`            // Client Id: used to generate shortened explore URLs. If set by client, must be a unique 22 character alphanumeric string. Otherwise one will be generated.
  QueryTimezone     *string                 `json:"query_timezone,omitempty"`       // Query Timezone
}

// Dynamically generated writeable type for RepositoryCredential removes properties:
// can, id, root_project_id, remote_url, is_configured
type WriteRepositoryCredential struct {
  GitUsername  *string `json:"git_username,omitempty"`    // Git username for HTTPS authentication.
  GitPassword  *string `json:"git_password,omitempty"`    // (Write-Only) Git password for HTTPS authentication.
  SshPublicKey *string `json:"ssh_public_key,omitempty"`  // Public deploy key for SSH authentication.
}

// Dynamically generated writeable type for ResultMakerWithIdVisConfigAndDynamicFields removes properties:
// id, dynamic_fields, filterables, sorts, merge_result_id, total, query_id, sql_query_id, vis_config
type WriteResultMakerWithIdVisConfigAndDynamicFields struct {
  Query *WriteQuery `json:"query,omitempty"` 
}

// Dynamically generated writeable type for Role removes properties:
// can, id, url, users_url
type WriteRole struct {
  Name            *string             `json:"name,omitempty"`               // Name of Role
  PermissionSet   *WritePermissionSet `json:"permission_set,omitempty"`    
  PermissionSetId *int64              `json:"permission_set_id,omitempty"`  // (Write-Only) Id of permission set
  ModelSet        *WriteModelSet      `json:"model_set,omitempty"`         
  ModelSetId      *int64              `json:"model_set_id,omitempty"`       // (Write-Only) Id of model set
}

// Dynamically generated writeable type for SamlConfig removes properties:
// can, test_slug, modified_at, modified_by, default_new_user_roles, default_new_user_groups, groups, user_attributes, url
type WriteSamlConfig struct {
  Enabled                    *bool                     `json:"enabled,omitempty"`                        // Enable/Disable Saml authentication for the server
  IdpCert                    *string                   `json:"idp_cert,omitempty"`                       // Identity Provider Certificate (provided by IdP)
  IdpUrl                     *string                   `json:"idp_url,omitempty"`                        // Identity Provider Url (provided by IdP)
  IdpIssuer                  *string                   `json:"idp_issuer,omitempty"`                     // Identity Provider Issuer (provided by IdP)
  IdpAudience                *string                   `json:"idp_audience,omitempty"`                   // Identity Provider Audience (set in IdP config). Optional in Looker. Set this only if you want Looker to validate the audience value returned by the IdP.
  AllowedClockDrift          *int64                    `json:"allowed_clock_drift,omitempty"`            // Count of seconds of clock drift to allow when validating timestamps of assertions.
  UserAttributeMapEmail      *string                   `json:"user_attribute_map_email,omitempty"`       // Name of user record attributes used to indicate email address field
  UserAttributeMapFirstName  *string                   `json:"user_attribute_map_first_name,omitempty"`  // Name of user record attributes used to indicate first name
  UserAttributeMapLastName   *string                   `json:"user_attribute_map_last_name,omitempty"`   // Name of user record attributes used to indicate last name
  NewUserMigrationTypes      *string                   `json:"new_user_migration_types,omitempty"`       // Merge first-time saml login to existing user account by email addresses. When a user logs in for the first time via saml this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
  AlternateEmailLoginAllowed *bool                     `json:"alternate_email_login_allowed,omitempty"`  // Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
  DefaultNewUserRoleIds      *[]int64                  `json:"default_new_user_role_ids,omitempty"`      // (Write-Only) Array of ids of roles that will be applied to new users the first time they login via Saml
  DefaultNewUserGroupIds     *[]int64                  `json:"default_new_user_group_ids,omitempty"`     // (Write-Only) Array of ids of groups that will be applied to new users the first time they login via Saml
  SetRolesFromGroups         *bool                     `json:"set_roles_from_groups,omitempty"`          // Set user roles in Looker based on groups from Saml
  GroupsAttribute            *string                   `json:"groups_attribute,omitempty"`               // Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
  GroupsWithRoleIds          *[]SamlGroupWrite         `json:"groups_with_role_ids,omitempty"`           // (Read/Write) Array of mappings between Saml Groups and arrays of Looker Role ids
  AuthRequiresRole           *bool                     `json:"auth_requires_role,omitempty"`             // Users will not be allowed to login at all unless a role for them is found in Saml if set to true
  UserAttributesWithIds      *[]SamlUserAttributeWrite `json:"user_attributes_with_ids,omitempty"`       // (Read/Write) Array of mappings between Saml User Attributes and arrays of Looker User Attribute ids
  GroupsFinderType           *string                   `json:"groups_finder_type,omitempty"`             // Identifier for a strategy for how Looker will find groups in the SAML response. One of ['grouped_attribute_values', 'individual_attributes']
  GroupsMemberValue          *string                   `json:"groups_member_value,omitempty"`            // Value for group attribute used to indicate membership. Used when 'groups_finder_type' is set to 'individual_attributes'
  BypassLoginPage            *bool                     `json:"bypass_login_page,omitempty"`              // Bypass the login page when user authentication is required. Redirect to IdP immediately instead.
}

// Dynamically generated writeable type for ScheduledPlan removes properties:
// id, created_at, updated_at, title, user, next_run_at, last_run_at, can
type WriteScheduledPlan struct {
  Name                     *string                     `json:"name,omitempty"`                        // Name of this scheduled plan
  UserId                   *int64                      `json:"user_id,omitempty"`                     // User Id which owns this scheduled plan
  RunAsRecipient           *bool                       `json:"run_as_recipient,omitempty"`            // Whether schedule is run as recipient (only applicable for email recipients)
  Enabled                  *bool                       `json:"enabled,omitempty"`                     // Whether the ScheduledPlan is enabled
  LookId                   *int64                      `json:"look_id,omitempty"`                     // Id of a look
  DashboardId              *int64                      `json:"dashboard_id,omitempty"`                // Id of a dashboard
  LookmlDashboardId        *string                     `json:"lookml_dashboard_id,omitempty"`         // Id of a LookML dashboard
  FiltersString            *string                     `json:"filters_string,omitempty"`              // Query string to run look or dashboard with
  DashboardFilters         *string                     `json:"dashboard_filters,omitempty"`           // (DEPRECATED) Alias for filters_string field
  RequireResults           *bool                       `json:"require_results,omitempty"`             // Delivery should occur if running the dashboard or look returns results
  RequireNoResults         *bool                       `json:"require_no_results,omitempty"`          // Delivery should occur if the dashboard look does not return results
  RequireChange            *bool                       `json:"require_change,omitempty"`              // Delivery should occur if data have changed since the last run
  SendAllResults           *bool                       `json:"send_all_results,omitempty"`            // Will run an unlimited query and send all results.
  Crontab                  *string                     `json:"crontab,omitempty"`                     // Vixie-Style crontab specification when to run
  Datagroup                *string                     `json:"datagroup,omitempty"`                   // Name of a datagroup; if specified will run when datagroup triggered (can't be used with cron string)
  Timezone                 *string                     `json:"timezone,omitempty"`                    // Timezone for interpreting the specified crontab (default is Looker instance timezone)
  QueryId                  *string                     `json:"query_id,omitempty"`                    // Query id
  ScheduledPlanDestination *[]ScheduledPlanDestination `json:"scheduled_plan_destination,omitempty"`  // Scheduled plan destinations
  RunOnce                  *bool                       `json:"run_once,omitempty"`                    // Whether the plan in question should only be run once (usually for testing)
  IncludeLinks             *bool                       `json:"include_links,omitempty"`               // Whether links back to Looker should be included in this ScheduledPlan
  PdfPaperSize             *string                     `json:"pdf_paper_size,omitempty"`              // The size of paper a PDF should be rendered for
  PdfLandscape             *bool                       `json:"pdf_landscape,omitempty"`               // Whether the paper should be landscape
  Embed                    *bool                       `json:"embed,omitempty"`                       // Whether this schedule is in an embed context or not
  ColorTheme               *string                     `json:"color_theme,omitempty"`                 // Color scheme of the dashboard if applicable
  LongTables               *bool                       `json:"long_tables,omitempty"`                 // Whether or not to expand table vis to full length
}

// Dynamically generated writeable type for SessionConfig removes properties:
// can
type WriteSessionConfig struct {
  AllowPersistentSessions  *bool  `json:"allow_persistent_sessions,omitempty"`    // Allow users to have persistent sessions when they login
  SessionMinutes           *int64 `json:"session_minutes,omitempty"`              // Number of minutes for user sessions.  Must be between 5 and 43200
  UnlimitedSessionsPerUser *bool  `json:"unlimited_sessions_per_user,omitempty"`  // Allow users to have an unbounded number of concurrent sessions (otherwise, users will be limited to only one session at a time).
  UseInactivityBasedLogout *bool  `json:"use_inactivity_based_logout,omitempty"`  // Enforce session logout for sessions that are inactive for 15 minutes.
  TrackSessionLocation     *bool  `json:"track_session_location,omitempty"`       // Track location of session when user logs in.
}

// Dynamically generated writeable type for SpaceBase removes properties:
// id, content_metadata_id, created_at, creator_id, child_count, external_id, is_embed, is_embed_shared_root, is_embed_users_root, is_personal, is_personal_descendant, is_shared_root, is_users_root, can
type WriteSpaceBase struct {
  Name     string  `json:"name"`                 // Unique Name
  ParentId *string `json:"parent_id,omitempty"`  // Id of Parent. If the parent id is null, this is a root-level entry
}

// Dynamically generated writeable type for Theme removes properties:
// can, id
type WriteTheme struct {
  BeginAt  *time.Time     `json:"begin_at,omitempty"`  // Timestamp for when this theme becomes active. Null=always
  EndAt    *time.Time     `json:"end_at,omitempty"`    // Timestamp for when this theme expires. Null=never
  Name     *string        `json:"name,omitempty"`      // Name of theme. Can only be alphanumeric and underscores.
  Settings *ThemeSettings `json:"settings,omitempty"` 
}

// Dynamically generated writeable type for User removes properties:
// can, avatar_url, avatar_url_without_sizing, credentials_api3, credentials_embed, credentials_google, credentials_ldap, credentials_looker_openid, credentials_oidc, credentials_saml, credentials_totp, display_name, email, embed_group_space_id, group_ids, id, looker_versions, personal_space_id, personal_folder_id, presumed_looker_employee, role_ids, sessions, verified_looker_employee, roles_externally_managed, url
type WriteUser struct {
  CredentialsEmail   *WriteCredentialsEmail  `json:"credentials_email,omitempty"`    
  FirstName          *string                 `json:"first_name,omitempty"`            // First name
  HomeSpaceId        *string                 `json:"home_space_id,omitempty"`         // ID string for user's home space
  HomeFolderId       *string                 `json:"home_folder_id,omitempty"`        // ID string for user's home folder
  IsDisabled         *bool                   `json:"is_disabled,omitempty"`           // Account has been disabled
  LastName           *string                 `json:"last_name,omitempty"`             // Last name
  Locale             *string                 `json:"locale,omitempty"`                // User's preferred locale. User locale takes precedence over Looker's system-wide default locale. Locale determines language of display strings and date and numeric formatting in API responses. Locale string must be a 2 letter language code or a combination of language code and region code: 'en' or 'en-US', for example.
  ModelsDirValidated *bool                   `json:"models_dir_validated,omitempty"`  // User's dev workspace has been checked for presence of applicable production projects
  UiState            *map[string]interface{} `json:"ui_state,omitempty"`              // Per user dictionary of undocumented state information owned by the Looker UI.
}

// Dynamically generated writeable type for UserAttribute removes properties:
// can, id, is_system, is_permanent
type WriteUserAttribute struct {
  Name                       *string `json:"name,omitempty"`                           // Name of user attribute
  Label                      *string `json:"label,omitempty"`                          // Human-friendly label for user attribute
  Type                       *string `json:"type,omitempty"`                           // Type of user attribute ("string", "number", "datetime", "yesno", "zipcode")
  DefaultValue               *string `json:"default_value,omitempty"`                  // Default value for when no value is set on the user
  ValueIsHidden              *bool   `json:"value_is_hidden,omitempty"`                // If true, users will not be able to view values of this attribute
  UserCanView                *bool   `json:"user_can_view,omitempty"`                  // Non-admin users can see the values of their attributes and use them in filters
  UserCanEdit                *bool   `json:"user_can_edit,omitempty"`                  // Users can change the value of this attribute for themselves
  HiddenValueDomainWhitelist *string `json:"hidden_value_domain_whitelist,omitempty"`  // Destinations to which a hidden attribute may be sent. Once set, cannot be edited.
}

// Dynamically generated writeable type for UserAttributeWithValue removes properties:
// can, name, label, rank, user_id, user_can_edit, value_is_hidden, user_attribute_id, source, hidden_value_domain_whitelist
type WriteUserAttributeWithValue struct {
  Value *string `json:"value,omitempty"`  // Value of attribute for user
}

// Dynamically generated writeable type for WelcomeEmailTest removes properties:
// can
type WriteWelcomeEmailTest struct {
  Content *string `json:"content,omitempty"`  // The content that will be sent as part of a custom welcome email
}

// Dynamically generated writeable type for WhitelabelConfiguration removes properties:
// can, id, logo_url, favicon_url
type WriteWhitelabelConfiguration struct {
  LogoFile            *string `json:"logo_file,omitempty"`               // Customer logo image. Expected base64 encoded data (write-only)
  FaviconFile         *string `json:"favicon_file,omitempty"`            // Custom favicon image. Expected base64 encoded data (write-only)
  DefaultTitle        *string `json:"default_title,omitempty"`           // Default page title
  ShowHelpMenu        *bool   `json:"show_help_menu,omitempty"`          // Boolean to toggle showing help menus
  ShowDocs            *bool   `json:"show_docs,omitempty"`               // Boolean to toggle showing docs
  ShowEmailSubOptions *bool   `json:"show_email_sub_options,omitempty"`  // Boolean to toggle showing email subscription options.
  AllowLookerMentions *bool   `json:"allow_looker_mentions,omitempty"`   // Boolean to toggle mentions of Looker in emails
  AllowLookerLinks    *bool   `json:"allow_looker_links,omitempty"`      // Boolean to toggle links to Looker in emails
}