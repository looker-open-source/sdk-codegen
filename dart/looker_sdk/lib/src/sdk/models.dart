/*

 MIT License

 Copyright (c) 2021 Looker Data Sciences, Inc.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.


 */

/// 307 API models: 229 Spec, 0 Request, 58 Write, 20 Enum

// NOTE: Do not edit this file generated by Looker SDK Codegen for API 4.0

class AccessToken {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _accessToken;
  bool _accessTokenSet = false;

  String _tokenType;
  bool _tokenTypeSet = false;

  int _expiresIn;
  bool _expiresInSet = false;

  String _refreshToken;
  bool _refreshTokenSet = false;

  /// Access Token used for API calls (read-only)

  String get accessToken {
    if (!_accessTokenSet && _apiMapResponse.containsKey('access_token')) {
      _accessToken = _apiMapResponse['access_token']?.toString();
      _accessTokenSet = true;
    }
    return _accessToken;
  }

  set accessToken(String v) {
    _accessToken = v;
    _accessTokenSet = true;
  }

  /// Type of Token (read-only)

  String get tokenType {
    if (!_tokenTypeSet && _apiMapResponse.containsKey('token_type')) {
      _tokenType = _apiMapResponse['token_type']?.toString();
      _tokenTypeSet = true;
    }
    return _tokenType;
  }

  set tokenType(String v) {
    _tokenType = v;
    _tokenTypeSet = true;
  }

  /// Number of seconds before the token expires (read-only)

  int get expiresIn {
    if (!_expiresInSet && _apiMapResponse.containsKey('expires_in')) {
      _expiresIn = _apiMapResponse['expires_in'];
      _expiresInSet = true;
    }
    return _expiresIn;
  }

  set expiresIn(int v) {
    _expiresIn = v;
    _expiresInSet = true;
  }

  /// Refresh token which can be used to obtain a new access token (read-only)

  String get refreshToken {
    if (!_refreshTokenSet && _apiMapResponse.containsKey('refresh_token')) {
      _refreshToken = _apiMapResponse['refresh_token']?.toString();
      _refreshTokenSet = true;
    }
    return _refreshToken;
  }

  set refreshToken(String v) {
    _refreshToken = v;
    _refreshTokenSet = true;
  }

  AccessToken() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  AccessToken.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_accessTokenSet || _apiMapResponse.containsKey('access_token')) {
      json['access_token'] = accessToken;
    }
    if (_tokenTypeSet || _apiMapResponse.containsKey('token_type')) {
      json['token_type'] = tokenType;
    }
    if (_expiresInSet || _apiMapResponse.containsKey('expires_in')) {
      json['expires_in'] = expiresIn;
    }
    if (_refreshTokenSet || _apiMapResponse.containsKey('refresh_token')) {
      json['refresh_token'] = refreshToken;
    }
    return json;
  }
}

class Alert {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  List<AlertAppliedDashboardFilter> _appliedDashboardFilters;
  bool _appliedDashboardFiltersSet = false;

  ComparisonType _comparisonType;
  bool _comparisonTypeSet = false;

  String _cron;
  bool _cronSet = false;

  String _customTitle;
  bool _customTitleSet = false;

  int _dashboardElementId;
  bool _dashboardElementIdSet = false;

  String _description;
  bool _descriptionSet = false;

  List<AlertDestination> _destinations;
  bool _destinationsSet = false;

  AlertField _field;
  bool _fieldSet = false;

  bool _followed;
  bool _followedSet = false;

  bool _followable;
  bool _followableSet = false;

  int _id;
  bool _idSet = false;

  bool _isDisabled;
  bool _isDisabledSet = false;

  String _disabledReason;
  bool _disabledReasonSet = false;

  bool _isPublic;
  bool _isPublicSet = false;

  InvestigativeContentType _investigativeContentType;
  bool _investigativeContentTypeSet = false;

  String _investigativeContentId;
  bool _investigativeContentIdSet = false;

  String _investigativeContentTitle;
  bool _investigativeContentTitleSet = false;

  String _lookmlDashboardId;
  bool _lookmlDashboardIdSet = false;

  String _lookmlLinkId;
  bool _lookmlLinkIdSet = false;

  int _ownerId;
  bool _ownerIdSet = false;

  String _ownerDisplayName;
  bool _ownerDisplayNameSet = false;

  double _threshold;
  bool _thresholdSet = false;

  AlertConditionState _timeSeriesConditionState;
  bool _timeSeriesConditionStateSet = false;

  /// Filters coming from the dashboard that are applied. Example `[{ "filter_title": "Name", "field_name": "distribution_centers.name", "filter_value": "Los Angeles CA" }]`

  List<AlertAppliedDashboardFilter> get appliedDashboardFilters {
    if (!_appliedDashboardFiltersSet &&
        _apiMapResponse.containsKey('applied_dashboard_filters')) {
      _appliedDashboardFilters =
          _apiMapResponse['applied_dashboard_filters'] == null
              ? null
              : (_apiMapResponse['applied_dashboard_filters'] as List)
                  .map((i) => AlertAppliedDashboardFilter.fromResponse(
                      i, apiResponseContentType))
                  .toList();
      _appliedDashboardFiltersSet = true;
    }
    return _appliedDashboardFilters;
  }

  set appliedDashboardFilters(List<AlertAppliedDashboardFilter> v) {
    _appliedDashboardFilters = v;
    _appliedDashboardFiltersSet = true;
  }

  /// This property informs the check what kind of comparison we are performing. Only certain condition types are valid for time series alerts. For details, refer to [Setting Alert Conditions](https://docs.looker.com/sharing-and-publishing/creating-alerts#setting_alert_conditions) Valid values are: "EQUAL_TO", "GREATER_THAN", "GREATER_THAN_OR_EQUAL_TO", "LESS_THAN", "LESS_THAN_OR_EQUAL_TO", "INCREASES_BY", "DECREASES_BY", "CHANGES_BY".

  ComparisonType get comparisonType {
    if (!_comparisonTypeSet && _apiMapResponse.containsKey('comparison_type')) {
      _comparisonType = ComparisonTypeMapper.fromStringValue(
          _apiMapResponse['comparison_type']);
      _comparisonTypeSet = true;
    }
    return _comparisonType;
  }

  set comparisonType(ComparisonType v) {
    _comparisonType = v;
    _comparisonTypeSet = true;
  }

  /// Vixie-Style crontab specification when to run. At minumum, it has to be longer than 15 minute intervals

  String get cron {
    if (!_cronSet && _apiMapResponse.containsKey('cron')) {
      _cron = _apiMapResponse['cron']?.toString();
      _cronSet = true;
    }
    return _cron;
  }

  set cron(String v) {
    _cron = v;
    _cronSet = true;
  }

  /// An optional, user-defined title for the alert

  String get customTitle {
    if (!_customTitleSet && _apiMapResponse.containsKey('custom_title')) {
      _customTitle = _apiMapResponse['custom_title']?.toString();
      _customTitleSet = true;
    }
    return _customTitle;
  }

  set customTitle(String v) {
    _customTitle = v;
    _customTitleSet = true;
  }

  /// ID of the dashboard element associated with the alert. Refer to [dashboard_element()](#!/Dashboard/DashboardElement)

  int get dashboardElementId {
    if (!_dashboardElementIdSet &&
        _apiMapResponse.containsKey('dashboard_element_id')) {
      _dashboardElementId = _apiMapResponse['dashboard_element_id'];
      _dashboardElementIdSet = true;
    }
    return _dashboardElementId;
  }

  set dashboardElementId(int v) {
    _dashboardElementId = v;
    _dashboardElementIdSet = true;
  }

  /// An optional description for the alert. This supplements the title

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Array of destinations to send alerts to. Must be the same type of destination. Example `[{ "destination_type": "EMAIL", "email_address": "test@test.com" }]`

  List<AlertDestination> get destinations {
    if (!_destinationsSet && _apiMapResponse.containsKey('destinations')) {
      _destinations = _apiMapResponse['destinations'] == null
          ? null
          : (_apiMapResponse['destinations'] as List)
              .map((i) =>
                  AlertDestination.fromResponse(i, apiResponseContentType))
              .toList();
      _destinationsSet = true;
    }
    return _destinations;
  }

  set destinations(List<AlertDestination> v) {
    _destinations = v;
    _destinationsSet = true;
  }

  AlertField get field {
    if (!_fieldSet && _apiMapResponse.containsKey('field')) {
      _field = _apiMapResponse['field'] == null
          ? null
          : AlertField.fromResponse(
              _apiMapResponse['field'], apiResponseContentType);
      _fieldSet = true;
    }
    return _field;
  }

  set field(AlertField v) {
    _field = v;
    _fieldSet = true;
  }

  /// Whether or not the user follows this alert. (read-only)

  bool get followed {
    if (!_followedSet && _apiMapResponse.containsKey('followed')) {
      _followed = _apiMapResponse['followed'];
      _followedSet = true;
    }
    return _followed;
  }

  set followed(bool v) {
    _followed = v;
    _followedSet = true;
  }

  /// Whether or not the alert is followable (read-only)

  bool get followable {
    if (!_followableSet && _apiMapResponse.containsKey('followable')) {
      _followable = _apiMapResponse['followable'];
      _followableSet = true;
    }
    return _followable;
  }

  set followable(bool v) {
    _followable = v;
    _followableSet = true;
  }

  /// ID of the alert (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Whether or not the alert is disabled

  bool get isDisabled {
    if (!_isDisabledSet && _apiMapResponse.containsKey('is_disabled')) {
      _isDisabled = _apiMapResponse['is_disabled'];
      _isDisabledSet = true;
    }
    return _isDisabled;
  }

  set isDisabled(bool v) {
    _isDisabled = v;
    _isDisabledSet = true;
  }

  /// Reason for disabling alert

  String get disabledReason {
    if (!_disabledReasonSet && _apiMapResponse.containsKey('disabled_reason')) {
      _disabledReason = _apiMapResponse['disabled_reason']?.toString();
      _disabledReasonSet = true;
    }
    return _disabledReason;
  }

  set disabledReason(String v) {
    _disabledReason = v;
    _disabledReasonSet = true;
  }

  /// Whether or not the alert is public

  bool get isPublic {
    if (!_isPublicSet && _apiMapResponse.containsKey('is_public')) {
      _isPublic = _apiMapResponse['is_public'];
      _isPublicSet = true;
    }
    return _isPublic;
  }

  set isPublic(bool v) {
    _isPublic = v;
    _isPublicSet = true;
  }

  /// The type of the investigative content Valid values are: "dashboard".

  InvestigativeContentType get investigativeContentType {
    if (!_investigativeContentTypeSet &&
        _apiMapResponse.containsKey('investigative_content_type')) {
      _investigativeContentType =
          InvestigativeContentTypeMapper.fromStringValue(
              _apiMapResponse['investigative_content_type']);
      _investigativeContentTypeSet = true;
    }
    return _investigativeContentType;
  }

  set investigativeContentType(InvestigativeContentType v) {
    _investigativeContentType = v;
    _investigativeContentTypeSet = true;
  }

  /// The ID of the investigative content. For dashboards, this will be the dashboard ID

  String get investigativeContentId {
    if (!_investigativeContentIdSet &&
        _apiMapResponse.containsKey('investigative_content_id')) {
      _investigativeContentId =
          _apiMapResponse['investigative_content_id']?.toString();
      _investigativeContentIdSet = true;
    }
    return _investigativeContentId;
  }

  set investigativeContentId(String v) {
    _investigativeContentId = v;
    _investigativeContentIdSet = true;
  }

  /// The title of the investigative content. (read-only)

  String get investigativeContentTitle {
    if (!_investigativeContentTitleSet &&
        _apiMapResponse.containsKey('investigative_content_title')) {
      _investigativeContentTitle =
          _apiMapResponse['investigative_content_title']?.toString();
      _investigativeContentTitleSet = true;
    }
    return _investigativeContentTitle;
  }

  set investigativeContentTitle(String v) {
    _investigativeContentTitle = v;
    _investigativeContentTitleSet = true;
  }

  /// ID of the LookML dashboard associated with the alert

  String get lookmlDashboardId {
    if (!_lookmlDashboardIdSet &&
        _apiMapResponse.containsKey('lookml_dashboard_id')) {
      _lookmlDashboardId = _apiMapResponse['lookml_dashboard_id']?.toString();
      _lookmlDashboardIdSet = true;
    }
    return _lookmlDashboardId;
  }

  set lookmlDashboardId(String v) {
    _lookmlDashboardId = v;
    _lookmlDashboardIdSet = true;
  }

  /// ID of the LookML dashboard element associated with the alert

  String get lookmlLinkId {
    if (!_lookmlLinkIdSet && _apiMapResponse.containsKey('lookml_link_id')) {
      _lookmlLinkId = _apiMapResponse['lookml_link_id']?.toString();
      _lookmlLinkIdSet = true;
    }
    return _lookmlLinkId;
  }

  set lookmlLinkId(String v) {
    _lookmlLinkId = v;
    _lookmlLinkIdSet = true;
  }

  /// User id of alert owner

  int get ownerId {
    if (!_ownerIdSet && _apiMapResponse.containsKey('owner_id')) {
      _ownerId = _apiMapResponse['owner_id'];
      _ownerIdSet = true;
    }
    return _ownerId;
  }

  set ownerId(int v) {
    _ownerId = v;
    _ownerIdSet = true;
  }

  /// Alert owner's display name (read-only)

  String get ownerDisplayName {
    if (!_ownerDisplayNameSet &&
        _apiMapResponse.containsKey('owner_display_name')) {
      _ownerDisplayName = _apiMapResponse['owner_display_name']?.toString();
      _ownerDisplayNameSet = true;
    }
    return _ownerDisplayName;
  }

  set ownerDisplayName(String v) {
    _ownerDisplayName = v;
    _ownerDisplayNameSet = true;
  }

  /// Value of the alert threshold

  double get threshold {
    if (!_thresholdSet && _apiMapResponse.containsKey('threshold')) {
      _threshold = _apiMapResponse['threshold'];
      _thresholdSet = true;
    }
    return _threshold;
  }

  set threshold(double v) {
    _threshold = v;
    _thresholdSet = true;
  }

  AlertConditionState get timeSeriesConditionState {
    if (!_timeSeriesConditionStateSet &&
        _apiMapResponse.containsKey('time_series_condition_state')) {
      _timeSeriesConditionState =
          _apiMapResponse['time_series_condition_state'] == null
              ? null
              : AlertConditionState.fromResponse(
                  _apiMapResponse['time_series_condition_state'],
                  apiResponseContentType);
      _timeSeriesConditionStateSet = true;
    }
    return _timeSeriesConditionState;
  }

  set timeSeriesConditionState(AlertConditionState v) {
    _timeSeriesConditionState = v;
    _timeSeriesConditionStateSet = true;
  }

  Alert() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Alert.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_appliedDashboardFiltersSet ||
        _apiMapResponse.containsKey('applied_dashboard_filters')) {
      json['applied_dashboard_filters'] =
          appliedDashboardFilters?.map((i) => i.toJson())?.toList();
    }
    if (_comparisonTypeSet || _apiMapResponse.containsKey('comparison_type')) {
      json['comparison_type'] =
          ComparisonTypeMapper.toStringValue(comparisonType);
    }
    if (_cronSet || _apiMapResponse.containsKey('cron')) {
      json['cron'] = cron;
    }
    if (_customTitleSet || _apiMapResponse.containsKey('custom_title')) {
      json['custom_title'] = customTitle;
    }
    if (_dashboardElementIdSet ||
        _apiMapResponse.containsKey('dashboard_element_id')) {
      json['dashboard_element_id'] = dashboardElementId;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_destinationsSet || _apiMapResponse.containsKey('destinations')) {
      json['destinations'] = destinations?.map((i) => i.toJson())?.toList();
    }
    if (_fieldSet || _apiMapResponse.containsKey('field')) {
      json['field'] = field?.toJson();
    }
    if (_followedSet || _apiMapResponse.containsKey('followed')) {
      json['followed'] = followed;
    }
    if (_followableSet || _apiMapResponse.containsKey('followable')) {
      json['followable'] = followable;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_isDisabledSet || _apiMapResponse.containsKey('is_disabled')) {
      json['is_disabled'] = isDisabled;
    }
    if (_disabledReasonSet || _apiMapResponse.containsKey('disabled_reason')) {
      json['disabled_reason'] = disabledReason;
    }
    if (_isPublicSet || _apiMapResponse.containsKey('is_public')) {
      json['is_public'] = isPublic;
    }
    if (_investigativeContentTypeSet ||
        _apiMapResponse.containsKey('investigative_content_type')) {
      json['investigative_content_type'] =
          InvestigativeContentTypeMapper.toStringValue(
              investigativeContentType);
    }
    if (_investigativeContentIdSet ||
        _apiMapResponse.containsKey('investigative_content_id')) {
      json['investigative_content_id'] = investigativeContentId;
    }
    if (_investigativeContentTitleSet ||
        _apiMapResponse.containsKey('investigative_content_title')) {
      json['investigative_content_title'] = investigativeContentTitle;
    }
    if (_lookmlDashboardIdSet ||
        _apiMapResponse.containsKey('lookml_dashboard_id')) {
      json['lookml_dashboard_id'] = lookmlDashboardId;
    }
    if (_lookmlLinkIdSet || _apiMapResponse.containsKey('lookml_link_id')) {
      json['lookml_link_id'] = lookmlLinkId;
    }
    if (_ownerIdSet || _apiMapResponse.containsKey('owner_id')) {
      json['owner_id'] = ownerId;
    }
    if (_ownerDisplayNameSet ||
        _apiMapResponse.containsKey('owner_display_name')) {
      json['owner_display_name'] = ownerDisplayName;
    }
    if (_thresholdSet || _apiMapResponse.containsKey('threshold')) {
      json['threshold'] = threshold;
    }
    if (_timeSeriesConditionStateSet ||
        _apiMapResponse.containsKey('time_series_condition_state')) {
      json['time_series_condition_state'] = timeSeriesConditionState?.toJson();
    }
    return json;
  }
}

class AlertAppliedDashboardFilter {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _filterTitle;
  bool _filterTitleSet = false;

  String _fieldName;
  bool _fieldNameSet = false;

  String _filterValue;
  bool _filterValueSet = false;

  String _filterDescription;
  bool _filterDescriptionSet = false;

  /// Field Title. Refer to `DashboardFilter.title` in [DashboardFilter](#!/types/DashboardFilter). Example `Name`

  String get filterTitle {
    if (!_filterTitleSet && _apiMapResponse.containsKey('filter_title')) {
      _filterTitle = _apiMapResponse['filter_title']?.toString();
      _filterTitleSet = true;
    }
    return _filterTitle;
  }

  set filterTitle(String v) {
    _filterTitle = v;
    _filterTitleSet = true;
  }

  /// Field Name. Refer to `DashboardFilter.dimension` in [DashboardFilter](#!/types/DashboardFilter). Example `distribution_centers.name`

  String get fieldName {
    if (!_fieldNameSet && _apiMapResponse.containsKey('field_name')) {
      _fieldName = _apiMapResponse['field_name']?.toString();
      _fieldNameSet = true;
    }
    return _fieldName;
  }

  set fieldName(String v) {
    _fieldName = v;
    _fieldNameSet = true;
  }

  /// Field Value. [Filter Expressions](https://docs.looker.com/reference/filter-expressions). Example `Los Angeles CA`

  String get filterValue {
    if (!_filterValueSet && _apiMapResponse.containsKey('filter_value')) {
      _filterValue = _apiMapResponse['filter_value']?.toString();
      _filterValueSet = true;
    }
    return _filterValue;
  }

  set filterValue(String v) {
    _filterValue = v;
    _filterValueSet = true;
  }

  /// Human Readable Filter Description. This may be null or auto-generated. Example `is Los Angeles CA` (read-only)

  String get filterDescription {
    if (!_filterDescriptionSet &&
        _apiMapResponse.containsKey('filter_description')) {
      _filterDescription = _apiMapResponse['filter_description']?.toString();
      _filterDescriptionSet = true;
    }
    return _filterDescription;
  }

  set filterDescription(String v) {
    _filterDescription = v;
    _filterDescriptionSet = true;
  }

  AlertAppliedDashboardFilter() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  AlertAppliedDashboardFilter.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_filterTitleSet || _apiMapResponse.containsKey('filter_title')) {
      json['filter_title'] = filterTitle;
    }
    if (_fieldNameSet || _apiMapResponse.containsKey('field_name')) {
      json['field_name'] = fieldName;
    }
    if (_filterValueSet || _apiMapResponse.containsKey('filter_value')) {
      json['filter_value'] = filterValue;
    }
    if (_filterDescriptionSet ||
        _apiMapResponse.containsKey('filter_description')) {
      json['filter_description'] = filterDescription;
    }
    return json;
  }
}

class AlertConditionState {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _previousTimeSeriesId;
  bool _previousTimeSeriesIdSet = false;

  String _latestTimeSeriesId;
  bool _latestTimeSeriesIdSet = false;

  /// (Write-Only) The second latest time string the alert has seen.

  String get previousTimeSeriesId {
    if (!_previousTimeSeriesIdSet &&
        _apiMapResponse.containsKey('previous_time_series_id')) {
      _previousTimeSeriesId =
          _apiMapResponse['previous_time_series_id']?.toString();
      _previousTimeSeriesIdSet = true;
    }
    return _previousTimeSeriesId;
  }

  set previousTimeSeriesId(String v) {
    _previousTimeSeriesId = v;
    _previousTimeSeriesIdSet = true;
  }

  /// (Write-Only) Latest time string the alert has seen.

  String get latestTimeSeriesId {
    if (!_latestTimeSeriesIdSet &&
        _apiMapResponse.containsKey('latest_time_series_id')) {
      _latestTimeSeriesId =
          _apiMapResponse['latest_time_series_id']?.toString();
      _latestTimeSeriesIdSet = true;
    }
    return _latestTimeSeriesId;
  }

  set latestTimeSeriesId(String v) {
    _latestTimeSeriesId = v;
    _latestTimeSeriesIdSet = true;
  }

  AlertConditionState() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  AlertConditionState.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_previousTimeSeriesIdSet ||
        _apiMapResponse.containsKey('previous_time_series_id')) {
      json['previous_time_series_id'] = previousTimeSeriesId;
    }
    if (_latestTimeSeriesIdSet ||
        _apiMapResponse.containsKey('latest_time_series_id')) {
      json['latest_time_series_id'] = latestTimeSeriesId;
    }
    return json;
  }
}

class AlertDestination {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  DestinationType _destinationType;
  bool _destinationTypeSet = false;

  String _emailAddress;
  bool _emailAddressSet = false;

  String _actionHubIntegrationId;
  bool _actionHubIntegrationIdSet = false;

  String _actionHubFormParamsJson;
  bool _actionHubFormParamsJsonSet = false;

  /// Type of destination that the alert will be sent to Valid values are: "EMAIL", "ACTION_HUB".

  DestinationType get destinationType {
    if (!_destinationTypeSet &&
        _apiMapResponse.containsKey('destination_type')) {
      _destinationType = DestinationTypeMapper.fromStringValue(
          _apiMapResponse['destination_type']);
      _destinationTypeSet = true;
    }
    return _destinationType;
  }

  set destinationType(DestinationType v) {
    _destinationType = v;
    _destinationTypeSet = true;
  }

  /// Email address for the 'email' type

  String get emailAddress {
    if (!_emailAddressSet && _apiMapResponse.containsKey('email_address')) {
      _emailAddress = _apiMapResponse['email_address']?.toString();
      _emailAddressSet = true;
    }
    return _emailAddress;
  }

  set emailAddress(String v) {
    _emailAddress = v;
    _emailAddressSet = true;
  }

  /// Action hub integration id for the 'action_hub' type. [Integration](#!/types/Integration)

  String get actionHubIntegrationId {
    if (!_actionHubIntegrationIdSet &&
        _apiMapResponse.containsKey('action_hub_integration_id')) {
      _actionHubIntegrationId =
          _apiMapResponse['action_hub_integration_id']?.toString();
      _actionHubIntegrationIdSet = true;
    }
    return _actionHubIntegrationId;
  }

  set actionHubIntegrationId(String v) {
    _actionHubIntegrationId = v;
    _actionHubIntegrationIdSet = true;
  }

  /// Action hub form params json for the 'action_hub' type [IntegrationParam](#!/types/IntegrationParam)

  String get actionHubFormParamsJson {
    if (!_actionHubFormParamsJsonSet &&
        _apiMapResponse.containsKey('action_hub_form_params_json')) {
      _actionHubFormParamsJson =
          _apiMapResponse['action_hub_form_params_json']?.toString();
      _actionHubFormParamsJsonSet = true;
    }
    return _actionHubFormParamsJson;
  }

  set actionHubFormParamsJson(String v) {
    _actionHubFormParamsJson = v;
    _actionHubFormParamsJsonSet = true;
  }

  AlertDestination() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  AlertDestination.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_destinationTypeSet ||
        _apiMapResponse.containsKey('destination_type')) {
      json['destination_type'] =
          DestinationTypeMapper.toStringValue(destinationType);
    }
    if (_emailAddressSet || _apiMapResponse.containsKey('email_address')) {
      json['email_address'] = emailAddress;
    }
    if (_actionHubIntegrationIdSet ||
        _apiMapResponse.containsKey('action_hub_integration_id')) {
      json['action_hub_integration_id'] = actionHubIntegrationId;
    }
    if (_actionHubFormParamsJsonSet ||
        _apiMapResponse.containsKey('action_hub_form_params_json')) {
      json['action_hub_form_params_json'] = actionHubFormParamsJson;
    }
    return json;
  }
}

class AlertField {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _title;
  bool _titleSet = false;

  String _name;
  bool _nameSet = false;

  List<AlertFieldFilter> _filter;
  bool _filterSet = false;

  /// Field's title. Usually auto-generated to reflect field name and its filters

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Field's name. Has the format `<view>.<field>` Refer to [docs](https://docs.looker.com/sharing-and-publishing/creating-alerts) for more details

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// (Optional / Advance Use) List of fields filter. This further restricts the alert to certain dashboard element's field values. This can be used on top of dashboard filters `applied_dashboard_filters`. To keep thing simple, it's suggested to just use dashboard filters. Example: `{ 'title': '12 Number on Hand', 'name': 'inventory_items.number_on_hand', 'filter': [{ 'field_name': 'inventory_items.id', 'field_value': 12, 'filter_value': null }] }`

  List<AlertFieldFilter> get filter {
    if (!_filterSet && _apiMapResponse.containsKey('filter')) {
      _filter = _apiMapResponse['filter'] == null
          ? null
          : (_apiMapResponse['filter'] as List)
              .map((i) =>
                  AlertFieldFilter.fromResponse(i, apiResponseContentType))
              .toList();
      _filterSet = true;
    }
    return _filter;
  }

  set filter(List<AlertFieldFilter> v) {
    _filter = v;
    _filterSet = true;
  }

  AlertField() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  AlertField.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_filterSet || _apiMapResponse.containsKey('filter')) {
      json['filter'] = filter?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class AlertFieldFilter {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _fieldName;
  bool _fieldNameSet = false;

  dynamic _fieldValue;
  bool _fieldValueSet = false;

  String _filterValue;
  bool _filterValueSet = false;

  /// Field Name. Has format `<view>.<field>`

  String get fieldName {
    if (!_fieldNameSet && _apiMapResponse.containsKey('field_name')) {
      _fieldName = _apiMapResponse['field_name']?.toString();
      _fieldNameSet = true;
    }
    return _fieldName;
  }

  set fieldName(String v) {
    _fieldName = v;
    _fieldNameSet = true;
  }

  /// Field Value. Depends on the type of field - numeric or string. For [location](https://docs.looker.com/reference/field-reference/dimension-type-reference#location) type, it's a list of floats. Example `[1.0, 56.0]`

  dynamic get fieldValue {
    if (!_fieldValueSet && _apiMapResponse.containsKey('field_value')) {
      _fieldValue = _apiMapResponse['field_value'];
      _fieldValueSet = true;
    }
    return _fieldValue;
  }

  set fieldValue(dynamic v) {
    _fieldValue = v;
    _fieldValueSet = true;
  }

  /// Filter Value. Usually null except for [location](https://docs.looker.com/reference/field-reference/dimension-type-reference#location) type. It'll be a string of lat,long ie `'1.0,56.0'`

  String get filterValue {
    if (!_filterValueSet && _apiMapResponse.containsKey('filter_value')) {
      _filterValue = _apiMapResponse['filter_value']?.toString();
      _filterValueSet = true;
    }
    return _filterValue;
  }

  set filterValue(String v) {
    _filterValue = v;
    _filterValueSet = true;
  }

  AlertFieldFilter() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  AlertFieldFilter.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_fieldNameSet || _apiMapResponse.containsKey('field_name')) {
      json['field_name'] = fieldName;
    }
    if (_fieldValueSet || _apiMapResponse.containsKey('field_value')) {
      json['field_value'] = fieldValue;
    }
    if (_filterValueSet || _apiMapResponse.containsKey('filter_value')) {
      json['filter_value'] = filterValue;
    }
    return json;
  }
}

class AlertPatch {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _ownerId;
  bool _ownerIdSet = false;

  bool _isDisabled;
  bool _isDisabledSet = false;

  String _disabledReason;
  bool _disabledReasonSet = false;

  bool _isPublic;
  bool _isPublicSet = false;

  double _threshold;
  bool _thresholdSet = false;

  /// New owner ID of the alert

  int get ownerId {
    if (!_ownerIdSet && _apiMapResponse.containsKey('owner_id')) {
      _ownerId = _apiMapResponse['owner_id'];
      _ownerIdSet = true;
    }
    return _ownerId;
  }

  set ownerId(int v) {
    _ownerId = v;
    _ownerIdSet = true;
  }

  /// Set alert enabled or disabled

  bool get isDisabled {
    if (!_isDisabledSet && _apiMapResponse.containsKey('is_disabled')) {
      _isDisabled = _apiMapResponse['is_disabled'];
      _isDisabledSet = true;
    }
    return _isDisabled;
  }

  set isDisabled(bool v) {
    _isDisabled = v;
    _isDisabledSet = true;
  }

  /// The reason this alert is disabled

  String get disabledReason {
    if (!_disabledReasonSet && _apiMapResponse.containsKey('disabled_reason')) {
      _disabledReason = _apiMapResponse['disabled_reason']?.toString();
      _disabledReasonSet = true;
    }
    return _disabledReason;
  }

  set disabledReason(String v) {
    _disabledReason = v;
    _disabledReasonSet = true;
  }

  /// Set alert public or private

  bool get isPublic {
    if (!_isPublicSet && _apiMapResponse.containsKey('is_public')) {
      _isPublic = _apiMapResponse['is_public'];
      _isPublicSet = true;
    }
    return _isPublic;
  }

  set isPublic(bool v) {
    _isPublic = v;
    _isPublicSet = true;
  }

  /// New threshold value

  double get threshold {
    if (!_thresholdSet && _apiMapResponse.containsKey('threshold')) {
      _threshold = _apiMapResponse['threshold'];
      _thresholdSet = true;
    }
    return _threshold;
  }

  set threshold(double v) {
    _threshold = v;
    _thresholdSet = true;
  }

  AlertPatch() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  AlertPatch.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_ownerIdSet || _apiMapResponse.containsKey('owner_id')) {
      json['owner_id'] = ownerId;
    }
    if (_isDisabledSet || _apiMapResponse.containsKey('is_disabled')) {
      json['is_disabled'] = isDisabled;
    }
    if (_disabledReasonSet || _apiMapResponse.containsKey('disabled_reason')) {
      json['disabled_reason'] = disabledReason;
    }
    if (_isPublicSet || _apiMapResponse.containsKey('is_public')) {
      json['is_public'] = isPublic;
    }
    if (_thresholdSet || _apiMapResponse.containsKey('threshold')) {
      json['threshold'] = threshold;
    }
    return json;
  }
}

/// The appropriate horizontal text alignment the values of this field should be displayed in. Valid values are: "left", "right". (Enum defined in LookmlModelExploreField)
enum Align { left, right }

class AlignMapper {
  static String toStringValue(Align e) {
    switch (e) {
      case Align.left:
        return 'left';
      case Align.right:
        return 'right';

      default:
        return null;
    }
  }

  static Align fromStringValue(String s) {
    if (s == 'left') {
      return Align.left;
    }
    if (s == 'right') {
      return Align.right;
    }
    return null;
  }
}

class ApiSession {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _workspaceId;
  bool _workspaceIdSet = false;

  int _sudoUserId;
  bool _sudoUserIdSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// The id of active workspace for this session

  String get workspaceId {
    if (!_workspaceIdSet && _apiMapResponse.containsKey('workspace_id')) {
      _workspaceId = _apiMapResponse['workspace_id']?.toString();
      _workspaceIdSet = true;
    }
    return _workspaceId;
  }

  set workspaceId(String v) {
    _workspaceId = v;
    _workspaceIdSet = true;
  }

  /// The id of the actual user in the case when this session represents one user sudo'ing as another (read-only)

  int get sudoUserId {
    if (!_sudoUserIdSet && _apiMapResponse.containsKey('sudo_user_id')) {
      _sudoUserId = _apiMapResponse['sudo_user_id'];
      _sudoUserIdSet = true;
    }
    return _sudoUserId;
  }

  set sudoUserId(int v) {
    _sudoUserId = v;
    _sudoUserIdSet = true;
  }

  ApiSession() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ApiSession.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_workspaceIdSet || _apiMapResponse.containsKey('workspace_id')) {
      json['workspace_id'] = workspaceId;
    }
    if (_sudoUserIdSet || _apiMapResponse.containsKey('sudo_user_id')) {
      json['sudo_user_id'] = sudoUserId;
    }
    return json;
  }
}

class ApiVersion {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _lookerReleaseVersion;
  bool _lookerReleaseVersionSet = false;

  ApiVersionElement _currentVersion;
  bool _currentVersionSet = false;

  List<ApiVersionElement> _supportedVersions;
  bool _supportedVersionsSet = false;

  String _apiServerUrl;
  bool _apiServerUrlSet = false;

  String _webServerUrl;
  bool _webServerUrlSet = false;

  /// Current Looker release version number (read-only)

  String get lookerReleaseVersion {
    if (!_lookerReleaseVersionSet &&
        _apiMapResponse.containsKey('looker_release_version')) {
      _lookerReleaseVersion =
          _apiMapResponse['looker_release_version']?.toString();
      _lookerReleaseVersionSet = true;
    }
    return _lookerReleaseVersion;
  }

  set lookerReleaseVersion(String v) {
    _lookerReleaseVersion = v;
    _lookerReleaseVersionSet = true;
  }

  ApiVersionElement get currentVersion {
    if (!_currentVersionSet && _apiMapResponse.containsKey('current_version')) {
      _currentVersion = _apiMapResponse['current_version'] == null
          ? null
          : ApiVersionElement.fromResponse(
              _apiMapResponse['current_version'], apiResponseContentType);
      _currentVersionSet = true;
    }
    return _currentVersion;
  }

  set currentVersion(ApiVersionElement v) {
    _currentVersion = v;
    _currentVersionSet = true;
  }

  /// Array of versions supported by this Looker instance (read-only)

  List<ApiVersionElement> get supportedVersions {
    if (!_supportedVersionsSet &&
        _apiMapResponse.containsKey('supported_versions')) {
      _supportedVersions = _apiMapResponse['supported_versions'] == null
          ? null
          : (_apiMapResponse['supported_versions'] as List)
              .map((i) =>
                  ApiVersionElement.fromResponse(i, apiResponseContentType))
              .toList();
      _supportedVersionsSet = true;
    }
    return _supportedVersions;
  }

  set supportedVersions(List<ApiVersionElement> v) {
    _supportedVersions = v;
    _supportedVersionsSet = true;
  }

  /// API server base url (read-only)

  String get apiServerUrl {
    if (!_apiServerUrlSet && _apiMapResponse.containsKey('api_server_url')) {
      _apiServerUrl = _apiMapResponse['api_server_url']?.toString();
      _apiServerUrlSet = true;
    }
    return _apiServerUrl;
  }

  set apiServerUrl(String v) {
    _apiServerUrl = v;
    _apiServerUrlSet = true;
  }

  /// Web server base url (read-only)

  String get webServerUrl {
    if (!_webServerUrlSet && _apiMapResponse.containsKey('web_server_url')) {
      _webServerUrl = _apiMapResponse['web_server_url']?.toString();
      _webServerUrlSet = true;
    }
    return _webServerUrl;
  }

  set webServerUrl(String v) {
    _webServerUrl = v;
    _webServerUrlSet = true;
  }

  ApiVersion() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ApiVersion.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_lookerReleaseVersionSet ||
        _apiMapResponse.containsKey('looker_release_version')) {
      json['looker_release_version'] = lookerReleaseVersion;
    }
    if (_currentVersionSet || _apiMapResponse.containsKey('current_version')) {
      json['current_version'] = currentVersion?.toJson();
    }
    if (_supportedVersionsSet ||
        _apiMapResponse.containsKey('supported_versions')) {
      json['supported_versions'] =
          supportedVersions?.map((i) => i.toJson())?.toList();
    }
    if (_apiServerUrlSet || _apiMapResponse.containsKey('api_server_url')) {
      json['api_server_url'] = apiServerUrl;
    }
    if (_webServerUrlSet || _apiMapResponse.containsKey('web_server_url')) {
      json['web_server_url'] = webServerUrl;
    }
    return json;
  }
}

class ApiVersionElement {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _version;
  bool _versionSet = false;

  String _fullVersion;
  bool _fullVersionSet = false;

  String _status;
  bool _statusSet = false;

  String _swaggerUrl;
  bool _swaggerUrlSet = false;

  /// Version number as it appears in '/api/xxx/' urls (read-only)

  String get version {
    if (!_versionSet && _apiMapResponse.containsKey('version')) {
      _version = _apiMapResponse['version']?.toString();
      _versionSet = true;
    }
    return _version;
  }

  set version(String v) {
    _version = v;
    _versionSet = true;
  }

  /// Full version number including minor version (read-only)

  String get fullVersion {
    if (!_fullVersionSet && _apiMapResponse.containsKey('full_version')) {
      _fullVersion = _apiMapResponse['full_version']?.toString();
      _fullVersionSet = true;
    }
    return _fullVersion;
  }

  set fullVersion(String v) {
    _fullVersion = v;
    _fullVersionSet = true;
  }

  /// Status of this version (read-only)

  String get status {
    if (!_statusSet && _apiMapResponse.containsKey('status')) {
      _status = _apiMapResponse['status']?.toString();
      _statusSet = true;
    }
    return _status;
  }

  set status(String v) {
    _status = v;
    _statusSet = true;
  }

  /// Url for swagger.json for this version (read-only)

  String get swaggerUrl {
    if (!_swaggerUrlSet && _apiMapResponse.containsKey('swagger_url')) {
      _swaggerUrl = _apiMapResponse['swagger_url']?.toString();
      _swaggerUrlSet = true;
    }
    return _swaggerUrl;
  }

  set swaggerUrl(String v) {
    _swaggerUrl = v;
    _swaggerUrlSet = true;
  }

  ApiVersionElement() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ApiVersionElement.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_versionSet || _apiMapResponse.containsKey('version')) {
      json['version'] = version;
    }
    if (_fullVersionSet || _apiMapResponse.containsKey('full_version')) {
      json['full_version'] = fullVersion;
    }
    if (_statusSet || _apiMapResponse.containsKey('status')) {
      json['status'] = status;
    }
    if (_swaggerUrlSet || _apiMapResponse.containsKey('swagger_url')) {
      json['swagger_url'] = swaggerUrl;
    }
    return json;
  }
}

class BackupConfiguration {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _type;
  bool _typeSet = false;

  String _customS3Bucket;
  bool _customS3BucketSet = false;

  String _customS3BucketRegion;
  bool _customS3BucketRegionSet = false;

  String _customS3Key;
  bool _customS3KeySet = false;

  String _customS3Secret;
  bool _customS3SecretSet = false;

  String _url;
  bool _urlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Type of backup: looker-s3 or custom-s3

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Name of bucket for custom-s3 backups

  String get customS3Bucket {
    if (!_customS3BucketSet &&
        _apiMapResponse.containsKey('custom_s3_bucket')) {
      _customS3Bucket = _apiMapResponse['custom_s3_bucket']?.toString();
      _customS3BucketSet = true;
    }
    return _customS3Bucket;
  }

  set customS3Bucket(String v) {
    _customS3Bucket = v;
    _customS3BucketSet = true;
  }

  /// Name of region where the bucket is located

  String get customS3BucketRegion {
    if (!_customS3BucketRegionSet &&
        _apiMapResponse.containsKey('custom_s3_bucket_region')) {
      _customS3BucketRegion =
          _apiMapResponse['custom_s3_bucket_region']?.toString();
      _customS3BucketRegionSet = true;
    }
    return _customS3BucketRegion;
  }

  set customS3BucketRegion(String v) {
    _customS3BucketRegion = v;
    _customS3BucketRegionSet = true;
  }

  /// (Write-Only) AWS S3 key used for custom-s3 backups

  String get customS3Key {
    if (!_customS3KeySet && _apiMapResponse.containsKey('custom_s3_key')) {
      _customS3Key = _apiMapResponse['custom_s3_key']?.toString();
      _customS3KeySet = true;
    }
    return _customS3Key;
  }

  set customS3Key(String v) {
    _customS3Key = v;
    _customS3KeySet = true;
  }

  /// (Write-Only) AWS S3 secret used for custom-s3 backups

  String get customS3Secret {
    if (!_customS3SecretSet &&
        _apiMapResponse.containsKey('custom_s3_secret')) {
      _customS3Secret = _apiMapResponse['custom_s3_secret']?.toString();
      _customS3SecretSet = true;
    }
    return _customS3Secret;
  }

  set customS3Secret(String v) {
    _customS3Secret = v;
    _customS3SecretSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  BackupConfiguration() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  BackupConfiguration.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_customS3BucketSet || _apiMapResponse.containsKey('custom_s3_bucket')) {
      json['custom_s3_bucket'] = customS3Bucket;
    }
    if (_customS3BucketRegionSet ||
        _apiMapResponse.containsKey('custom_s3_bucket_region')) {
      json['custom_s3_bucket_region'] = customS3BucketRegion;
    }
    if (_customS3KeySet || _apiMapResponse.containsKey('custom_s3_key')) {
      json['custom_s3_key'] = customS3Key;
    }
    if (_customS3SecretSet || _apiMapResponse.containsKey('custom_s3_secret')) {
      json['custom_s3_secret'] = customS3Secret;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class Board {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _contentMetadataId;
  bool _contentMetadataIdSet = false;

  DateTime _createdAt;
  bool _createdAtSet = false;

  DateTime _deletedAt;
  bool _deletedAtSet = false;

  String _description;
  bool _descriptionSet = false;

  List<BoardSection> _boardSections;
  bool _boardSectionsSet = false;

  int _id;
  bool _idSet = false;

  List<int> _sectionOrder;
  bool _sectionOrderSet = false;

  String _title;
  bool _titleSet = false;

  DateTime _updatedAt;
  bool _updatedAtSet = false;

  int _userId;
  bool _userIdSet = false;

  bool _primaryHomepage;
  bool _primaryHomepageSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Id of associated content_metadata record (read-only)

  int get contentMetadataId {
    if (!_contentMetadataIdSet &&
        _apiMapResponse.containsKey('content_metadata_id')) {
      _contentMetadataId = _apiMapResponse['content_metadata_id'];
      _contentMetadataIdSet = true;
    }
    return _contentMetadataId;
  }

  set contentMetadataId(int v) {
    _contentMetadataId = v;
    _contentMetadataIdSet = true;
  }

  /// Date of board creation (read-only)

  DateTime get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['created_at']);
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(DateTime v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// Date of board deletion

  DateTime get deletedAt {
    if (!_deletedAtSet && _apiMapResponse.containsKey('deleted_at')) {
      _deletedAt = _apiMapResponse['deleted_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['deleted_at']);
      _deletedAtSet = true;
    }
    return _deletedAt;
  }

  set deletedAt(DateTime v) {
    _deletedAt = v;
    _deletedAtSet = true;
  }

  /// Description of the board

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Sections of the board (read-only)

  List<BoardSection> get boardSections {
    if (!_boardSectionsSet && _apiMapResponse.containsKey('board_sections')) {
      _boardSections = _apiMapResponse['board_sections'] == null
          ? null
          : (_apiMapResponse['board_sections'] as List)
              .map((i) => BoardSection.fromResponse(i, apiResponseContentType))
              .toList();
      _boardSectionsSet = true;
    }
    return _boardSections;
  }

  set boardSections(List<BoardSection> v) {
    _boardSections = v;
    _boardSectionsSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// ids of the board sections in the order they should be displayed

  List<int> get sectionOrder {
    if (!_sectionOrderSet && _apiMapResponse.containsKey('section_order')) {
      _sectionOrder =
          _apiMapResponse['section_order']?.map<int>((i) => i as int)?.toList();
      _sectionOrderSet = true;
    }
    return _sectionOrder;
  }

  set sectionOrder(List<int> v) {
    _sectionOrder = v;
    _sectionOrderSet = true;
  }

  /// Title of the board

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Date of last board update (read-only)

  DateTime get updatedAt {
    if (!_updatedAtSet && _apiMapResponse.containsKey('updated_at')) {
      _updatedAt = _apiMapResponse['updated_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['updated_at']);
      _updatedAtSet = true;
    }
    return _updatedAt;
  }

  set updatedAt(DateTime v) {
    _updatedAt = v;
    _updatedAtSet = true;
  }

  /// User id of board creator (read-only)

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  /// Whether the board is the primary homepage or not (read-only)

  bool get primaryHomepage {
    if (!_primaryHomepageSet &&
        _apiMapResponse.containsKey('primary_homepage')) {
      _primaryHomepage = _apiMapResponse['primary_homepage'];
      _primaryHomepageSet = true;
    }
    return _primaryHomepage;
  }

  set primaryHomepage(bool v) {
    _primaryHomepage = v;
    _primaryHomepageSet = true;
  }

  Board() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Board.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_contentMetadataIdSet ||
        _apiMapResponse.containsKey('content_metadata_id')) {
      json['content_metadata_id'] = contentMetadataId;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt?.toIso8601String();
    }
    if (_deletedAtSet || _apiMapResponse.containsKey('deleted_at')) {
      json['deleted_at'] = deletedAt?.toIso8601String();
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_boardSectionsSet || _apiMapResponse.containsKey('board_sections')) {
      json['board_sections'] = boardSections?.map((i) => i.toJson())?.toList();
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_sectionOrderSet || _apiMapResponse.containsKey('section_order')) {
      json['section_order'] = sectionOrder;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_updatedAtSet || _apiMapResponse.containsKey('updated_at')) {
      json['updated_at'] = updatedAt?.toIso8601String();
    }
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    if (_primaryHomepageSet ||
        _apiMapResponse.containsKey('primary_homepage')) {
      json['primary_homepage'] = primaryHomepage;
    }
    return json;
  }
}

class BoardItem {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _contentCreatedBy;
  bool _contentCreatedBySet = false;

  int _contentFavoriteId;
  bool _contentFavoriteIdSet = false;

  int _contentMetadataId;
  bool _contentMetadataIdSet = false;

  String _contentUpdatedAt;
  bool _contentUpdatedAtSet = false;

  String _customDescription;
  bool _customDescriptionSet = false;

  String _customTitle;
  bool _customTitleSet = false;

  String _customUrl;
  bool _customUrlSet = false;

  int _dashboardId;
  bool _dashboardIdSet = false;

  String _description;
  bool _descriptionSet = false;

  int _favoriteCount;
  bool _favoriteCountSet = false;

  int _boardSectionId;
  bool _boardSectionIdSet = false;

  int _id;
  bool _idSet = false;

  String _imageUrl;
  bool _imageUrlSet = false;

  String _location;
  bool _locationSet = false;

  String _lookId;
  bool _lookIdSet = false;

  String _lookmlDashboardId;
  bool _lookmlDashboardIdSet = false;

  int _order;
  bool _orderSet = false;

  String _title;
  bool _titleSet = false;

  String _url;
  bool _urlSet = false;

  int _viewCount;
  bool _viewCountSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Name of user who created the content this item is based on (read-only)

  String get contentCreatedBy {
    if (!_contentCreatedBySet &&
        _apiMapResponse.containsKey('content_created_by')) {
      _contentCreatedBy = _apiMapResponse['content_created_by']?.toString();
      _contentCreatedBySet = true;
    }
    return _contentCreatedBy;
  }

  set contentCreatedBy(String v) {
    _contentCreatedBy = v;
    _contentCreatedBySet = true;
  }

  /// Content favorite id associated with the item this content is based on (read-only)

  int get contentFavoriteId {
    if (!_contentFavoriteIdSet &&
        _apiMapResponse.containsKey('content_favorite_id')) {
      _contentFavoriteId = _apiMapResponse['content_favorite_id'];
      _contentFavoriteIdSet = true;
    }
    return _contentFavoriteId;
  }

  set contentFavoriteId(int v) {
    _contentFavoriteId = v;
    _contentFavoriteIdSet = true;
  }

  /// Content metadata id associated with the item this content is based on (read-only)

  int get contentMetadataId {
    if (!_contentMetadataIdSet &&
        _apiMapResponse.containsKey('content_metadata_id')) {
      _contentMetadataId = _apiMapResponse['content_metadata_id'];
      _contentMetadataIdSet = true;
    }
    return _contentMetadataId;
  }

  set contentMetadataId(int v) {
    _contentMetadataId = v;
    _contentMetadataIdSet = true;
  }

  /// Last time the content that this item is based on was updated (read-only)

  String get contentUpdatedAt {
    if (!_contentUpdatedAtSet &&
        _apiMapResponse.containsKey('content_updated_at')) {
      _contentUpdatedAt = _apiMapResponse['content_updated_at']?.toString();
      _contentUpdatedAtSet = true;
    }
    return _contentUpdatedAt;
  }

  set contentUpdatedAt(String v) {
    _contentUpdatedAt = v;
    _contentUpdatedAtSet = true;
  }

  /// Custom description entered by the user, if present

  String get customDescription {
    if (!_customDescriptionSet &&
        _apiMapResponse.containsKey('custom_description')) {
      _customDescription = _apiMapResponse['custom_description']?.toString();
      _customDescriptionSet = true;
    }
    return _customDescription;
  }

  set customDescription(String v) {
    _customDescription = v;
    _customDescriptionSet = true;
  }

  /// Custom title entered by the user, if present

  String get customTitle {
    if (!_customTitleSet && _apiMapResponse.containsKey('custom_title')) {
      _customTitle = _apiMapResponse['custom_title']?.toString();
      _customTitleSet = true;
    }
    return _customTitle;
  }

  set customTitle(String v) {
    _customTitle = v;
    _customTitleSet = true;
  }

  /// Custom url entered by the user, if present

  String get customUrl {
    if (!_customUrlSet && _apiMapResponse.containsKey('custom_url')) {
      _customUrl = _apiMapResponse['custom_url']?.toString();
      _customUrlSet = true;
    }
    return _customUrl;
  }

  set customUrl(String v) {
    _customUrl = v;
    _customUrlSet = true;
  }

  /// Dashboard to base this item on

  int get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id'];
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(int v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// The actual description for display (read-only)

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Number of times content has been favorited, if present (read-only)

  int get favoriteCount {
    if (!_favoriteCountSet && _apiMapResponse.containsKey('favorite_count')) {
      _favoriteCount = _apiMapResponse['favorite_count'];
      _favoriteCountSet = true;
    }
    return _favoriteCount;
  }

  set favoriteCount(int v) {
    _favoriteCount = v;
    _favoriteCountSet = true;
  }

  /// Associated Board Section

  int get boardSectionId {
    if (!_boardSectionIdSet &&
        _apiMapResponse.containsKey('board_section_id')) {
      _boardSectionId = _apiMapResponse['board_section_id'];
      _boardSectionIdSet = true;
    }
    return _boardSectionId;
  }

  set boardSectionId(int v) {
    _boardSectionId = v;
    _boardSectionIdSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// The actual image_url for display (read-only)

  String get imageUrl {
    if (!_imageUrlSet && _apiMapResponse.containsKey('image_url')) {
      _imageUrl = _apiMapResponse['image_url']?.toString();
      _imageUrlSet = true;
    }
    return _imageUrl;
  }

  set imageUrl(String v) {
    _imageUrl = v;
    _imageUrlSet = true;
  }

  /// The container folder name of the content (read-only)

  String get location {
    if (!_locationSet && _apiMapResponse.containsKey('location')) {
      _location = _apiMapResponse['location']?.toString();
      _locationSet = true;
    }
    return _location;
  }

  set location(String v) {
    _location = v;
    _locationSet = true;
  }

  /// Look to base this item on

  String get lookId {
    if (!_lookIdSet && _apiMapResponse.containsKey('look_id')) {
      _lookId = _apiMapResponse['look_id']?.toString();
      _lookIdSet = true;
    }
    return _lookId;
  }

  set lookId(String v) {
    _lookId = v;
    _lookIdSet = true;
  }

  /// LookML Dashboard to base this item on

  String get lookmlDashboardId {
    if (!_lookmlDashboardIdSet &&
        _apiMapResponse.containsKey('lookml_dashboard_id')) {
      _lookmlDashboardId = _apiMapResponse['lookml_dashboard_id']?.toString();
      _lookmlDashboardIdSet = true;
    }
    return _lookmlDashboardId;
  }

  set lookmlDashboardId(String v) {
    _lookmlDashboardId = v;
    _lookmlDashboardIdSet = true;
  }

  /// An arbitrary integer representing the sort order within the section

  int get order {
    if (!_orderSet && _apiMapResponse.containsKey('order')) {
      _order = _apiMapResponse['order'];
      _orderSet = true;
    }
    return _order;
  }

  set order(int v) {
    _order = v;
    _orderSet = true;
  }

  /// The actual title for display (read-only)

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Relative url for the associated content (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  /// Number of times content has been viewed, if present (read-only)

  int get viewCount {
    if (!_viewCountSet && _apiMapResponse.containsKey('view_count')) {
      _viewCount = _apiMapResponse['view_count'];
      _viewCountSet = true;
    }
    return _viewCount;
  }

  set viewCount(int v) {
    _viewCount = v;
    _viewCountSet = true;
  }

  BoardItem() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  BoardItem.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_contentCreatedBySet ||
        _apiMapResponse.containsKey('content_created_by')) {
      json['content_created_by'] = contentCreatedBy;
    }
    if (_contentFavoriteIdSet ||
        _apiMapResponse.containsKey('content_favorite_id')) {
      json['content_favorite_id'] = contentFavoriteId;
    }
    if (_contentMetadataIdSet ||
        _apiMapResponse.containsKey('content_metadata_id')) {
      json['content_metadata_id'] = contentMetadataId;
    }
    if (_contentUpdatedAtSet ||
        _apiMapResponse.containsKey('content_updated_at')) {
      json['content_updated_at'] = contentUpdatedAt;
    }
    if (_customDescriptionSet ||
        _apiMapResponse.containsKey('custom_description')) {
      json['custom_description'] = customDescription;
    }
    if (_customTitleSet || _apiMapResponse.containsKey('custom_title')) {
      json['custom_title'] = customTitle;
    }
    if (_customUrlSet || _apiMapResponse.containsKey('custom_url')) {
      json['custom_url'] = customUrl;
    }
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_favoriteCountSet || _apiMapResponse.containsKey('favorite_count')) {
      json['favorite_count'] = favoriteCount;
    }
    if (_boardSectionIdSet || _apiMapResponse.containsKey('board_section_id')) {
      json['board_section_id'] = boardSectionId;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_imageUrlSet || _apiMapResponse.containsKey('image_url')) {
      json['image_url'] = imageUrl;
    }
    if (_locationSet || _apiMapResponse.containsKey('location')) {
      json['location'] = location;
    }
    if (_lookIdSet || _apiMapResponse.containsKey('look_id')) {
      json['look_id'] = lookId;
    }
    if (_lookmlDashboardIdSet ||
        _apiMapResponse.containsKey('lookml_dashboard_id')) {
      json['lookml_dashboard_id'] = lookmlDashboardId;
    }
    if (_orderSet || _apiMapResponse.containsKey('order')) {
      json['order'] = order;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    if (_viewCountSet || _apiMapResponse.containsKey('view_count')) {
      json['view_count'] = viewCount;
    }
    return json;
  }
}

class BoardSection {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  DateTime _createdAt;
  bool _createdAtSet = false;

  DateTime _deletedAt;
  bool _deletedAtSet = false;

  String _description;
  bool _descriptionSet = false;

  int _boardId;
  bool _boardIdSet = false;

  List<BoardItem> _boardItems;
  bool _boardItemsSet = false;

  int _id;
  bool _idSet = false;

  List<int> _itemOrder;
  bool _itemOrderSet = false;

  List<int> _visibleItemOrder;
  bool _visibleItemOrderSet = false;

  String _title;
  bool _titleSet = false;

  DateTime _updatedAt;
  bool _updatedAtSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Time at which this section was created. (read-only)

  DateTime get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['created_at']);
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(DateTime v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// Time at which this section was deleted.

  DateTime get deletedAt {
    if (!_deletedAtSet && _apiMapResponse.containsKey('deleted_at')) {
      _deletedAt = _apiMapResponse['deleted_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['deleted_at']);
      _deletedAtSet = true;
    }
    return _deletedAt;
  }

  set deletedAt(DateTime v) {
    _deletedAt = v;
    _deletedAtSet = true;
  }

  /// Description of the content found in this section.

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Id reference to parent board

  int get boardId {
    if (!_boardIdSet && _apiMapResponse.containsKey('board_id')) {
      _boardId = _apiMapResponse['board_id'];
      _boardIdSet = true;
    }
    return _boardId;
  }

  set boardId(int v) {
    _boardId = v;
    _boardIdSet = true;
  }

  /// Items in the board section (read-only)

  List<BoardItem> get boardItems {
    if (!_boardItemsSet && _apiMapResponse.containsKey('board_items')) {
      _boardItems = _apiMapResponse['board_items'] == null
          ? null
          : (_apiMapResponse['board_items'] as List)
              .map((i) => BoardItem.fromResponse(i, apiResponseContentType))
              .toList();
      _boardItemsSet = true;
    }
    return _boardItems;
  }

  set boardItems(List<BoardItem> v) {
    _boardItems = v;
    _boardItemsSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// ids of the board items in the order they should be displayed

  List<int> get itemOrder {
    if (!_itemOrderSet && _apiMapResponse.containsKey('item_order')) {
      _itemOrder =
          _apiMapResponse['item_order']?.map<int>((i) => i as int)?.toList();
      _itemOrderSet = true;
    }
    return _itemOrder;
  }

  set itemOrder(List<int> v) {
    _itemOrder = v;
    _itemOrderSet = true;
  }

  /// ids of the homepage items the user can see in the order they should be displayed (read-only)

  List<int> get visibleItemOrder {
    if (!_visibleItemOrderSet &&
        _apiMapResponse.containsKey('visible_item_order')) {
      _visibleItemOrder = _apiMapResponse['visible_item_order']
          ?.map<int>((i) => i as int)
          ?.toList();
      _visibleItemOrderSet = true;
    }
    return _visibleItemOrder;
  }

  set visibleItemOrder(List<int> v) {
    _visibleItemOrder = v;
    _visibleItemOrderSet = true;
  }

  /// Name of row

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Time at which this section was last updated. (read-only)

  DateTime get updatedAt {
    if (!_updatedAtSet && _apiMapResponse.containsKey('updated_at')) {
      _updatedAt = _apiMapResponse['updated_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['updated_at']);
      _updatedAtSet = true;
    }
    return _updatedAt;
  }

  set updatedAt(DateTime v) {
    _updatedAt = v;
    _updatedAtSet = true;
  }

  BoardSection() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  BoardSection.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt?.toIso8601String();
    }
    if (_deletedAtSet || _apiMapResponse.containsKey('deleted_at')) {
      json['deleted_at'] = deletedAt?.toIso8601String();
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_boardIdSet || _apiMapResponse.containsKey('board_id')) {
      json['board_id'] = boardId;
    }
    if (_boardItemsSet || _apiMapResponse.containsKey('board_items')) {
      json['board_items'] = boardItems?.map((i) => i.toJson())?.toList();
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_itemOrderSet || _apiMapResponse.containsKey('item_order')) {
      json['item_order'] = itemOrder;
    }
    if (_visibleItemOrderSet ||
        _apiMapResponse.containsKey('visible_item_order')) {
      json['visible_item_order'] = visibleItemOrder;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_updatedAtSet || _apiMapResponse.containsKey('updated_at')) {
      json['updated_at'] = updatedAt?.toIso8601String();
    }
    return json;
  }
}

/// Field category Valid values are: "parameter", "filter", "measure", "dimension". (Enum defined in LookmlModelExploreField)
enum Category { parameter, filter, measure, dimension }

class CategoryMapper {
  static String toStringValue(Category e) {
    switch (e) {
      case Category.parameter:
        return 'parameter';
      case Category.filter:
        return 'filter';
      case Category.measure:
        return 'measure';
      case Category.dimension:
        return 'dimension';

      default:
        return null;
    }
  }

  static Category fromStringValue(String s) {
    if (s == 'parameter') {
      return Category.parameter;
    }
    if (s == 'filter') {
      return Category.filter;
    }
    if (s == 'measure') {
      return Category.measure;
    }
    if (s == 'dimension') {
      return Category.dimension;
    }
    return null;
  }
}

class ColorCollection {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _id;
  bool _idSet = false;

  String _label;
  bool _labelSet = false;

  List<DiscretePalette> _categoricalPalettes;
  bool _categoricalPalettesSet = false;

  List<ContinuousPalette> _sequentialPalettes;
  bool _sequentialPalettesSet = false;

  List<ContinuousPalette> _divergingPalettes;
  bool _divergingPalettesSet = false;

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Label of color collection

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// Array of categorical palette definitions

  List<DiscretePalette> get categoricalPalettes {
    if (!_categoricalPalettesSet &&
        _apiMapResponse.containsKey('categoricalPalettes')) {
      _categoricalPalettes = _apiMapResponse['categoricalPalettes'] == null
          ? null
          : (_apiMapResponse['categoricalPalettes'] as List)
              .map((i) =>
                  DiscretePalette.fromResponse(i, apiResponseContentType))
              .toList();
      _categoricalPalettesSet = true;
    }
    return _categoricalPalettes;
  }

  set categoricalPalettes(List<DiscretePalette> v) {
    _categoricalPalettes = v;
    _categoricalPalettesSet = true;
  }

  /// Array of discrete palette definitions

  List<ContinuousPalette> get sequentialPalettes {
    if (!_sequentialPalettesSet &&
        _apiMapResponse.containsKey('sequentialPalettes')) {
      _sequentialPalettes = _apiMapResponse['sequentialPalettes'] == null
          ? null
          : (_apiMapResponse['sequentialPalettes'] as List)
              .map((i) =>
                  ContinuousPalette.fromResponse(i, apiResponseContentType))
              .toList();
      _sequentialPalettesSet = true;
    }
    return _sequentialPalettes;
  }

  set sequentialPalettes(List<ContinuousPalette> v) {
    _sequentialPalettes = v;
    _sequentialPalettesSet = true;
  }

  /// Array of diverging palette definitions

  List<ContinuousPalette> get divergingPalettes {
    if (!_divergingPalettesSet &&
        _apiMapResponse.containsKey('divergingPalettes')) {
      _divergingPalettes = _apiMapResponse['divergingPalettes'] == null
          ? null
          : (_apiMapResponse['divergingPalettes'] as List)
              .map((i) =>
                  ContinuousPalette.fromResponse(i, apiResponseContentType))
              .toList();
      _divergingPalettesSet = true;
    }
    return _divergingPalettes;
  }

  set divergingPalettes(List<ContinuousPalette> v) {
    _divergingPalettes = v;
    _divergingPalettesSet = true;
  }

  ColorCollection() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ColorCollection.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_categoricalPalettesSet ||
        _apiMapResponse.containsKey('categoricalPalettes')) {
      json['categoricalPalettes'] =
          categoricalPalettes?.map((i) => i.toJson())?.toList();
    }
    if (_sequentialPalettesSet ||
        _apiMapResponse.containsKey('sequentialPalettes')) {
      json['sequentialPalettes'] =
          sequentialPalettes?.map((i) => i.toJson())?.toList();
    }
    if (_divergingPalettesSet ||
        _apiMapResponse.containsKey('divergingPalettes')) {
      json['divergingPalettes'] =
          divergingPalettes?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class ColorStop {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _color;
  bool _colorSet = false;

  int _offset;
  bool _offsetSet = false;

  /// CSS color string

  String get color {
    if (!_colorSet && _apiMapResponse.containsKey('color')) {
      _color = _apiMapResponse['color']?.toString();
      _colorSet = true;
    }
    return _color;
  }

  set color(String v) {
    _color = v;
    _colorSet = true;
  }

  /// Offset in continuous palette (0 to 100)

  int get offset {
    if (!_offsetSet && _apiMapResponse.containsKey('offset')) {
      _offset = _apiMapResponse['offset'];
      _offsetSet = true;
    }
    return _offset;
  }

  set offset(int v) {
    _offset = v;
    _offsetSet = true;
  }

  ColorStop() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ColorStop.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_colorSet || _apiMapResponse.containsKey('color')) {
      json['color'] = color;
    }
    if (_offsetSet || _apiMapResponse.containsKey('offset')) {
      json['offset'] = offset;
    }
    return json;
  }
}

class ColumnSearch {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _schemaName;
  bool _schemaNameSet = false;

  String _tableName;
  bool _tableNameSet = false;

  String _columnName;
  bool _columnNameSet = false;

  String _dataType;
  bool _dataTypeSet = false;

  /// Name of schema containing the table (read-only)

  String get schemaName {
    if (!_schemaNameSet && _apiMapResponse.containsKey('schema_name')) {
      _schemaName = _apiMapResponse['schema_name']?.toString();
      _schemaNameSet = true;
    }
    return _schemaName;
  }

  set schemaName(String v) {
    _schemaName = v;
    _schemaNameSet = true;
  }

  /// Name of table containing the column (read-only)

  String get tableName {
    if (!_tableNameSet && _apiMapResponse.containsKey('table_name')) {
      _tableName = _apiMapResponse['table_name']?.toString();
      _tableNameSet = true;
    }
    return _tableName;
  }

  set tableName(String v) {
    _tableName = v;
    _tableNameSet = true;
  }

  /// Name of column (read-only)

  String get columnName {
    if (!_columnNameSet && _apiMapResponse.containsKey('column_name')) {
      _columnName = _apiMapResponse['column_name']?.toString();
      _columnNameSet = true;
    }
    return _columnName;
  }

  set columnName(String v) {
    _columnName = v;
    _columnNameSet = true;
  }

  /// Column data type (read-only)

  String get dataType {
    if (!_dataTypeSet && _apiMapResponse.containsKey('data_type')) {
      _dataType = _apiMapResponse['data_type']?.toString();
      _dataTypeSet = true;
    }
    return _dataType;
  }

  set dataType(String v) {
    _dataType = v;
    _dataTypeSet = true;
  }

  ColumnSearch() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ColumnSearch.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_schemaNameSet || _apiMapResponse.containsKey('schema_name')) {
      json['schema_name'] = schemaName;
    }
    if (_tableNameSet || _apiMapResponse.containsKey('table_name')) {
      json['table_name'] = tableName;
    }
    if (_columnNameSet || _apiMapResponse.containsKey('column_name')) {
      json['column_name'] = columnName;
    }
    if (_dataTypeSet || _apiMapResponse.containsKey('data_type')) {
      json['data_type'] = dataType;
    }
    return json;
  }
}

class Command {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _id;
  bool _idSet = false;

  int _authorId;
  bool _authorIdSet = false;

  String _name;
  bool _nameSet = false;

  String _description;
  bool _descriptionSet = false;

  String _linkedContentId;
  bool _linkedContentIdSet = false;

  LinkedContentType _linkedContentType;
  bool _linkedContentTypeSet = false;

  /// Id of the command record (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Id of the command author (read-only)

  int get authorId {
    if (!_authorIdSet && _apiMapResponse.containsKey('author_id')) {
      _authorId = _apiMapResponse['author_id'];
      _authorIdSet = true;
    }
    return _authorId;
  }

  set authorId(int v) {
    _authorId = v;
    _authorIdSet = true;
  }

  /// Name of the command

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Description of the command

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Id of the content associated with the command

  String get linkedContentId {
    if (!_linkedContentIdSet &&
        _apiMapResponse.containsKey('linked_content_id')) {
      _linkedContentId = _apiMapResponse['linked_content_id']?.toString();
      _linkedContentIdSet = true;
    }
    return _linkedContentId;
  }

  set linkedContentId(String v) {
    _linkedContentId = v;
    _linkedContentIdSet = true;
  }

  /// Name of the command Valid values are: "dashboard", "lookml_dashboard".

  LinkedContentType get linkedContentType {
    if (!_linkedContentTypeSet &&
        _apiMapResponse.containsKey('linked_content_type')) {
      _linkedContentType = LinkedContentTypeMapper.fromStringValue(
          _apiMapResponse['linked_content_type']);
      _linkedContentTypeSet = true;
    }
    return _linkedContentType;
  }

  set linkedContentType(LinkedContentType v) {
    _linkedContentType = v;
    _linkedContentTypeSet = true;
  }

  Command() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Command.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_authorIdSet || _apiMapResponse.containsKey('author_id')) {
      json['author_id'] = authorId;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_linkedContentIdSet ||
        _apiMapResponse.containsKey('linked_content_id')) {
      json['linked_content_id'] = linkedContentId;
    }
    if (_linkedContentTypeSet ||
        _apiMapResponse.containsKey('linked_content_type')) {
      json['linked_content_type'] =
          LinkedContentTypeMapper.toStringValue(linkedContentType);
    }
    return json;
  }
}

/// This property informs the check what kind of comparison we are performing. Only certain condition types are valid for time series alerts. For details, refer to [Setting Alert Conditions](https://docs.looker.com/sharing-and-publishing/creating-alerts#setting_alert_conditions) Valid values are: "EQUAL_TO", "GREATER_THAN", "GREATER_THAN_OR_EQUAL_TO", "LESS_THAN", "LESS_THAN_OR_EQUAL_TO", "INCREASES_BY", "DECREASES_BY", "CHANGES_BY". (Enum defined in Alert)
enum ComparisonType {
  equalTo,
  greaterThan,
  greaterThanOrEqualTo,
  lessThan,
  lessThanOrEqualTo,
  increasesBy,
  decreasesBy,
  changesBy
}

class ComparisonTypeMapper {
  static String toStringValue(ComparisonType e) {
    switch (e) {
      case ComparisonType.equalTo:
        return 'EQUAL_TO';
      case ComparisonType.greaterThan:
        return 'GREATER_THAN';
      case ComparisonType.greaterThanOrEqualTo:
        return 'GREATER_THAN_OR_EQUAL_TO';
      case ComparisonType.lessThan:
        return 'LESS_THAN';
      case ComparisonType.lessThanOrEqualTo:
        return 'LESS_THAN_OR_EQUAL_TO';
      case ComparisonType.increasesBy:
        return 'INCREASES_BY';
      case ComparisonType.decreasesBy:
        return 'DECREASES_BY';
      case ComparisonType.changesBy:
        return 'CHANGES_BY';

      default:
        return null;
    }
  }

  static ComparisonType fromStringValue(String s) {
    if (s == 'EQUAL_TO') {
      return ComparisonType.equalTo;
    }
    if (s == 'GREATER_THAN') {
      return ComparisonType.greaterThan;
    }
    if (s == 'GREATER_THAN_OR_EQUAL_TO') {
      return ComparisonType.greaterThanOrEqualTo;
    }
    if (s == 'LESS_THAN') {
      return ComparisonType.lessThan;
    }
    if (s == 'LESS_THAN_OR_EQUAL_TO') {
      return ComparisonType.lessThanOrEqualTo;
    }
    if (s == 'INCREASES_BY') {
      return ComparisonType.increasesBy;
    }
    if (s == 'DECREASES_BY') {
      return ComparisonType.decreasesBy;
    }
    if (s == 'CHANGES_BY') {
      return ComparisonType.changesBy;
    }
    return null;
  }
}

class ConnectionFeatures {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _dialectName;
  bool _dialectNameSet = false;

  bool _costEstimate;
  bool _costEstimateSet = false;

  bool _multipleDatabases;
  bool _multipleDatabasesSet = false;

  bool _columnSearch;
  bool _columnSearchSet = false;

  bool _persistentTableIndexes;
  bool _persistentTableIndexesSet = false;

  bool _persistentDerivedTables;
  bool _persistentDerivedTablesSet = false;

  bool _turtles;
  bool _turtlesSet = false;

  bool _percentile;
  bool _percentileSet = false;

  bool _distinctPercentile;
  bool _distinctPercentileSet = false;

  bool _stableViews;
  bool _stableViewsSet = false;

  bool _milliseconds;
  bool _millisecondsSet = false;

  bool _microseconds;
  bool _microsecondsSet = false;

  bool _subtotals;
  bool _subtotalsSet = false;

  bool _location;
  bool _locationSet = false;

  bool _timezone;
  bool _timezoneSet = false;

  bool _connectionPooling;
  bool _connectionPoolingSet = false;

  /// Name of the dialect for this connection (read-only)

  String get dialectName {
    if (!_dialectNameSet && _apiMapResponse.containsKey('dialect_name')) {
      _dialectName = _apiMapResponse['dialect_name']?.toString();
      _dialectNameSet = true;
    }
    return _dialectName;
  }

  set dialectName(String v) {
    _dialectName = v;
    _dialectNameSet = true;
  }

  /// True for cost estimating support (read-only)

  bool get costEstimate {
    if (!_costEstimateSet && _apiMapResponse.containsKey('cost_estimate')) {
      _costEstimate = _apiMapResponse['cost_estimate'];
      _costEstimateSet = true;
    }
    return _costEstimate;
  }

  set costEstimate(bool v) {
    _costEstimate = v;
    _costEstimateSet = true;
  }

  /// True for multiple database support (read-only)

  bool get multipleDatabases {
    if (!_multipleDatabasesSet &&
        _apiMapResponse.containsKey('multiple_databases')) {
      _multipleDatabases = _apiMapResponse['multiple_databases'];
      _multipleDatabasesSet = true;
    }
    return _multipleDatabases;
  }

  set multipleDatabases(bool v) {
    _multipleDatabases = v;
    _multipleDatabasesSet = true;
  }

  /// True for cost estimating support (read-only)

  bool get columnSearch {
    if (!_columnSearchSet && _apiMapResponse.containsKey('column_search')) {
      _columnSearch = _apiMapResponse['column_search'];
      _columnSearchSet = true;
    }
    return _columnSearch;
  }

  set columnSearch(bool v) {
    _columnSearch = v;
    _columnSearchSet = true;
  }

  /// True for secondary index support (read-only)

  bool get persistentTableIndexes {
    if (!_persistentTableIndexesSet &&
        _apiMapResponse.containsKey('persistent_table_indexes')) {
      _persistentTableIndexes = _apiMapResponse['persistent_table_indexes'];
      _persistentTableIndexesSet = true;
    }
    return _persistentTableIndexes;
  }

  set persistentTableIndexes(bool v) {
    _persistentTableIndexes = v;
    _persistentTableIndexesSet = true;
  }

  /// True for persistent derived table support (read-only)

  bool get persistentDerivedTables {
    if (!_persistentDerivedTablesSet &&
        _apiMapResponse.containsKey('persistent_derived_tables')) {
      _persistentDerivedTables = _apiMapResponse['persistent_derived_tables'];
      _persistentDerivedTablesSet = true;
    }
    return _persistentDerivedTables;
  }

  set persistentDerivedTables(bool v) {
    _persistentDerivedTables = v;
    _persistentDerivedTablesSet = true;
  }

  /// True for turtles support (read-only)

  bool get turtles {
    if (!_turtlesSet && _apiMapResponse.containsKey('turtles')) {
      _turtles = _apiMapResponse['turtles'];
      _turtlesSet = true;
    }
    return _turtles;
  }

  set turtles(bool v) {
    _turtles = v;
    _turtlesSet = true;
  }

  /// True for percentile support (read-only)

  bool get percentile {
    if (!_percentileSet && _apiMapResponse.containsKey('percentile')) {
      _percentile = _apiMapResponse['percentile'];
      _percentileSet = true;
    }
    return _percentile;
  }

  set percentile(bool v) {
    _percentile = v;
    _percentileSet = true;
  }

  /// True for distinct percentile support (read-only)

  bool get distinctPercentile {
    if (!_distinctPercentileSet &&
        _apiMapResponse.containsKey('distinct_percentile')) {
      _distinctPercentile = _apiMapResponse['distinct_percentile'];
      _distinctPercentileSet = true;
    }
    return _distinctPercentile;
  }

  set distinctPercentile(bool v) {
    _distinctPercentile = v;
    _distinctPercentileSet = true;
  }

  /// True for stable views support (read-only)

  bool get stableViews {
    if (!_stableViewsSet && _apiMapResponse.containsKey('stable_views')) {
      _stableViews = _apiMapResponse['stable_views'];
      _stableViewsSet = true;
    }
    return _stableViews;
  }

  set stableViews(bool v) {
    _stableViews = v;
    _stableViewsSet = true;
  }

  /// True for millisecond support (read-only)

  bool get milliseconds {
    if (!_millisecondsSet && _apiMapResponse.containsKey('milliseconds')) {
      _milliseconds = _apiMapResponse['milliseconds'];
      _millisecondsSet = true;
    }
    return _milliseconds;
  }

  set milliseconds(bool v) {
    _milliseconds = v;
    _millisecondsSet = true;
  }

  /// True for microsecond support (read-only)

  bool get microseconds {
    if (!_microsecondsSet && _apiMapResponse.containsKey('microseconds')) {
      _microseconds = _apiMapResponse['microseconds'];
      _microsecondsSet = true;
    }
    return _microseconds;
  }

  set microseconds(bool v) {
    _microseconds = v;
    _microsecondsSet = true;
  }

  /// True for subtotal support (read-only)

  bool get subtotals {
    if (!_subtotalsSet && _apiMapResponse.containsKey('subtotals')) {
      _subtotals = _apiMapResponse['subtotals'];
      _subtotalsSet = true;
    }
    return _subtotals;
  }

  set subtotals(bool v) {
    _subtotals = v;
    _subtotalsSet = true;
  }

  /// True for geographic location support (read-only)

  bool get location {
    if (!_locationSet && _apiMapResponse.containsKey('location')) {
      _location = _apiMapResponse['location'];
      _locationSet = true;
    }
    return _location;
  }

  set location(bool v) {
    _location = v;
    _locationSet = true;
  }

  /// True for timezone conversion in query support (read-only)

  bool get timezone {
    if (!_timezoneSet && _apiMapResponse.containsKey('timezone')) {
      _timezone = _apiMapResponse['timezone'];
      _timezoneSet = true;
    }
    return _timezone;
  }

  set timezone(bool v) {
    _timezone = v;
    _timezoneSet = true;
  }

  /// True for connection pooling support (read-only)

  bool get connectionPooling {
    if (!_connectionPoolingSet &&
        _apiMapResponse.containsKey('connection_pooling')) {
      _connectionPooling = _apiMapResponse['connection_pooling'];
      _connectionPoolingSet = true;
    }
    return _connectionPooling;
  }

  set connectionPooling(bool v) {
    _connectionPooling = v;
    _connectionPoolingSet = true;
  }

  ConnectionFeatures() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ConnectionFeatures.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_dialectNameSet || _apiMapResponse.containsKey('dialect_name')) {
      json['dialect_name'] = dialectName;
    }
    if (_costEstimateSet || _apiMapResponse.containsKey('cost_estimate')) {
      json['cost_estimate'] = costEstimate;
    }
    if (_multipleDatabasesSet ||
        _apiMapResponse.containsKey('multiple_databases')) {
      json['multiple_databases'] = multipleDatabases;
    }
    if (_columnSearchSet || _apiMapResponse.containsKey('column_search')) {
      json['column_search'] = columnSearch;
    }
    if (_persistentTableIndexesSet ||
        _apiMapResponse.containsKey('persistent_table_indexes')) {
      json['persistent_table_indexes'] = persistentTableIndexes;
    }
    if (_persistentDerivedTablesSet ||
        _apiMapResponse.containsKey('persistent_derived_tables')) {
      json['persistent_derived_tables'] = persistentDerivedTables;
    }
    if (_turtlesSet || _apiMapResponse.containsKey('turtles')) {
      json['turtles'] = turtles;
    }
    if (_percentileSet || _apiMapResponse.containsKey('percentile')) {
      json['percentile'] = percentile;
    }
    if (_distinctPercentileSet ||
        _apiMapResponse.containsKey('distinct_percentile')) {
      json['distinct_percentile'] = distinctPercentile;
    }
    if (_stableViewsSet || _apiMapResponse.containsKey('stable_views')) {
      json['stable_views'] = stableViews;
    }
    if (_millisecondsSet || _apiMapResponse.containsKey('milliseconds')) {
      json['milliseconds'] = milliseconds;
    }
    if (_microsecondsSet || _apiMapResponse.containsKey('microseconds')) {
      json['microseconds'] = microseconds;
    }
    if (_subtotalsSet || _apiMapResponse.containsKey('subtotals')) {
      json['subtotals'] = subtotals;
    }
    if (_locationSet || _apiMapResponse.containsKey('location')) {
      json['location'] = location;
    }
    if (_timezoneSet || _apiMapResponse.containsKey('timezone')) {
      json['timezone'] = timezone;
    }
    if (_connectionPoolingSet ||
        _apiMapResponse.containsKey('connection_pooling')) {
      json['connection_pooling'] = connectionPooling;
    }
    return json;
  }
}

class ContentFavorite {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _id;
  bool _idSet = false;

  int _userId;
  bool _userIdSet = false;

  int _contentMetadataId;
  bool _contentMetadataIdSet = false;

  String _lookId;
  bool _lookIdSet = false;

  int _dashboardId;
  bool _dashboardIdSet = false;

  LookBasic _look;
  bool _lookSet = false;

  DashboardBase _dashboard;
  bool _dashboardSet = false;

  int _boardId;
  bool _boardIdSet = false;

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// User Id which owns this ContentFavorite

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  /// Content Metadata Id associated with this ContentFavorite

  int get contentMetadataId {
    if (!_contentMetadataIdSet &&
        _apiMapResponse.containsKey('content_metadata_id')) {
      _contentMetadataId = _apiMapResponse['content_metadata_id'];
      _contentMetadataIdSet = true;
    }
    return _contentMetadataId;
  }

  set contentMetadataId(int v) {
    _contentMetadataId = v;
    _contentMetadataIdSet = true;
  }

  /// Id of a look (read-only)

  String get lookId {
    if (!_lookIdSet && _apiMapResponse.containsKey('look_id')) {
      _lookId = _apiMapResponse['look_id']?.toString();
      _lookIdSet = true;
    }
    return _lookId;
  }

  set lookId(String v) {
    _lookId = v;
    _lookIdSet = true;
  }

  /// Id of a dashboard (read-only)

  int get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id'];
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(int v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  LookBasic get look {
    if (!_lookSet && _apiMapResponse.containsKey('look')) {
      _look = _apiMapResponse['look'] == null
          ? null
          : LookBasic.fromResponse(
              _apiMapResponse['look'], apiResponseContentType);
      _lookSet = true;
    }
    return _look;
  }

  set look(LookBasic v) {
    _look = v;
    _lookSet = true;
  }

  DashboardBase get dashboard {
    if (!_dashboardSet && _apiMapResponse.containsKey('dashboard')) {
      _dashboard = _apiMapResponse['dashboard'] == null
          ? null
          : DashboardBase.fromResponse(
              _apiMapResponse['dashboard'], apiResponseContentType);
      _dashboardSet = true;
    }
    return _dashboard;
  }

  set dashboard(DashboardBase v) {
    _dashboard = v;
    _dashboardSet = true;
  }

  /// Id of a board (read-only)

  int get boardId {
    if (!_boardIdSet && _apiMapResponse.containsKey('board_id')) {
      _boardId = _apiMapResponse['board_id'];
      _boardIdSet = true;
    }
    return _boardId;
  }

  set boardId(int v) {
    _boardId = v;
    _boardIdSet = true;
  }

  ContentFavorite() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ContentFavorite.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    if (_contentMetadataIdSet ||
        _apiMapResponse.containsKey('content_metadata_id')) {
      json['content_metadata_id'] = contentMetadataId;
    }
    if (_lookIdSet || _apiMapResponse.containsKey('look_id')) {
      json['look_id'] = lookId;
    }
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_lookSet || _apiMapResponse.containsKey('look')) {
      json['look'] = look?.toJson();
    }
    if (_dashboardSet || _apiMapResponse.containsKey('dashboard')) {
      json['dashboard'] = dashboard?.toJson();
    }
    if (_boardIdSet || _apiMapResponse.containsKey('board_id')) {
      json['board_id'] = boardId;
    }
    return json;
  }
}

class ContentMeta {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _id;
  bool _idSet = false;

  String _name;
  bool _nameSet = false;

  int _parentId;
  bool _parentIdSet = false;

  String _dashboardId;
  bool _dashboardIdSet = false;

  String _lookId;
  bool _lookIdSet = false;

  String _folderId;
  bool _folderIdSet = false;

  String _contentType;
  bool _contentTypeSet = false;

  bool _inherits;
  bool _inheritsSet = false;

  int _inheritingId;
  bool _inheritingIdSet = false;

  String _slug;
  bool _slugSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Name or title of underlying content (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Id of Parent Content (read-only)

  int get parentId {
    if (!_parentIdSet && _apiMapResponse.containsKey('parent_id')) {
      _parentId = _apiMapResponse['parent_id'];
      _parentIdSet = true;
    }
    return _parentId;
  }

  set parentId(int v) {
    _parentId = v;
    _parentIdSet = true;
  }

  /// Id of associated dashboard when content_type is "dashboard" (read-only)

  String get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id']?.toString();
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(String v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// Id of associated look when content_type is "look" (read-only)

  String get lookId {
    if (!_lookIdSet && _apiMapResponse.containsKey('look_id')) {
      _lookId = _apiMapResponse['look_id']?.toString();
      _lookIdSet = true;
    }
    return _lookId;
  }

  set lookId(String v) {
    _lookId = v;
    _lookIdSet = true;
  }

  /// Id of associated folder when content_type is "space" (read-only)

  String get folderId {
    if (!_folderIdSet && _apiMapResponse.containsKey('folder_id')) {
      _folderId = _apiMapResponse['folder_id']?.toString();
      _folderIdSet = true;
    }
    return _folderId;
  }

  set folderId(String v) {
    _folderId = v;
    _folderIdSet = true;
  }

  /// Content Type ("dashboard", "look", or "folder") (read-only)

  String get contentType {
    if (!_contentTypeSet && _apiMapResponse.containsKey('content_type')) {
      _contentType = _apiMapResponse['content_type']?.toString();
      _contentTypeSet = true;
    }
    return _contentType;
  }

  set contentType(String v) {
    _contentType = v;
    _contentTypeSet = true;
  }

  /// Whether content inherits its access levels from parent

  bool get inherits {
    if (!_inheritsSet && _apiMapResponse.containsKey('inherits')) {
      _inherits = _apiMapResponse['inherits'];
      _inheritsSet = true;
    }
    return _inherits;
  }

  set inherits(bool v) {
    _inherits = v;
    _inheritsSet = true;
  }

  /// Id of Inherited Content (read-only)

  int get inheritingId {
    if (!_inheritingIdSet && _apiMapResponse.containsKey('inheriting_id')) {
      _inheritingId = _apiMapResponse['inheriting_id'];
      _inheritingIdSet = true;
    }
    return _inheritingId;
  }

  set inheritingId(int v) {
    _inheritingId = v;
    _inheritingIdSet = true;
  }

  /// Content Slug (read-only)

  String get slug {
    if (!_slugSet && _apiMapResponse.containsKey('slug')) {
      _slug = _apiMapResponse['slug']?.toString();
      _slugSet = true;
    }
    return _slug;
  }

  set slug(String v) {
    _slug = v;
    _slugSet = true;
  }

  ContentMeta() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ContentMeta.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_parentIdSet || _apiMapResponse.containsKey('parent_id')) {
      json['parent_id'] = parentId;
    }
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_lookIdSet || _apiMapResponse.containsKey('look_id')) {
      json['look_id'] = lookId;
    }
    if (_folderIdSet || _apiMapResponse.containsKey('folder_id')) {
      json['folder_id'] = folderId;
    }
    if (_contentTypeSet || _apiMapResponse.containsKey('content_type')) {
      json['content_type'] = contentType;
    }
    if (_inheritsSet || _apiMapResponse.containsKey('inherits')) {
      json['inherits'] = inherits;
    }
    if (_inheritingIdSet || _apiMapResponse.containsKey('inheriting_id')) {
      json['inheriting_id'] = inheritingId;
    }
    if (_slugSet || _apiMapResponse.containsKey('slug')) {
      json['slug'] = slug;
    }
    return json;
  }
}

/// WARNING: no writeable properties found for POST, PUT, or PATCH
class ContentMetaGroupUser {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _id;
  bool _idSet = false;

  String _contentMetadataId;
  bool _contentMetadataIdSet = false;

  PermissionType _permissionType;
  bool _permissionTypeSet = false;

  int _groupId;
  bool _groupIdSet = false;

  int _userId;
  bool _userIdSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Id of associated Content Metadata (read-only)

  String get contentMetadataId {
    if (!_contentMetadataIdSet &&
        _apiMapResponse.containsKey('content_metadata_id')) {
      _contentMetadataId = _apiMapResponse['content_metadata_id']?.toString();
      _contentMetadataIdSet = true;
    }
    return _contentMetadataId;
  }

  set contentMetadataId(String v) {
    _contentMetadataId = v;
    _contentMetadataIdSet = true;
  }

  /// Type of permission: "view" or "edit" Valid values are: "view", "edit". (read-only)

  PermissionType get permissionType {
    if (!_permissionTypeSet && _apiMapResponse.containsKey('permission_type')) {
      _permissionType = PermissionTypeMapper.fromStringValue(
          _apiMapResponse['permission_type']);
      _permissionTypeSet = true;
    }
    return _permissionType;
  }

  set permissionType(PermissionType v) {
    _permissionType = v;
    _permissionTypeSet = true;
  }

  /// ID of associated group (read-only)

  int get groupId {
    if (!_groupIdSet && _apiMapResponse.containsKey('group_id')) {
      _groupId = _apiMapResponse['group_id'];
      _groupIdSet = true;
    }
    return _groupId;
  }

  set groupId(int v) {
    _groupId = v;
    _groupIdSet = true;
  }

  /// ID of associated user (read-only)

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  ContentMetaGroupUser() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ContentMetaGroupUser.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_contentMetadataIdSet ||
        _apiMapResponse.containsKey('content_metadata_id')) {
      json['content_metadata_id'] = contentMetadataId;
    }
    if (_permissionTypeSet || _apiMapResponse.containsKey('permission_type')) {
      json['permission_type'] =
          PermissionTypeMapper.toStringValue(permissionType);
    }
    if (_groupIdSet || _apiMapResponse.containsKey('group_id')) {
      json['group_id'] = groupId;
    }
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    return json;
  }
}

class ContentValidation {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  List<ContentValidatorError> _contentWithErrors;
  bool _contentWithErrorsSet = false;

  double _computationTime;
  bool _computationTimeSet = false;

  int _totalLooksValidated;
  bool _totalLooksValidatedSet = false;

  int _totalDashboardElementsValidated;
  bool _totalDashboardElementsValidatedSet = false;

  int _totalDashboardFiltersValidated;
  bool _totalDashboardFiltersValidatedSet = false;

  int _totalScheduledPlansValidated;
  bool _totalScheduledPlansValidatedSet = false;

  int _totalAlertsValidated;
  bool _totalAlertsValidatedSet = false;

  int _totalExploresValidated;
  bool _totalExploresValidatedSet = false;

  /// A list of content errors (read-only)

  List<ContentValidatorError> get contentWithErrors {
    if (!_contentWithErrorsSet &&
        _apiMapResponse.containsKey('content_with_errors')) {
      _contentWithErrors = _apiMapResponse['content_with_errors'] == null
          ? null
          : (_apiMapResponse['content_with_errors'] as List)
              .map((i) =>
                  ContentValidatorError.fromResponse(i, apiResponseContentType))
              .toList();
      _contentWithErrorsSet = true;
    }
    return _contentWithErrors;
  }

  set contentWithErrors(List<ContentValidatorError> v) {
    _contentWithErrors = v;
    _contentWithErrorsSet = true;
  }

  /// Duration of content validation in seconds (read-only)

  double get computationTime {
    if (!_computationTimeSet &&
        _apiMapResponse.containsKey('computation_time')) {
      _computationTime = _apiMapResponse['computation_time'];
      _computationTimeSet = true;
    }
    return _computationTime;
  }

  set computationTime(double v) {
    _computationTime = v;
    _computationTimeSet = true;
  }

  /// The number of looks validated (read-only)

  int get totalLooksValidated {
    if (!_totalLooksValidatedSet &&
        _apiMapResponse.containsKey('total_looks_validated')) {
      _totalLooksValidated = _apiMapResponse['total_looks_validated'];
      _totalLooksValidatedSet = true;
    }
    return _totalLooksValidated;
  }

  set totalLooksValidated(int v) {
    _totalLooksValidated = v;
    _totalLooksValidatedSet = true;
  }

  /// The number of dashboard elements validated (read-only)

  int get totalDashboardElementsValidated {
    if (!_totalDashboardElementsValidatedSet &&
        _apiMapResponse.containsKey('total_dashboard_elements_validated')) {
      _totalDashboardElementsValidated =
          _apiMapResponse['total_dashboard_elements_validated'];
      _totalDashboardElementsValidatedSet = true;
    }
    return _totalDashboardElementsValidated;
  }

  set totalDashboardElementsValidated(int v) {
    _totalDashboardElementsValidated = v;
    _totalDashboardElementsValidatedSet = true;
  }

  /// The number of dashboard filters validated (read-only)

  int get totalDashboardFiltersValidated {
    if (!_totalDashboardFiltersValidatedSet &&
        _apiMapResponse.containsKey('total_dashboard_filters_validated')) {
      _totalDashboardFiltersValidated =
          _apiMapResponse['total_dashboard_filters_validated'];
      _totalDashboardFiltersValidatedSet = true;
    }
    return _totalDashboardFiltersValidated;
  }

  set totalDashboardFiltersValidated(int v) {
    _totalDashboardFiltersValidated = v;
    _totalDashboardFiltersValidatedSet = true;
  }

  /// The number of scheduled plans validated (read-only)

  int get totalScheduledPlansValidated {
    if (!_totalScheduledPlansValidatedSet &&
        _apiMapResponse.containsKey('total_scheduled_plans_validated')) {
      _totalScheduledPlansValidated =
          _apiMapResponse['total_scheduled_plans_validated'];
      _totalScheduledPlansValidatedSet = true;
    }
    return _totalScheduledPlansValidated;
  }

  set totalScheduledPlansValidated(int v) {
    _totalScheduledPlansValidated = v;
    _totalScheduledPlansValidatedSet = true;
  }

  /// The number of alerts validated (read-only)

  int get totalAlertsValidated {
    if (!_totalAlertsValidatedSet &&
        _apiMapResponse.containsKey('total_alerts_validated')) {
      _totalAlertsValidated = _apiMapResponse['total_alerts_validated'];
      _totalAlertsValidatedSet = true;
    }
    return _totalAlertsValidated;
  }

  set totalAlertsValidated(int v) {
    _totalAlertsValidated = v;
    _totalAlertsValidatedSet = true;
  }

  /// The number of explores used across all content validated (read-only)

  int get totalExploresValidated {
    if (!_totalExploresValidatedSet &&
        _apiMapResponse.containsKey('total_explores_validated')) {
      _totalExploresValidated = _apiMapResponse['total_explores_validated'];
      _totalExploresValidatedSet = true;
    }
    return _totalExploresValidated;
  }

  set totalExploresValidated(int v) {
    _totalExploresValidated = v;
    _totalExploresValidatedSet = true;
  }

  ContentValidation() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ContentValidation.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_contentWithErrorsSet ||
        _apiMapResponse.containsKey('content_with_errors')) {
      json['content_with_errors'] =
          contentWithErrors?.map((i) => i.toJson())?.toList();
    }
    if (_computationTimeSet ||
        _apiMapResponse.containsKey('computation_time')) {
      json['computation_time'] = computationTime;
    }
    if (_totalLooksValidatedSet ||
        _apiMapResponse.containsKey('total_looks_validated')) {
      json['total_looks_validated'] = totalLooksValidated;
    }
    if (_totalDashboardElementsValidatedSet ||
        _apiMapResponse.containsKey('total_dashboard_elements_validated')) {
      json['total_dashboard_elements_validated'] =
          totalDashboardElementsValidated;
    }
    if (_totalDashboardFiltersValidatedSet ||
        _apiMapResponse.containsKey('total_dashboard_filters_validated')) {
      json['total_dashboard_filters_validated'] =
          totalDashboardFiltersValidated;
    }
    if (_totalScheduledPlansValidatedSet ||
        _apiMapResponse.containsKey('total_scheduled_plans_validated')) {
      json['total_scheduled_plans_validated'] = totalScheduledPlansValidated;
    }
    if (_totalAlertsValidatedSet ||
        _apiMapResponse.containsKey('total_alerts_validated')) {
      json['total_alerts_validated'] = totalAlertsValidated;
    }
    if (_totalExploresValidatedSet ||
        _apiMapResponse.containsKey('total_explores_validated')) {
      json['total_explores_validated'] = totalExploresValidated;
    }
    return json;
  }
}

class ContentValidationAlert {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _id;
  bool _idSet = false;

  String _lookmlDashboardId;
  bool _lookmlDashboardIdSet = false;

  String _lookmlLinkId;
  bool _lookmlLinkIdSet = false;

  String _customTitle;
  bool _customTitleSet = false;

  /// ID of the alert

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// ID of the LookML dashboard associated with the alert

  String get lookmlDashboardId {
    if (!_lookmlDashboardIdSet &&
        _apiMapResponse.containsKey('lookml_dashboard_id')) {
      _lookmlDashboardId = _apiMapResponse['lookml_dashboard_id']?.toString();
      _lookmlDashboardIdSet = true;
    }
    return _lookmlDashboardId;
  }

  set lookmlDashboardId(String v) {
    _lookmlDashboardId = v;
    _lookmlDashboardIdSet = true;
  }

  /// ID of the LookML dashboard element associated with the alert

  String get lookmlLinkId {
    if (!_lookmlLinkIdSet && _apiMapResponse.containsKey('lookml_link_id')) {
      _lookmlLinkId = _apiMapResponse['lookml_link_id']?.toString();
      _lookmlLinkIdSet = true;
    }
    return _lookmlLinkId;
  }

  set lookmlLinkId(String v) {
    _lookmlLinkId = v;
    _lookmlLinkIdSet = true;
  }

  /// An optional, user-defined title for the alert

  String get customTitle {
    if (!_customTitleSet && _apiMapResponse.containsKey('custom_title')) {
      _customTitle = _apiMapResponse['custom_title']?.toString();
      _customTitleSet = true;
    }
    return _customTitle;
  }

  set customTitle(String v) {
    _customTitle = v;
    _customTitleSet = true;
  }

  ContentValidationAlert() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ContentValidationAlert.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_lookmlDashboardIdSet ||
        _apiMapResponse.containsKey('lookml_dashboard_id')) {
      json['lookml_dashboard_id'] = lookmlDashboardId;
    }
    if (_lookmlLinkIdSet || _apiMapResponse.containsKey('lookml_link_id')) {
      json['lookml_link_id'] = lookmlLinkId;
    }
    if (_customTitleSet || _apiMapResponse.containsKey('custom_title')) {
      json['custom_title'] = customTitle;
    }
    return json;
  }
}

class ContentValidationDashboard {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _description;
  bool _descriptionSet = false;

  String _id;
  bool _idSet = false;

  ContentValidationFolder _folder;
  bool _folderSet = false;

  String _title;
  bool _titleSet = false;

  String _url;
  bool _urlSet = false;

  /// Description

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  ContentValidationFolder get folder {
    if (!_folderSet && _apiMapResponse.containsKey('folder')) {
      _folder = _apiMapResponse['folder'] == null
          ? null
          : ContentValidationFolder.fromResponse(
              _apiMapResponse['folder'], apiResponseContentType);
      _folderSet = true;
    }
    return _folder;
  }

  set folder(ContentValidationFolder v) {
    _folder = v;
    _folderSet = true;
  }

  /// Dashboard Title

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Relative URL of the dashboard (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  ContentValidationDashboard() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ContentValidationDashboard.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_folderSet || _apiMapResponse.containsKey('folder')) {
      json['folder'] = folder?.toJson();
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class ContentValidationDashboardElement {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _bodyText;
  bool _bodyTextSet = false;

  String _dashboardId;
  bool _dashboardIdSet = false;

  String _id;
  bool _idSet = false;

  String _lookId;
  bool _lookIdSet = false;

  String _noteDisplay;
  bool _noteDisplaySet = false;

  String _noteState;
  bool _noteStateSet = false;

  String _noteText;
  bool _noteTextSet = false;

  String _noteTextAsHtml;
  bool _noteTextAsHtmlSet = false;

  int _queryId;
  bool _queryIdSet = false;

  String _subtitleText;
  bool _subtitleTextSet = false;

  String _title;
  bool _titleSet = false;

  bool _titleHidden;
  bool _titleHiddenSet = false;

  String _titleText;
  bool _titleTextSet = false;

  String _type;
  bool _typeSet = false;

  /// Text tile body text

  String get bodyText {
    if (!_bodyTextSet && _apiMapResponse.containsKey('body_text')) {
      _bodyText = _apiMapResponse['body_text']?.toString();
      _bodyTextSet = true;
    }
    return _bodyText;
  }

  set bodyText(String v) {
    _bodyText = v;
    _bodyTextSet = true;
  }

  /// Id of Dashboard

  String get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id']?.toString();
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(String v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Id Of Look

  String get lookId {
    if (!_lookIdSet && _apiMapResponse.containsKey('look_id')) {
      _lookId = _apiMapResponse['look_id']?.toString();
      _lookIdSet = true;
    }
    return _lookId;
  }

  set lookId(String v) {
    _lookId = v;
    _lookIdSet = true;
  }

  /// Note Display

  String get noteDisplay {
    if (!_noteDisplaySet && _apiMapResponse.containsKey('note_display')) {
      _noteDisplay = _apiMapResponse['note_display']?.toString();
      _noteDisplaySet = true;
    }
    return _noteDisplay;
  }

  set noteDisplay(String v) {
    _noteDisplay = v;
    _noteDisplaySet = true;
  }

  /// Note State

  String get noteState {
    if (!_noteStateSet && _apiMapResponse.containsKey('note_state')) {
      _noteState = _apiMapResponse['note_state']?.toString();
      _noteStateSet = true;
    }
    return _noteState;
  }

  set noteState(String v) {
    _noteState = v;
    _noteStateSet = true;
  }

  /// Note Text

  String get noteText {
    if (!_noteTextSet && _apiMapResponse.containsKey('note_text')) {
      _noteText = _apiMapResponse['note_text']?.toString();
      _noteTextSet = true;
    }
    return _noteText;
  }

  set noteText(String v) {
    _noteText = v;
    _noteTextSet = true;
  }

  /// Note Text as Html (read-only)

  String get noteTextAsHtml {
    if (!_noteTextAsHtmlSet &&
        _apiMapResponse.containsKey('note_text_as_html')) {
      _noteTextAsHtml = _apiMapResponse['note_text_as_html']?.toString();
      _noteTextAsHtmlSet = true;
    }
    return _noteTextAsHtml;
  }

  set noteTextAsHtml(String v) {
    _noteTextAsHtml = v;
    _noteTextAsHtmlSet = true;
  }

  /// Id Of Query

  int get queryId {
    if (!_queryIdSet && _apiMapResponse.containsKey('query_id')) {
      _queryId = _apiMapResponse['query_id'];
      _queryIdSet = true;
    }
    return _queryId;
  }

  set queryId(int v) {
    _queryId = v;
    _queryIdSet = true;
  }

  /// Text tile subtitle text

  String get subtitleText {
    if (!_subtitleTextSet && _apiMapResponse.containsKey('subtitle_text')) {
      _subtitleText = _apiMapResponse['subtitle_text']?.toString();
      _subtitleTextSet = true;
    }
    return _subtitleText;
  }

  set subtitleText(String v) {
    _subtitleText = v;
    _subtitleTextSet = true;
  }

  /// Title of dashboard element

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Whether title is hidden

  bool get titleHidden {
    if (!_titleHiddenSet && _apiMapResponse.containsKey('title_hidden')) {
      _titleHidden = _apiMapResponse['title_hidden'];
      _titleHiddenSet = true;
    }
    return _titleHidden;
  }

  set titleHidden(bool v) {
    _titleHidden = v;
    _titleHiddenSet = true;
  }

  /// Text tile title

  String get titleText {
    if (!_titleTextSet && _apiMapResponse.containsKey('title_text')) {
      _titleText = _apiMapResponse['title_text']?.toString();
      _titleTextSet = true;
    }
    return _titleText;
  }

  set titleText(String v) {
    _titleText = v;
    _titleTextSet = true;
  }

  /// Type

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  ContentValidationDashboardElement() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ContentValidationDashboardElement.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_bodyTextSet || _apiMapResponse.containsKey('body_text')) {
      json['body_text'] = bodyText;
    }
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_lookIdSet || _apiMapResponse.containsKey('look_id')) {
      json['look_id'] = lookId;
    }
    if (_noteDisplaySet || _apiMapResponse.containsKey('note_display')) {
      json['note_display'] = noteDisplay;
    }
    if (_noteStateSet || _apiMapResponse.containsKey('note_state')) {
      json['note_state'] = noteState;
    }
    if (_noteTextSet || _apiMapResponse.containsKey('note_text')) {
      json['note_text'] = noteText;
    }
    if (_noteTextAsHtmlSet ||
        _apiMapResponse.containsKey('note_text_as_html')) {
      json['note_text_as_html'] = noteTextAsHtml;
    }
    if (_queryIdSet || _apiMapResponse.containsKey('query_id')) {
      json['query_id'] = queryId;
    }
    if (_subtitleTextSet || _apiMapResponse.containsKey('subtitle_text')) {
      json['subtitle_text'] = subtitleText;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_titleHiddenSet || _apiMapResponse.containsKey('title_hidden')) {
      json['title_hidden'] = titleHidden;
    }
    if (_titleTextSet || _apiMapResponse.containsKey('title_text')) {
      json['title_text'] = titleText;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    return json;
  }
}

class ContentValidationDashboardFilter {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _id;
  bool _idSet = false;

  String _dashboardId;
  bool _dashboardIdSet = false;

  String _name;
  bool _nameSet = false;

  String _title;
  bool _titleSet = false;

  String _type;
  bool _typeSet = false;

  String _defaultValue;
  bool _defaultValueSet = false;

  String _model;
  bool _modelSet = false;

  String _explore;
  bool _exploreSet = false;

  String _dimension;
  bool _dimensionSet = false;

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Id of Dashboard (read-only)

  String get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id']?.toString();
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(String v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// Name of filter

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Title of filter

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Type of filter: one of date, number, string, or field

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Default value of filter

  String get defaultValue {
    if (!_defaultValueSet && _apiMapResponse.containsKey('default_value')) {
      _defaultValue = _apiMapResponse['default_value']?.toString();
      _defaultValueSet = true;
    }
    return _defaultValue;
  }

  set defaultValue(String v) {
    _defaultValue = v;
    _defaultValueSet = true;
  }

  /// Model of filter (required if type = field)

  String get model {
    if (!_modelSet && _apiMapResponse.containsKey('model')) {
      _model = _apiMapResponse['model']?.toString();
      _modelSet = true;
    }
    return _model;
  }

  set model(String v) {
    _model = v;
    _modelSet = true;
  }

  /// Explore of filter (required if type = field)

  String get explore {
    if (!_exploreSet && _apiMapResponse.containsKey('explore')) {
      _explore = _apiMapResponse['explore']?.toString();
      _exploreSet = true;
    }
    return _explore;
  }

  set explore(String v) {
    _explore = v;
    _exploreSet = true;
  }

  /// Dimension of filter (required if type = field)

  String get dimension {
    if (!_dimensionSet && _apiMapResponse.containsKey('dimension')) {
      _dimension = _apiMapResponse['dimension']?.toString();
      _dimensionSet = true;
    }
    return _dimension;
  }

  set dimension(String v) {
    _dimension = v;
    _dimensionSet = true;
  }

  ContentValidationDashboardFilter() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ContentValidationDashboardFilter.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_defaultValueSet || _apiMapResponse.containsKey('default_value')) {
      json['default_value'] = defaultValue;
    }
    if (_modelSet || _apiMapResponse.containsKey('model')) {
      json['model'] = model;
    }
    if (_exploreSet || _apiMapResponse.containsKey('explore')) {
      json['explore'] = explore;
    }
    if (_dimensionSet || _apiMapResponse.containsKey('dimension')) {
      json['dimension'] = dimension;
    }
    return json;
  }
}

class ContentValidationError {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _message;
  bool _messageSet = false;

  String _fieldName;
  bool _fieldNameSet = false;

  String _modelName;
  bool _modelNameSet = false;

  String _exploreName;
  bool _exploreNameSet = false;

  bool _removable;
  bool _removableSet = false;

  /// Error message (read-only)

  String get message {
    if (!_messageSet && _apiMapResponse.containsKey('message')) {
      _message = _apiMapResponse['message']?.toString();
      _messageSet = true;
    }
    return _message;
  }

  set message(String v) {
    _message = v;
    _messageSet = true;
  }

  /// Name of the field involved in the error (read-only)

  String get fieldName {
    if (!_fieldNameSet && _apiMapResponse.containsKey('field_name')) {
      _fieldName = _apiMapResponse['field_name']?.toString();
      _fieldNameSet = true;
    }
    return _fieldName;
  }

  set fieldName(String v) {
    _fieldName = v;
    _fieldNameSet = true;
  }

  /// Name of the model involved in the error (read-only)

  String get modelName {
    if (!_modelNameSet && _apiMapResponse.containsKey('model_name')) {
      _modelName = _apiMapResponse['model_name']?.toString();
      _modelNameSet = true;
    }
    return _modelName;
  }

  set modelName(String v) {
    _modelName = v;
    _modelNameSet = true;
  }

  /// Name of the explore involved in the error (read-only)

  String get exploreName {
    if (!_exploreNameSet && _apiMapResponse.containsKey('explore_name')) {
      _exploreName = _apiMapResponse['explore_name']?.toString();
      _exploreNameSet = true;
    }
    return _exploreName;
  }

  set exploreName(String v) {
    _exploreName = v;
    _exploreNameSet = true;
  }

  /// Whether this validation error is removable (read-only)

  bool get removable {
    if (!_removableSet && _apiMapResponse.containsKey('removable')) {
      _removable = _apiMapResponse['removable'];
      _removableSet = true;
    }
    return _removable;
  }

  set removable(bool v) {
    _removable = v;
    _removableSet = true;
  }

  ContentValidationError() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ContentValidationError.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_messageSet || _apiMapResponse.containsKey('message')) {
      json['message'] = message;
    }
    if (_fieldNameSet || _apiMapResponse.containsKey('field_name')) {
      json['field_name'] = fieldName;
    }
    if (_modelNameSet || _apiMapResponse.containsKey('model_name')) {
      json['model_name'] = modelName;
    }
    if (_exploreNameSet || _apiMapResponse.containsKey('explore_name')) {
      json['explore_name'] = exploreName;
    }
    if (_removableSet || _apiMapResponse.containsKey('removable')) {
      json['removable'] = removable;
    }
    return json;
  }
}

class ContentValidationFolder {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _id;
  bool _idSet = false;

  /// Unique Name

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  ContentValidationFolder() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ContentValidationFolder.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    return json;
  }
}

class ContentValidationLook {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _id;
  bool _idSet = false;

  String _title;
  bool _titleSet = false;

  String _shortUrl;
  bool _shortUrlSet = false;

  ContentValidationFolder _folder;
  bool _folderSet = false;

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Look Title

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Short Url (read-only)

  String get shortUrl {
    if (!_shortUrlSet && _apiMapResponse.containsKey('short_url')) {
      _shortUrl = _apiMapResponse['short_url']?.toString();
      _shortUrlSet = true;
    }
    return _shortUrl;
  }

  set shortUrl(String v) {
    _shortUrl = v;
    _shortUrlSet = true;
  }

  ContentValidationFolder get folder {
    if (!_folderSet && _apiMapResponse.containsKey('folder')) {
      _folder = _apiMapResponse['folder'] == null
          ? null
          : ContentValidationFolder.fromResponse(
              _apiMapResponse['folder'], apiResponseContentType);
      _folderSet = true;
    }
    return _folder;
  }

  set folder(ContentValidationFolder v) {
    _folder = v;
    _folderSet = true;
  }

  ContentValidationLook() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ContentValidationLook.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_shortUrlSet || _apiMapResponse.containsKey('short_url')) {
      json['short_url'] = shortUrl;
    }
    if (_folderSet || _apiMapResponse.containsKey('folder')) {
      json['folder'] = folder?.toJson();
    }
    return json;
  }
}

class ContentValidationLookMLDashboard {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _id;
  bool _idSet = false;

  String _title;
  bool _titleSet = false;

  String _spaceId;
  bool _spaceIdSet = false;

  /// ID of the LookML Dashboard (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Title of the LookML Dashboard (read-only)

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// ID of Space (read-only)

  String get spaceId {
    if (!_spaceIdSet && _apiMapResponse.containsKey('space_id')) {
      _spaceId = _apiMapResponse['space_id']?.toString();
      _spaceIdSet = true;
    }
    return _spaceId;
  }

  set spaceId(String v) {
    _spaceId = v;
    _spaceIdSet = true;
  }

  ContentValidationLookMLDashboard() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ContentValidationLookMLDashboard.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_spaceIdSet || _apiMapResponse.containsKey('space_id')) {
      json['space_id'] = spaceId;
    }
    return json;
  }
}

class ContentValidationLookMLDashboardElement {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _lookmlLinkId;
  bool _lookmlLinkIdSet = false;

  String _title;
  bool _titleSet = false;

  /// Link ID of the LookML Dashboard Element (read-only)

  String get lookmlLinkId {
    if (!_lookmlLinkIdSet && _apiMapResponse.containsKey('lookml_link_id')) {
      _lookmlLinkId = _apiMapResponse['lookml_link_id']?.toString();
      _lookmlLinkIdSet = true;
    }
    return _lookmlLinkId;
  }

  set lookmlLinkId(String v) {
    _lookmlLinkId = v;
    _lookmlLinkIdSet = true;
  }

  /// Title of the LookML Dashboard Element (read-only)

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  ContentValidationLookMLDashboardElement() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ContentValidationLookMLDashboardElement.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_lookmlLinkIdSet || _apiMapResponse.containsKey('lookml_link_id')) {
      json['lookml_link_id'] = lookmlLinkId;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    return json;
  }
}

class ContentValidationScheduledPlan {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _lookId;
  bool _lookIdSet = false;

  int _id;
  bool _idSet = false;

  /// Name of this scheduled plan

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Id of a look

  String get lookId {
    if (!_lookIdSet && _apiMapResponse.containsKey('look_id')) {
      _lookId = _apiMapResponse['look_id']?.toString();
      _lookIdSet = true;
    }
    return _lookId;
  }

  set lookId(String v) {
    _lookId = v;
    _lookIdSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  ContentValidationScheduledPlan() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ContentValidationScheduledPlan.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_lookIdSet || _apiMapResponse.containsKey('look_id')) {
      json['look_id'] = lookId;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    return json;
  }
}

class ContentValidatorError {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  ContentValidationLook _look;
  bool _lookSet = false;

  ContentValidationDashboard _dashboard;
  bool _dashboardSet = false;

  ContentValidationDashboardElement _dashboardElement;
  bool _dashboardElementSet = false;

  ContentValidationDashboardFilter _dashboardFilter;
  bool _dashboardFilterSet = false;

  ContentValidationScheduledPlan _scheduledPlan;
  bool _scheduledPlanSet = false;

  ContentValidationAlert _alert;
  bool _alertSet = false;

  ContentValidationLookMLDashboard _lookmlDashboard;
  bool _lookmlDashboardSet = false;

  ContentValidationLookMLDashboardElement _lookmlDashboardElement;
  bool _lookmlDashboardElementSet = false;

  List<ContentValidationError> _errors;
  bool _errorsSet = false;

  String _id;
  bool _idSet = false;

  ContentValidationLook get look {
    if (!_lookSet && _apiMapResponse.containsKey('look')) {
      _look = _apiMapResponse['look'] == null
          ? null
          : ContentValidationLook.fromResponse(
              _apiMapResponse['look'], apiResponseContentType);
      _lookSet = true;
    }
    return _look;
  }

  set look(ContentValidationLook v) {
    _look = v;
    _lookSet = true;
  }

  ContentValidationDashboard get dashboard {
    if (!_dashboardSet && _apiMapResponse.containsKey('dashboard')) {
      _dashboard = _apiMapResponse['dashboard'] == null
          ? null
          : ContentValidationDashboard.fromResponse(
              _apiMapResponse['dashboard'], apiResponseContentType);
      _dashboardSet = true;
    }
    return _dashboard;
  }

  set dashboard(ContentValidationDashboard v) {
    _dashboard = v;
    _dashboardSet = true;
  }

  ContentValidationDashboardElement get dashboardElement {
    if (!_dashboardElementSet &&
        _apiMapResponse.containsKey('dashboard_element')) {
      _dashboardElement = _apiMapResponse['dashboard_element'] == null
          ? null
          : ContentValidationDashboardElement.fromResponse(
              _apiMapResponse['dashboard_element'], apiResponseContentType);
      _dashboardElementSet = true;
    }
    return _dashboardElement;
  }

  set dashboardElement(ContentValidationDashboardElement v) {
    _dashboardElement = v;
    _dashboardElementSet = true;
  }

  ContentValidationDashboardFilter get dashboardFilter {
    if (!_dashboardFilterSet &&
        _apiMapResponse.containsKey('dashboard_filter')) {
      _dashboardFilter = _apiMapResponse['dashboard_filter'] == null
          ? null
          : ContentValidationDashboardFilter.fromResponse(
              _apiMapResponse['dashboard_filter'], apiResponseContentType);
      _dashboardFilterSet = true;
    }
    return _dashboardFilter;
  }

  set dashboardFilter(ContentValidationDashboardFilter v) {
    _dashboardFilter = v;
    _dashboardFilterSet = true;
  }

  ContentValidationScheduledPlan get scheduledPlan {
    if (!_scheduledPlanSet && _apiMapResponse.containsKey('scheduled_plan')) {
      _scheduledPlan = _apiMapResponse['scheduled_plan'] == null
          ? null
          : ContentValidationScheduledPlan.fromResponse(
              _apiMapResponse['scheduled_plan'], apiResponseContentType);
      _scheduledPlanSet = true;
    }
    return _scheduledPlan;
  }

  set scheduledPlan(ContentValidationScheduledPlan v) {
    _scheduledPlan = v;
    _scheduledPlanSet = true;
  }

  ContentValidationAlert get alert {
    if (!_alertSet && _apiMapResponse.containsKey('alert')) {
      _alert = _apiMapResponse['alert'] == null
          ? null
          : ContentValidationAlert.fromResponse(
              _apiMapResponse['alert'], apiResponseContentType);
      _alertSet = true;
    }
    return _alert;
  }

  set alert(ContentValidationAlert v) {
    _alert = v;
    _alertSet = true;
  }

  ContentValidationLookMLDashboard get lookmlDashboard {
    if (!_lookmlDashboardSet &&
        _apiMapResponse.containsKey('lookml_dashboard')) {
      _lookmlDashboard = _apiMapResponse['lookml_dashboard'] == null
          ? null
          : ContentValidationLookMLDashboard.fromResponse(
              _apiMapResponse['lookml_dashboard'], apiResponseContentType);
      _lookmlDashboardSet = true;
    }
    return _lookmlDashboard;
  }

  set lookmlDashboard(ContentValidationLookMLDashboard v) {
    _lookmlDashboard = v;
    _lookmlDashboardSet = true;
  }

  ContentValidationLookMLDashboardElement get lookmlDashboardElement {
    if (!_lookmlDashboardElementSet &&
        _apiMapResponse.containsKey('lookml_dashboard_element')) {
      _lookmlDashboardElement =
          _apiMapResponse['lookml_dashboard_element'] == null
              ? null
              : ContentValidationLookMLDashboardElement.fromResponse(
                  _apiMapResponse['lookml_dashboard_element'],
                  apiResponseContentType);
      _lookmlDashboardElementSet = true;
    }
    return _lookmlDashboardElement;
  }

  set lookmlDashboardElement(ContentValidationLookMLDashboardElement v) {
    _lookmlDashboardElement = v;
    _lookmlDashboardElementSet = true;
  }

  /// A list of errors found for this piece of content (read-only)

  List<ContentValidationError> get errors {
    if (!_errorsSet && _apiMapResponse.containsKey('errors')) {
      _errors = _apiMapResponse['errors'] == null
          ? null
          : (_apiMapResponse['errors'] as List)
              .map((i) => ContentValidationError.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _errorsSet = true;
    }
    return _errors;
  }

  set errors(List<ContentValidationError> v) {
    _errors = v;
    _errorsSet = true;
  }

  /// An id unique to this piece of content for this validation run (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  ContentValidatorError() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ContentValidatorError.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_lookSet || _apiMapResponse.containsKey('look')) {
      json['look'] = look?.toJson();
    }
    if (_dashboardSet || _apiMapResponse.containsKey('dashboard')) {
      json['dashboard'] = dashboard?.toJson();
    }
    if (_dashboardElementSet ||
        _apiMapResponse.containsKey('dashboard_element')) {
      json['dashboard_element'] = dashboardElement?.toJson();
    }
    if (_dashboardFilterSet ||
        _apiMapResponse.containsKey('dashboard_filter')) {
      json['dashboard_filter'] = dashboardFilter?.toJson();
    }
    if (_scheduledPlanSet || _apiMapResponse.containsKey('scheduled_plan')) {
      json['scheduled_plan'] = scheduledPlan?.toJson();
    }
    if (_alertSet || _apiMapResponse.containsKey('alert')) {
      json['alert'] = alert?.toJson();
    }
    if (_lookmlDashboardSet ||
        _apiMapResponse.containsKey('lookml_dashboard')) {
      json['lookml_dashboard'] = lookmlDashboard?.toJson();
    }
    if (_lookmlDashboardElementSet ||
        _apiMapResponse.containsKey('lookml_dashboard_element')) {
      json['lookml_dashboard_element'] = lookmlDashboardElement?.toJson();
    }
    if (_errorsSet || _apiMapResponse.containsKey('errors')) {
      json['errors'] = errors?.map((i) => i.toJson())?.toList();
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    return json;
  }
}

class ContentView {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _id;
  bool _idSet = false;

  String _lookId;
  bool _lookIdSet = false;

  int _dashboardId;
  bool _dashboardIdSet = false;

  String _title;
  bool _titleSet = false;

  int _contentMetadataId;
  bool _contentMetadataIdSet = false;

  int _userId;
  bool _userIdSet = false;

  int _groupId;
  bool _groupIdSet = false;

  int _viewCount;
  bool _viewCountSet = false;

  int _favoriteCount;
  bool _favoriteCountSet = false;

  String _lastViewedAt;
  bool _lastViewedAtSet = false;

  String _startOfWeekDate;
  bool _startOfWeekDateSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Id of viewed Look (read-only)

  String get lookId {
    if (!_lookIdSet && _apiMapResponse.containsKey('look_id')) {
      _lookId = _apiMapResponse['look_id']?.toString();
      _lookIdSet = true;
    }
    return _lookId;
  }

  set lookId(String v) {
    _lookId = v;
    _lookIdSet = true;
  }

  /// Id of the viewed Dashboard (read-only)

  int get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id'];
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(int v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// Name or title of underlying content (read-only)

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Content metadata id of the Look or Dashboard (read-only)

  int get contentMetadataId {
    if (!_contentMetadataIdSet &&
        _apiMapResponse.containsKey('content_metadata_id')) {
      _contentMetadataId = _apiMapResponse['content_metadata_id'];
      _contentMetadataIdSet = true;
    }
    return _contentMetadataId;
  }

  set contentMetadataId(int v) {
    _contentMetadataId = v;
    _contentMetadataIdSet = true;
  }

  /// Id of user content was viewed by (read-only)

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  /// Id of group content was viewed by (read-only)

  int get groupId {
    if (!_groupIdSet && _apiMapResponse.containsKey('group_id')) {
      _groupId = _apiMapResponse['group_id'];
      _groupIdSet = true;
    }
    return _groupId;
  }

  set groupId(int v) {
    _groupId = v;
    _groupIdSet = true;
  }

  /// Number of times piece of content was viewed (read-only)

  int get viewCount {
    if (!_viewCountSet && _apiMapResponse.containsKey('view_count')) {
      _viewCount = _apiMapResponse['view_count'];
      _viewCountSet = true;
    }
    return _viewCount;
  }

  set viewCount(int v) {
    _viewCount = v;
    _viewCountSet = true;
  }

  /// Number of times piece of content was favorited (read-only)

  int get favoriteCount {
    if (!_favoriteCountSet && _apiMapResponse.containsKey('favorite_count')) {
      _favoriteCount = _apiMapResponse['favorite_count'];
      _favoriteCountSet = true;
    }
    return _favoriteCount;
  }

  set favoriteCount(int v) {
    _favoriteCount = v;
    _favoriteCountSet = true;
  }

  /// Date the piece of content was last viewed (read-only)

  String get lastViewedAt {
    if (!_lastViewedAtSet && _apiMapResponse.containsKey('last_viewed_at')) {
      _lastViewedAt = _apiMapResponse['last_viewed_at']?.toString();
      _lastViewedAtSet = true;
    }
    return _lastViewedAt;
  }

  set lastViewedAt(String v) {
    _lastViewedAt = v;
    _lastViewedAtSet = true;
  }

  /// Week start date for the view and favorite count during that given week (read-only)

  String get startOfWeekDate {
    if (!_startOfWeekDateSet &&
        _apiMapResponse.containsKey('start_of_week_date')) {
      _startOfWeekDate = _apiMapResponse['start_of_week_date']?.toString();
      _startOfWeekDateSet = true;
    }
    return _startOfWeekDate;
  }

  set startOfWeekDate(String v) {
    _startOfWeekDate = v;
    _startOfWeekDateSet = true;
  }

  ContentView() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ContentView.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_lookIdSet || _apiMapResponse.containsKey('look_id')) {
      json['look_id'] = lookId;
    }
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_contentMetadataIdSet ||
        _apiMapResponse.containsKey('content_metadata_id')) {
      json['content_metadata_id'] = contentMetadataId;
    }
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    if (_groupIdSet || _apiMapResponse.containsKey('group_id')) {
      json['group_id'] = groupId;
    }
    if (_viewCountSet || _apiMapResponse.containsKey('view_count')) {
      json['view_count'] = viewCount;
    }
    if (_favoriteCountSet || _apiMapResponse.containsKey('favorite_count')) {
      json['favorite_count'] = favoriteCount;
    }
    if (_lastViewedAtSet || _apiMapResponse.containsKey('last_viewed_at')) {
      json['last_viewed_at'] = lastViewedAt;
    }
    if (_startOfWeekDateSet ||
        _apiMapResponse.containsKey('start_of_week_date')) {
      json['start_of_week_date'] = startOfWeekDate;
    }
    return json;
  }
}

class ContinuousPalette {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _id;
  bool _idSet = false;

  String _label;
  bool _labelSet = false;

  String _type;
  bool _typeSet = false;

  List<ColorStop> _stops;
  bool _stopsSet = false;

  /// Unique identity string (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Label for palette

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// Type of palette

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Array of ColorStops in the palette

  List<ColorStop> get stops {
    if (!_stopsSet && _apiMapResponse.containsKey('stops')) {
      _stops = _apiMapResponse['stops'] == null
          ? null
          : (_apiMapResponse['stops'] as List)
              .map((i) => ColorStop.fromResponse(i, apiResponseContentType))
              .toList();
      _stopsSet = true;
    }
    return _stops;
  }

  set stops(List<ColorStop> v) {
    _stops = v;
    _stopsSet = true;
  }

  ContinuousPalette() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ContinuousPalette.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_stopsSet || _apiMapResponse.containsKey('stops')) {
      json['stops'] = stops?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class CostEstimate {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _cost;
  bool _costSet = false;

  bool _cacheHit;
  bool _cacheHitSet = false;

  String _costUnit;
  bool _costUnitSet = false;

  String _message;
  bool _messageSet = false;

  /// Cost of SQL statement (read-only)

  int get cost {
    if (!_costSet && _apiMapResponse.containsKey('cost')) {
      _cost = _apiMapResponse['cost'];
      _costSet = true;
    }
    return _cost;
  }

  set cost(int v) {
    _cost = v;
    _costSet = true;
  }

  /// Does the result come from the cache? (read-only)

  bool get cacheHit {
    if (!_cacheHitSet && _apiMapResponse.containsKey('cache_hit')) {
      _cacheHit = _apiMapResponse['cache_hit'];
      _cacheHitSet = true;
    }
    return _cacheHit;
  }

  set cacheHit(bool v) {
    _cacheHit = v;
    _cacheHitSet = true;
  }

  /// Cost measurement size (read-only)

  String get costUnit {
    if (!_costUnitSet && _apiMapResponse.containsKey('cost_unit')) {
      _costUnit = _apiMapResponse['cost_unit']?.toString();
      _costUnitSet = true;
    }
    return _costUnit;
  }

  set costUnit(String v) {
    _costUnit = v;
    _costUnitSet = true;
  }

  /// Human-friendly message (read-only)

  String get message {
    if (!_messageSet && _apiMapResponse.containsKey('message')) {
      _message = _apiMapResponse['message']?.toString();
      _messageSet = true;
    }
    return _message;
  }

  set message(String v) {
    _message = v;
    _messageSet = true;
  }

  CostEstimate() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CostEstimate.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_costSet || _apiMapResponse.containsKey('cost')) {
      json['cost'] = cost;
    }
    if (_cacheHitSet || _apiMapResponse.containsKey('cache_hit')) {
      json['cache_hit'] = cacheHit;
    }
    if (_costUnitSet || _apiMapResponse.containsKey('cost_unit')) {
      json['cost_unit'] = costUnit;
    }
    if (_messageSet || _apiMapResponse.containsKey('message')) {
      json['message'] = message;
    }
    return json;
  }
}

/// WARNING: no writeable properties found for POST, PUT, or PATCH
class CreateCostEstimate {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _sql;
  bool _sqlSet = false;

  /// SQL statement to estimate (read-only)

  String get sql {
    if (!_sqlSet && _apiMapResponse.containsKey('sql')) {
      _sql = _apiMapResponse['sql']?.toString();
      _sqlSet = true;
    }
    return _sql;
  }

  set sql(String v) {
    _sql = v;
    _sqlSet = true;
  }

  CreateCostEstimate() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CreateCostEstimate.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_sqlSet || _apiMapResponse.containsKey('sql')) {
      json['sql'] = sql;
    }
    return json;
  }
}

class CreateCredentialsApi3 {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _id;
  bool _idSet = false;

  String _clientId;
  bool _clientIdSet = false;

  String _createdAt;
  bool _createdAtSet = false;

  bool _isDisabled;
  bool _isDisabledSet = false;

  String _type;
  bool _typeSet = false;

  String _clientSecret;
  bool _clientSecretSet = false;

  String _url;
  bool _urlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// API key client_id (read-only)

  String get clientId {
    if (!_clientIdSet && _apiMapResponse.containsKey('client_id')) {
      _clientId = _apiMapResponse['client_id']?.toString();
      _clientIdSet = true;
    }
    return _clientId;
  }

  set clientId(String v) {
    _clientId = v;
    _clientIdSet = true;
  }

  /// Timestamp for the creation of this credential (read-only)

  String get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at']?.toString();
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(String v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// Has this credential been disabled? (read-only)

  bool get isDisabled {
    if (!_isDisabledSet && _apiMapResponse.containsKey('is_disabled')) {
      _isDisabled = _apiMapResponse['is_disabled'];
      _isDisabledSet = true;
    }
    return _isDisabled;
  }

  set isDisabled(bool v) {
    _isDisabled = v;
    _isDisabledSet = true;
  }

  /// Short name for the type of this kind of credential (read-only)

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// API key client_secret (read-only)

  String get clientSecret {
    if (!_clientSecretSet && _apiMapResponse.containsKey('client_secret')) {
      _clientSecret = _apiMapResponse['client_secret']?.toString();
      _clientSecretSet = true;
    }
    return _clientSecret;
  }

  set clientSecret(String v) {
    _clientSecret = v;
    _clientSecretSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  CreateCredentialsApi3() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CreateCredentialsApi3.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_clientIdSet || _apiMapResponse.containsKey('client_id')) {
      json['client_id'] = clientId;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt;
    }
    if (_isDisabledSet || _apiMapResponse.containsKey('is_disabled')) {
      json['is_disabled'] = isDisabled;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_clientSecretSet || _apiMapResponse.containsKey('client_secret')) {
      json['client_secret'] = clientSecret;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class CreateDashboardFilter {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _id;
  bool _idSet = false;

  String _dashboardId;
  bool _dashboardIdSet = false;

  String _name;
  bool _nameSet = false;

  String _title;
  bool _titleSet = false;

  String _type;
  bool _typeSet = false;

  String _defaultValue;
  bool _defaultValueSet = false;

  String _model;
  bool _modelSet = false;

  String _explore;
  bool _exploreSet = false;

  String _dimension;
  bool _dimensionSet = false;

  Map<String, dynamic> _field;
  bool _fieldSet = false;

  int _row;
  bool _rowSet = false;

  List<String> _listensToFilters;
  bool _listensToFiltersSet = false;

  bool _allowMultipleValues;
  bool _allowMultipleValuesSet = false;

  bool _required;
  bool _requiredSet = false;

  Map<String, dynamic> _uiConfig;
  bool _uiConfigSet = false;

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Id of Dashboard

  String get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id']?.toString();
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(String v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// Name of filter

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Title of filter

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Type of filter: one of date, number, string, or field

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Default value of filter

  String get defaultValue {
    if (!_defaultValueSet && _apiMapResponse.containsKey('default_value')) {
      _defaultValue = _apiMapResponse['default_value']?.toString();
      _defaultValueSet = true;
    }
    return _defaultValue;
  }

  set defaultValue(String v) {
    _defaultValue = v;
    _defaultValueSet = true;
  }

  /// Model of filter (required if type = field)

  String get model {
    if (!_modelSet && _apiMapResponse.containsKey('model')) {
      _model = _apiMapResponse['model']?.toString();
      _modelSet = true;
    }
    return _model;
  }

  set model(String v) {
    _model = v;
    _modelSet = true;
  }

  /// Explore of filter (required if type = field)

  String get explore {
    if (!_exploreSet && _apiMapResponse.containsKey('explore')) {
      _explore = _apiMapResponse['explore']?.toString();
      _exploreSet = true;
    }
    return _explore;
  }

  set explore(String v) {
    _explore = v;
    _exploreSet = true;
  }

  /// Dimension of filter (required if type = field)

  String get dimension {
    if (!_dimensionSet && _apiMapResponse.containsKey('dimension')) {
      _dimension = _apiMapResponse['dimension']?.toString();
      _dimensionSet = true;
    }
    return _dimension;
  }

  set dimension(String v) {
    _dimension = v;
    _dimensionSet = true;
  }

  /// Field information (read-only)

  Map<String, dynamic> get field {
    if (!_fieldSet && _apiMapResponse.containsKey('field')) {
      _field = _apiMapResponse['field'];
      _fieldSet = true;
    }
    return _field;
  }

  set field(Map<String, dynamic> v) {
    _field = v;
    _fieldSet = true;
  }

  /// Display order of this filter relative to other filters

  int get row {
    if (!_rowSet && _apiMapResponse.containsKey('row')) {
      _row = _apiMapResponse['row'];
      _rowSet = true;
    }
    return _row;
  }

  set row(int v) {
    _row = v;
    _rowSet = true;
  }

  /// Array of listeners for faceted filters

  List<String> get listensToFilters {
    if (!_listensToFiltersSet &&
        _apiMapResponse.containsKey('listens_to_filters')) {
      _listensToFilters = _apiMapResponse['listens_to_filters']
          ?.map<String>((i) => i as String)
          ?.toList();
      _listensToFiltersSet = true;
    }
    return _listensToFilters;
  }

  set listensToFilters(List<String> v) {
    _listensToFilters = v;
    _listensToFiltersSet = true;
  }

  /// Whether the filter allows multiple filter values (deprecated in the latest version of dashboards)

  bool get allowMultipleValues {
    if (!_allowMultipleValuesSet &&
        _apiMapResponse.containsKey('allow_multiple_values')) {
      _allowMultipleValues = _apiMapResponse['allow_multiple_values'];
      _allowMultipleValuesSet = true;
    }
    return _allowMultipleValues;
  }

  set allowMultipleValues(bool v) {
    _allowMultipleValues = v;
    _allowMultipleValuesSet = true;
  }

  /// Whether the filter requires a value to run the dashboard

  bool get required {
    if (!_requiredSet && _apiMapResponse.containsKey('required')) {
      _required = _apiMapResponse['required'];
      _requiredSet = true;
    }
    return _required;
  }

  set required(bool v) {
    _required = v;
    _requiredSet = true;
  }

  /// The visual configuration for this filter. Used to set up how the UI for this filter should appear.

  Map<String, dynamic> get uiConfig {
    if (!_uiConfigSet && _apiMapResponse.containsKey('ui_config')) {
      _uiConfig = _apiMapResponse['ui_config'];
      _uiConfigSet = true;
    }
    return _uiConfig;
  }

  set uiConfig(Map<String, dynamic> v) {
    _uiConfig = v;
    _uiConfigSet = true;
  }

  CreateDashboardFilter() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CreateDashboardFilter.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_defaultValueSet || _apiMapResponse.containsKey('default_value')) {
      json['default_value'] = defaultValue;
    }
    if (_modelSet || _apiMapResponse.containsKey('model')) {
      json['model'] = model;
    }
    if (_exploreSet || _apiMapResponse.containsKey('explore')) {
      json['explore'] = explore;
    }
    if (_dimensionSet || _apiMapResponse.containsKey('dimension')) {
      json['dimension'] = dimension;
    }
    if (_fieldSet || _apiMapResponse.containsKey('field')) {
      json['field'] = field;
    }
    if (_rowSet || _apiMapResponse.containsKey('row')) {
      json['row'] = row;
    }
    if (_listensToFiltersSet ||
        _apiMapResponse.containsKey('listens_to_filters')) {
      json['listens_to_filters'] = listensToFilters;
    }
    if (_allowMultipleValuesSet ||
        _apiMapResponse.containsKey('allow_multiple_values')) {
      json['allow_multiple_values'] = allowMultipleValues;
    }
    if (_requiredSet || _apiMapResponse.containsKey('required')) {
      json['required'] = required;
    }
    if (_uiConfigSet || _apiMapResponse.containsKey('ui_config')) {
      json['ui_config'] = uiConfig;
    }
    return json;
  }
}

class CreateDashboardRenderTask {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _dashboardFilters;
  bool _dashboardFiltersSet = false;

  String _dashboardStyle;
  bool _dashboardStyleSet = false;

  /// Filter values to apply to the dashboard queries, in URL query format

  String get dashboardFilters {
    if (!_dashboardFiltersSet &&
        _apiMapResponse.containsKey('dashboard_filters')) {
      _dashboardFilters = _apiMapResponse['dashboard_filters']?.toString();
      _dashboardFiltersSet = true;
    }
    return _dashboardFilters;
  }

  set dashboardFilters(String v) {
    _dashboardFilters = v;
    _dashboardFiltersSet = true;
  }

  /// Dashboard layout style: single_column or tiled

  String get dashboardStyle {
    if (!_dashboardStyleSet && _apiMapResponse.containsKey('dashboard_style')) {
      _dashboardStyle = _apiMapResponse['dashboard_style']?.toString();
      _dashboardStyleSet = true;
    }
    return _dashboardStyle;
  }

  set dashboardStyle(String v) {
    _dashboardStyle = v;
    _dashboardStyleSet = true;
  }

  CreateDashboardRenderTask() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CreateDashboardRenderTask.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_dashboardFiltersSet ||
        _apiMapResponse.containsKey('dashboard_filters')) {
      json['dashboard_filters'] = dashboardFilters;
    }
    if (_dashboardStyleSet || _apiMapResponse.containsKey('dashboard_style')) {
      json['dashboard_style'] = dashboardStyle;
    }
    return json;
  }
}

class CreateEmbedUserRequest {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _externalUserId;
  bool _externalUserIdSet = false;

  String get externalUserId {
    if (!_externalUserIdSet &&
        _apiMapResponse.containsKey('external_user_id')) {
      _externalUserId = _apiMapResponse['external_user_id']?.toString();
      _externalUserIdSet = true;
    }
    return _externalUserId;
  }

  set externalUserId(String v) {
    _externalUserId = v;
    _externalUserIdSet = true;
  }

  CreateEmbedUserRequest() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CreateEmbedUserRequest.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_externalUserIdSet || _apiMapResponse.containsKey('external_user_id')) {
      json['external_user_id'] = externalUserId;
    }
    return json;
  }
}

class CreateFolder {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _parentId;
  bool _parentIdSet = false;

  /// Unique Name

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Id of Parent. If the parent id is null, this is a root-level entry

  String get parentId {
    if (!_parentIdSet && _apiMapResponse.containsKey('parent_id')) {
      _parentId = _apiMapResponse['parent_id']?.toString();
      _parentIdSet = true;
    }
    return _parentId;
  }

  set parentId(String v) {
    _parentId = v;
    _parentIdSet = true;
  }

  CreateFolder() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CreateFolder.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_parentIdSet || _apiMapResponse.containsKey('parent_id')) {
      json['parent_id'] = parentId;
    }
    return json;
  }
}

class CreateOAuthApplicationUserStateRequest {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _userId;
  bool _userIdSet = false;

  String _oauthApplicationId;
  bool _oauthApplicationIdSet = false;

  String _accessToken;
  bool _accessTokenSet = false;

  DateTime _accessTokenExpiresAt;
  bool _accessTokenExpiresAtSet = false;

  String _refreshToken;
  bool _refreshTokenSet = false;

  DateTime _refreshTokenExpiresAt;
  bool _refreshTokenExpiresAtSet = false;

  String get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id']?.toString();
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(String v) {
    _userId = v;
    _userIdSet = true;
  }

  String get oauthApplicationId {
    if (!_oauthApplicationIdSet &&
        _apiMapResponse.containsKey('oauth_application_id')) {
      _oauthApplicationId = _apiMapResponse['oauth_application_id']?.toString();
      _oauthApplicationIdSet = true;
    }
    return _oauthApplicationId;
  }

  set oauthApplicationId(String v) {
    _oauthApplicationId = v;
    _oauthApplicationIdSet = true;
  }

  String get accessToken {
    if (!_accessTokenSet && _apiMapResponse.containsKey('access_token')) {
      _accessToken = _apiMapResponse['access_token']?.toString();
      _accessTokenSet = true;
    }
    return _accessToken;
  }

  set accessToken(String v) {
    _accessToken = v;
    _accessTokenSet = true;
  }

  DateTime get accessTokenExpiresAt {
    if (!_accessTokenExpiresAtSet &&
        _apiMapResponse.containsKey('access_token_expires_at')) {
      _accessTokenExpiresAt = _apiMapResponse['access_token_expires_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['access_token_expires_at']);
      _accessTokenExpiresAtSet = true;
    }
    return _accessTokenExpiresAt;
  }

  set accessTokenExpiresAt(DateTime v) {
    _accessTokenExpiresAt = v;
    _accessTokenExpiresAtSet = true;
  }

  String get refreshToken {
    if (!_refreshTokenSet && _apiMapResponse.containsKey('refresh_token')) {
      _refreshToken = _apiMapResponse['refresh_token']?.toString();
      _refreshTokenSet = true;
    }
    return _refreshToken;
  }

  set refreshToken(String v) {
    _refreshToken = v;
    _refreshTokenSet = true;
  }

  DateTime get refreshTokenExpiresAt {
    if (!_refreshTokenExpiresAtSet &&
        _apiMapResponse.containsKey('refresh_token_expires_at')) {
      _refreshTokenExpiresAt =
          _apiMapResponse['refresh_token_expires_at'] == null
              ? null
              : DateTime.parse(_apiMapResponse['refresh_token_expires_at']);
      _refreshTokenExpiresAtSet = true;
    }
    return _refreshTokenExpiresAt;
  }

  set refreshTokenExpiresAt(DateTime v) {
    _refreshTokenExpiresAt = v;
    _refreshTokenExpiresAtSet = true;
  }

  CreateOAuthApplicationUserStateRequest() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CreateOAuthApplicationUserStateRequest.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    if (_oauthApplicationIdSet ||
        _apiMapResponse.containsKey('oauth_application_id')) {
      json['oauth_application_id'] = oauthApplicationId;
    }
    if (_accessTokenSet || _apiMapResponse.containsKey('access_token')) {
      json['access_token'] = accessToken;
    }
    if (_accessTokenExpiresAtSet ||
        _apiMapResponse.containsKey('access_token_expires_at')) {
      json['access_token_expires_at'] = accessTokenExpiresAt?.toIso8601String();
    }
    if (_refreshTokenSet || _apiMapResponse.containsKey('refresh_token')) {
      json['refresh_token'] = refreshToken;
    }
    if (_refreshTokenExpiresAtSet ||
        _apiMapResponse.containsKey('refresh_token_expires_at')) {
      json['refresh_token_expires_at'] =
          refreshTokenExpiresAt?.toIso8601String();
    }
    return json;
  }
}

class CreateOAuthApplicationUserStateResponse {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _userId;
  bool _userIdSet = false;

  int _oauthApplicationId;
  bool _oauthApplicationIdSet = false;

  /// User Id (read-only)

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  /// OAuth Application ID (read-only)

  int get oauthApplicationId {
    if (!_oauthApplicationIdSet &&
        _apiMapResponse.containsKey('oauth_application_id')) {
      _oauthApplicationId = _apiMapResponse['oauth_application_id'];
      _oauthApplicationIdSet = true;
    }
    return _oauthApplicationId;
  }

  set oauthApplicationId(int v) {
    _oauthApplicationId = v;
    _oauthApplicationIdSet = true;
  }

  CreateOAuthApplicationUserStateResponse() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CreateOAuthApplicationUserStateResponse.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    if (_oauthApplicationIdSet ||
        _apiMapResponse.containsKey('oauth_application_id')) {
      json['oauth_application_id'] = oauthApplicationId;
    }
    return json;
  }
}

class CreateQueryTask {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _queryId;
  bool _queryIdSet = false;

  ResultFormat _resultFormat;
  bool _resultFormatSet = false;

  String _source;
  bool _sourceSet = false;

  bool _deferred;
  bool _deferredSet = false;

  String _lookId;
  bool _lookIdSet = false;

  String _dashboardId;
  bool _dashboardIdSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Id of query to run

  int get queryId {
    if (!_queryIdSet && _apiMapResponse.containsKey('query_id')) {
      _queryId = _apiMapResponse['query_id'];
      _queryIdSet = true;
    }
    return _queryId;
  }

  set queryId(int v) {
    _queryId = v;
    _queryIdSet = true;
  }

  /// Desired async query result format. Valid values are: "inline_json", "json", "json_detail", "json_fe", "csv", "html", "md", "txt", "xlsx", "gsxml".

  ResultFormat get resultFormat {
    if (!_resultFormatSet && _apiMapResponse.containsKey('result_format')) {
      _resultFormat =
          ResultFormatMapper.fromStringValue(_apiMapResponse['result_format']);
      _resultFormatSet = true;
    }
    return _resultFormat;
  }

  set resultFormat(ResultFormat v) {
    _resultFormat = v;
    _resultFormatSet = true;
  }

  /// Source of query task

  String get source {
    if (!_sourceSet && _apiMapResponse.containsKey('source')) {
      _source = _apiMapResponse['source']?.toString();
      _sourceSet = true;
    }
    return _source;
  }

  set source(String v) {
    _source = v;
    _sourceSet = true;
  }

  /// Create the task but defer execution

  bool get deferred {
    if (!_deferredSet && _apiMapResponse.containsKey('deferred')) {
      _deferred = _apiMapResponse['deferred'];
      _deferredSet = true;
    }
    return _deferred;
  }

  set deferred(bool v) {
    _deferred = v;
    _deferredSet = true;
  }

  /// Id of look associated with query.

  String get lookId {
    if (!_lookIdSet && _apiMapResponse.containsKey('look_id')) {
      _lookId = _apiMapResponse['look_id']?.toString();
      _lookIdSet = true;
    }
    return _lookId;
  }

  set lookId(String v) {
    _lookId = v;
    _lookIdSet = true;
  }

  /// Id of dashboard associated with query.

  String get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id']?.toString();
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(String v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  CreateQueryTask() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CreateQueryTask.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_queryIdSet || _apiMapResponse.containsKey('query_id')) {
      json['query_id'] = queryId;
    }
    if (_resultFormatSet || _apiMapResponse.containsKey('result_format')) {
      json['result_format'] = ResultFormatMapper.toStringValue(resultFormat);
    }
    if (_sourceSet || _apiMapResponse.containsKey('source')) {
      json['source'] = source;
    }
    if (_deferredSet || _apiMapResponse.containsKey('deferred')) {
      json['deferred'] = deferred;
    }
    if (_lookIdSet || _apiMapResponse.containsKey('look_id')) {
      json['look_id'] = lookId;
    }
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    return json;
  }
}

class CredentialsApi3 {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _id;
  bool _idSet = false;

  String _clientId;
  bool _clientIdSet = false;

  String _createdAt;
  bool _createdAtSet = false;

  bool _isDisabled;
  bool _isDisabledSet = false;

  String _type;
  bool _typeSet = false;

  String _url;
  bool _urlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// API key client_id (read-only)

  String get clientId {
    if (!_clientIdSet && _apiMapResponse.containsKey('client_id')) {
      _clientId = _apiMapResponse['client_id']?.toString();
      _clientIdSet = true;
    }
    return _clientId;
  }

  set clientId(String v) {
    _clientId = v;
    _clientIdSet = true;
  }

  /// Timestamp for the creation of this credential (read-only)

  String get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at']?.toString();
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(String v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// Has this credential been disabled? (read-only)

  bool get isDisabled {
    if (!_isDisabledSet && _apiMapResponse.containsKey('is_disabled')) {
      _isDisabled = _apiMapResponse['is_disabled'];
      _isDisabledSet = true;
    }
    return _isDisabled;
  }

  set isDisabled(bool v) {
    _isDisabled = v;
    _isDisabledSet = true;
  }

  /// Short name for the type of this kind of credential (read-only)

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  CredentialsApi3() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CredentialsApi3.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_clientIdSet || _apiMapResponse.containsKey('client_id')) {
      json['client_id'] = clientId;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt;
    }
    if (_isDisabledSet || _apiMapResponse.containsKey('is_disabled')) {
      json['is_disabled'] = isDisabled;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class CredentialsEmail {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _createdAt;
  bool _createdAtSet = false;

  String _email;
  bool _emailSet = false;

  bool _forcedPasswordResetAtNextLogin;
  bool _forcedPasswordResetAtNextLoginSet = false;

  bool _isDisabled;
  bool _isDisabledSet = false;

  String _loggedInAt;
  bool _loggedInAtSet = false;

  String _passwordResetUrl;
  bool _passwordResetUrlSet = false;

  String _type;
  bool _typeSet = false;

  String _url;
  bool _urlSet = false;

  String _userUrl;
  bool _userUrlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Timestamp for the creation of this credential (read-only)

  String get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at']?.toString();
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(String v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// EMail address used for user login

  String get email {
    if (!_emailSet && _apiMapResponse.containsKey('email')) {
      _email = _apiMapResponse['email']?.toString();
      _emailSet = true;
    }
    return _email;
  }

  set email(String v) {
    _email = v;
    _emailSet = true;
  }

  /// Force the user to change their password upon their next login

  bool get forcedPasswordResetAtNextLogin {
    if (!_forcedPasswordResetAtNextLoginSet &&
        _apiMapResponse.containsKey('forced_password_reset_at_next_login')) {
      _forcedPasswordResetAtNextLogin =
          _apiMapResponse['forced_password_reset_at_next_login'];
      _forcedPasswordResetAtNextLoginSet = true;
    }
    return _forcedPasswordResetAtNextLogin;
  }

  set forcedPasswordResetAtNextLogin(bool v) {
    _forcedPasswordResetAtNextLogin = v;
    _forcedPasswordResetAtNextLoginSet = true;
  }

  /// Has this credential been disabled? (read-only)

  bool get isDisabled {
    if (!_isDisabledSet && _apiMapResponse.containsKey('is_disabled')) {
      _isDisabled = _apiMapResponse['is_disabled'];
      _isDisabledSet = true;
    }
    return _isDisabled;
  }

  set isDisabled(bool v) {
    _isDisabled = v;
    _isDisabledSet = true;
  }

  /// Timestamp for most recent login using credential (read-only)

  String get loggedInAt {
    if (!_loggedInAtSet && _apiMapResponse.containsKey('logged_in_at')) {
      _loggedInAt = _apiMapResponse['logged_in_at']?.toString();
      _loggedInAtSet = true;
    }
    return _loggedInAt;
  }

  set loggedInAt(String v) {
    _loggedInAt = v;
    _loggedInAtSet = true;
  }

  /// Url with one-time use secret token that the user can use to reset password (read-only)

  String get passwordResetUrl {
    if (!_passwordResetUrlSet &&
        _apiMapResponse.containsKey('password_reset_url')) {
      _passwordResetUrl = _apiMapResponse['password_reset_url']?.toString();
      _passwordResetUrlSet = true;
    }
    return _passwordResetUrl;
  }

  set passwordResetUrl(String v) {
    _passwordResetUrl = v;
    _passwordResetUrlSet = true;
  }

  /// Short name for the type of this kind of credential (read-only)

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  /// Link to get this user (read-only)

  String get userUrl {
    if (!_userUrlSet && _apiMapResponse.containsKey('user_url')) {
      _userUrl = _apiMapResponse['user_url']?.toString();
      _userUrlSet = true;
    }
    return _userUrl;
  }

  set userUrl(String v) {
    _userUrl = v;
    _userUrlSet = true;
  }

  CredentialsEmail() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CredentialsEmail.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt;
    }
    if (_emailSet || _apiMapResponse.containsKey('email')) {
      json['email'] = email;
    }
    if (_forcedPasswordResetAtNextLoginSet ||
        _apiMapResponse.containsKey('forced_password_reset_at_next_login')) {
      json['forced_password_reset_at_next_login'] =
          forcedPasswordResetAtNextLogin;
    }
    if (_isDisabledSet || _apiMapResponse.containsKey('is_disabled')) {
      json['is_disabled'] = isDisabled;
    }
    if (_loggedInAtSet || _apiMapResponse.containsKey('logged_in_at')) {
      json['logged_in_at'] = loggedInAt;
    }
    if (_passwordResetUrlSet ||
        _apiMapResponse.containsKey('password_reset_url')) {
      json['password_reset_url'] = passwordResetUrl;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    if (_userUrlSet || _apiMapResponse.containsKey('user_url')) {
      json['user_url'] = userUrl;
    }
    return json;
  }
}

class CredentialsEmailSearch {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _createdAt;
  bool _createdAtSet = false;

  String _email;
  bool _emailSet = false;

  bool _forcedPasswordResetAtNextLogin;
  bool _forcedPasswordResetAtNextLoginSet = false;

  bool _isDisabled;
  bool _isDisabledSet = false;

  String _loggedInAt;
  bool _loggedInAtSet = false;

  String _passwordResetUrl;
  bool _passwordResetUrlSet = false;

  String _type;
  bool _typeSet = false;

  String _url;
  bool _urlSet = false;

  String _userUrl;
  bool _userUrlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Timestamp for the creation of this credential (read-only)

  String get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at']?.toString();
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(String v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// EMail address used for user login

  String get email {
    if (!_emailSet && _apiMapResponse.containsKey('email')) {
      _email = _apiMapResponse['email']?.toString();
      _emailSet = true;
    }
    return _email;
  }

  set email(String v) {
    _email = v;
    _emailSet = true;
  }

  /// Force the user to change their password upon their next login

  bool get forcedPasswordResetAtNextLogin {
    if (!_forcedPasswordResetAtNextLoginSet &&
        _apiMapResponse.containsKey('forced_password_reset_at_next_login')) {
      _forcedPasswordResetAtNextLogin =
          _apiMapResponse['forced_password_reset_at_next_login'];
      _forcedPasswordResetAtNextLoginSet = true;
    }
    return _forcedPasswordResetAtNextLogin;
  }

  set forcedPasswordResetAtNextLogin(bool v) {
    _forcedPasswordResetAtNextLogin = v;
    _forcedPasswordResetAtNextLoginSet = true;
  }

  /// Has this credential been disabled? (read-only)

  bool get isDisabled {
    if (!_isDisabledSet && _apiMapResponse.containsKey('is_disabled')) {
      _isDisabled = _apiMapResponse['is_disabled'];
      _isDisabledSet = true;
    }
    return _isDisabled;
  }

  set isDisabled(bool v) {
    _isDisabled = v;
    _isDisabledSet = true;
  }

  /// Timestamp for most recent login using credential (read-only)

  String get loggedInAt {
    if (!_loggedInAtSet && _apiMapResponse.containsKey('logged_in_at')) {
      _loggedInAt = _apiMapResponse['logged_in_at']?.toString();
      _loggedInAtSet = true;
    }
    return _loggedInAt;
  }

  set loggedInAt(String v) {
    _loggedInAt = v;
    _loggedInAtSet = true;
  }

  /// Url with one-time use secret token that the user can use to reset password (read-only)

  String get passwordResetUrl {
    if (!_passwordResetUrlSet &&
        _apiMapResponse.containsKey('password_reset_url')) {
      _passwordResetUrl = _apiMapResponse['password_reset_url']?.toString();
      _passwordResetUrlSet = true;
    }
    return _passwordResetUrl;
  }

  set passwordResetUrl(String v) {
    _passwordResetUrl = v;
    _passwordResetUrlSet = true;
  }

  /// Short name for the type of this kind of credential (read-only)

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  /// Link to get this user (read-only)

  String get userUrl {
    if (!_userUrlSet && _apiMapResponse.containsKey('user_url')) {
      _userUrl = _apiMapResponse['user_url']?.toString();
      _userUrlSet = true;
    }
    return _userUrl;
  }

  set userUrl(String v) {
    _userUrl = v;
    _userUrlSet = true;
  }

  CredentialsEmailSearch() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CredentialsEmailSearch.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt;
    }
    if (_emailSet || _apiMapResponse.containsKey('email')) {
      json['email'] = email;
    }
    if (_forcedPasswordResetAtNextLoginSet ||
        _apiMapResponse.containsKey('forced_password_reset_at_next_login')) {
      json['forced_password_reset_at_next_login'] =
          forcedPasswordResetAtNextLogin;
    }
    if (_isDisabledSet || _apiMapResponse.containsKey('is_disabled')) {
      json['is_disabled'] = isDisabled;
    }
    if (_loggedInAtSet || _apiMapResponse.containsKey('logged_in_at')) {
      json['logged_in_at'] = loggedInAt;
    }
    if (_passwordResetUrlSet ||
        _apiMapResponse.containsKey('password_reset_url')) {
      json['password_reset_url'] = passwordResetUrl;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    if (_userUrlSet || _apiMapResponse.containsKey('user_url')) {
      json['user_url'] = userUrl;
    }
    return json;
  }
}

class CredentialsEmbed {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _createdAt;
  bool _createdAtSet = false;

  String _externalGroupId;
  bool _externalGroupIdSet = false;

  String _externalUserId;
  bool _externalUserIdSet = false;

  int _id;
  bool _idSet = false;

  bool _isDisabled;
  bool _isDisabledSet = false;

  String _loggedInAt;
  bool _loggedInAtSet = false;

  String _type;
  bool _typeSet = false;

  String _url;
  bool _urlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Timestamp for the creation of this credential (read-only)

  String get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at']?.toString();
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(String v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// Embedder's id for a group to which this user was added during the most recent login (read-only)

  String get externalGroupId {
    if (!_externalGroupIdSet &&
        _apiMapResponse.containsKey('external_group_id')) {
      _externalGroupId = _apiMapResponse['external_group_id']?.toString();
      _externalGroupIdSet = true;
    }
    return _externalGroupId;
  }

  set externalGroupId(String v) {
    _externalGroupId = v;
    _externalGroupIdSet = true;
  }

  /// Embedder's unique id for the user (read-only)

  String get externalUserId {
    if (!_externalUserIdSet &&
        _apiMapResponse.containsKey('external_user_id')) {
      _externalUserId = _apiMapResponse['external_user_id']?.toString();
      _externalUserIdSet = true;
    }
    return _externalUserId;
  }

  set externalUserId(String v) {
    _externalUserId = v;
    _externalUserIdSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Has this credential been disabled? (read-only)

  bool get isDisabled {
    if (!_isDisabledSet && _apiMapResponse.containsKey('is_disabled')) {
      _isDisabled = _apiMapResponse['is_disabled'];
      _isDisabledSet = true;
    }
    return _isDisabled;
  }

  set isDisabled(bool v) {
    _isDisabled = v;
    _isDisabledSet = true;
  }

  /// Timestamp for most recent login using credential (read-only)

  String get loggedInAt {
    if (!_loggedInAtSet && _apiMapResponse.containsKey('logged_in_at')) {
      _loggedInAt = _apiMapResponse['logged_in_at']?.toString();
      _loggedInAtSet = true;
    }
    return _loggedInAt;
  }

  set loggedInAt(String v) {
    _loggedInAt = v;
    _loggedInAtSet = true;
  }

  /// Short name for the type of this kind of credential (read-only)

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  CredentialsEmbed() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CredentialsEmbed.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt;
    }
    if (_externalGroupIdSet ||
        _apiMapResponse.containsKey('external_group_id')) {
      json['external_group_id'] = externalGroupId;
    }
    if (_externalUserIdSet || _apiMapResponse.containsKey('external_user_id')) {
      json['external_user_id'] = externalUserId;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_isDisabledSet || _apiMapResponse.containsKey('is_disabled')) {
      json['is_disabled'] = isDisabled;
    }
    if (_loggedInAtSet || _apiMapResponse.containsKey('logged_in_at')) {
      json['logged_in_at'] = loggedInAt;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class CredentialsGoogle {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _createdAt;
  bool _createdAtSet = false;

  String _domain;
  bool _domainSet = false;

  String _email;
  bool _emailSet = false;

  String _googleUserId;
  bool _googleUserIdSet = false;

  bool _isDisabled;
  bool _isDisabledSet = false;

  String _loggedInAt;
  bool _loggedInAtSet = false;

  String _type;
  bool _typeSet = false;

  String _url;
  bool _urlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Timestamp for the creation of this credential (read-only)

  String get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at']?.toString();
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(String v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// Google domain (read-only)

  String get domain {
    if (!_domainSet && _apiMapResponse.containsKey('domain')) {
      _domain = _apiMapResponse['domain']?.toString();
      _domainSet = true;
    }
    return _domain;
  }

  set domain(String v) {
    _domain = v;
    _domainSet = true;
  }

  /// EMail address (read-only)

  String get email {
    if (!_emailSet && _apiMapResponse.containsKey('email')) {
      _email = _apiMapResponse['email']?.toString();
      _emailSet = true;
    }
    return _email;
  }

  set email(String v) {
    _email = v;
    _emailSet = true;
  }

  /// Google's Unique ID for this user (read-only)

  String get googleUserId {
    if (!_googleUserIdSet && _apiMapResponse.containsKey('google_user_id')) {
      _googleUserId = _apiMapResponse['google_user_id']?.toString();
      _googleUserIdSet = true;
    }
    return _googleUserId;
  }

  set googleUserId(String v) {
    _googleUserId = v;
    _googleUserIdSet = true;
  }

  /// Has this credential been disabled? (read-only)

  bool get isDisabled {
    if (!_isDisabledSet && _apiMapResponse.containsKey('is_disabled')) {
      _isDisabled = _apiMapResponse['is_disabled'];
      _isDisabledSet = true;
    }
    return _isDisabled;
  }

  set isDisabled(bool v) {
    _isDisabled = v;
    _isDisabledSet = true;
  }

  /// Timestamp for most recent login using credential (read-only)

  String get loggedInAt {
    if (!_loggedInAtSet && _apiMapResponse.containsKey('logged_in_at')) {
      _loggedInAt = _apiMapResponse['logged_in_at']?.toString();
      _loggedInAtSet = true;
    }
    return _loggedInAt;
  }

  set loggedInAt(String v) {
    _loggedInAt = v;
    _loggedInAtSet = true;
  }

  /// Short name for the type of this kind of credential (read-only)

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  CredentialsGoogle() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CredentialsGoogle.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt;
    }
    if (_domainSet || _apiMapResponse.containsKey('domain')) {
      json['domain'] = domain;
    }
    if (_emailSet || _apiMapResponse.containsKey('email')) {
      json['email'] = email;
    }
    if (_googleUserIdSet || _apiMapResponse.containsKey('google_user_id')) {
      json['google_user_id'] = googleUserId;
    }
    if (_isDisabledSet || _apiMapResponse.containsKey('is_disabled')) {
      json['is_disabled'] = isDisabled;
    }
    if (_loggedInAtSet || _apiMapResponse.containsKey('logged_in_at')) {
      json['logged_in_at'] = loggedInAt;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class CredentialsLDAP {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _createdAt;
  bool _createdAtSet = false;

  String _email;
  bool _emailSet = false;

  bool _isDisabled;
  bool _isDisabledSet = false;

  String _ldapDn;
  bool _ldapDnSet = false;

  String _ldapId;
  bool _ldapIdSet = false;

  String _loggedInAt;
  bool _loggedInAtSet = false;

  String _type;
  bool _typeSet = false;

  String _url;
  bool _urlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Timestamp for the creation of this credential (read-only)

  String get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at']?.toString();
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(String v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// EMail address (read-only)

  String get email {
    if (!_emailSet && _apiMapResponse.containsKey('email')) {
      _email = _apiMapResponse['email']?.toString();
      _emailSet = true;
    }
    return _email;
  }

  set email(String v) {
    _email = v;
    _emailSet = true;
  }

  /// Has this credential been disabled? (read-only)

  bool get isDisabled {
    if (!_isDisabledSet && _apiMapResponse.containsKey('is_disabled')) {
      _isDisabled = _apiMapResponse['is_disabled'];
      _isDisabledSet = true;
    }
    return _isDisabled;
  }

  set isDisabled(bool v) {
    _isDisabled = v;
    _isDisabledSet = true;
  }

  /// LDAP Distinguished name for this user (as-of the last login) (read-only)

  String get ldapDn {
    if (!_ldapDnSet && _apiMapResponse.containsKey('ldap_dn')) {
      _ldapDn = _apiMapResponse['ldap_dn']?.toString();
      _ldapDnSet = true;
    }
    return _ldapDn;
  }

  set ldapDn(String v) {
    _ldapDn = v;
    _ldapDnSet = true;
  }

  /// LDAP Unique ID for this user (read-only)

  String get ldapId {
    if (!_ldapIdSet && _apiMapResponse.containsKey('ldap_id')) {
      _ldapId = _apiMapResponse['ldap_id']?.toString();
      _ldapIdSet = true;
    }
    return _ldapId;
  }

  set ldapId(String v) {
    _ldapId = v;
    _ldapIdSet = true;
  }

  /// Timestamp for most recent login using credential (read-only)

  String get loggedInAt {
    if (!_loggedInAtSet && _apiMapResponse.containsKey('logged_in_at')) {
      _loggedInAt = _apiMapResponse['logged_in_at']?.toString();
      _loggedInAtSet = true;
    }
    return _loggedInAt;
  }

  set loggedInAt(String v) {
    _loggedInAt = v;
    _loggedInAtSet = true;
  }

  /// Short name for the type of this kind of credential (read-only)

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  CredentialsLDAP() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CredentialsLDAP.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt;
    }
    if (_emailSet || _apiMapResponse.containsKey('email')) {
      json['email'] = email;
    }
    if (_isDisabledSet || _apiMapResponse.containsKey('is_disabled')) {
      json['is_disabled'] = isDisabled;
    }
    if (_ldapDnSet || _apiMapResponse.containsKey('ldap_dn')) {
      json['ldap_dn'] = ldapDn;
    }
    if (_ldapIdSet || _apiMapResponse.containsKey('ldap_id')) {
      json['ldap_id'] = ldapId;
    }
    if (_loggedInAtSet || _apiMapResponse.containsKey('logged_in_at')) {
      json['logged_in_at'] = loggedInAt;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class CredentialsLookerOpenid {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _createdAt;
  bool _createdAtSet = false;

  String _email;
  bool _emailSet = false;

  bool _isDisabled;
  bool _isDisabledSet = false;

  String _loggedInAt;
  bool _loggedInAtSet = false;

  String _loggedInIp;
  bool _loggedInIpSet = false;

  String _type;
  bool _typeSet = false;

  String _url;
  bool _urlSet = false;

  String _userUrl;
  bool _userUrlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Timestamp for the creation of this credential (read-only)

  String get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at']?.toString();
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(String v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// EMail address used for user login (read-only)

  String get email {
    if (!_emailSet && _apiMapResponse.containsKey('email')) {
      _email = _apiMapResponse['email']?.toString();
      _emailSet = true;
    }
    return _email;
  }

  set email(String v) {
    _email = v;
    _emailSet = true;
  }

  /// Has this credential been disabled? (read-only)

  bool get isDisabled {
    if (!_isDisabledSet && _apiMapResponse.containsKey('is_disabled')) {
      _isDisabled = _apiMapResponse['is_disabled'];
      _isDisabledSet = true;
    }
    return _isDisabled;
  }

  set isDisabled(bool v) {
    _isDisabled = v;
    _isDisabledSet = true;
  }

  /// Timestamp for most recent login using credential (read-only)

  String get loggedInAt {
    if (!_loggedInAtSet && _apiMapResponse.containsKey('logged_in_at')) {
      _loggedInAt = _apiMapResponse['logged_in_at']?.toString();
      _loggedInAtSet = true;
    }
    return _loggedInAt;
  }

  set loggedInAt(String v) {
    _loggedInAt = v;
    _loggedInAtSet = true;
  }

  /// IP address of client for most recent login using credential (read-only)

  String get loggedInIp {
    if (!_loggedInIpSet && _apiMapResponse.containsKey('logged_in_ip')) {
      _loggedInIp = _apiMapResponse['logged_in_ip']?.toString();
      _loggedInIpSet = true;
    }
    return _loggedInIp;
  }

  set loggedInIp(String v) {
    _loggedInIp = v;
    _loggedInIpSet = true;
  }

  /// Short name for the type of this kind of credential (read-only)

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  /// Link to get this user (read-only)

  String get userUrl {
    if (!_userUrlSet && _apiMapResponse.containsKey('user_url')) {
      _userUrl = _apiMapResponse['user_url']?.toString();
      _userUrlSet = true;
    }
    return _userUrl;
  }

  set userUrl(String v) {
    _userUrl = v;
    _userUrlSet = true;
  }

  CredentialsLookerOpenid() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CredentialsLookerOpenid.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt;
    }
    if (_emailSet || _apiMapResponse.containsKey('email')) {
      json['email'] = email;
    }
    if (_isDisabledSet || _apiMapResponse.containsKey('is_disabled')) {
      json['is_disabled'] = isDisabled;
    }
    if (_loggedInAtSet || _apiMapResponse.containsKey('logged_in_at')) {
      json['logged_in_at'] = loggedInAt;
    }
    if (_loggedInIpSet || _apiMapResponse.containsKey('logged_in_ip')) {
      json['logged_in_ip'] = loggedInIp;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    if (_userUrlSet || _apiMapResponse.containsKey('user_url')) {
      json['user_url'] = userUrl;
    }
    return json;
  }
}

class CredentialsOIDC {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _createdAt;
  bool _createdAtSet = false;

  String _email;
  bool _emailSet = false;

  bool _isDisabled;
  bool _isDisabledSet = false;

  String _loggedInAt;
  bool _loggedInAtSet = false;

  String _oidcUserId;
  bool _oidcUserIdSet = false;

  String _type;
  bool _typeSet = false;

  String _url;
  bool _urlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Timestamp for the creation of this credential (read-only)

  String get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at']?.toString();
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(String v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// EMail address (read-only)

  String get email {
    if (!_emailSet && _apiMapResponse.containsKey('email')) {
      _email = _apiMapResponse['email']?.toString();
      _emailSet = true;
    }
    return _email;
  }

  set email(String v) {
    _email = v;
    _emailSet = true;
  }

  /// Has this credential been disabled? (read-only)

  bool get isDisabled {
    if (!_isDisabledSet && _apiMapResponse.containsKey('is_disabled')) {
      _isDisabled = _apiMapResponse['is_disabled'];
      _isDisabledSet = true;
    }
    return _isDisabled;
  }

  set isDisabled(bool v) {
    _isDisabled = v;
    _isDisabledSet = true;
  }

  /// Timestamp for most recent login using credential (read-only)

  String get loggedInAt {
    if (!_loggedInAtSet && _apiMapResponse.containsKey('logged_in_at')) {
      _loggedInAt = _apiMapResponse['logged_in_at']?.toString();
      _loggedInAtSet = true;
    }
    return _loggedInAt;
  }

  set loggedInAt(String v) {
    _loggedInAt = v;
    _loggedInAtSet = true;
  }

  /// OIDC OP's Unique ID for this user (read-only)

  String get oidcUserId {
    if (!_oidcUserIdSet && _apiMapResponse.containsKey('oidc_user_id')) {
      _oidcUserId = _apiMapResponse['oidc_user_id']?.toString();
      _oidcUserIdSet = true;
    }
    return _oidcUserId;
  }

  set oidcUserId(String v) {
    _oidcUserId = v;
    _oidcUserIdSet = true;
  }

  /// Short name for the type of this kind of credential (read-only)

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  CredentialsOIDC() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CredentialsOIDC.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt;
    }
    if (_emailSet || _apiMapResponse.containsKey('email')) {
      json['email'] = email;
    }
    if (_isDisabledSet || _apiMapResponse.containsKey('is_disabled')) {
      json['is_disabled'] = isDisabled;
    }
    if (_loggedInAtSet || _apiMapResponse.containsKey('logged_in_at')) {
      json['logged_in_at'] = loggedInAt;
    }
    if (_oidcUserIdSet || _apiMapResponse.containsKey('oidc_user_id')) {
      json['oidc_user_id'] = oidcUserId;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class CredentialsSaml {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _createdAt;
  bool _createdAtSet = false;

  String _email;
  bool _emailSet = false;

  bool _isDisabled;
  bool _isDisabledSet = false;

  String _loggedInAt;
  bool _loggedInAtSet = false;

  String _samlUserId;
  bool _samlUserIdSet = false;

  String _type;
  bool _typeSet = false;

  String _url;
  bool _urlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Timestamp for the creation of this credential (read-only)

  String get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at']?.toString();
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(String v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// EMail address (read-only)

  String get email {
    if (!_emailSet && _apiMapResponse.containsKey('email')) {
      _email = _apiMapResponse['email']?.toString();
      _emailSet = true;
    }
    return _email;
  }

  set email(String v) {
    _email = v;
    _emailSet = true;
  }

  /// Has this credential been disabled? (read-only)

  bool get isDisabled {
    if (!_isDisabledSet && _apiMapResponse.containsKey('is_disabled')) {
      _isDisabled = _apiMapResponse['is_disabled'];
      _isDisabledSet = true;
    }
    return _isDisabled;
  }

  set isDisabled(bool v) {
    _isDisabled = v;
    _isDisabledSet = true;
  }

  /// Timestamp for most recent login using credential (read-only)

  String get loggedInAt {
    if (!_loggedInAtSet && _apiMapResponse.containsKey('logged_in_at')) {
      _loggedInAt = _apiMapResponse['logged_in_at']?.toString();
      _loggedInAtSet = true;
    }
    return _loggedInAt;
  }

  set loggedInAt(String v) {
    _loggedInAt = v;
    _loggedInAtSet = true;
  }

  /// Saml IdP's Unique ID for this user (read-only)

  String get samlUserId {
    if (!_samlUserIdSet && _apiMapResponse.containsKey('saml_user_id')) {
      _samlUserId = _apiMapResponse['saml_user_id']?.toString();
      _samlUserIdSet = true;
    }
    return _samlUserId;
  }

  set samlUserId(String v) {
    _samlUserId = v;
    _samlUserIdSet = true;
  }

  /// Short name for the type of this kind of credential (read-only)

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  CredentialsSaml() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CredentialsSaml.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt;
    }
    if (_emailSet || _apiMapResponse.containsKey('email')) {
      json['email'] = email;
    }
    if (_isDisabledSet || _apiMapResponse.containsKey('is_disabled')) {
      json['is_disabled'] = isDisabled;
    }
    if (_loggedInAtSet || _apiMapResponse.containsKey('logged_in_at')) {
      json['logged_in_at'] = loggedInAt;
    }
    if (_samlUserIdSet || _apiMapResponse.containsKey('saml_user_id')) {
      json['saml_user_id'] = samlUserId;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

/// WARNING: no writeable properties found for POST, PUT, or PATCH
class CredentialsTotp {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _createdAt;
  bool _createdAtSet = false;

  bool _isDisabled;
  bool _isDisabledSet = false;

  String _type;
  bool _typeSet = false;

  bool _verified;
  bool _verifiedSet = false;

  String _url;
  bool _urlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Timestamp for the creation of this credential (read-only)

  String get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at']?.toString();
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(String v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// Has this credential been disabled? (read-only)

  bool get isDisabled {
    if (!_isDisabledSet && _apiMapResponse.containsKey('is_disabled')) {
      _isDisabled = _apiMapResponse['is_disabled'];
      _isDisabledSet = true;
    }
    return _isDisabled;
  }

  set isDisabled(bool v) {
    _isDisabled = v;
    _isDisabledSet = true;
  }

  /// Short name for the type of this kind of credential (read-only)

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// User has verified (read-only)

  bool get verified {
    if (!_verifiedSet && _apiMapResponse.containsKey('verified')) {
      _verified = _apiMapResponse['verified'];
      _verifiedSet = true;
    }
    return _verified;
  }

  set verified(bool v) {
    _verified = v;
    _verifiedSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  CredentialsTotp() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CredentialsTotp.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt;
    }
    if (_isDisabledSet || _apiMapResponse.containsKey('is_disabled')) {
      json['is_disabled'] = isDisabled;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_verifiedSet || _apiMapResponse.containsKey('verified')) {
      json['verified'] = verified;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class CustomWelcomeEmail {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _enabled;
  bool _enabledSet = false;

  String _content;
  bool _contentSet = false;

  String _subject;
  bool _subjectSet = false;

  String _header;
  bool _headerSet = false;

  /// If true, custom email content will replace the default body of welcome emails

  bool get enabled {
    if (!_enabledSet && _apiMapResponse.containsKey('enabled')) {
      _enabled = _apiMapResponse['enabled'];
      _enabledSet = true;
    }
    return _enabled;
  }

  set enabled(bool v) {
    _enabled = v;
    _enabledSet = true;
  }

  /// The HTML to use as custom content for welcome emails. Script elements and other potentially dangerous markup will be removed.

  String get content {
    if (!_contentSet && _apiMapResponse.containsKey('content')) {
      _content = _apiMapResponse['content']?.toString();
      _contentSet = true;
    }
    return _content;
  }

  set content(String v) {
    _content = v;
    _contentSet = true;
  }

  /// The text to appear in the email subject line. Only available with a whitelabel license and whitelabel_configuration.advanced_custom_welcome_email enabled.

  String get subject {
    if (!_subjectSet && _apiMapResponse.containsKey('subject')) {
      _subject = _apiMapResponse['subject']?.toString();
      _subjectSet = true;
    }
    return _subject;
  }

  set subject(String v) {
    _subject = v;
    _subjectSet = true;
  }

  /// The text to appear in the header line of the email body. Only available with a whitelabel license and whitelabel_configuration.advanced_custom_welcome_email enabled.

  String get header {
    if (!_headerSet && _apiMapResponse.containsKey('header')) {
      _header = _apiMapResponse['header']?.toString();
      _headerSet = true;
    }
    return _header;
  }

  set header(String v) {
    _header = v;
    _headerSet = true;
  }

  CustomWelcomeEmail() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  CustomWelcomeEmail.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_enabledSet || _apiMapResponse.containsKey('enabled')) {
      json['enabled'] = enabled;
    }
    if (_contentSet || _apiMapResponse.containsKey('content')) {
      json['content'] = content;
    }
    if (_subjectSet || _apiMapResponse.containsKey('subject')) {
      json['subject'] = subject;
    }
    if (_headerSet || _apiMapResponse.containsKey('header')) {
      json['header'] = header;
    }
    return json;
  }
}

class Dashboard {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _contentFavoriteId;
  bool _contentFavoriteIdSet = false;

  int _contentMetadataId;
  bool _contentMetadataIdSet = false;

  String _description;
  bool _descriptionSet = false;

  bool _hidden;
  bool _hiddenSet = false;

  String _id;
  bool _idSet = false;

  LookModel _model;
  bool _modelSet = false;

  String _queryTimezone;
  bool _queryTimezoneSet = false;

  bool _readonly;
  bool _readonlySet = false;

  String _refreshInterval;
  bool _refreshIntervalSet = false;

  int _refreshIntervalToI;
  bool _refreshIntervalToISet = false;

  FolderBase _folder;
  bool _folderSet = false;

  String _title;
  bool _titleSet = false;

  int _userId;
  bool _userIdSet = false;

  String _slug;
  bool _slugSet = false;

  String _preferredViewer;
  bool _preferredViewerSet = false;

  bool _alertSyncWithDashboardFilterEnabled;
  bool _alertSyncWithDashboardFilterEnabledSet = false;

  String _backgroundColor;
  bool _backgroundColorSet = false;

  DateTime _createdAt;
  bool _createdAtSet = false;

  bool _crossfilterEnabled;
  bool _crossfilterEnabledSet = false;

  List<DashboardElement> _dashboardElements;
  bool _dashboardElementsSet = false;

  List<DashboardFilter> _dashboardFilters;
  bool _dashboardFiltersSet = false;

  List<DashboardLayout> _dashboardLayouts;
  bool _dashboardLayoutsSet = false;

  bool _deleted;
  bool _deletedSet = false;

  DateTime _deletedAt;
  bool _deletedAtSet = false;

  int _deleterId;
  bool _deleterIdSet = false;

  String _editUri;
  bool _editUriSet = false;

  int _favoriteCount;
  bool _favoriteCountSet = false;

  bool _filtersBarCollapsed;
  bool _filtersBarCollapsedSet = false;

  DateTime _lastAccessedAt;
  bool _lastAccessedAtSet = false;

  DateTime _lastViewedAt;
  bool _lastViewedAtSet = false;

  DateTime _updatedAt;
  bool _updatedAtSet = false;

  int _lastUpdaterId;
  bool _lastUpdaterIdSet = false;

  String _lastUpdaterName;
  bool _lastUpdaterNameSet = false;

  String _userName;
  bool _userNameSet = false;

  String _loadConfiguration;
  bool _loadConfigurationSet = false;

  String _lookmlLinkId;
  bool _lookmlLinkIdSet = false;

  bool _showFiltersBar;
  bool _showFiltersBarSet = false;

  bool _showTitle;
  bool _showTitleSet = false;

  String _folderId;
  bool _folderIdSet = false;

  String _textTileTextColor;
  bool _textTileTextColorSet = false;

  String _tileBackgroundColor;
  bool _tileBackgroundColorSet = false;

  String _tileTextColor;
  bool _tileTextColorSet = false;

  String _titleColor;
  bool _titleColorSet = false;

  int _viewCount;
  bool _viewCountSet = false;

  DashboardAppearance _appearance;
  bool _appearanceSet = false;

  String _url;
  bool _urlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Content Favorite Id (read-only)

  int get contentFavoriteId {
    if (!_contentFavoriteIdSet &&
        _apiMapResponse.containsKey('content_favorite_id')) {
      _contentFavoriteId = _apiMapResponse['content_favorite_id'];
      _contentFavoriteIdSet = true;
    }
    return _contentFavoriteId;
  }

  set contentFavoriteId(int v) {
    _contentFavoriteId = v;
    _contentFavoriteIdSet = true;
  }

  /// Id of content metadata (read-only)

  int get contentMetadataId {
    if (!_contentMetadataIdSet &&
        _apiMapResponse.containsKey('content_metadata_id')) {
      _contentMetadataId = _apiMapResponse['content_metadata_id'];
      _contentMetadataIdSet = true;
    }
    return _contentMetadataId;
  }

  set contentMetadataId(int v) {
    _contentMetadataId = v;
    _contentMetadataIdSet = true;
  }

  /// Description

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Is Hidden

  bool get hidden {
    if (!_hiddenSet && _apiMapResponse.containsKey('hidden')) {
      _hidden = _apiMapResponse['hidden'];
      _hiddenSet = true;
    }
    return _hidden;
  }

  set hidden(bool v) {
    _hidden = v;
    _hiddenSet = true;
  }

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  LookModel get model {
    if (!_modelSet && _apiMapResponse.containsKey('model')) {
      _model = _apiMapResponse['model'] == null
          ? null
          : LookModel.fromResponse(
              _apiMapResponse['model'], apiResponseContentType);
      _modelSet = true;
    }
    return _model;
  }

  set model(LookModel v) {
    _model = v;
    _modelSet = true;
  }

  /// Timezone in which the Dashboard will run by default.

  String get queryTimezone {
    if (!_queryTimezoneSet && _apiMapResponse.containsKey('query_timezone')) {
      _queryTimezone = _apiMapResponse['query_timezone']?.toString();
      _queryTimezoneSet = true;
    }
    return _queryTimezone;
  }

  set queryTimezone(String v) {
    _queryTimezone = v;
    _queryTimezoneSet = true;
  }

  /// Is Read-only (read-only)

  bool get readonly {
    if (!_readonlySet && _apiMapResponse.containsKey('readonly')) {
      _readonly = _apiMapResponse['readonly'];
      _readonlySet = true;
    }
    return _readonly;
  }

  set readonly(bool v) {
    _readonly = v;
    _readonlySet = true;
  }

  /// Refresh Interval, as a time duration phrase like "2 hours 30 minutes". A number with no time units will be interpreted as whole seconds.

  String get refreshInterval {
    if (!_refreshIntervalSet &&
        _apiMapResponse.containsKey('refresh_interval')) {
      _refreshInterval = _apiMapResponse['refresh_interval']?.toString();
      _refreshIntervalSet = true;
    }
    return _refreshInterval;
  }

  set refreshInterval(String v) {
    _refreshInterval = v;
    _refreshIntervalSet = true;
  }

  /// Refresh Interval in milliseconds (read-only)

  int get refreshIntervalToI {
    if (!_refreshIntervalToISet &&
        _apiMapResponse.containsKey('refresh_interval_to_i')) {
      _refreshIntervalToI = _apiMapResponse['refresh_interval_to_i'];
      _refreshIntervalToISet = true;
    }
    return _refreshIntervalToI;
  }

  set refreshIntervalToI(int v) {
    _refreshIntervalToI = v;
    _refreshIntervalToISet = true;
  }

  FolderBase get folder {
    if (!_folderSet && _apiMapResponse.containsKey('folder')) {
      _folder = _apiMapResponse['folder'] == null
          ? null
          : FolderBase.fromResponse(
              _apiMapResponse['folder'], apiResponseContentType);
      _folderSet = true;
    }
    return _folder;
  }

  set folder(FolderBase v) {
    _folder = v;
    _folderSet = true;
  }

  /// Dashboard Title

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Id of User (read-only)

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  /// Content Metadata Slug

  String get slug {
    if (!_slugSet && _apiMapResponse.containsKey('slug')) {
      _slug = _apiMapResponse['slug']?.toString();
      _slugSet = true;
    }
    return _slug;
  }

  set slug(String v) {
    _slug = v;
    _slugSet = true;
  }

  /// The preferred route for viewing this dashboard (ie: dashboards or dashboards-next)

  String get preferredViewer {
    if (!_preferredViewerSet &&
        _apiMapResponse.containsKey('preferred_viewer')) {
      _preferredViewer = _apiMapResponse['preferred_viewer']?.toString();
      _preferredViewerSet = true;
    }
    return _preferredViewer;
  }

  set preferredViewer(String v) {
    _preferredViewer = v;
    _preferredViewerSet = true;
  }

  /// Enables alerts to keep in sync with dashboard filter changes

  bool get alertSyncWithDashboardFilterEnabled {
    if (!_alertSyncWithDashboardFilterEnabledSet &&
        _apiMapResponse
            .containsKey('alert_sync_with_dashboard_filter_enabled')) {
      _alertSyncWithDashboardFilterEnabled =
          _apiMapResponse['alert_sync_with_dashboard_filter_enabled'];
      _alertSyncWithDashboardFilterEnabledSet = true;
    }
    return _alertSyncWithDashboardFilterEnabled;
  }

  set alertSyncWithDashboardFilterEnabled(bool v) {
    _alertSyncWithDashboardFilterEnabled = v;
    _alertSyncWithDashboardFilterEnabledSet = true;
  }

  /// Background color

  String get backgroundColor {
    if (!_backgroundColorSet &&
        _apiMapResponse.containsKey('background_color')) {
      _backgroundColor = _apiMapResponse['background_color']?.toString();
      _backgroundColorSet = true;
    }
    return _backgroundColor;
  }

  set backgroundColor(String v) {
    _backgroundColor = v;
    _backgroundColorSet = true;
  }

  /// Time that the Dashboard was created. (read-only)

  DateTime get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['created_at']);
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(DateTime v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// Enables crossfiltering in dashboards - only available in dashboards-next (beta)

  bool get crossfilterEnabled {
    if (!_crossfilterEnabledSet &&
        _apiMapResponse.containsKey('crossfilter_enabled')) {
      _crossfilterEnabled = _apiMapResponse['crossfilter_enabled'];
      _crossfilterEnabledSet = true;
    }
    return _crossfilterEnabled;
  }

  set crossfilterEnabled(bool v) {
    _crossfilterEnabled = v;
    _crossfilterEnabledSet = true;
  }

  /// Elements (read-only)

  List<DashboardElement> get dashboardElements {
    if (!_dashboardElementsSet &&
        _apiMapResponse.containsKey('dashboard_elements')) {
      _dashboardElements = _apiMapResponse['dashboard_elements'] == null
          ? null
          : (_apiMapResponse['dashboard_elements'] as List)
              .map((i) =>
                  DashboardElement.fromResponse(i, apiResponseContentType))
              .toList();
      _dashboardElementsSet = true;
    }
    return _dashboardElements;
  }

  set dashboardElements(List<DashboardElement> v) {
    _dashboardElements = v;
    _dashboardElementsSet = true;
  }

  /// Filters (read-only)

  List<DashboardFilter> get dashboardFilters {
    if (!_dashboardFiltersSet &&
        _apiMapResponse.containsKey('dashboard_filters')) {
      _dashboardFilters = _apiMapResponse['dashboard_filters'] == null
          ? null
          : (_apiMapResponse['dashboard_filters'] as List)
              .map((i) =>
                  DashboardFilter.fromResponse(i, apiResponseContentType))
              .toList();
      _dashboardFiltersSet = true;
    }
    return _dashboardFilters;
  }

  set dashboardFilters(List<DashboardFilter> v) {
    _dashboardFilters = v;
    _dashboardFiltersSet = true;
  }

  /// Layouts (read-only)

  List<DashboardLayout> get dashboardLayouts {
    if (!_dashboardLayoutsSet &&
        _apiMapResponse.containsKey('dashboard_layouts')) {
      _dashboardLayouts = _apiMapResponse['dashboard_layouts'] == null
          ? null
          : (_apiMapResponse['dashboard_layouts'] as List)
              .map((i) =>
                  DashboardLayout.fromResponse(i, apiResponseContentType))
              .toList();
      _dashboardLayoutsSet = true;
    }
    return _dashboardLayouts;
  }

  set dashboardLayouts(List<DashboardLayout> v) {
    _dashboardLayouts = v;
    _dashboardLayoutsSet = true;
  }

  /// Whether or not a dashboard is 'soft' deleted.

  bool get deleted {
    if (!_deletedSet && _apiMapResponse.containsKey('deleted')) {
      _deleted = _apiMapResponse['deleted'];
      _deletedSet = true;
    }
    return _deleted;
  }

  set deleted(bool v) {
    _deleted = v;
    _deletedSet = true;
  }

  /// Time that the Dashboard was 'soft' deleted. (read-only)

  DateTime get deletedAt {
    if (!_deletedAtSet && _apiMapResponse.containsKey('deleted_at')) {
      _deletedAt = _apiMapResponse['deleted_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['deleted_at']);
      _deletedAtSet = true;
    }
    return _deletedAt;
  }

  set deletedAt(DateTime v) {
    _deletedAt = v;
    _deletedAtSet = true;
  }

  /// Id of User that 'soft' deleted the dashboard. (read-only)

  int get deleterId {
    if (!_deleterIdSet && _apiMapResponse.containsKey('deleter_id')) {
      _deleterId = _apiMapResponse['deleter_id'];
      _deleterIdSet = true;
    }
    return _deleterId;
  }

  set deleterId(int v) {
    _deleterId = v;
    _deleterIdSet = true;
  }

  /// Relative path of URI of LookML file to edit the dashboard (LookML dashboard only). (read-only)

  String get editUri {
    if (!_editUriSet && _apiMapResponse.containsKey('edit_uri')) {
      _editUri = _apiMapResponse['edit_uri']?.toString();
      _editUriSet = true;
    }
    return _editUri;
  }

  set editUri(String v) {
    _editUri = v;
    _editUriSet = true;
  }

  /// Number of times favorited (read-only)

  int get favoriteCount {
    if (!_favoriteCountSet && _apiMapResponse.containsKey('favorite_count')) {
      _favoriteCount = _apiMapResponse['favorite_count'];
      _favoriteCountSet = true;
    }
    return _favoriteCount;
  }

  set favoriteCount(int v) {
    _favoriteCount = v;
    _favoriteCountSet = true;
  }

  /// Sets the default state of the filters bar to collapsed or open

  bool get filtersBarCollapsed {
    if (!_filtersBarCollapsedSet &&
        _apiMapResponse.containsKey('filters_bar_collapsed')) {
      _filtersBarCollapsed = _apiMapResponse['filters_bar_collapsed'];
      _filtersBarCollapsedSet = true;
    }
    return _filtersBarCollapsed;
  }

  set filtersBarCollapsed(bool v) {
    _filtersBarCollapsed = v;
    _filtersBarCollapsedSet = true;
  }

  /// Time the dashboard was last accessed (read-only)

  DateTime get lastAccessedAt {
    if (!_lastAccessedAtSet &&
        _apiMapResponse.containsKey('last_accessed_at')) {
      _lastAccessedAt = _apiMapResponse['last_accessed_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['last_accessed_at']);
      _lastAccessedAtSet = true;
    }
    return _lastAccessedAt;
  }

  set lastAccessedAt(DateTime v) {
    _lastAccessedAt = v;
    _lastAccessedAtSet = true;
  }

  /// Time last viewed in the Looker web UI (read-only)

  DateTime get lastViewedAt {
    if (!_lastViewedAtSet && _apiMapResponse.containsKey('last_viewed_at')) {
      _lastViewedAt = _apiMapResponse['last_viewed_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['last_viewed_at']);
      _lastViewedAtSet = true;
    }
    return _lastViewedAt;
  }

  set lastViewedAt(DateTime v) {
    _lastViewedAt = v;
    _lastViewedAtSet = true;
  }

  /// Time that the Dashboard was most recently updated. (read-only)

  DateTime get updatedAt {
    if (!_updatedAtSet && _apiMapResponse.containsKey('updated_at')) {
      _updatedAt = _apiMapResponse['updated_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['updated_at']);
      _updatedAtSet = true;
    }
    return _updatedAt;
  }

  set updatedAt(DateTime v) {
    _updatedAt = v;
    _updatedAtSet = true;
  }

  /// Id of User that most recently updated the dashboard. (read-only)

  int get lastUpdaterId {
    if (!_lastUpdaterIdSet && _apiMapResponse.containsKey('last_updater_id')) {
      _lastUpdaterId = _apiMapResponse['last_updater_id'];
      _lastUpdaterIdSet = true;
    }
    return _lastUpdaterId;
  }

  set lastUpdaterId(int v) {
    _lastUpdaterId = v;
    _lastUpdaterIdSet = true;
  }

  /// Name of User that most recently updated the dashboard. (read-only)

  String get lastUpdaterName {
    if (!_lastUpdaterNameSet &&
        _apiMapResponse.containsKey('last_updater_name')) {
      _lastUpdaterName = _apiMapResponse['last_updater_name']?.toString();
      _lastUpdaterNameSet = true;
    }
    return _lastUpdaterName;
  }

  set lastUpdaterName(String v) {
    _lastUpdaterName = v;
    _lastUpdaterNameSet = true;
  }

  /// Name of User that created the dashboard. (read-only)

  String get userName {
    if (!_userNameSet && _apiMapResponse.containsKey('user_name')) {
      _userName = _apiMapResponse['user_name']?.toString();
      _userNameSet = true;
    }
    return _userName;
  }

  set userName(String v) {
    _userName = v;
    _userNameSet = true;
  }

  /// configuration option that governs how dashboard loading will happen.

  String get loadConfiguration {
    if (!_loadConfigurationSet &&
        _apiMapResponse.containsKey('load_configuration')) {
      _loadConfiguration = _apiMapResponse['load_configuration']?.toString();
      _loadConfigurationSet = true;
    }
    return _loadConfiguration;
  }

  set loadConfiguration(String v) {
    _loadConfiguration = v;
    _loadConfigurationSet = true;
  }

  /// Links this dashboard to a particular LookML dashboard such that calling a **sync** operation on that LookML dashboard will update this dashboard to match.

  String get lookmlLinkId {
    if (!_lookmlLinkIdSet && _apiMapResponse.containsKey('lookml_link_id')) {
      _lookmlLinkId = _apiMapResponse['lookml_link_id']?.toString();
      _lookmlLinkIdSet = true;
    }
    return _lookmlLinkId;
  }

  set lookmlLinkId(String v) {
    _lookmlLinkId = v;
    _lookmlLinkIdSet = true;
  }

  /// Show filters bar.  **Security Note:** This property only affects the *cosmetic* appearance of the dashboard, not a user's ability to access data. Hiding the filters bar does **NOT** prevent users from changing filters by other means. For information on how to set up secure data access control policies, see [Control User Access to Data](https://looker.com/docs/r/api/control-access)

  bool get showFiltersBar {
    if (!_showFiltersBarSet &&
        _apiMapResponse.containsKey('show_filters_bar')) {
      _showFiltersBar = _apiMapResponse['show_filters_bar'];
      _showFiltersBarSet = true;
    }
    return _showFiltersBar;
  }

  set showFiltersBar(bool v) {
    _showFiltersBar = v;
    _showFiltersBarSet = true;
  }

  /// Show title

  bool get showTitle {
    if (!_showTitleSet && _apiMapResponse.containsKey('show_title')) {
      _showTitle = _apiMapResponse['show_title'];
      _showTitleSet = true;
    }
    return _showTitle;
  }

  set showTitle(bool v) {
    _showTitle = v;
    _showTitleSet = true;
  }

  /// Id of folder

  String get folderId {
    if (!_folderIdSet && _apiMapResponse.containsKey('folder_id')) {
      _folderId = _apiMapResponse['folder_id']?.toString();
      _folderIdSet = true;
    }
    return _folderId;
  }

  set folderId(String v) {
    _folderId = v;
    _folderIdSet = true;
  }

  /// Color of text on text tiles

  String get textTileTextColor {
    if (!_textTileTextColorSet &&
        _apiMapResponse.containsKey('text_tile_text_color')) {
      _textTileTextColor = _apiMapResponse['text_tile_text_color']?.toString();
      _textTileTextColorSet = true;
    }
    return _textTileTextColor;
  }

  set textTileTextColor(String v) {
    _textTileTextColor = v;
    _textTileTextColorSet = true;
  }

  /// Tile background color

  String get tileBackgroundColor {
    if (!_tileBackgroundColorSet &&
        _apiMapResponse.containsKey('tile_background_color')) {
      _tileBackgroundColor =
          _apiMapResponse['tile_background_color']?.toString();
      _tileBackgroundColorSet = true;
    }
    return _tileBackgroundColor;
  }

  set tileBackgroundColor(String v) {
    _tileBackgroundColor = v;
    _tileBackgroundColorSet = true;
  }

  /// Tile text color

  String get tileTextColor {
    if (!_tileTextColorSet && _apiMapResponse.containsKey('tile_text_color')) {
      _tileTextColor = _apiMapResponse['tile_text_color']?.toString();
      _tileTextColorSet = true;
    }
    return _tileTextColor;
  }

  set tileTextColor(String v) {
    _tileTextColor = v;
    _tileTextColorSet = true;
  }

  /// Title color

  String get titleColor {
    if (!_titleColorSet && _apiMapResponse.containsKey('title_color')) {
      _titleColor = _apiMapResponse['title_color']?.toString();
      _titleColorSet = true;
    }
    return _titleColor;
  }

  set titleColor(String v) {
    _titleColor = v;
    _titleColorSet = true;
  }

  /// Number of times viewed in the Looker web UI (read-only)

  int get viewCount {
    if (!_viewCountSet && _apiMapResponse.containsKey('view_count')) {
      _viewCount = _apiMapResponse['view_count'];
      _viewCountSet = true;
    }
    return _viewCount;
  }

  set viewCount(int v) {
    _viewCount = v;
    _viewCountSet = true;
  }

  DashboardAppearance get appearance {
    if (!_appearanceSet && _apiMapResponse.containsKey('appearance')) {
      _appearance = _apiMapResponse['appearance'] == null
          ? null
          : DashboardAppearance.fromResponse(
              _apiMapResponse['appearance'], apiResponseContentType);
      _appearanceSet = true;
    }
    return _appearance;
  }

  set appearance(DashboardAppearance v) {
    _appearance = v;
    _appearanceSet = true;
  }

  /// Relative URL of the dashboard (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  Dashboard() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Dashboard.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_contentFavoriteIdSet ||
        _apiMapResponse.containsKey('content_favorite_id')) {
      json['content_favorite_id'] = contentFavoriteId;
    }
    if (_contentMetadataIdSet ||
        _apiMapResponse.containsKey('content_metadata_id')) {
      json['content_metadata_id'] = contentMetadataId;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_hiddenSet || _apiMapResponse.containsKey('hidden')) {
      json['hidden'] = hidden;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_modelSet || _apiMapResponse.containsKey('model')) {
      json['model'] = model?.toJson();
    }
    if (_queryTimezoneSet || _apiMapResponse.containsKey('query_timezone')) {
      json['query_timezone'] = queryTimezone;
    }
    if (_readonlySet || _apiMapResponse.containsKey('readonly')) {
      json['readonly'] = readonly;
    }
    if (_refreshIntervalSet ||
        _apiMapResponse.containsKey('refresh_interval')) {
      json['refresh_interval'] = refreshInterval;
    }
    if (_refreshIntervalToISet ||
        _apiMapResponse.containsKey('refresh_interval_to_i')) {
      json['refresh_interval_to_i'] = refreshIntervalToI;
    }
    if (_folderSet || _apiMapResponse.containsKey('folder')) {
      json['folder'] = folder?.toJson();
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    if (_slugSet || _apiMapResponse.containsKey('slug')) {
      json['slug'] = slug;
    }
    if (_preferredViewerSet ||
        _apiMapResponse.containsKey('preferred_viewer')) {
      json['preferred_viewer'] = preferredViewer;
    }
    if (_alertSyncWithDashboardFilterEnabledSet ||
        _apiMapResponse
            .containsKey('alert_sync_with_dashboard_filter_enabled')) {
      json['alert_sync_with_dashboard_filter_enabled'] =
          alertSyncWithDashboardFilterEnabled;
    }
    if (_backgroundColorSet ||
        _apiMapResponse.containsKey('background_color')) {
      json['background_color'] = backgroundColor;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt?.toIso8601String();
    }
    if (_crossfilterEnabledSet ||
        _apiMapResponse.containsKey('crossfilter_enabled')) {
      json['crossfilter_enabled'] = crossfilterEnabled;
    }
    if (_dashboardElementsSet ||
        _apiMapResponse.containsKey('dashboard_elements')) {
      json['dashboard_elements'] =
          dashboardElements?.map((i) => i.toJson())?.toList();
    }
    if (_dashboardFiltersSet ||
        _apiMapResponse.containsKey('dashboard_filters')) {
      json['dashboard_filters'] =
          dashboardFilters?.map((i) => i.toJson())?.toList();
    }
    if (_dashboardLayoutsSet ||
        _apiMapResponse.containsKey('dashboard_layouts')) {
      json['dashboard_layouts'] =
          dashboardLayouts?.map((i) => i.toJson())?.toList();
    }
    if (_deletedSet || _apiMapResponse.containsKey('deleted')) {
      json['deleted'] = deleted;
    }
    if (_deletedAtSet || _apiMapResponse.containsKey('deleted_at')) {
      json['deleted_at'] = deletedAt?.toIso8601String();
    }
    if (_deleterIdSet || _apiMapResponse.containsKey('deleter_id')) {
      json['deleter_id'] = deleterId;
    }
    if (_editUriSet || _apiMapResponse.containsKey('edit_uri')) {
      json['edit_uri'] = editUri;
    }
    if (_favoriteCountSet || _apiMapResponse.containsKey('favorite_count')) {
      json['favorite_count'] = favoriteCount;
    }
    if (_filtersBarCollapsedSet ||
        _apiMapResponse.containsKey('filters_bar_collapsed')) {
      json['filters_bar_collapsed'] = filtersBarCollapsed;
    }
    if (_lastAccessedAtSet || _apiMapResponse.containsKey('last_accessed_at')) {
      json['last_accessed_at'] = lastAccessedAt?.toIso8601String();
    }
    if (_lastViewedAtSet || _apiMapResponse.containsKey('last_viewed_at')) {
      json['last_viewed_at'] = lastViewedAt?.toIso8601String();
    }
    if (_updatedAtSet || _apiMapResponse.containsKey('updated_at')) {
      json['updated_at'] = updatedAt?.toIso8601String();
    }
    if (_lastUpdaterIdSet || _apiMapResponse.containsKey('last_updater_id')) {
      json['last_updater_id'] = lastUpdaterId;
    }
    if (_lastUpdaterNameSet ||
        _apiMapResponse.containsKey('last_updater_name')) {
      json['last_updater_name'] = lastUpdaterName;
    }
    if (_userNameSet || _apiMapResponse.containsKey('user_name')) {
      json['user_name'] = userName;
    }
    if (_loadConfigurationSet ||
        _apiMapResponse.containsKey('load_configuration')) {
      json['load_configuration'] = loadConfiguration;
    }
    if (_lookmlLinkIdSet || _apiMapResponse.containsKey('lookml_link_id')) {
      json['lookml_link_id'] = lookmlLinkId;
    }
    if (_showFiltersBarSet || _apiMapResponse.containsKey('show_filters_bar')) {
      json['show_filters_bar'] = showFiltersBar;
    }
    if (_showTitleSet || _apiMapResponse.containsKey('show_title')) {
      json['show_title'] = showTitle;
    }
    if (_folderIdSet || _apiMapResponse.containsKey('folder_id')) {
      json['folder_id'] = folderId;
    }
    if (_textTileTextColorSet ||
        _apiMapResponse.containsKey('text_tile_text_color')) {
      json['text_tile_text_color'] = textTileTextColor;
    }
    if (_tileBackgroundColorSet ||
        _apiMapResponse.containsKey('tile_background_color')) {
      json['tile_background_color'] = tileBackgroundColor;
    }
    if (_tileTextColorSet || _apiMapResponse.containsKey('tile_text_color')) {
      json['tile_text_color'] = tileTextColor;
    }
    if (_titleColorSet || _apiMapResponse.containsKey('title_color')) {
      json['title_color'] = titleColor;
    }
    if (_viewCountSet || _apiMapResponse.containsKey('view_count')) {
      json['view_count'] = viewCount;
    }
    if (_appearanceSet || _apiMapResponse.containsKey('appearance')) {
      json['appearance'] = appearance?.toJson();
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class DashboardAggregateTableLookml {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _dashboardId;
  bool _dashboardIdSet = false;

  String _aggregateTableLookml;
  bool _aggregateTableLookmlSet = false;

  /// Dashboard Id (read-only)

  String get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id']?.toString();
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(String v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// Aggregate Table LookML (read-only)

  String get aggregateTableLookml {
    if (!_aggregateTableLookmlSet &&
        _apiMapResponse.containsKey('aggregate_table_lookml')) {
      _aggregateTableLookml =
          _apiMapResponse['aggregate_table_lookml']?.toString();
      _aggregateTableLookmlSet = true;
    }
    return _aggregateTableLookml;
  }

  set aggregateTableLookml(String v) {
    _aggregateTableLookml = v;
    _aggregateTableLookmlSet = true;
  }

  DashboardAggregateTableLookml() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DashboardAggregateTableLookml.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_aggregateTableLookmlSet ||
        _apiMapResponse.containsKey('aggregate_table_lookml')) {
      json['aggregate_table_lookml'] = aggregateTableLookml;
    }
    return json;
  }
}

class DashboardAppearance {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _pageSideMargins;
  bool _pageSideMarginsSet = false;

  String _pageBackgroundColor;
  bool _pageBackgroundColorSet = false;

  String _tileTitleAlignment;
  bool _tileTitleAlignmentSet = false;

  int _tileSpaceBetween;
  bool _tileSpaceBetweenSet = false;

  String _tileBackgroundColor;
  bool _tileBackgroundColorSet = false;

  bool _tileShadow;
  bool _tileShadowSet = false;

  String _keyColor;
  bool _keyColorSet = false;

  /// Page margin (side) width

  int get pageSideMargins {
    if (!_pageSideMarginsSet &&
        _apiMapResponse.containsKey('page_side_margins')) {
      _pageSideMargins = _apiMapResponse['page_side_margins'];
      _pageSideMarginsSet = true;
    }
    return _pageSideMargins;
  }

  set pageSideMargins(int v) {
    _pageSideMargins = v;
    _pageSideMarginsSet = true;
  }

  /// Background color for the dashboard

  String get pageBackgroundColor {
    if (!_pageBackgroundColorSet &&
        _apiMapResponse.containsKey('page_background_color')) {
      _pageBackgroundColor =
          _apiMapResponse['page_background_color']?.toString();
      _pageBackgroundColorSet = true;
    }
    return _pageBackgroundColor;
  }

  set pageBackgroundColor(String v) {
    _pageBackgroundColor = v;
    _pageBackgroundColorSet = true;
  }

  /// Title alignment on dashboard tiles

  String get tileTitleAlignment {
    if (!_tileTitleAlignmentSet &&
        _apiMapResponse.containsKey('tile_title_alignment')) {
      _tileTitleAlignment = _apiMapResponse['tile_title_alignment']?.toString();
      _tileTitleAlignmentSet = true;
    }
    return _tileTitleAlignment;
  }

  set tileTitleAlignment(String v) {
    _tileTitleAlignment = v;
    _tileTitleAlignmentSet = true;
  }

  /// Space between tiles

  int get tileSpaceBetween {
    if (!_tileSpaceBetweenSet &&
        _apiMapResponse.containsKey('tile_space_between')) {
      _tileSpaceBetween = _apiMapResponse['tile_space_between'];
      _tileSpaceBetweenSet = true;
    }
    return _tileSpaceBetween;
  }

  set tileSpaceBetween(int v) {
    _tileSpaceBetween = v;
    _tileSpaceBetweenSet = true;
  }

  /// Background color for tiles

  String get tileBackgroundColor {
    if (!_tileBackgroundColorSet &&
        _apiMapResponse.containsKey('tile_background_color')) {
      _tileBackgroundColor =
          _apiMapResponse['tile_background_color']?.toString();
      _tileBackgroundColorSet = true;
    }
    return _tileBackgroundColor;
  }

  set tileBackgroundColor(String v) {
    _tileBackgroundColor = v;
    _tileBackgroundColorSet = true;
  }

  /// Tile shadow on/off

  bool get tileShadow {
    if (!_tileShadowSet && _apiMapResponse.containsKey('tile_shadow')) {
      _tileShadow = _apiMapResponse['tile_shadow'];
      _tileShadowSet = true;
    }
    return _tileShadow;
  }

  set tileShadow(bool v) {
    _tileShadow = v;
    _tileShadowSet = true;
  }

  /// Key color

  String get keyColor {
    if (!_keyColorSet && _apiMapResponse.containsKey('key_color')) {
      _keyColor = _apiMapResponse['key_color']?.toString();
      _keyColorSet = true;
    }
    return _keyColor;
  }

  set keyColor(String v) {
    _keyColor = v;
    _keyColorSet = true;
  }

  DashboardAppearance() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DashboardAppearance.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_pageSideMarginsSet ||
        _apiMapResponse.containsKey('page_side_margins')) {
      json['page_side_margins'] = pageSideMargins;
    }
    if (_pageBackgroundColorSet ||
        _apiMapResponse.containsKey('page_background_color')) {
      json['page_background_color'] = pageBackgroundColor;
    }
    if (_tileTitleAlignmentSet ||
        _apiMapResponse.containsKey('tile_title_alignment')) {
      json['tile_title_alignment'] = tileTitleAlignment;
    }
    if (_tileSpaceBetweenSet ||
        _apiMapResponse.containsKey('tile_space_between')) {
      json['tile_space_between'] = tileSpaceBetween;
    }
    if (_tileBackgroundColorSet ||
        _apiMapResponse.containsKey('tile_background_color')) {
      json['tile_background_color'] = tileBackgroundColor;
    }
    if (_tileShadowSet || _apiMapResponse.containsKey('tile_shadow')) {
      json['tile_shadow'] = tileShadow;
    }
    if (_keyColorSet || _apiMapResponse.containsKey('key_color')) {
      json['key_color'] = keyColor;
    }
    return json;
  }
}

class DashboardBase {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _contentFavoriteId;
  bool _contentFavoriteIdSet = false;

  int _contentMetadataId;
  bool _contentMetadataIdSet = false;

  String _description;
  bool _descriptionSet = false;

  bool _hidden;
  bool _hiddenSet = false;

  String _id;
  bool _idSet = false;

  LookModel _model;
  bool _modelSet = false;

  String _queryTimezone;
  bool _queryTimezoneSet = false;

  bool _readonly;
  bool _readonlySet = false;

  String _refreshInterval;
  bool _refreshIntervalSet = false;

  int _refreshIntervalToI;
  bool _refreshIntervalToISet = false;

  FolderBase _folder;
  bool _folderSet = false;

  String _title;
  bool _titleSet = false;

  int _userId;
  bool _userIdSet = false;

  String _slug;
  bool _slugSet = false;

  String _preferredViewer;
  bool _preferredViewerSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Content Favorite Id (read-only)

  int get contentFavoriteId {
    if (!_contentFavoriteIdSet &&
        _apiMapResponse.containsKey('content_favorite_id')) {
      _contentFavoriteId = _apiMapResponse['content_favorite_id'];
      _contentFavoriteIdSet = true;
    }
    return _contentFavoriteId;
  }

  set contentFavoriteId(int v) {
    _contentFavoriteId = v;
    _contentFavoriteIdSet = true;
  }

  /// Id of content metadata (read-only)

  int get contentMetadataId {
    if (!_contentMetadataIdSet &&
        _apiMapResponse.containsKey('content_metadata_id')) {
      _contentMetadataId = _apiMapResponse['content_metadata_id'];
      _contentMetadataIdSet = true;
    }
    return _contentMetadataId;
  }

  set contentMetadataId(int v) {
    _contentMetadataId = v;
    _contentMetadataIdSet = true;
  }

  /// Description (read-only)

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Is Hidden (read-only)

  bool get hidden {
    if (!_hiddenSet && _apiMapResponse.containsKey('hidden')) {
      _hidden = _apiMapResponse['hidden'];
      _hiddenSet = true;
    }
    return _hidden;
  }

  set hidden(bool v) {
    _hidden = v;
    _hiddenSet = true;
  }

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  LookModel get model {
    if (!_modelSet && _apiMapResponse.containsKey('model')) {
      _model = _apiMapResponse['model'] == null
          ? null
          : LookModel.fromResponse(
              _apiMapResponse['model'], apiResponseContentType);
      _modelSet = true;
    }
    return _model;
  }

  set model(LookModel v) {
    _model = v;
    _modelSet = true;
  }

  /// Timezone in which the Dashboard will run by default. (read-only)

  String get queryTimezone {
    if (!_queryTimezoneSet && _apiMapResponse.containsKey('query_timezone')) {
      _queryTimezone = _apiMapResponse['query_timezone']?.toString();
      _queryTimezoneSet = true;
    }
    return _queryTimezone;
  }

  set queryTimezone(String v) {
    _queryTimezone = v;
    _queryTimezoneSet = true;
  }

  /// Is Read-only (read-only)

  bool get readonly {
    if (!_readonlySet && _apiMapResponse.containsKey('readonly')) {
      _readonly = _apiMapResponse['readonly'];
      _readonlySet = true;
    }
    return _readonly;
  }

  set readonly(bool v) {
    _readonly = v;
    _readonlySet = true;
  }

  /// Refresh Interval, as a time duration phrase like "2 hours 30 minutes". A number with no time units will be interpreted as whole seconds. (read-only)

  String get refreshInterval {
    if (!_refreshIntervalSet &&
        _apiMapResponse.containsKey('refresh_interval')) {
      _refreshInterval = _apiMapResponse['refresh_interval']?.toString();
      _refreshIntervalSet = true;
    }
    return _refreshInterval;
  }

  set refreshInterval(String v) {
    _refreshInterval = v;
    _refreshIntervalSet = true;
  }

  /// Refresh Interval in milliseconds (read-only)

  int get refreshIntervalToI {
    if (!_refreshIntervalToISet &&
        _apiMapResponse.containsKey('refresh_interval_to_i')) {
      _refreshIntervalToI = _apiMapResponse['refresh_interval_to_i'];
      _refreshIntervalToISet = true;
    }
    return _refreshIntervalToI;
  }

  set refreshIntervalToI(int v) {
    _refreshIntervalToI = v;
    _refreshIntervalToISet = true;
  }

  FolderBase get folder {
    if (!_folderSet && _apiMapResponse.containsKey('folder')) {
      _folder = _apiMapResponse['folder'] == null
          ? null
          : FolderBase.fromResponse(
              _apiMapResponse['folder'], apiResponseContentType);
      _folderSet = true;
    }
    return _folder;
  }

  set folder(FolderBase v) {
    _folder = v;
    _folderSet = true;
  }

  /// Dashboard Title (read-only)

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Id of User (read-only)

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  /// Content Metadata Slug (read-only)

  String get slug {
    if (!_slugSet && _apiMapResponse.containsKey('slug')) {
      _slug = _apiMapResponse['slug']?.toString();
      _slugSet = true;
    }
    return _slug;
  }

  set slug(String v) {
    _slug = v;
    _slugSet = true;
  }

  /// The preferred route for viewing this dashboard (ie: dashboards or dashboards-next) (read-only)

  String get preferredViewer {
    if (!_preferredViewerSet &&
        _apiMapResponse.containsKey('preferred_viewer')) {
      _preferredViewer = _apiMapResponse['preferred_viewer']?.toString();
      _preferredViewerSet = true;
    }
    return _preferredViewer;
  }

  set preferredViewer(String v) {
    _preferredViewer = v;
    _preferredViewerSet = true;
  }

  DashboardBase() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DashboardBase.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_contentFavoriteIdSet ||
        _apiMapResponse.containsKey('content_favorite_id')) {
      json['content_favorite_id'] = contentFavoriteId;
    }
    if (_contentMetadataIdSet ||
        _apiMapResponse.containsKey('content_metadata_id')) {
      json['content_metadata_id'] = contentMetadataId;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_hiddenSet || _apiMapResponse.containsKey('hidden')) {
      json['hidden'] = hidden;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_modelSet || _apiMapResponse.containsKey('model')) {
      json['model'] = model?.toJson();
    }
    if (_queryTimezoneSet || _apiMapResponse.containsKey('query_timezone')) {
      json['query_timezone'] = queryTimezone;
    }
    if (_readonlySet || _apiMapResponse.containsKey('readonly')) {
      json['readonly'] = readonly;
    }
    if (_refreshIntervalSet ||
        _apiMapResponse.containsKey('refresh_interval')) {
      json['refresh_interval'] = refreshInterval;
    }
    if (_refreshIntervalToISet ||
        _apiMapResponse.containsKey('refresh_interval_to_i')) {
      json['refresh_interval_to_i'] = refreshIntervalToI;
    }
    if (_folderSet || _apiMapResponse.containsKey('folder')) {
      json['folder'] = folder?.toJson();
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    if (_slugSet || _apiMapResponse.containsKey('slug')) {
      json['slug'] = slug;
    }
    if (_preferredViewerSet ||
        _apiMapResponse.containsKey('preferred_viewer')) {
      json['preferred_viewer'] = preferredViewer;
    }
    return json;
  }
}

class DashboardElement {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _bodyText;
  bool _bodyTextSet = false;

  String _bodyTextAsHtml;
  bool _bodyTextAsHtmlSet = false;

  String _dashboardId;
  bool _dashboardIdSet = false;

  String _editUri;
  bool _editUriSet = false;

  String _id;
  bool _idSet = false;

  LookWithQuery _look;
  bool _lookSet = false;

  String _lookId;
  bool _lookIdSet = false;

  String _lookmlLinkId;
  bool _lookmlLinkIdSet = false;

  String _mergeResultId;
  bool _mergeResultIdSet = false;

  String _noteDisplay;
  bool _noteDisplaySet = false;

  String _noteState;
  bool _noteStateSet = false;

  String _noteText;
  bool _noteTextSet = false;

  String _noteTextAsHtml;
  bool _noteTextAsHtmlSet = false;

  Query _query;
  bool _querySet = false;

  int _queryId;
  bool _queryIdSet = false;

  String _refreshInterval;
  bool _refreshIntervalSet = false;

  int _refreshIntervalToI;
  bool _refreshIntervalToISet = false;

  ResultMakerWithIdVisConfigAndDynamicFields _resultMaker;
  bool _resultMakerSet = false;

  int _resultMakerId;
  bool _resultMakerIdSet = false;

  String _subtitleText;
  bool _subtitleTextSet = false;

  String _title;
  bool _titleSet = false;

  bool _titleHidden;
  bool _titleHiddenSet = false;

  String _titleText;
  bool _titleTextSet = false;

  String _type;
  bool _typeSet = false;

  int _alertCount;
  bool _alertCountSet = false;

  String _titleTextAsHtml;
  bool _titleTextAsHtmlSet = false;

  String _subtitleTextAsHtml;
  bool _subtitleTextAsHtmlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Text tile body text

  String get bodyText {
    if (!_bodyTextSet && _apiMapResponse.containsKey('body_text')) {
      _bodyText = _apiMapResponse['body_text']?.toString();
      _bodyTextSet = true;
    }
    return _bodyText;
  }

  set bodyText(String v) {
    _bodyText = v;
    _bodyTextSet = true;
  }

  /// Text tile body text as Html (read-only)

  String get bodyTextAsHtml {
    if (!_bodyTextAsHtmlSet &&
        _apiMapResponse.containsKey('body_text_as_html')) {
      _bodyTextAsHtml = _apiMapResponse['body_text_as_html']?.toString();
      _bodyTextAsHtmlSet = true;
    }
    return _bodyTextAsHtml;
  }

  set bodyTextAsHtml(String v) {
    _bodyTextAsHtml = v;
    _bodyTextAsHtmlSet = true;
  }

  /// Id of Dashboard

  String get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id']?.toString();
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(String v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// Relative path of URI of LookML file to edit the dashboard element (LookML dashboard only). (read-only)

  String get editUri {
    if (!_editUriSet && _apiMapResponse.containsKey('edit_uri')) {
      _editUri = _apiMapResponse['edit_uri']?.toString();
      _editUriSet = true;
    }
    return _editUri;
  }

  set editUri(String v) {
    _editUri = v;
    _editUriSet = true;
  }

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  LookWithQuery get look {
    if (!_lookSet && _apiMapResponse.containsKey('look')) {
      _look = _apiMapResponse['look'] == null
          ? null
          : LookWithQuery.fromResponse(
              _apiMapResponse['look'], apiResponseContentType);
      _lookSet = true;
    }
    return _look;
  }

  set look(LookWithQuery v) {
    _look = v;
    _lookSet = true;
  }

  /// Id Of Look

  String get lookId {
    if (!_lookIdSet && _apiMapResponse.containsKey('look_id')) {
      _lookId = _apiMapResponse['look_id']?.toString();
      _lookIdSet = true;
    }
    return _lookId;
  }

  set lookId(String v) {
    _lookId = v;
    _lookIdSet = true;
  }

  /// LookML link ID (read-only)

  String get lookmlLinkId {
    if (!_lookmlLinkIdSet && _apiMapResponse.containsKey('lookml_link_id')) {
      _lookmlLinkId = _apiMapResponse['lookml_link_id']?.toString();
      _lookmlLinkIdSet = true;
    }
    return _lookmlLinkId;
  }

  set lookmlLinkId(String v) {
    _lookmlLinkId = v;
    _lookmlLinkIdSet = true;
  }

  /// ID of merge result

  String get mergeResultId {
    if (!_mergeResultIdSet && _apiMapResponse.containsKey('merge_result_id')) {
      _mergeResultId = _apiMapResponse['merge_result_id']?.toString();
      _mergeResultIdSet = true;
    }
    return _mergeResultId;
  }

  set mergeResultId(String v) {
    _mergeResultId = v;
    _mergeResultIdSet = true;
  }

  /// Note Display

  String get noteDisplay {
    if (!_noteDisplaySet && _apiMapResponse.containsKey('note_display')) {
      _noteDisplay = _apiMapResponse['note_display']?.toString();
      _noteDisplaySet = true;
    }
    return _noteDisplay;
  }

  set noteDisplay(String v) {
    _noteDisplay = v;
    _noteDisplaySet = true;
  }

  /// Note State

  String get noteState {
    if (!_noteStateSet && _apiMapResponse.containsKey('note_state')) {
      _noteState = _apiMapResponse['note_state']?.toString();
      _noteStateSet = true;
    }
    return _noteState;
  }

  set noteState(String v) {
    _noteState = v;
    _noteStateSet = true;
  }

  /// Note Text

  String get noteText {
    if (!_noteTextSet && _apiMapResponse.containsKey('note_text')) {
      _noteText = _apiMapResponse['note_text']?.toString();
      _noteTextSet = true;
    }
    return _noteText;
  }

  set noteText(String v) {
    _noteText = v;
    _noteTextSet = true;
  }

  /// Note Text as Html (read-only)

  String get noteTextAsHtml {
    if (!_noteTextAsHtmlSet &&
        _apiMapResponse.containsKey('note_text_as_html')) {
      _noteTextAsHtml = _apiMapResponse['note_text_as_html']?.toString();
      _noteTextAsHtmlSet = true;
    }
    return _noteTextAsHtml;
  }

  set noteTextAsHtml(String v) {
    _noteTextAsHtml = v;
    _noteTextAsHtmlSet = true;
  }

  Query get query {
    if (!_querySet && _apiMapResponse.containsKey('query')) {
      _query = _apiMapResponse['query'] == null
          ? null
          : Query.fromResponse(
              _apiMapResponse['query'], apiResponseContentType);
      _querySet = true;
    }
    return _query;
  }

  set query(Query v) {
    _query = v;
    _querySet = true;
  }

  /// Id Of Query

  int get queryId {
    if (!_queryIdSet && _apiMapResponse.containsKey('query_id')) {
      _queryId = _apiMapResponse['query_id'];
      _queryIdSet = true;
    }
    return _queryId;
  }

  set queryId(int v) {
    _queryId = v;
    _queryIdSet = true;
  }

  /// Refresh Interval

  String get refreshInterval {
    if (!_refreshIntervalSet &&
        _apiMapResponse.containsKey('refresh_interval')) {
      _refreshInterval = _apiMapResponse['refresh_interval']?.toString();
      _refreshIntervalSet = true;
    }
    return _refreshInterval;
  }

  set refreshInterval(String v) {
    _refreshInterval = v;
    _refreshIntervalSet = true;
  }

  /// Refresh Interval as integer (read-only)

  int get refreshIntervalToI {
    if (!_refreshIntervalToISet &&
        _apiMapResponse.containsKey('refresh_interval_to_i')) {
      _refreshIntervalToI = _apiMapResponse['refresh_interval_to_i'];
      _refreshIntervalToISet = true;
    }
    return _refreshIntervalToI;
  }

  set refreshIntervalToI(int v) {
    _refreshIntervalToI = v;
    _refreshIntervalToISet = true;
  }

  ResultMakerWithIdVisConfigAndDynamicFields get resultMaker {
    if (!_resultMakerSet && _apiMapResponse.containsKey('result_maker')) {
      _resultMaker = _apiMapResponse['result_maker'] == null
          ? null
          : ResultMakerWithIdVisConfigAndDynamicFields.fromResponse(
              _apiMapResponse['result_maker'], apiResponseContentType);
      _resultMakerSet = true;
    }
    return _resultMaker;
  }

  set resultMaker(ResultMakerWithIdVisConfigAndDynamicFields v) {
    _resultMaker = v;
    _resultMakerSet = true;
  }

  /// ID of the ResultMakerLookup entry.

  int get resultMakerId {
    if (!_resultMakerIdSet && _apiMapResponse.containsKey('result_maker_id')) {
      _resultMakerId = _apiMapResponse['result_maker_id'];
      _resultMakerIdSet = true;
    }
    return _resultMakerId;
  }

  set resultMakerId(int v) {
    _resultMakerId = v;
    _resultMakerIdSet = true;
  }

  /// Text tile subtitle text

  String get subtitleText {
    if (!_subtitleTextSet && _apiMapResponse.containsKey('subtitle_text')) {
      _subtitleText = _apiMapResponse['subtitle_text']?.toString();
      _subtitleTextSet = true;
    }
    return _subtitleText;
  }

  set subtitleText(String v) {
    _subtitleText = v;
    _subtitleTextSet = true;
  }

  /// Title of dashboard element

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Whether title is hidden

  bool get titleHidden {
    if (!_titleHiddenSet && _apiMapResponse.containsKey('title_hidden')) {
      _titleHidden = _apiMapResponse['title_hidden'];
      _titleHiddenSet = true;
    }
    return _titleHidden;
  }

  set titleHidden(bool v) {
    _titleHidden = v;
    _titleHiddenSet = true;
  }

  /// Text tile title

  String get titleText {
    if (!_titleTextSet && _apiMapResponse.containsKey('title_text')) {
      _titleText = _apiMapResponse['title_text']?.toString();
      _titleTextSet = true;
    }
    return _titleText;
  }

  set titleText(String v) {
    _titleText = v;
    _titleTextSet = true;
  }

  /// Type

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Count of Alerts associated to a dashboard element (read-only)

  int get alertCount {
    if (!_alertCountSet && _apiMapResponse.containsKey('alert_count')) {
      _alertCount = _apiMapResponse['alert_count'];
      _alertCountSet = true;
    }
    return _alertCount;
  }

  set alertCount(int v) {
    _alertCount = v;
    _alertCountSet = true;
  }

  /// Text tile title text as Html (read-only)

  String get titleTextAsHtml {
    if (!_titleTextAsHtmlSet &&
        _apiMapResponse.containsKey('title_text_as_html')) {
      _titleTextAsHtml = _apiMapResponse['title_text_as_html']?.toString();
      _titleTextAsHtmlSet = true;
    }
    return _titleTextAsHtml;
  }

  set titleTextAsHtml(String v) {
    _titleTextAsHtml = v;
    _titleTextAsHtmlSet = true;
  }

  /// Text tile subtitle text as Html (read-only)

  String get subtitleTextAsHtml {
    if (!_subtitleTextAsHtmlSet &&
        _apiMapResponse.containsKey('subtitle_text_as_html')) {
      _subtitleTextAsHtml =
          _apiMapResponse['subtitle_text_as_html']?.toString();
      _subtitleTextAsHtmlSet = true;
    }
    return _subtitleTextAsHtml;
  }

  set subtitleTextAsHtml(String v) {
    _subtitleTextAsHtml = v;
    _subtitleTextAsHtmlSet = true;
  }

  DashboardElement() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DashboardElement.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_bodyTextSet || _apiMapResponse.containsKey('body_text')) {
      json['body_text'] = bodyText;
    }
    if (_bodyTextAsHtmlSet ||
        _apiMapResponse.containsKey('body_text_as_html')) {
      json['body_text_as_html'] = bodyTextAsHtml;
    }
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_editUriSet || _apiMapResponse.containsKey('edit_uri')) {
      json['edit_uri'] = editUri;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_lookSet || _apiMapResponse.containsKey('look')) {
      json['look'] = look?.toJson();
    }
    if (_lookIdSet || _apiMapResponse.containsKey('look_id')) {
      json['look_id'] = lookId;
    }
    if (_lookmlLinkIdSet || _apiMapResponse.containsKey('lookml_link_id')) {
      json['lookml_link_id'] = lookmlLinkId;
    }
    if (_mergeResultIdSet || _apiMapResponse.containsKey('merge_result_id')) {
      json['merge_result_id'] = mergeResultId;
    }
    if (_noteDisplaySet || _apiMapResponse.containsKey('note_display')) {
      json['note_display'] = noteDisplay;
    }
    if (_noteStateSet || _apiMapResponse.containsKey('note_state')) {
      json['note_state'] = noteState;
    }
    if (_noteTextSet || _apiMapResponse.containsKey('note_text')) {
      json['note_text'] = noteText;
    }
    if (_noteTextAsHtmlSet ||
        _apiMapResponse.containsKey('note_text_as_html')) {
      json['note_text_as_html'] = noteTextAsHtml;
    }
    if (_querySet || _apiMapResponse.containsKey('query')) {
      json['query'] = query?.toJson();
    }
    if (_queryIdSet || _apiMapResponse.containsKey('query_id')) {
      json['query_id'] = queryId;
    }
    if (_refreshIntervalSet ||
        _apiMapResponse.containsKey('refresh_interval')) {
      json['refresh_interval'] = refreshInterval;
    }
    if (_refreshIntervalToISet ||
        _apiMapResponse.containsKey('refresh_interval_to_i')) {
      json['refresh_interval_to_i'] = refreshIntervalToI;
    }
    if (_resultMakerSet || _apiMapResponse.containsKey('result_maker')) {
      json['result_maker'] = resultMaker?.toJson();
    }
    if (_resultMakerIdSet || _apiMapResponse.containsKey('result_maker_id')) {
      json['result_maker_id'] = resultMakerId;
    }
    if (_subtitleTextSet || _apiMapResponse.containsKey('subtitle_text')) {
      json['subtitle_text'] = subtitleText;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_titleHiddenSet || _apiMapResponse.containsKey('title_hidden')) {
      json['title_hidden'] = titleHidden;
    }
    if (_titleTextSet || _apiMapResponse.containsKey('title_text')) {
      json['title_text'] = titleText;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_alertCountSet || _apiMapResponse.containsKey('alert_count')) {
      json['alert_count'] = alertCount;
    }
    if (_titleTextAsHtmlSet ||
        _apiMapResponse.containsKey('title_text_as_html')) {
      json['title_text_as_html'] = titleTextAsHtml;
    }
    if (_subtitleTextAsHtmlSet ||
        _apiMapResponse.containsKey('subtitle_text_as_html')) {
      json['subtitle_text_as_html'] = subtitleTextAsHtml;
    }
    return json;
  }
}

class DashboardFilter {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _id;
  bool _idSet = false;

  String _dashboardId;
  bool _dashboardIdSet = false;

  String _name;
  bool _nameSet = false;

  String _title;
  bool _titleSet = false;

  String _type;
  bool _typeSet = false;

  String _defaultValue;
  bool _defaultValueSet = false;

  String _model;
  bool _modelSet = false;

  String _explore;
  bool _exploreSet = false;

  String _dimension;
  bool _dimensionSet = false;

  Map<String, dynamic> _field;
  bool _fieldSet = false;

  int _row;
  bool _rowSet = false;

  List<String> _listensToFilters;
  bool _listensToFiltersSet = false;

  bool _allowMultipleValues;
  bool _allowMultipleValuesSet = false;

  bool _required;
  bool _requiredSet = false;

  Map<String, dynamic> _uiConfig;
  bool _uiConfigSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Id of Dashboard (read-only)

  String get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id']?.toString();
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(String v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// Name of filter

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Title of filter

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Type of filter: one of date, number, string, or field

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Default value of filter

  String get defaultValue {
    if (!_defaultValueSet && _apiMapResponse.containsKey('default_value')) {
      _defaultValue = _apiMapResponse['default_value']?.toString();
      _defaultValueSet = true;
    }
    return _defaultValue;
  }

  set defaultValue(String v) {
    _defaultValue = v;
    _defaultValueSet = true;
  }

  /// Model of filter (required if type = field)

  String get model {
    if (!_modelSet && _apiMapResponse.containsKey('model')) {
      _model = _apiMapResponse['model']?.toString();
      _modelSet = true;
    }
    return _model;
  }

  set model(String v) {
    _model = v;
    _modelSet = true;
  }

  /// Explore of filter (required if type = field)

  String get explore {
    if (!_exploreSet && _apiMapResponse.containsKey('explore')) {
      _explore = _apiMapResponse['explore']?.toString();
      _exploreSet = true;
    }
    return _explore;
  }

  set explore(String v) {
    _explore = v;
    _exploreSet = true;
  }

  /// Dimension of filter (required if type = field)

  String get dimension {
    if (!_dimensionSet && _apiMapResponse.containsKey('dimension')) {
      _dimension = _apiMapResponse['dimension']?.toString();
      _dimensionSet = true;
    }
    return _dimension;
  }

  set dimension(String v) {
    _dimension = v;
    _dimensionSet = true;
  }

  /// Field information (read-only)

  Map<String, dynamic> get field {
    if (!_fieldSet && _apiMapResponse.containsKey('field')) {
      _field = _apiMapResponse['field'];
      _fieldSet = true;
    }
    return _field;
  }

  set field(Map<String, dynamic> v) {
    _field = v;
    _fieldSet = true;
  }

  /// Display order of this filter relative to other filters

  int get row {
    if (!_rowSet && _apiMapResponse.containsKey('row')) {
      _row = _apiMapResponse['row'];
      _rowSet = true;
    }
    return _row;
  }

  set row(int v) {
    _row = v;
    _rowSet = true;
  }

  /// Array of listeners for faceted filters

  List<String> get listensToFilters {
    if (!_listensToFiltersSet &&
        _apiMapResponse.containsKey('listens_to_filters')) {
      _listensToFilters = _apiMapResponse['listens_to_filters']
          ?.map<String>((i) => i as String)
          ?.toList();
      _listensToFiltersSet = true;
    }
    return _listensToFilters;
  }

  set listensToFilters(List<String> v) {
    _listensToFilters = v;
    _listensToFiltersSet = true;
  }

  /// Whether the filter allows multiple filter values (deprecated in the latest version of dashboards)

  bool get allowMultipleValues {
    if (!_allowMultipleValuesSet &&
        _apiMapResponse.containsKey('allow_multiple_values')) {
      _allowMultipleValues = _apiMapResponse['allow_multiple_values'];
      _allowMultipleValuesSet = true;
    }
    return _allowMultipleValues;
  }

  set allowMultipleValues(bool v) {
    _allowMultipleValues = v;
    _allowMultipleValuesSet = true;
  }

  /// Whether the filter requires a value to run the dashboard

  bool get required {
    if (!_requiredSet && _apiMapResponse.containsKey('required')) {
      _required = _apiMapResponse['required'];
      _requiredSet = true;
    }
    return _required;
  }

  set required(bool v) {
    _required = v;
    _requiredSet = true;
  }

  /// The visual configuration for this filter. Used to set up how the UI for this filter should appear.

  Map<String, dynamic> get uiConfig {
    if (!_uiConfigSet && _apiMapResponse.containsKey('ui_config')) {
      _uiConfig = _apiMapResponse['ui_config'];
      _uiConfigSet = true;
    }
    return _uiConfig;
  }

  set uiConfig(Map<String, dynamic> v) {
    _uiConfig = v;
    _uiConfigSet = true;
  }

  DashboardFilter() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DashboardFilter.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_defaultValueSet || _apiMapResponse.containsKey('default_value')) {
      json['default_value'] = defaultValue;
    }
    if (_modelSet || _apiMapResponse.containsKey('model')) {
      json['model'] = model;
    }
    if (_exploreSet || _apiMapResponse.containsKey('explore')) {
      json['explore'] = explore;
    }
    if (_dimensionSet || _apiMapResponse.containsKey('dimension')) {
      json['dimension'] = dimension;
    }
    if (_fieldSet || _apiMapResponse.containsKey('field')) {
      json['field'] = field;
    }
    if (_rowSet || _apiMapResponse.containsKey('row')) {
      json['row'] = row;
    }
    if (_listensToFiltersSet ||
        _apiMapResponse.containsKey('listens_to_filters')) {
      json['listens_to_filters'] = listensToFilters;
    }
    if (_allowMultipleValuesSet ||
        _apiMapResponse.containsKey('allow_multiple_values')) {
      json['allow_multiple_values'] = allowMultipleValues;
    }
    if (_requiredSet || _apiMapResponse.containsKey('required')) {
      json['required'] = required;
    }
    if (_uiConfigSet || _apiMapResponse.containsKey('ui_config')) {
      json['ui_config'] = uiConfig;
    }
    return json;
  }
}

class DashboardLayout {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _id;
  bool _idSet = false;

  String _dashboardId;
  bool _dashboardIdSet = false;

  String _type;
  bool _typeSet = false;

  bool _active;
  bool _activeSet = false;

  int _columnWidth;
  bool _columnWidthSet = false;

  int _width;
  bool _widthSet = false;

  bool _deleted;
  bool _deletedSet = false;

  String _dashboardTitle;
  bool _dashboardTitleSet = false;

  List<DashboardLayoutComponent> _dashboardLayoutComponents;
  bool _dashboardLayoutComponentsSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Id of Dashboard

  String get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id']?.toString();
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(String v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// Type

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Is Active

  bool get active {
    if (!_activeSet && _apiMapResponse.containsKey('active')) {
      _active = _apiMapResponse['active'];
      _activeSet = true;
    }
    return _active;
  }

  set active(bool v) {
    _active = v;
    _activeSet = true;
  }

  /// Column Width

  int get columnWidth {
    if (!_columnWidthSet && _apiMapResponse.containsKey('column_width')) {
      _columnWidth = _apiMapResponse['column_width'];
      _columnWidthSet = true;
    }
    return _columnWidth;
  }

  set columnWidth(int v) {
    _columnWidth = v;
    _columnWidthSet = true;
  }

  /// Width

  int get width {
    if (!_widthSet && _apiMapResponse.containsKey('width')) {
      _width = _apiMapResponse['width'];
      _widthSet = true;
    }
    return _width;
  }

  set width(int v) {
    _width = v;
    _widthSet = true;
  }

  /// Whether or not the dashboard layout is deleted. (read-only)

  bool get deleted {
    if (!_deletedSet && _apiMapResponse.containsKey('deleted')) {
      _deleted = _apiMapResponse['deleted'];
      _deletedSet = true;
    }
    return _deleted;
  }

  set deleted(bool v) {
    _deleted = v;
    _deletedSet = true;
  }

  /// Title extracted from the dashboard this layout represents. (read-only)

  String get dashboardTitle {
    if (!_dashboardTitleSet && _apiMapResponse.containsKey('dashboard_title')) {
      _dashboardTitle = _apiMapResponse['dashboard_title']?.toString();
      _dashboardTitleSet = true;
    }
    return _dashboardTitle;
  }

  set dashboardTitle(String v) {
    _dashboardTitle = v;
    _dashboardTitleSet = true;
  }

  /// Components (read-only)

  List<DashboardLayoutComponent> get dashboardLayoutComponents {
    if (!_dashboardLayoutComponentsSet &&
        _apiMapResponse.containsKey('dashboard_layout_components')) {
      _dashboardLayoutComponents =
          _apiMapResponse['dashboard_layout_components'] == null
              ? null
              : (_apiMapResponse['dashboard_layout_components'] as List)
                  .map((i) => DashboardLayoutComponent.fromResponse(
                      i, apiResponseContentType))
                  .toList();
      _dashboardLayoutComponentsSet = true;
    }
    return _dashboardLayoutComponents;
  }

  set dashboardLayoutComponents(List<DashboardLayoutComponent> v) {
    _dashboardLayoutComponents = v;
    _dashboardLayoutComponentsSet = true;
  }

  DashboardLayout() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DashboardLayout.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_activeSet || _apiMapResponse.containsKey('active')) {
      json['active'] = active;
    }
    if (_columnWidthSet || _apiMapResponse.containsKey('column_width')) {
      json['column_width'] = columnWidth;
    }
    if (_widthSet || _apiMapResponse.containsKey('width')) {
      json['width'] = width;
    }
    if (_deletedSet || _apiMapResponse.containsKey('deleted')) {
      json['deleted'] = deleted;
    }
    if (_dashboardTitleSet || _apiMapResponse.containsKey('dashboard_title')) {
      json['dashboard_title'] = dashboardTitle;
    }
    if (_dashboardLayoutComponentsSet ||
        _apiMapResponse.containsKey('dashboard_layout_components')) {
      json['dashboard_layout_components'] =
          dashboardLayoutComponents?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class DashboardLayoutComponent {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _id;
  bool _idSet = false;

  String _dashboardLayoutId;
  bool _dashboardLayoutIdSet = false;

  String _dashboardElementId;
  bool _dashboardElementIdSet = false;

  int _row;
  bool _rowSet = false;

  int _column;
  bool _columnSet = false;

  int _width;
  bool _widthSet = false;

  int _height;
  bool _heightSet = false;

  bool _deleted;
  bool _deletedSet = false;

  String _elementTitle;
  bool _elementTitleSet = false;

  bool _elementTitleHidden;
  bool _elementTitleHiddenSet = false;

  String _visType;
  bool _visTypeSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Id of Dashboard Layout

  String get dashboardLayoutId {
    if (!_dashboardLayoutIdSet &&
        _apiMapResponse.containsKey('dashboard_layout_id')) {
      _dashboardLayoutId = _apiMapResponse['dashboard_layout_id']?.toString();
      _dashboardLayoutIdSet = true;
    }
    return _dashboardLayoutId;
  }

  set dashboardLayoutId(String v) {
    _dashboardLayoutId = v;
    _dashboardLayoutIdSet = true;
  }

  /// Id Of Dashboard Element

  String get dashboardElementId {
    if (!_dashboardElementIdSet &&
        _apiMapResponse.containsKey('dashboard_element_id')) {
      _dashboardElementId = _apiMapResponse['dashboard_element_id']?.toString();
      _dashboardElementIdSet = true;
    }
    return _dashboardElementId;
  }

  set dashboardElementId(String v) {
    _dashboardElementId = v;
    _dashboardElementIdSet = true;
  }

  /// Row

  int get row {
    if (!_rowSet && _apiMapResponse.containsKey('row')) {
      _row = _apiMapResponse['row'];
      _rowSet = true;
    }
    return _row;
  }

  set row(int v) {
    _row = v;
    _rowSet = true;
  }

  /// Column

  int get column {
    if (!_columnSet && _apiMapResponse.containsKey('column')) {
      _column = _apiMapResponse['column'];
      _columnSet = true;
    }
    return _column;
  }

  set column(int v) {
    _column = v;
    _columnSet = true;
  }

  /// Width

  int get width {
    if (!_widthSet && _apiMapResponse.containsKey('width')) {
      _width = _apiMapResponse['width'];
      _widthSet = true;
    }
    return _width;
  }

  set width(int v) {
    _width = v;
    _widthSet = true;
  }

  /// Height

  int get height {
    if (!_heightSet && _apiMapResponse.containsKey('height')) {
      _height = _apiMapResponse['height'];
      _heightSet = true;
    }
    return _height;
  }

  set height(int v) {
    _height = v;
    _heightSet = true;
  }

  /// Whether or not the dashboard layout component is deleted (read-only)

  bool get deleted {
    if (!_deletedSet && _apiMapResponse.containsKey('deleted')) {
      _deleted = _apiMapResponse['deleted'];
      _deletedSet = true;
    }
    return _deleted;
  }

  set deleted(bool v) {
    _deleted = v;
    _deletedSet = true;
  }

  /// Dashboard element title, extracted from the Dashboard Element. (read-only)

  String get elementTitle {
    if (!_elementTitleSet && _apiMapResponse.containsKey('element_title')) {
      _elementTitle = _apiMapResponse['element_title']?.toString();
      _elementTitleSet = true;
    }
    return _elementTitle;
  }

  set elementTitle(String v) {
    _elementTitle = v;
    _elementTitleSet = true;
  }

  /// Whether or not the dashboard element title is displayed. (read-only)

  bool get elementTitleHidden {
    if (!_elementTitleHiddenSet &&
        _apiMapResponse.containsKey('element_title_hidden')) {
      _elementTitleHidden = _apiMapResponse['element_title_hidden'];
      _elementTitleHiddenSet = true;
    }
    return _elementTitleHidden;
  }

  set elementTitleHidden(bool v) {
    _elementTitleHidden = v;
    _elementTitleHiddenSet = true;
  }

  /// Visualization type, extracted from a query's vis_config (read-only)

  String get visType {
    if (!_visTypeSet && _apiMapResponse.containsKey('vis_type')) {
      _visType = _apiMapResponse['vis_type']?.toString();
      _visTypeSet = true;
    }
    return _visType;
  }

  set visType(String v) {
    _visType = v;
    _visTypeSet = true;
  }

  DashboardLayoutComponent() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DashboardLayoutComponent.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_dashboardLayoutIdSet ||
        _apiMapResponse.containsKey('dashboard_layout_id')) {
      json['dashboard_layout_id'] = dashboardLayoutId;
    }
    if (_dashboardElementIdSet ||
        _apiMapResponse.containsKey('dashboard_element_id')) {
      json['dashboard_element_id'] = dashboardElementId;
    }
    if (_rowSet || _apiMapResponse.containsKey('row')) {
      json['row'] = row;
    }
    if (_columnSet || _apiMapResponse.containsKey('column')) {
      json['column'] = column;
    }
    if (_widthSet || _apiMapResponse.containsKey('width')) {
      json['width'] = width;
    }
    if (_heightSet || _apiMapResponse.containsKey('height')) {
      json['height'] = height;
    }
    if (_deletedSet || _apiMapResponse.containsKey('deleted')) {
      json['deleted'] = deleted;
    }
    if (_elementTitleSet || _apiMapResponse.containsKey('element_title')) {
      json['element_title'] = elementTitle;
    }
    if (_elementTitleHiddenSet ||
        _apiMapResponse.containsKey('element_title_hidden')) {
      json['element_title_hidden'] = elementTitleHidden;
    }
    if (_visTypeSet || _apiMapResponse.containsKey('vis_type')) {
      json['vis_type'] = visType;
    }
    return json;
  }
}

class DashboardLookml {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _dashboardId;
  bool _dashboardIdSet = false;

  String _lookml;
  bool _lookmlSet = false;

  /// Id of Dashboard (read-only)

  String get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id']?.toString();
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(String v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// lookml of UDD (read-only)

  String get lookml {
    if (!_lookmlSet && _apiMapResponse.containsKey('lookml')) {
      _lookml = _apiMapResponse['lookml']?.toString();
      _lookmlSet = true;
    }
    return _lookml;
  }

  set lookml(String v) {
    _lookml = v;
    _lookmlSet = true;
  }

  DashboardLookml() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DashboardLookml.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_lookmlSet || _apiMapResponse.containsKey('lookml')) {
      json['lookml'] = lookml;
    }
    return json;
  }
}

class DataActionForm {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  DataActionUserState _state;
  bool _stateSet = false;

  List<DataActionFormField> _fields;
  bool _fieldsSet = false;

  DataActionUserState get state {
    if (!_stateSet && _apiMapResponse.containsKey('state')) {
      _state = _apiMapResponse['state'] == null
          ? null
          : DataActionUserState.fromResponse(
              _apiMapResponse['state'], apiResponseContentType);
      _stateSet = true;
    }
    return _state;
  }

  set state(DataActionUserState v) {
    _state = v;
    _stateSet = true;
  }

  /// Array of form fields. (read-only)

  List<DataActionFormField> get fields {
    if (!_fieldsSet && _apiMapResponse.containsKey('fields')) {
      _fields = _apiMapResponse['fields'] == null
          ? null
          : (_apiMapResponse['fields'] as List)
              .map((i) =>
                  DataActionFormField.fromResponse(i, apiResponseContentType))
              .toList();
      _fieldsSet = true;
    }
    return _fields;
  }

  set fields(List<DataActionFormField> v) {
    _fields = v;
    _fieldsSet = true;
  }

  DataActionForm() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DataActionForm.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_stateSet || _apiMapResponse.containsKey('state')) {
      json['state'] = state?.toJson();
    }
    if (_fieldsSet || _apiMapResponse.containsKey('fields')) {
      json['fields'] = fields?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class DataActionFormField {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _label;
  bool _labelSet = false;

  String _description;
  bool _descriptionSet = false;

  String _type;
  bool _typeSet = false;

  String _defaultValue;
  bool _defaultValueSet = false;

  String _oauthUrl;
  bool _oauthUrlSet = false;

  bool _interactive;
  bool _interactiveSet = false;

  bool _required;
  bool _requiredSet = false;

  List<DataActionFormSelectOption> _options;
  bool _optionsSet = false;

  /// Name (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Human-readable label (read-only)

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// Description of field (read-only)

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Type of field. (read-only)

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Default value of the field. (read-only)

  String get defaultValue {
    if (!_defaultValueSet && _apiMapResponse.containsKey('default')) {
      _defaultValue = _apiMapResponse['default']?.toString();
      _defaultValueSet = true;
    }
    return _defaultValue;
  }

  set defaultValue(String v) {
    _defaultValue = v;
    _defaultValueSet = true;
  }

  /// The URL for an oauth link, if type is 'oauth_link'. (read-only)

  String get oauthUrl {
    if (!_oauthUrlSet && _apiMapResponse.containsKey('oauth_url')) {
      _oauthUrl = _apiMapResponse['oauth_url']?.toString();
      _oauthUrlSet = true;
    }
    return _oauthUrl;
  }

  set oauthUrl(String v) {
    _oauthUrl = v;
    _oauthUrlSet = true;
  }

  /// Whether or not a field supports interactive forms. (read-only)

  bool get interactive {
    if (!_interactiveSet && _apiMapResponse.containsKey('interactive')) {
      _interactive = _apiMapResponse['interactive'];
      _interactiveSet = true;
    }
    return _interactive;
  }

  set interactive(bool v) {
    _interactive = v;
    _interactiveSet = true;
  }

  /// Whether or not the field is required. This is a user-interface hint. A user interface displaying this form should not submit it without a value for this field. The action server must also perform this validation. (read-only)

  bool get required {
    if (!_requiredSet && _apiMapResponse.containsKey('required')) {
      _required = _apiMapResponse['required'];
      _requiredSet = true;
    }
    return _required;
  }

  set required(bool v) {
    _required = v;
    _requiredSet = true;
  }

  /// If the form type is 'select', a list of options to be selected from. (read-only)

  List<DataActionFormSelectOption> get options {
    if (!_optionsSet && _apiMapResponse.containsKey('options')) {
      _options = _apiMapResponse['options'] == null
          ? null
          : (_apiMapResponse['options'] as List)
              .map((i) => DataActionFormSelectOption.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _optionsSet = true;
    }
    return _options;
  }

  set options(List<DataActionFormSelectOption> v) {
    _options = v;
    _optionsSet = true;
  }

  DataActionFormField() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DataActionFormField.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_defaultValueSet || _apiMapResponse.containsKey('default')) {
      json['default'] = defaultValue;
    }
    if (_oauthUrlSet || _apiMapResponse.containsKey('oauth_url')) {
      json['oauth_url'] = oauthUrl;
    }
    if (_interactiveSet || _apiMapResponse.containsKey('interactive')) {
      json['interactive'] = interactive;
    }
    if (_requiredSet || _apiMapResponse.containsKey('required')) {
      json['required'] = required;
    }
    if (_optionsSet || _apiMapResponse.containsKey('options')) {
      json['options'] = options?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class DataActionFormSelectOption {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _label;
  bool _labelSet = false;

  /// Name (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Human-readable label (read-only)

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  DataActionFormSelectOption() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DataActionFormSelectOption.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    return json;
  }
}

class DataActionRequest {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _action;
  bool _actionSet = false;

  Map<String, dynamic> _formValues;
  bool _formValuesSet = false;

  /// The JSON describing the data action. This JSON should be considered opaque and should be passed through unmodified from the query result it came from.

  Map<String, dynamic> get action {
    if (!_actionSet && _apiMapResponse.containsKey('action')) {
      _action = _apiMapResponse['action'];
      _actionSet = true;
    }
    return _action;
  }

  set action(Map<String, dynamic> v) {
    _action = v;
    _actionSet = true;
  }

  /// User input for any form values the data action might use.

  Map<String, dynamic> get formValues {
    if (!_formValuesSet && _apiMapResponse.containsKey('form_values')) {
      _formValues = _apiMapResponse['form_values'];
      _formValuesSet = true;
    }
    return _formValues;
  }

  set formValues(Map<String, dynamic> v) {
    _formValues = v;
    _formValuesSet = true;
  }

  DataActionRequest() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DataActionRequest.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_actionSet || _apiMapResponse.containsKey('action')) {
      json['action'] = action;
    }
    if (_formValuesSet || _apiMapResponse.containsKey('form_values')) {
      json['form_values'] = formValues;
    }
    return json;
  }
}

class DataActionResponse {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _webhookId;
  bool _webhookIdSet = false;

  bool _success;
  bool _successSet = false;

  bool _refreshQuery;
  bool _refreshQuerySet = false;

  ValidationError _validationErrors;
  bool _validationErrorsSet = false;

  String _message;
  bool _messageSet = false;

  /// ID of the webhook event that sent this data action. In some error conditions, this may be null. (read-only)

  String get webhookId {
    if (!_webhookIdSet && _apiMapResponse.containsKey('webhook_id')) {
      _webhookId = _apiMapResponse['webhook_id']?.toString();
      _webhookIdSet = true;
    }
    return _webhookId;
  }

  set webhookId(String v) {
    _webhookId = v;
    _webhookIdSet = true;
  }

  /// Whether the data action was successful. (read-only)

  bool get success {
    if (!_successSet && _apiMapResponse.containsKey('success')) {
      _success = _apiMapResponse['success'];
      _successSet = true;
    }
    return _success;
  }

  set success(bool v) {
    _success = v;
    _successSet = true;
  }

  /// When true, indicates that the client should refresh (rerun) the source query because the data may have been changed by the action. (read-only)

  bool get refreshQuery {
    if (!_refreshQuerySet && _apiMapResponse.containsKey('refresh_query')) {
      _refreshQuery = _apiMapResponse['refresh_query'];
      _refreshQuerySet = true;
    }
    return _refreshQuery;
  }

  set refreshQuery(bool v) {
    _refreshQuery = v;
    _refreshQuerySet = true;
  }

  ValidationError get validationErrors {
    if (!_validationErrorsSet &&
        _apiMapResponse.containsKey('validation_errors')) {
      _validationErrors = _apiMapResponse['validation_errors'] == null
          ? null
          : ValidationError.fromResponse(
              _apiMapResponse['validation_errors'], apiResponseContentType);
      _validationErrorsSet = true;
    }
    return _validationErrors;
  }

  set validationErrors(ValidationError v) {
    _validationErrors = v;
    _validationErrorsSet = true;
  }

  /// Optional message returned by the data action server describing the state of the action that took place. This can be used to implement custom failure messages. If a failure is related to a particular form field, the server should send back a validation error instead. The Looker web UI does not currently display any message if the action indicates 'success', but may do so in the future. (read-only)

  String get message {
    if (!_messageSet && _apiMapResponse.containsKey('message')) {
      _message = _apiMapResponse['message']?.toString();
      _messageSet = true;
    }
    return _message;
  }

  set message(String v) {
    _message = v;
    _messageSet = true;
  }

  DataActionResponse() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DataActionResponse.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_webhookIdSet || _apiMapResponse.containsKey('webhook_id')) {
      json['webhook_id'] = webhookId;
    }
    if (_successSet || _apiMapResponse.containsKey('success')) {
      json['success'] = success;
    }
    if (_refreshQuerySet || _apiMapResponse.containsKey('refresh_query')) {
      json['refresh_query'] = refreshQuery;
    }
    if (_validationErrorsSet ||
        _apiMapResponse.containsKey('validation_errors')) {
      json['validation_errors'] = validationErrors?.toJson();
    }
    if (_messageSet || _apiMapResponse.containsKey('message')) {
      json['message'] = message;
    }
    return json;
  }
}

class DataActionUserState {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _data;
  bool _dataSet = false;

  int _refreshTime;
  bool _refreshTimeSet = false;

  /// User state data (read-only)

  String get data {
    if (!_dataSet && _apiMapResponse.containsKey('data')) {
      _data = _apiMapResponse['data']?.toString();
      _dataSet = true;
    }
    return _data;
  }

  set data(String v) {
    _data = v;
    _dataSet = true;
  }

  /// Time in seconds until the state needs to be refreshed (read-only)

  int get refreshTime {
    if (!_refreshTimeSet && _apiMapResponse.containsKey('refresh_time')) {
      _refreshTime = _apiMapResponse['refresh_time'];
      _refreshTimeSet = true;
    }
    return _refreshTime;
  }

  set refreshTime(int v) {
    _refreshTime = v;
    _refreshTimeSet = true;
  }

  DataActionUserState() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DataActionUserState.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_dataSet || _apiMapResponse.containsKey('data')) {
      json['data'] = data;
    }
    if (_refreshTimeSet || _apiMapResponse.containsKey('refresh_time')) {
      json['refresh_time'] = refreshTime;
    }
    return json;
  }
}

class Datagroup {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _createdAt;
  bool _createdAtSet = false;

  int _id;
  bool _idSet = false;

  String _modelName;
  bool _modelNameSet = false;

  String _name;
  bool _nameSet = false;

  int _staleBefore;
  bool _staleBeforeSet = false;

  int _triggerCheckAt;
  bool _triggerCheckAtSet = false;

  String _triggerError;
  bool _triggerErrorSet = false;

  String _triggerValue;
  bool _triggerValueSet = false;

  int _triggeredAt;
  bool _triggeredAtSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// UNIX timestamp at which this entry was created. (read-only)

  int get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at'];
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(int v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// Unique ID of the datagroup (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Name of the model containing the datagroup. Unique when combined with name. (read-only)

  String get modelName {
    if (!_modelNameSet && _apiMapResponse.containsKey('model_name')) {
      _modelName = _apiMapResponse['model_name']?.toString();
      _modelNameSet = true;
    }
    return _modelName;
  }

  set modelName(String v) {
    _modelName = v;
    _modelNameSet = true;
  }

  /// Name of the datagroup. Unique when combined with model_name. (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// UNIX timestamp before which cache entries are considered stale. Cannot be in the future.

  int get staleBefore {
    if (!_staleBeforeSet && _apiMapResponse.containsKey('stale_before')) {
      _staleBefore = _apiMapResponse['stale_before'];
      _staleBeforeSet = true;
    }
    return _staleBefore;
  }

  set staleBefore(int v) {
    _staleBefore = v;
    _staleBeforeSet = true;
  }

  /// UNIX timestamp at which this entry trigger was last checked. (read-only)

  int get triggerCheckAt {
    if (!_triggerCheckAtSet &&
        _apiMapResponse.containsKey('trigger_check_at')) {
      _triggerCheckAt = _apiMapResponse['trigger_check_at'];
      _triggerCheckAtSet = true;
    }
    return _triggerCheckAt;
  }

  set triggerCheckAt(int v) {
    _triggerCheckAt = v;
    _triggerCheckAtSet = true;
  }

  /// The message returned with the error of the last trigger check. (read-only)

  String get triggerError {
    if (!_triggerErrorSet && _apiMapResponse.containsKey('trigger_error')) {
      _triggerError = _apiMapResponse['trigger_error']?.toString();
      _triggerErrorSet = true;
    }
    return _triggerError;
  }

  set triggerError(String v) {
    _triggerError = v;
    _triggerErrorSet = true;
  }

  /// The value of the trigger when last checked. (read-only)

  String get triggerValue {
    if (!_triggerValueSet && _apiMapResponse.containsKey('trigger_value')) {
      _triggerValue = _apiMapResponse['trigger_value']?.toString();
      _triggerValueSet = true;
    }
    return _triggerValue;
  }

  set triggerValue(String v) {
    _triggerValue = v;
    _triggerValueSet = true;
  }

  /// UNIX timestamp at which this entry became triggered. Cannot be in the future.

  int get triggeredAt {
    if (!_triggeredAtSet && _apiMapResponse.containsKey('triggered_at')) {
      _triggeredAt = _apiMapResponse['triggered_at'];
      _triggeredAtSet = true;
    }
    return _triggeredAt;
  }

  set triggeredAt(int v) {
    _triggeredAt = v;
    _triggeredAtSet = true;
  }

  Datagroup() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Datagroup.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_modelNameSet || _apiMapResponse.containsKey('model_name')) {
      json['model_name'] = modelName;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_staleBeforeSet || _apiMapResponse.containsKey('stale_before')) {
      json['stale_before'] = staleBefore;
    }
    if (_triggerCheckAtSet || _apiMapResponse.containsKey('trigger_check_at')) {
      json['trigger_check_at'] = triggerCheckAt;
    }
    if (_triggerErrorSet || _apiMapResponse.containsKey('trigger_error')) {
      json['trigger_error'] = triggerError;
    }
    if (_triggerValueSet || _apiMapResponse.containsKey('trigger_value')) {
      json['trigger_value'] = triggerValue;
    }
    if (_triggeredAtSet || _apiMapResponse.containsKey('triggered_at')) {
      json['triggered_at'] = triggeredAt;
    }
    return json;
  }
}

class DBConnection {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _name;
  bool _nameSet = false;

  Dialect _dialect;
  bool _dialectSet = false;

  List<Snippet> _snippets;
  bool _snippetsSet = false;

  bool _pdtsEnabled;
  bool _pdtsEnabledSet = false;

  String _host;
  bool _hostSet = false;

  String _port;
  bool _portSet = false;

  String _username;
  bool _usernameSet = false;

  String _password;
  bool _passwordSet = false;

  bool _usesOauth;
  bool _usesOauthSet = false;

  String _certificate;
  bool _certificateSet = false;

  String _fileType;
  bool _fileTypeSet = false;

  String _database;
  bool _databaseSet = false;

  String _dbTimezone;
  bool _dbTimezoneSet = false;

  String _queryTimezone;
  bool _queryTimezoneSet = false;

  String _schema;
  bool _schemaSet = false;

  int _maxConnections;
  bool _maxConnectionsSet = false;

  String _maxBillingGigabytes;
  bool _maxBillingGigabytesSet = false;

  bool _ssl;
  bool _sslSet = false;

  bool _verifySsl;
  bool _verifySslSet = false;

  String _tmpDbName;
  bool _tmpDbNameSet = false;

  String _jdbcAdditionalParams;
  bool _jdbcAdditionalParamsSet = false;

  int _poolTimeout;
  bool _poolTimeoutSet = false;

  String _dialectName;
  bool _dialectNameSet = false;

  String _createdAt;
  bool _createdAtSet = false;

  String _userId;
  bool _userIdSet = false;

  bool _example;
  bool _exampleSet = false;

  bool _userDbCredentials;
  bool _userDbCredentialsSet = false;

  List<String> _userAttributeFields;
  bool _userAttributeFieldsSet = false;

  String _maintenanceCron;
  bool _maintenanceCronSet = false;

  String _lastRegenAt;
  bool _lastRegenAtSet = false;

  String _lastReapAt;
  bool _lastReapAtSet = false;

  bool _sqlRunnerPrecacheTables;
  bool _sqlRunnerPrecacheTablesSet = false;

  bool _sqlWritingWithInfoSchema;
  bool _sqlWritingWithInfoSchemaSet = false;

  String _afterConnectStatements;
  bool _afterConnectStatementsSet = false;

  DBConnectionOverride _pdtContextOverride;
  bool _pdtContextOverrideSet = false;

  bool _managed;
  bool _managedSet = false;

  String _tunnelId;
  bool _tunnelIdSet = false;

  int _pdtConcurrency;
  bool _pdtConcurrencySet = false;

  bool _disableContextComment;
  bool _disableContextCommentSet = false;

  int _oauthApplicationId;
  bool _oauthApplicationIdSet = false;

  bool _alwaysRetryFailedBuilds;
  bool _alwaysRetryFailedBuildsSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Name of the connection. Also used as the unique identifier

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  Dialect get dialect {
    if (!_dialectSet && _apiMapResponse.containsKey('dialect')) {
      _dialect = _apiMapResponse['dialect'] == null
          ? null
          : Dialect.fromResponse(
              _apiMapResponse['dialect'], apiResponseContentType);
      _dialectSet = true;
    }
    return _dialect;
  }

  set dialect(Dialect v) {
    _dialect = v;
    _dialectSet = true;
  }

  /// SQL Runner snippets for this connection (read-only)

  List<Snippet> get snippets {
    if (!_snippetsSet && _apiMapResponse.containsKey('snippets')) {
      _snippets = _apiMapResponse['snippets'] == null
          ? null
          : (_apiMapResponse['snippets'] as List)
              .map((i) => Snippet.fromResponse(i, apiResponseContentType))
              .toList();
      _snippetsSet = true;
    }
    return _snippets;
  }

  set snippets(List<Snippet> v) {
    _snippets = v;
    _snippetsSet = true;
  }

  /// True if PDTs are enabled on this connection (read-only)

  bool get pdtsEnabled {
    if (!_pdtsEnabledSet && _apiMapResponse.containsKey('pdts_enabled')) {
      _pdtsEnabled = _apiMapResponse['pdts_enabled'];
      _pdtsEnabledSet = true;
    }
    return _pdtsEnabled;
  }

  set pdtsEnabled(bool v) {
    _pdtsEnabled = v;
    _pdtsEnabledSet = true;
  }

  /// Host name/address of server

  String get host {
    if (!_hostSet && _apiMapResponse.containsKey('host')) {
      _host = _apiMapResponse['host']?.toString();
      _hostSet = true;
    }
    return _host;
  }

  set host(String v) {
    _host = v;
    _hostSet = true;
  }

  /// Port number on server

  String get port {
    if (!_portSet && _apiMapResponse.containsKey('port')) {
      _port = _apiMapResponse['port']?.toString();
      _portSet = true;
    }
    return _port;
  }

  set port(String v) {
    _port = v;
    _portSet = true;
  }

  /// Username for server authentication

  String get username {
    if (!_usernameSet && _apiMapResponse.containsKey('username')) {
      _username = _apiMapResponse['username']?.toString();
      _usernameSet = true;
    }
    return _username;
  }

  set username(String v) {
    _username = v;
    _usernameSet = true;
  }

  /// (Write-Only) Password for server authentication

  String get password {
    if (!_passwordSet && _apiMapResponse.containsKey('password')) {
      _password = _apiMapResponse['password']?.toString();
      _passwordSet = true;
    }
    return _password;
  }

  set password(String v) {
    _password = v;
    _passwordSet = true;
  }

  /// Whether the connection uses OAuth for authentication. (read-only)

  bool get usesOauth {
    if (!_usesOauthSet && _apiMapResponse.containsKey('uses_oauth')) {
      _usesOauth = _apiMapResponse['uses_oauth'];
      _usesOauthSet = true;
    }
    return _usesOauth;
  }

  set usesOauth(bool v) {
    _usesOauth = v;
    _usesOauthSet = true;
  }

  /// (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).

  String get certificate {
    if (!_certificateSet && _apiMapResponse.containsKey('certificate')) {
      _certificate = _apiMapResponse['certificate']?.toString();
      _certificateSet = true;
    }
    return _certificate;
  }

  set certificate(String v) {
    _certificate = v;
    _certificateSet = true;
  }

  /// (Write-Only) Certificate keyfile type - .json or .p12

  String get fileType {
    if (!_fileTypeSet && _apiMapResponse.containsKey('file_type')) {
      _fileType = _apiMapResponse['file_type']?.toString();
      _fileTypeSet = true;
    }
    return _fileType;
  }

  set fileType(String v) {
    _fileType = v;
    _fileTypeSet = true;
  }

  /// Database name

  String get database {
    if (!_databaseSet && _apiMapResponse.containsKey('database')) {
      _database = _apiMapResponse['database']?.toString();
      _databaseSet = true;
    }
    return _database;
  }

  set database(String v) {
    _database = v;
    _databaseSet = true;
  }

  /// Time zone of database

  String get dbTimezone {
    if (!_dbTimezoneSet && _apiMapResponse.containsKey('db_timezone')) {
      _dbTimezone = _apiMapResponse['db_timezone']?.toString();
      _dbTimezoneSet = true;
    }
    return _dbTimezone;
  }

  set dbTimezone(String v) {
    _dbTimezone = v;
    _dbTimezoneSet = true;
  }

  /// Timezone to use in queries

  String get queryTimezone {
    if (!_queryTimezoneSet && _apiMapResponse.containsKey('query_timezone')) {
      _queryTimezone = _apiMapResponse['query_timezone']?.toString();
      _queryTimezoneSet = true;
    }
    return _queryTimezone;
  }

  set queryTimezone(String v) {
    _queryTimezone = v;
    _queryTimezoneSet = true;
  }

  /// Scheme name

  String get schema {
    if (!_schemaSet && _apiMapResponse.containsKey('schema')) {
      _schema = _apiMapResponse['schema']?.toString();
      _schemaSet = true;
    }
    return _schema;
  }

  set schema(String v) {
    _schema = v;
    _schemaSet = true;
  }

  /// Maximum number of concurrent connection to use

  int get maxConnections {
    if (!_maxConnectionsSet && _apiMapResponse.containsKey('max_connections')) {
      _maxConnections = _apiMapResponse['max_connections'];
      _maxConnectionsSet = true;
    }
    return _maxConnections;
  }

  set maxConnections(int v) {
    _maxConnections = v;
    _maxConnectionsSet = true;
  }

  /// Maximum size of query in GBs (BigQuery only, can be a user_attribute name)

  String get maxBillingGigabytes {
    if (!_maxBillingGigabytesSet &&
        _apiMapResponse.containsKey('max_billing_gigabytes')) {
      _maxBillingGigabytes =
          _apiMapResponse['max_billing_gigabytes']?.toString();
      _maxBillingGigabytesSet = true;
    }
    return _maxBillingGigabytes;
  }

  set maxBillingGigabytes(String v) {
    _maxBillingGigabytes = v;
    _maxBillingGigabytesSet = true;
  }

  /// Use SSL/TLS when connecting to server

  bool get ssl {
    if (!_sslSet && _apiMapResponse.containsKey('ssl')) {
      _ssl = _apiMapResponse['ssl'];
      _sslSet = true;
    }
    return _ssl;
  }

  set ssl(bool v) {
    _ssl = v;
    _sslSet = true;
  }

  /// Verify the SSL

  bool get verifySsl {
    if (!_verifySslSet && _apiMapResponse.containsKey('verify_ssl')) {
      _verifySsl = _apiMapResponse['verify_ssl'];
      _verifySslSet = true;
    }
    return _verifySsl;
  }

  set verifySsl(bool v) {
    _verifySsl = v;
    _verifySslSet = true;
  }

  /// Name of temporary database (if used)

  String get tmpDbName {
    if (!_tmpDbNameSet && _apiMapResponse.containsKey('tmp_db_name')) {
      _tmpDbName = _apiMapResponse['tmp_db_name']?.toString();
      _tmpDbNameSet = true;
    }
    return _tmpDbName;
  }

  set tmpDbName(String v) {
    _tmpDbName = v;
    _tmpDbNameSet = true;
  }

  /// Additional params to add to JDBC connection string

  String get jdbcAdditionalParams {
    if (!_jdbcAdditionalParamsSet &&
        _apiMapResponse.containsKey('jdbc_additional_params')) {
      _jdbcAdditionalParams =
          _apiMapResponse['jdbc_additional_params']?.toString();
      _jdbcAdditionalParamsSet = true;
    }
    return _jdbcAdditionalParams;
  }

  set jdbcAdditionalParams(String v) {
    _jdbcAdditionalParams = v;
    _jdbcAdditionalParamsSet = true;
  }

  /// Connection Pool Timeout, in seconds

  int get poolTimeout {
    if (!_poolTimeoutSet && _apiMapResponse.containsKey('pool_timeout')) {
      _poolTimeout = _apiMapResponse['pool_timeout'];
      _poolTimeoutSet = true;
    }
    return _poolTimeout;
  }

  set poolTimeout(int v) {
    _poolTimeout = v;
    _poolTimeoutSet = true;
  }

  /// (Read/Write) SQL Dialect name

  String get dialectName {
    if (!_dialectNameSet && _apiMapResponse.containsKey('dialect_name')) {
      _dialectName = _apiMapResponse['dialect_name']?.toString();
      _dialectNameSet = true;
    }
    return _dialectName;
  }

  set dialectName(String v) {
    _dialectName = v;
    _dialectNameSet = true;
  }

  /// Creation date for this connection (read-only)

  String get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at']?.toString();
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(String v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// Id of user who last modified this connection configuration (read-only)

  String get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id']?.toString();
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(String v) {
    _userId = v;
    _userIdSet = true;
  }

  /// Is this an example connection? (read-only)

  bool get example {
    if (!_exampleSet && _apiMapResponse.containsKey('example')) {
      _example = _apiMapResponse['example'];
      _exampleSet = true;
    }
    return _example;
  }

  set example(bool v) {
    _example = v;
    _exampleSet = true;
  }

  /// (Limited access feature) Are per user db credentials enabled. Enabling will remove previously set username and password

  bool get userDbCredentials {
    if (!_userDbCredentialsSet &&
        _apiMapResponse.containsKey('user_db_credentials')) {
      _userDbCredentials = _apiMapResponse['user_db_credentials'];
      _userDbCredentialsSet = true;
    }
    return _userDbCredentials;
  }

  set userDbCredentials(bool v) {
    _userDbCredentials = v;
    _userDbCredentialsSet = true;
  }

  /// Fields whose values map to user attribute names

  List<String> get userAttributeFields {
    if (!_userAttributeFieldsSet &&
        _apiMapResponse.containsKey('user_attribute_fields')) {
      _userAttributeFields = _apiMapResponse['user_attribute_fields']
          ?.map<String>((i) => i as String)
          ?.toList();
      _userAttributeFieldsSet = true;
    }
    return _userAttributeFields;
  }

  set userAttributeFields(List<String> v) {
    _userAttributeFields = v;
    _userAttributeFieldsSet = true;
  }

  /// Cron string specifying when maintenance such as PDT trigger checks and drops should be performed

  String get maintenanceCron {
    if (!_maintenanceCronSet &&
        _apiMapResponse.containsKey('maintenance_cron')) {
      _maintenanceCron = _apiMapResponse['maintenance_cron']?.toString();
      _maintenanceCronSet = true;
    }
    return _maintenanceCron;
  }

  set maintenanceCron(String v) {
    _maintenanceCron = v;
    _maintenanceCronSet = true;
  }

  /// Unix timestamp at start of last completed PDT trigger check process (read-only)

  String get lastRegenAt {
    if (!_lastRegenAtSet && _apiMapResponse.containsKey('last_regen_at')) {
      _lastRegenAt = _apiMapResponse['last_regen_at']?.toString();
      _lastRegenAtSet = true;
    }
    return _lastRegenAt;
  }

  set lastRegenAt(String v) {
    _lastRegenAt = v;
    _lastRegenAtSet = true;
  }

  /// Unix timestamp at start of last completed PDT reap process (read-only)

  String get lastReapAt {
    if (!_lastReapAtSet && _apiMapResponse.containsKey('last_reap_at')) {
      _lastReapAt = _apiMapResponse['last_reap_at']?.toString();
      _lastReapAtSet = true;
    }
    return _lastReapAt;
  }

  set lastReapAt(String v) {
    _lastReapAt = v;
    _lastReapAtSet = true;
  }

  /// Precache tables in the SQL Runner

  bool get sqlRunnerPrecacheTables {
    if (!_sqlRunnerPrecacheTablesSet &&
        _apiMapResponse.containsKey('sql_runner_precache_tables')) {
      _sqlRunnerPrecacheTables = _apiMapResponse['sql_runner_precache_tables'];
      _sqlRunnerPrecacheTablesSet = true;
    }
    return _sqlRunnerPrecacheTables;
  }

  set sqlRunnerPrecacheTables(bool v) {
    _sqlRunnerPrecacheTables = v;
    _sqlRunnerPrecacheTablesSet = true;
  }

  /// Fetch Information Schema For SQL Writing

  bool get sqlWritingWithInfoSchema {
    if (!_sqlWritingWithInfoSchemaSet &&
        _apiMapResponse.containsKey('sql_writing_with_info_schema')) {
      _sqlWritingWithInfoSchema =
          _apiMapResponse['sql_writing_with_info_schema'];
      _sqlWritingWithInfoSchemaSet = true;
    }
    return _sqlWritingWithInfoSchema;
  }

  set sqlWritingWithInfoSchema(bool v) {
    _sqlWritingWithInfoSchema = v;
    _sqlWritingWithInfoSchemaSet = true;
  }

  /// SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature

  String get afterConnectStatements {
    if (!_afterConnectStatementsSet &&
        _apiMapResponse.containsKey('after_connect_statements')) {
      _afterConnectStatements =
          _apiMapResponse['after_connect_statements']?.toString();
      _afterConnectStatementsSet = true;
    }
    return _afterConnectStatements;
  }

  set afterConnectStatements(String v) {
    _afterConnectStatements = v;
    _afterConnectStatementsSet = true;
  }

  DBConnectionOverride get pdtContextOverride {
    if (!_pdtContextOverrideSet &&
        _apiMapResponse.containsKey('pdt_context_override')) {
      _pdtContextOverride = _apiMapResponse['pdt_context_override'] == null
          ? null
          : DBConnectionOverride.fromResponse(
              _apiMapResponse['pdt_context_override'], apiResponseContentType);
      _pdtContextOverrideSet = true;
    }
    return _pdtContextOverride;
  }

  set pdtContextOverride(DBConnectionOverride v) {
    _pdtContextOverride = v;
    _pdtContextOverrideSet = true;
  }

  /// Is this connection created and managed by Looker (read-only)

  bool get managed {
    if (!_managedSet && _apiMapResponse.containsKey('managed')) {
      _managed = _apiMapResponse['managed'];
      _managedSet = true;
    }
    return _managed;
  }

  set managed(bool v) {
    _managed = v;
    _managedSet = true;
  }

  /// The Id of the ssh tunnel this connection uses

  String get tunnelId {
    if (!_tunnelIdSet && _apiMapResponse.containsKey('tunnel_id')) {
      _tunnelId = _apiMapResponse['tunnel_id']?.toString();
      _tunnelIdSet = true;
    }
    return _tunnelId;
  }

  set tunnelId(String v) {
    _tunnelId = v;
    _tunnelIdSet = true;
  }

  /// Maximum number of threads to use to build PDTs in parallel

  int get pdtConcurrency {
    if (!_pdtConcurrencySet && _apiMapResponse.containsKey('pdt_concurrency')) {
      _pdtConcurrency = _apiMapResponse['pdt_concurrency'];
      _pdtConcurrencySet = true;
    }
    return _pdtConcurrency;
  }

  set pdtConcurrency(int v) {
    _pdtConcurrency = v;
    _pdtConcurrencySet = true;
  }

  /// When disable_context_comment is true comment will not be added to SQL

  bool get disableContextComment {
    if (!_disableContextCommentSet &&
        _apiMapResponse.containsKey('disable_context_comment')) {
      _disableContextComment = _apiMapResponse['disable_context_comment'];
      _disableContextCommentSet = true;
    }
    return _disableContextComment;
  }

  set disableContextComment(bool v) {
    _disableContextComment = v;
    _disableContextCommentSet = true;
  }

  /// An External OAuth Application to use for authenticating to the database

  int get oauthApplicationId {
    if (!_oauthApplicationIdSet &&
        _apiMapResponse.containsKey('oauth_application_id')) {
      _oauthApplicationId = _apiMapResponse['oauth_application_id'];
      _oauthApplicationIdSet = true;
    }
    return _oauthApplicationId;
  }

  set oauthApplicationId(int v) {
    _oauthApplicationId = v;
    _oauthApplicationIdSet = true;
  }

  /// When true, error PDTs will be retried every regenerator cycle

  bool get alwaysRetryFailedBuilds {
    if (!_alwaysRetryFailedBuildsSet &&
        _apiMapResponse.containsKey('always_retry_failed_builds')) {
      _alwaysRetryFailedBuilds = _apiMapResponse['always_retry_failed_builds'];
      _alwaysRetryFailedBuildsSet = true;
    }
    return _alwaysRetryFailedBuilds;
  }

  set alwaysRetryFailedBuilds(bool v) {
    _alwaysRetryFailedBuilds = v;
    _alwaysRetryFailedBuildsSet = true;
  }

  DBConnection() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DBConnection.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_dialectSet || _apiMapResponse.containsKey('dialect')) {
      json['dialect'] = dialect?.toJson();
    }
    if (_snippetsSet || _apiMapResponse.containsKey('snippets')) {
      json['snippets'] = snippets?.map((i) => i.toJson())?.toList();
    }
    if (_pdtsEnabledSet || _apiMapResponse.containsKey('pdts_enabled')) {
      json['pdts_enabled'] = pdtsEnabled;
    }
    if (_hostSet || _apiMapResponse.containsKey('host')) {
      json['host'] = host;
    }
    if (_portSet || _apiMapResponse.containsKey('port')) {
      json['port'] = port;
    }
    if (_usernameSet || _apiMapResponse.containsKey('username')) {
      json['username'] = username;
    }
    if (_passwordSet || _apiMapResponse.containsKey('password')) {
      json['password'] = password;
    }
    if (_usesOauthSet || _apiMapResponse.containsKey('uses_oauth')) {
      json['uses_oauth'] = usesOauth;
    }
    if (_certificateSet || _apiMapResponse.containsKey('certificate')) {
      json['certificate'] = certificate;
    }
    if (_fileTypeSet || _apiMapResponse.containsKey('file_type')) {
      json['file_type'] = fileType;
    }
    if (_databaseSet || _apiMapResponse.containsKey('database')) {
      json['database'] = database;
    }
    if (_dbTimezoneSet || _apiMapResponse.containsKey('db_timezone')) {
      json['db_timezone'] = dbTimezone;
    }
    if (_queryTimezoneSet || _apiMapResponse.containsKey('query_timezone')) {
      json['query_timezone'] = queryTimezone;
    }
    if (_schemaSet || _apiMapResponse.containsKey('schema')) {
      json['schema'] = schema;
    }
    if (_maxConnectionsSet || _apiMapResponse.containsKey('max_connections')) {
      json['max_connections'] = maxConnections;
    }
    if (_maxBillingGigabytesSet ||
        _apiMapResponse.containsKey('max_billing_gigabytes')) {
      json['max_billing_gigabytes'] = maxBillingGigabytes;
    }
    if (_sslSet || _apiMapResponse.containsKey('ssl')) {
      json['ssl'] = ssl;
    }
    if (_verifySslSet || _apiMapResponse.containsKey('verify_ssl')) {
      json['verify_ssl'] = verifySsl;
    }
    if (_tmpDbNameSet || _apiMapResponse.containsKey('tmp_db_name')) {
      json['tmp_db_name'] = tmpDbName;
    }
    if (_jdbcAdditionalParamsSet ||
        _apiMapResponse.containsKey('jdbc_additional_params')) {
      json['jdbc_additional_params'] = jdbcAdditionalParams;
    }
    if (_poolTimeoutSet || _apiMapResponse.containsKey('pool_timeout')) {
      json['pool_timeout'] = poolTimeout;
    }
    if (_dialectNameSet || _apiMapResponse.containsKey('dialect_name')) {
      json['dialect_name'] = dialectName;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt;
    }
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    if (_exampleSet || _apiMapResponse.containsKey('example')) {
      json['example'] = example;
    }
    if (_userDbCredentialsSet ||
        _apiMapResponse.containsKey('user_db_credentials')) {
      json['user_db_credentials'] = userDbCredentials;
    }
    if (_userAttributeFieldsSet ||
        _apiMapResponse.containsKey('user_attribute_fields')) {
      json['user_attribute_fields'] = userAttributeFields;
    }
    if (_maintenanceCronSet ||
        _apiMapResponse.containsKey('maintenance_cron')) {
      json['maintenance_cron'] = maintenanceCron;
    }
    if (_lastRegenAtSet || _apiMapResponse.containsKey('last_regen_at')) {
      json['last_regen_at'] = lastRegenAt;
    }
    if (_lastReapAtSet || _apiMapResponse.containsKey('last_reap_at')) {
      json['last_reap_at'] = lastReapAt;
    }
    if (_sqlRunnerPrecacheTablesSet ||
        _apiMapResponse.containsKey('sql_runner_precache_tables')) {
      json['sql_runner_precache_tables'] = sqlRunnerPrecacheTables;
    }
    if (_sqlWritingWithInfoSchemaSet ||
        _apiMapResponse.containsKey('sql_writing_with_info_schema')) {
      json['sql_writing_with_info_schema'] = sqlWritingWithInfoSchema;
    }
    if (_afterConnectStatementsSet ||
        _apiMapResponse.containsKey('after_connect_statements')) {
      json['after_connect_statements'] = afterConnectStatements;
    }
    if (_pdtContextOverrideSet ||
        _apiMapResponse.containsKey('pdt_context_override')) {
      json['pdt_context_override'] = pdtContextOverride?.toJson();
    }
    if (_managedSet || _apiMapResponse.containsKey('managed')) {
      json['managed'] = managed;
    }
    if (_tunnelIdSet || _apiMapResponse.containsKey('tunnel_id')) {
      json['tunnel_id'] = tunnelId;
    }
    if (_pdtConcurrencySet || _apiMapResponse.containsKey('pdt_concurrency')) {
      json['pdt_concurrency'] = pdtConcurrency;
    }
    if (_disableContextCommentSet ||
        _apiMapResponse.containsKey('disable_context_comment')) {
      json['disable_context_comment'] = disableContextComment;
    }
    if (_oauthApplicationIdSet ||
        _apiMapResponse.containsKey('oauth_application_id')) {
      json['oauth_application_id'] = oauthApplicationId;
    }
    if (_alwaysRetryFailedBuildsSet ||
        _apiMapResponse.containsKey('always_retry_failed_builds')) {
      json['always_retry_failed_builds'] = alwaysRetryFailedBuilds;
    }
    return json;
  }
}

class DBConnectionBase {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _name;
  bool _nameSet = false;

  Dialect _dialect;
  bool _dialectSet = false;

  List<Snippet> _snippets;
  bool _snippetsSet = false;

  bool _pdtsEnabled;
  bool _pdtsEnabledSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Name of the connection. Also used as the unique identifier (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  Dialect get dialect {
    if (!_dialectSet && _apiMapResponse.containsKey('dialect')) {
      _dialect = _apiMapResponse['dialect'] == null
          ? null
          : Dialect.fromResponse(
              _apiMapResponse['dialect'], apiResponseContentType);
      _dialectSet = true;
    }
    return _dialect;
  }

  set dialect(Dialect v) {
    _dialect = v;
    _dialectSet = true;
  }

  /// SQL Runner snippets for this connection (read-only)

  List<Snippet> get snippets {
    if (!_snippetsSet && _apiMapResponse.containsKey('snippets')) {
      _snippets = _apiMapResponse['snippets'] == null
          ? null
          : (_apiMapResponse['snippets'] as List)
              .map((i) => Snippet.fromResponse(i, apiResponseContentType))
              .toList();
      _snippetsSet = true;
    }
    return _snippets;
  }

  set snippets(List<Snippet> v) {
    _snippets = v;
    _snippetsSet = true;
  }

  /// True if PDTs are enabled on this connection (read-only)

  bool get pdtsEnabled {
    if (!_pdtsEnabledSet && _apiMapResponse.containsKey('pdts_enabled')) {
      _pdtsEnabled = _apiMapResponse['pdts_enabled'];
      _pdtsEnabledSet = true;
    }
    return _pdtsEnabled;
  }

  set pdtsEnabled(bool v) {
    _pdtsEnabled = v;
    _pdtsEnabledSet = true;
  }

  DBConnectionBase() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DBConnectionBase.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_dialectSet || _apiMapResponse.containsKey('dialect')) {
      json['dialect'] = dialect?.toJson();
    }
    if (_snippetsSet || _apiMapResponse.containsKey('snippets')) {
      json['snippets'] = snippets?.map((i) => i.toJson())?.toList();
    }
    if (_pdtsEnabledSet || _apiMapResponse.containsKey('pdts_enabled')) {
      json['pdts_enabled'] = pdtsEnabled;
    }
    return json;
  }
}

class DBConnectionOverride {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _context;
  bool _contextSet = false;

  String _host;
  bool _hostSet = false;

  String _port;
  bool _portSet = false;

  String _username;
  bool _usernameSet = false;

  String _password;
  bool _passwordSet = false;

  bool _hasPassword;
  bool _hasPasswordSet = false;

  String _certificate;
  bool _certificateSet = false;

  String _fileType;
  bool _fileTypeSet = false;

  String _database;
  bool _databaseSet = false;

  String _schema;
  bool _schemaSet = false;

  String _jdbcAdditionalParams;
  bool _jdbcAdditionalParamsSet = false;

  String _afterConnectStatements;
  bool _afterConnectStatementsSet = false;

  /// Context in which to override (`pdt` is the only allowed value)

  String get context {
    if (!_contextSet && _apiMapResponse.containsKey('context')) {
      _context = _apiMapResponse['context']?.toString();
      _contextSet = true;
    }
    return _context;
  }

  set context(String v) {
    _context = v;
    _contextSet = true;
  }

  /// Host name/address of server

  String get host {
    if (!_hostSet && _apiMapResponse.containsKey('host')) {
      _host = _apiMapResponse['host']?.toString();
      _hostSet = true;
    }
    return _host;
  }

  set host(String v) {
    _host = v;
    _hostSet = true;
  }

  /// Port number on server

  String get port {
    if (!_portSet && _apiMapResponse.containsKey('port')) {
      _port = _apiMapResponse['port']?.toString();
      _portSet = true;
    }
    return _port;
  }

  set port(String v) {
    _port = v;
    _portSet = true;
  }

  /// Username for server authentication

  String get username {
    if (!_usernameSet && _apiMapResponse.containsKey('username')) {
      _username = _apiMapResponse['username']?.toString();
      _usernameSet = true;
    }
    return _username;
  }

  set username(String v) {
    _username = v;
    _usernameSet = true;
  }

  /// (Write-Only) Password for server authentication

  String get password {
    if (!_passwordSet && _apiMapResponse.containsKey('password')) {
      _password = _apiMapResponse['password']?.toString();
      _passwordSet = true;
    }
    return _password;
  }

  set password(String v) {
    _password = v;
    _passwordSet = true;
  }

  /// Whether or not the password is overridden in this context (read-only)

  bool get hasPassword {
    if (!_hasPasswordSet && _apiMapResponse.containsKey('has_password')) {
      _hasPassword = _apiMapResponse['has_password'];
      _hasPasswordSet = true;
    }
    return _hasPassword;
  }

  set hasPassword(bool v) {
    _hasPassword = v;
    _hasPasswordSet = true;
  }

  /// (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).

  String get certificate {
    if (!_certificateSet && _apiMapResponse.containsKey('certificate')) {
      _certificate = _apiMapResponse['certificate']?.toString();
      _certificateSet = true;
    }
    return _certificate;
  }

  set certificate(String v) {
    _certificate = v;
    _certificateSet = true;
  }

  /// (Write-Only) Certificate keyfile type - .json or .p12

  String get fileType {
    if (!_fileTypeSet && _apiMapResponse.containsKey('file_type')) {
      _fileType = _apiMapResponse['file_type']?.toString();
      _fileTypeSet = true;
    }
    return _fileType;
  }

  set fileType(String v) {
    _fileType = v;
    _fileTypeSet = true;
  }

  /// Database name

  String get database {
    if (!_databaseSet && _apiMapResponse.containsKey('database')) {
      _database = _apiMapResponse['database']?.toString();
      _databaseSet = true;
    }
    return _database;
  }

  set database(String v) {
    _database = v;
    _databaseSet = true;
  }

  /// Scheme name

  String get schema {
    if (!_schemaSet && _apiMapResponse.containsKey('schema')) {
      _schema = _apiMapResponse['schema']?.toString();
      _schemaSet = true;
    }
    return _schema;
  }

  set schema(String v) {
    _schema = v;
    _schemaSet = true;
  }

  /// Additional params to add to JDBC connection string

  String get jdbcAdditionalParams {
    if (!_jdbcAdditionalParamsSet &&
        _apiMapResponse.containsKey('jdbc_additional_params')) {
      _jdbcAdditionalParams =
          _apiMapResponse['jdbc_additional_params']?.toString();
      _jdbcAdditionalParamsSet = true;
    }
    return _jdbcAdditionalParams;
  }

  set jdbcAdditionalParams(String v) {
    _jdbcAdditionalParams = v;
    _jdbcAdditionalParamsSet = true;
  }

  /// SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature

  String get afterConnectStatements {
    if (!_afterConnectStatementsSet &&
        _apiMapResponse.containsKey('after_connect_statements')) {
      _afterConnectStatements =
          _apiMapResponse['after_connect_statements']?.toString();
      _afterConnectStatementsSet = true;
    }
    return _afterConnectStatements;
  }

  set afterConnectStatements(String v) {
    _afterConnectStatements = v;
    _afterConnectStatementsSet = true;
  }

  DBConnectionOverride() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DBConnectionOverride.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_contextSet || _apiMapResponse.containsKey('context')) {
      json['context'] = context;
    }
    if (_hostSet || _apiMapResponse.containsKey('host')) {
      json['host'] = host;
    }
    if (_portSet || _apiMapResponse.containsKey('port')) {
      json['port'] = port;
    }
    if (_usernameSet || _apiMapResponse.containsKey('username')) {
      json['username'] = username;
    }
    if (_passwordSet || _apiMapResponse.containsKey('password')) {
      json['password'] = password;
    }
    if (_hasPasswordSet || _apiMapResponse.containsKey('has_password')) {
      json['has_password'] = hasPassword;
    }
    if (_certificateSet || _apiMapResponse.containsKey('certificate')) {
      json['certificate'] = certificate;
    }
    if (_fileTypeSet || _apiMapResponse.containsKey('file_type')) {
      json['file_type'] = fileType;
    }
    if (_databaseSet || _apiMapResponse.containsKey('database')) {
      json['database'] = database;
    }
    if (_schemaSet || _apiMapResponse.containsKey('schema')) {
      json['schema'] = schema;
    }
    if (_jdbcAdditionalParamsSet ||
        _apiMapResponse.containsKey('jdbc_additional_params')) {
      json['jdbc_additional_params'] = jdbcAdditionalParams;
    }
    if (_afterConnectStatementsSet ||
        _apiMapResponse.containsKey('after_connect_statements')) {
      json['after_connect_statements'] = afterConnectStatements;
    }
    return json;
  }
}

class DBConnectionTestResult {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _connectionString;
  bool _connectionStringSet = false;

  String _message;
  bool _messageSet = false;

  String _name;
  bool _nameSet = false;

  String _status;
  bool _statusSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// JDBC connection string. (only populated in the 'connect' test) (read-only)

  String get connectionString {
    if (!_connectionStringSet &&
        _apiMapResponse.containsKey('connection_string')) {
      _connectionString = _apiMapResponse['connection_string']?.toString();
      _connectionStringSet = true;
    }
    return _connectionString;
  }

  set connectionString(String v) {
    _connectionString = v;
    _connectionStringSet = true;
  }

  /// Result message of test (read-only)

  String get message {
    if (!_messageSet && _apiMapResponse.containsKey('message')) {
      _message = _apiMapResponse['message']?.toString();
      _messageSet = true;
    }
    return _message;
  }

  set message(String v) {
    _message = v;
    _messageSet = true;
  }

  /// Name of test (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Result code of test (read-only)

  String get status {
    if (!_statusSet && _apiMapResponse.containsKey('status')) {
      _status = _apiMapResponse['status']?.toString();
      _statusSet = true;
    }
    return _status;
  }

  set status(String v) {
    _status = v;
    _statusSet = true;
  }

  DBConnectionTestResult() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DBConnectionTestResult.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_connectionStringSet ||
        _apiMapResponse.containsKey('connection_string')) {
      json['connection_string'] = connectionString;
    }
    if (_messageSet || _apiMapResponse.containsKey('message')) {
      json['message'] = message;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_statusSet || _apiMapResponse.containsKey('status')) {
      json['status'] = status;
    }
    return json;
  }
}

class DelegateOauthTest {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _installationTargetId;
  bool _installationTargetIdSet = false;

  int _installationId;
  bool _installationIdSet = false;

  bool _success;
  bool _successSet = false;

  /// Delegate Oauth Connection Name (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// The ID of the installation target. For Slack, this would be workspace id. (read-only)

  String get installationTargetId {
    if (!_installationTargetIdSet &&
        _apiMapResponse.containsKey('installation_target_id')) {
      _installationTargetId =
          _apiMapResponse['installation_target_id']?.toString();
      _installationTargetIdSet = true;
    }
    return _installationTargetId;
  }

  set installationTargetId(String v) {
    _installationTargetId = v;
    _installationTargetIdSet = true;
  }

  /// Installation ID (read-only)

  int get installationId {
    if (!_installationIdSet && _apiMapResponse.containsKey('installation_id')) {
      _installationId = _apiMapResponse['installation_id'];
      _installationIdSet = true;
    }
    return _installationId;
  }

  set installationId(int v) {
    _installationId = v;
    _installationIdSet = true;
  }

  /// Whether or not the test was successful (read-only)

  bool get success {
    if (!_successSet && _apiMapResponse.containsKey('success')) {
      _success = _apiMapResponse['success'];
      _successSet = true;
    }
    return _success;
  }

  set success(bool v) {
    _success = v;
    _successSet = true;
  }

  DelegateOauthTest() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DelegateOauthTest.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_installationTargetIdSet ||
        _apiMapResponse.containsKey('installation_target_id')) {
      json['installation_target_id'] = installationTargetId;
    }
    if (_installationIdSet || _apiMapResponse.containsKey('installation_id')) {
      json['installation_id'] = installationId;
    }
    if (_successSet || _apiMapResponse.containsKey('success')) {
      json['success'] = success;
    }
    return json;
  }
}

class DependencyGraph {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _graphText;
  bool _graphTextSet = false;

  /// The graph structure in the dot language that can be rendered into an image. (read-only)

  String get graphText {
    if (!_graphTextSet && _apiMapResponse.containsKey('graph_text')) {
      _graphText = _apiMapResponse['graph_text']?.toString();
      _graphTextSet = true;
    }
    return _graphText;
  }

  set graphText(String v) {
    _graphText = v;
    _graphTextSet = true;
  }

  DependencyGraph() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DependencyGraph.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_graphTextSet || _apiMapResponse.containsKey('graph_text')) {
      json['graph_text'] = graphText;
    }
    return json;
  }
}

/// Status of the dependencies in your project. Valid values are: "lock_optional", "lock_required", "lock_error", "install_none". (Enum defined in ProjectWorkspace)
enum DependencyStatus { lockOptional, lockRequired, lockError, installNone }

class DependencyStatusMapper {
  static String toStringValue(DependencyStatus e) {
    switch (e) {
      case DependencyStatus.lockOptional:
        return 'lock_optional';
      case DependencyStatus.lockRequired:
        return 'lock_required';
      case DependencyStatus.lockError:
        return 'lock_error';
      case DependencyStatus.installNone:
        return 'install_none';

      default:
        return null;
    }
  }

  static DependencyStatus fromStringValue(String s) {
    if (s == 'lock_optional') {
      return DependencyStatus.lockOptional;
    }
    if (s == 'lock_required') {
      return DependencyStatus.lockRequired;
    }
    if (s == 'lock_error') {
      return DependencyStatus.lockError;
    }
    if (s == 'install_none') {
      return DependencyStatus.installNone;
    }
    return null;
  }
}

/// Type of destination that the alert will be sent to Valid values are: "EMAIL", "ACTION_HUB". (Enum defined in AlertDestination)
enum DestinationType { email, actionHub }

class DestinationTypeMapper {
  static String toStringValue(DestinationType e) {
    switch (e) {
      case DestinationType.email:
        return 'EMAIL';
      case DestinationType.actionHub:
        return 'ACTION_HUB';

      default:
        return null;
    }
  }

  static DestinationType fromStringValue(String s) {
    if (s == 'EMAIL') {
      return DestinationType.email;
    }
    if (s == 'ACTION_HUB') {
      return DestinationType.actionHub;
    }
    return null;
  }
}

class Dialect {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _label;
  bool _labelSet = false;

  bool _supportsCostEstimate;
  bool _supportsCostEstimateSet = false;

  String _persistentTableIndexes;
  bool _persistentTableIndexesSet = false;

  String _persistentTableSortkeys;
  bool _persistentTableSortkeysSet = false;

  String _persistentTableDistkey;
  bool _persistentTableDistkeySet = false;

  bool _supportsStreaming;
  bool _supportsStreamingSet = false;

  bool _automaticallyRunSqlRunnerSnippets;
  bool _automaticallyRunSqlRunnerSnippetsSet = false;

  List<String> _connectionTests;
  bool _connectionTestsSet = false;

  bool _supportsInducer;
  bool _supportsInducerSet = false;

  bool _supportsMultipleDatabases;
  bool _supportsMultipleDatabasesSet = false;

  bool _supportsPersistentDerivedTables;
  bool _supportsPersistentDerivedTablesSet = false;

  bool _hasSslSupport;
  bool _hasSslSupportSet = false;

  /// The name of the dialect (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// The human-readable label of the connection (read-only)

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// Whether the dialect supports query cost estimates (read-only)

  bool get supportsCostEstimate {
    if (!_supportsCostEstimateSet &&
        _apiMapResponse.containsKey('supports_cost_estimate')) {
      _supportsCostEstimate = _apiMapResponse['supports_cost_estimate'];
      _supportsCostEstimateSet = true;
    }
    return _supportsCostEstimate;
  }

  set supportsCostEstimate(bool v) {
    _supportsCostEstimate = v;
    _supportsCostEstimateSet = true;
  }

  /// PDT index columns (read-only)

  String get persistentTableIndexes {
    if (!_persistentTableIndexesSet &&
        _apiMapResponse.containsKey('persistent_table_indexes')) {
      _persistentTableIndexes =
          _apiMapResponse['persistent_table_indexes']?.toString();
      _persistentTableIndexesSet = true;
    }
    return _persistentTableIndexes;
  }

  set persistentTableIndexes(String v) {
    _persistentTableIndexes = v;
    _persistentTableIndexesSet = true;
  }

  /// PDT sortkey columns (read-only)

  String get persistentTableSortkeys {
    if (!_persistentTableSortkeysSet &&
        _apiMapResponse.containsKey('persistent_table_sortkeys')) {
      _persistentTableSortkeys =
          _apiMapResponse['persistent_table_sortkeys']?.toString();
      _persistentTableSortkeysSet = true;
    }
    return _persistentTableSortkeys;
  }

  set persistentTableSortkeys(String v) {
    _persistentTableSortkeys = v;
    _persistentTableSortkeysSet = true;
  }

  /// PDT distkey column (read-only)

  String get persistentTableDistkey {
    if (!_persistentTableDistkeySet &&
        _apiMapResponse.containsKey('persistent_table_distkey')) {
      _persistentTableDistkey =
          _apiMapResponse['persistent_table_distkey']?.toString();
      _persistentTableDistkeySet = true;
    }
    return _persistentTableDistkey;
  }

  set persistentTableDistkey(String v) {
    _persistentTableDistkey = v;
    _persistentTableDistkeySet = true;
  }

  /// Suports streaming results (read-only)

  bool get supportsStreaming {
    if (!_supportsStreamingSet &&
        _apiMapResponse.containsKey('supports_streaming')) {
      _supportsStreaming = _apiMapResponse['supports_streaming'];
      _supportsStreamingSet = true;
    }
    return _supportsStreaming;
  }

  set supportsStreaming(bool v) {
    _supportsStreaming = v;
    _supportsStreamingSet = true;
  }

  /// Should SQL Runner snippets automatically be run (read-only)

  bool get automaticallyRunSqlRunnerSnippets {
    if (!_automaticallyRunSqlRunnerSnippetsSet &&
        _apiMapResponse.containsKey('automatically_run_sql_runner_snippets')) {
      _automaticallyRunSqlRunnerSnippets =
          _apiMapResponse['automatically_run_sql_runner_snippets'];
      _automaticallyRunSqlRunnerSnippetsSet = true;
    }
    return _automaticallyRunSqlRunnerSnippets;
  }

  set automaticallyRunSqlRunnerSnippets(bool v) {
    _automaticallyRunSqlRunnerSnippets = v;
    _automaticallyRunSqlRunnerSnippetsSet = true;
  }

  /// Array of names of the tests that can be run on a connection using this dialect (read-only)

  List<String> get connectionTests {
    if (!_connectionTestsSet &&
        _apiMapResponse.containsKey('connection_tests')) {
      _connectionTests = _apiMapResponse['connection_tests']
          ?.map<String>((i) => i as String)
          ?.toList();
      _connectionTestsSet = true;
    }
    return _connectionTests;
  }

  set connectionTests(List<String> v) {
    _connectionTests = v;
    _connectionTestsSet = true;
  }

  /// Is supported with the inducer (i.e. generate from sql) (read-only)

  bool get supportsInducer {
    if (!_supportsInducerSet &&
        _apiMapResponse.containsKey('supports_inducer')) {
      _supportsInducer = _apiMapResponse['supports_inducer'];
      _supportsInducerSet = true;
    }
    return _supportsInducer;
  }

  set supportsInducer(bool v) {
    _supportsInducer = v;
    _supportsInducerSet = true;
  }

  /// Can multiple databases be accessed from a connection using this dialect (read-only)

  bool get supportsMultipleDatabases {
    if (!_supportsMultipleDatabasesSet &&
        _apiMapResponse.containsKey('supports_multiple_databases')) {
      _supportsMultipleDatabases =
          _apiMapResponse['supports_multiple_databases'];
      _supportsMultipleDatabasesSet = true;
    }
    return _supportsMultipleDatabases;
  }

  set supportsMultipleDatabases(bool v) {
    _supportsMultipleDatabases = v;
    _supportsMultipleDatabasesSet = true;
  }

  /// Whether the dialect supports allowing Looker to build persistent derived tables (read-only)

  bool get supportsPersistentDerivedTables {
    if (!_supportsPersistentDerivedTablesSet &&
        _apiMapResponse.containsKey('supports_persistent_derived_tables')) {
      _supportsPersistentDerivedTables =
          _apiMapResponse['supports_persistent_derived_tables'];
      _supportsPersistentDerivedTablesSet = true;
    }
    return _supportsPersistentDerivedTables;
  }

  set supportsPersistentDerivedTables(bool v) {
    _supportsPersistentDerivedTables = v;
    _supportsPersistentDerivedTablesSet = true;
  }

  /// Does the database have client SSL support settable through the JDBC string explicitly? (read-only)

  bool get hasSslSupport {
    if (!_hasSslSupportSet && _apiMapResponse.containsKey('has_ssl_support')) {
      _hasSslSupport = _apiMapResponse['has_ssl_support'];
      _hasSslSupportSet = true;
    }
    return _hasSslSupport;
  }

  set hasSslSupport(bool v) {
    _hasSslSupport = v;
    _hasSslSupportSet = true;
  }

  Dialect() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Dialect.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_supportsCostEstimateSet ||
        _apiMapResponse.containsKey('supports_cost_estimate')) {
      json['supports_cost_estimate'] = supportsCostEstimate;
    }
    if (_persistentTableIndexesSet ||
        _apiMapResponse.containsKey('persistent_table_indexes')) {
      json['persistent_table_indexes'] = persistentTableIndexes;
    }
    if (_persistentTableSortkeysSet ||
        _apiMapResponse.containsKey('persistent_table_sortkeys')) {
      json['persistent_table_sortkeys'] = persistentTableSortkeys;
    }
    if (_persistentTableDistkeySet ||
        _apiMapResponse.containsKey('persistent_table_distkey')) {
      json['persistent_table_distkey'] = persistentTableDistkey;
    }
    if (_supportsStreamingSet ||
        _apiMapResponse.containsKey('supports_streaming')) {
      json['supports_streaming'] = supportsStreaming;
    }
    if (_automaticallyRunSqlRunnerSnippetsSet ||
        _apiMapResponse.containsKey('automatically_run_sql_runner_snippets')) {
      json['automatically_run_sql_runner_snippets'] =
          automaticallyRunSqlRunnerSnippets;
    }
    if (_connectionTestsSet ||
        _apiMapResponse.containsKey('connection_tests')) {
      json['connection_tests'] = connectionTests;
    }
    if (_supportsInducerSet ||
        _apiMapResponse.containsKey('supports_inducer')) {
      json['supports_inducer'] = supportsInducer;
    }
    if (_supportsMultipleDatabasesSet ||
        _apiMapResponse.containsKey('supports_multiple_databases')) {
      json['supports_multiple_databases'] = supportsMultipleDatabases;
    }
    if (_supportsPersistentDerivedTablesSet ||
        _apiMapResponse.containsKey('supports_persistent_derived_tables')) {
      json['supports_persistent_derived_tables'] =
          supportsPersistentDerivedTables;
    }
    if (_hasSslSupportSet || _apiMapResponse.containsKey('has_ssl_support')) {
      json['has_ssl_support'] = hasSslSupport;
    }
    return json;
  }
}

class DialectInfo {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _defaultMaxConnections;
  bool _defaultMaxConnectionsSet = false;

  String _defaultPort;
  bool _defaultPortSet = false;

  bool _installed;
  bool _installedSet = false;

  String _label;
  bool _labelSet = false;

  String _labelForDatabaseEquivalent;
  bool _labelForDatabaseEquivalentSet = false;

  String _name;
  bool _nameSet = false;

  DialectInfoOptions _supportedOptions;
  bool _supportedOptionsSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Default number max connections (read-only)

  String get defaultMaxConnections {
    if (!_defaultMaxConnectionsSet &&
        _apiMapResponse.containsKey('default_max_connections')) {
      _defaultMaxConnections =
          _apiMapResponse['default_max_connections']?.toString();
      _defaultMaxConnectionsSet = true;
    }
    return _defaultMaxConnections;
  }

  set defaultMaxConnections(String v) {
    _defaultMaxConnections = v;
    _defaultMaxConnectionsSet = true;
  }

  /// Default port number (read-only)

  String get defaultPort {
    if (!_defaultPortSet && _apiMapResponse.containsKey('default_port')) {
      _defaultPort = _apiMapResponse['default_port']?.toString();
      _defaultPortSet = true;
    }
    return _defaultPort;
  }

  set defaultPort(String v) {
    _defaultPort = v;
    _defaultPortSet = true;
  }

  /// Is the supporting driver installed (read-only)

  bool get installed {
    if (!_installedSet && _apiMapResponse.containsKey('installed')) {
      _installed = _apiMapResponse['installed'];
      _installedSet = true;
    }
    return _installed;
  }

  set installed(bool v) {
    _installed = v;
    _installedSet = true;
  }

  /// The human-readable label of the connection (read-only)

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// What the dialect calls the equivalent of a normal SQL table (read-only)

  String get labelForDatabaseEquivalent {
    if (!_labelForDatabaseEquivalentSet &&
        _apiMapResponse.containsKey('label_for_database_equivalent')) {
      _labelForDatabaseEquivalent =
          _apiMapResponse['label_for_database_equivalent']?.toString();
      _labelForDatabaseEquivalentSet = true;
    }
    return _labelForDatabaseEquivalent;
  }

  set labelForDatabaseEquivalent(String v) {
    _labelForDatabaseEquivalent = v;
    _labelForDatabaseEquivalentSet = true;
  }

  /// The name of the dialect (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  DialectInfoOptions get supportedOptions {
    if (!_supportedOptionsSet &&
        _apiMapResponse.containsKey('supported_options')) {
      _supportedOptions = _apiMapResponse['supported_options'] == null
          ? null
          : DialectInfoOptions.fromResponse(
              _apiMapResponse['supported_options'], apiResponseContentType);
      _supportedOptionsSet = true;
    }
    return _supportedOptions;
  }

  set supportedOptions(DialectInfoOptions v) {
    _supportedOptions = v;
    _supportedOptionsSet = true;
  }

  DialectInfo() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DialectInfo.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_defaultMaxConnectionsSet ||
        _apiMapResponse.containsKey('default_max_connections')) {
      json['default_max_connections'] = defaultMaxConnections;
    }
    if (_defaultPortSet || _apiMapResponse.containsKey('default_port')) {
      json['default_port'] = defaultPort;
    }
    if (_installedSet || _apiMapResponse.containsKey('installed')) {
      json['installed'] = installed;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_labelForDatabaseEquivalentSet ||
        _apiMapResponse.containsKey('label_for_database_equivalent')) {
      json['label_for_database_equivalent'] = labelForDatabaseEquivalent;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_supportedOptionsSet ||
        _apiMapResponse.containsKey('supported_options')) {
      json['supported_options'] = supportedOptions?.toJson();
    }
    return json;
  }
}

class DialectInfoOptions {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _additionalParams;
  bool _additionalParamsSet = false;

  bool _auth;
  bool _authSet = false;

  bool _host;
  bool _hostSet = false;

  bool _oauthCredentials;
  bool _oauthCredentialsSet = false;

  bool _projectName;
  bool _projectNameSet = false;

  bool _schema;
  bool _schemaSet = false;

  bool _ssl;
  bool _sslSet = false;

  bool _timezone;
  bool _timezoneSet = false;

  bool _tmpTable;
  bool _tmpTableSet = false;

  bool _usernameRequired;
  bool _usernameRequiredSet = false;

  /// Has additional params support (read-only)

  bool get additionalParams {
    if (!_additionalParamsSet &&
        _apiMapResponse.containsKey('additional_params')) {
      _additionalParams = _apiMapResponse['additional_params'];
      _additionalParamsSet = true;
    }
    return _additionalParams;
  }

  set additionalParams(bool v) {
    _additionalParams = v;
    _additionalParamsSet = true;
  }

  /// Has auth support (read-only)

  bool get auth {
    if (!_authSet && _apiMapResponse.containsKey('auth')) {
      _auth = _apiMapResponse['auth'];
      _authSet = true;
    }
    return _auth;
  }

  set auth(bool v) {
    _auth = v;
    _authSet = true;
  }

  /// Has host support (read-only)

  bool get host {
    if (!_hostSet && _apiMapResponse.containsKey('host')) {
      _host = _apiMapResponse['host'];
      _hostSet = true;
    }
    return _host;
  }

  set host(bool v) {
    _host = v;
    _hostSet = true;
  }

  /// Has support for a service account (read-only)

  bool get oauthCredentials {
    if (!_oauthCredentialsSet &&
        _apiMapResponse.containsKey('oauth_credentials')) {
      _oauthCredentials = _apiMapResponse['oauth_credentials'];
      _oauthCredentialsSet = true;
    }
    return _oauthCredentials;
  }

  set oauthCredentials(bool v) {
    _oauthCredentials = v;
    _oauthCredentialsSet = true;
  }

  /// Has project name support (read-only)

  bool get projectName {
    if (!_projectNameSet && _apiMapResponse.containsKey('project_name')) {
      _projectName = _apiMapResponse['project_name'];
      _projectNameSet = true;
    }
    return _projectName;
  }

  set projectName(bool v) {
    _projectName = v;
    _projectNameSet = true;
  }

  /// Has schema support (read-only)

  bool get schema {
    if (!_schemaSet && _apiMapResponse.containsKey('schema')) {
      _schema = _apiMapResponse['schema'];
      _schemaSet = true;
    }
    return _schema;
  }

  set schema(bool v) {
    _schema = v;
    _schemaSet = true;
  }

  /// Has SSL support (read-only)

  bool get ssl {
    if (!_sslSet && _apiMapResponse.containsKey('ssl')) {
      _ssl = _apiMapResponse['ssl'];
      _sslSet = true;
    }
    return _ssl;
  }

  set ssl(bool v) {
    _ssl = v;
    _sslSet = true;
  }

  /// Has timezone support (read-only)

  bool get timezone {
    if (!_timezoneSet && _apiMapResponse.containsKey('timezone')) {
      _timezone = _apiMapResponse['timezone'];
      _timezoneSet = true;
    }
    return _timezone;
  }

  set timezone(bool v) {
    _timezone = v;
    _timezoneSet = true;
  }

  /// Has tmp table support (read-only)

  bool get tmpTable {
    if (!_tmpTableSet && _apiMapResponse.containsKey('tmp_table')) {
      _tmpTable = _apiMapResponse['tmp_table'];
      _tmpTableSet = true;
    }
    return _tmpTable;
  }

  set tmpTable(bool v) {
    _tmpTable = v;
    _tmpTableSet = true;
  }

  /// Username is required (read-only)

  bool get usernameRequired {
    if (!_usernameRequiredSet &&
        _apiMapResponse.containsKey('username_required')) {
      _usernameRequired = _apiMapResponse['username_required'];
      _usernameRequiredSet = true;
    }
    return _usernameRequired;
  }

  set usernameRequired(bool v) {
    _usernameRequired = v;
    _usernameRequiredSet = true;
  }

  DialectInfoOptions() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DialectInfoOptions.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_additionalParamsSet ||
        _apiMapResponse.containsKey('additional_params')) {
      json['additional_params'] = additionalParams;
    }
    if (_authSet || _apiMapResponse.containsKey('auth')) {
      json['auth'] = auth;
    }
    if (_hostSet || _apiMapResponse.containsKey('host')) {
      json['host'] = host;
    }
    if (_oauthCredentialsSet ||
        _apiMapResponse.containsKey('oauth_credentials')) {
      json['oauth_credentials'] = oauthCredentials;
    }
    if (_projectNameSet || _apiMapResponse.containsKey('project_name')) {
      json['project_name'] = projectName;
    }
    if (_schemaSet || _apiMapResponse.containsKey('schema')) {
      json['schema'] = schema;
    }
    if (_sslSet || _apiMapResponse.containsKey('ssl')) {
      json['ssl'] = ssl;
    }
    if (_timezoneSet || _apiMapResponse.containsKey('timezone')) {
      json['timezone'] = timezone;
    }
    if (_tmpTableSet || _apiMapResponse.containsKey('tmp_table')) {
      json['tmp_table'] = tmpTable;
    }
    if (_usernameRequiredSet ||
        _apiMapResponse.containsKey('username_required')) {
      json['username_required'] = usernameRequired;
    }
    return json;
  }
}

class DigestEmails {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _isEnabled;
  bool _isEnabledSet = false;

  /// Whether or not digest emails are enabled

  bool get isEnabled {
    if (!_isEnabledSet && _apiMapResponse.containsKey('is_enabled')) {
      _isEnabled = _apiMapResponse['is_enabled'];
      _isEnabledSet = true;
    }
    return _isEnabled;
  }

  set isEnabled(bool v) {
    _isEnabled = v;
    _isEnabledSet = true;
  }

  DigestEmails() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DigestEmails.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_isEnabledSet || _apiMapResponse.containsKey('is_enabled')) {
      json['is_enabled'] = isEnabled;
    }
    return json;
  }
}

class DigestEmailSend {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _configurationDelivered;
  bool _configurationDeliveredSet = false;

  /// True if content was successfully generated and delivered

  bool get configurationDelivered {
    if (!_configurationDeliveredSet &&
        _apiMapResponse.containsKey('configuration_delivered')) {
      _configurationDelivered = _apiMapResponse['configuration_delivered'];
      _configurationDeliveredSet = true;
    }
    return _configurationDelivered;
  }

  set configurationDelivered(bool v) {
    _configurationDelivered = v;
    _configurationDeliveredSet = true;
  }

  DigestEmailSend() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DigestEmailSend.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_configurationDeliveredSet ||
        _apiMapResponse.containsKey('configuration_delivered')) {
      json['configuration_delivered'] = configurationDelivered;
    }
    return json;
  }
}

class DiscretePalette {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _id;
  bool _idSet = false;

  String _label;
  bool _labelSet = false;

  String _type;
  bool _typeSet = false;

  List<String> _colors;
  bool _colorsSet = false;

  /// Unique identity string (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Label for palette

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// Type of palette

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Array of colors in the palette

  List<String> get colors {
    if (!_colorsSet && _apiMapResponse.containsKey('colors')) {
      _colors =
          _apiMapResponse['colors']?.map<String>((i) => i as String)?.toList();
      _colorsSet = true;
    }
    return _colors;
  }

  set colors(List<String> v) {
    _colors = v;
    _colorsSet = true;
  }

  DiscretePalette() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  DiscretePalette.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_colorsSet || _apiMapResponse.containsKey('colors')) {
      json['colors'] = colors;
    }
    return json;
  }
}

class EmbedParams {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _targetUrl;
  bool _targetUrlSet = false;

  int _sessionLength;
  bool _sessionLengthSet = false;

  bool _forceLogoutLogin;
  bool _forceLogoutLoginSet = false;

  /// The complete URL of the Looker UI page to display in the embed context. For example, to display the dashboard with id 34, `target_url` would look like: `https://mycompany.looker.com:9999/dashboards/34`. `target_uri` MUST contain a scheme (HTTPS), domain name, and URL path. Port must be included if it is required to reach the Looker server from browser clients. If the Looker instance is behind a load balancer or other proxy, `target_uri` must be the public-facing domain name and port required to reach the Looker instance, not the actual internal network machine name of the Looker instance.

  String get targetUrl {
    if (!_targetUrlSet && _apiMapResponse.containsKey('target_url')) {
      _targetUrl = _apiMapResponse['target_url']?.toString();
      _targetUrlSet = true;
    }
    return _targetUrl;
  }

  set targetUrl(String v) {
    _targetUrl = v;
    _targetUrlSet = true;
  }

  /// Number of seconds the SSO embed session will be valid after the embed session is started. Defaults to 300 seconds. Maximum session length accepted is 2592000 seconds (30 days).

  int get sessionLength {
    if (!_sessionLengthSet && _apiMapResponse.containsKey('session_length')) {
      _sessionLength = _apiMapResponse['session_length'];
      _sessionLengthSet = true;
    }
    return _sessionLength;
  }

  set sessionLength(int v) {
    _sessionLength = v;
    _sessionLengthSet = true;
  }

  /// When true, the embed session will purge any residual Looker login state (such as in browser cookies) before creating a new login state with the given embed user info. Defaults to true.

  bool get forceLogoutLogin {
    if (!_forceLogoutLoginSet &&
        _apiMapResponse.containsKey('force_logout_login')) {
      _forceLogoutLogin = _apiMapResponse['force_logout_login'];
      _forceLogoutLoginSet = true;
    }
    return _forceLogoutLogin;
  }

  set forceLogoutLogin(bool v) {
    _forceLogoutLogin = v;
    _forceLogoutLoginSet = true;
  }

  EmbedParams() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  EmbedParams.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_targetUrlSet || _apiMapResponse.containsKey('target_url')) {
      json['target_url'] = targetUrl;
    }
    if (_sessionLengthSet || _apiMapResponse.containsKey('session_length')) {
      json['session_length'] = sessionLength;
    }
    if (_forceLogoutLoginSet ||
        _apiMapResponse.containsKey('force_logout_login')) {
      json['force_logout_login'] = forceLogoutLogin;
    }
    return json;
  }
}

class EmbedSecret {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _algorithm;
  bool _algorithmSet = false;

  String _createdAt;
  bool _createdAtSet = false;

  bool _enabled;
  bool _enabledSet = false;

  int _id;
  bool _idSet = false;

  String _secret;
  bool _secretSet = false;

  int _userId;
  bool _userIdSet = false;

  /// Signing algorithm to use with this secret. Either `hmac/sha-256`(default) or `hmac/sha-1`

  String get algorithm {
    if (!_algorithmSet && _apiMapResponse.containsKey('algorithm')) {
      _algorithm = _apiMapResponse['algorithm']?.toString();
      _algorithmSet = true;
    }
    return _algorithm;
  }

  set algorithm(String v) {
    _algorithm = v;
    _algorithmSet = true;
  }

  /// When secret was created (read-only)

  String get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at']?.toString();
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(String v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// Is this secret currently enabled

  bool get enabled {
    if (!_enabledSet && _apiMapResponse.containsKey('enabled')) {
      _enabled = _apiMapResponse['enabled'];
      _enabledSet = true;
    }
    return _enabled;
  }

  set enabled(bool v) {
    _enabled = v;
    _enabledSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Secret for use with SSO embedding (read-only)

  String get secret {
    if (!_secretSet && _apiMapResponse.containsKey('secret')) {
      _secret = _apiMapResponse['secret']?.toString();
      _secretSet = true;
    }
    return _secret;
  }

  set secret(String v) {
    _secret = v;
    _secretSet = true;
  }

  /// Id of user who created this secret (read-only)

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  EmbedSecret() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  EmbedSecret.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_algorithmSet || _apiMapResponse.containsKey('algorithm')) {
      json['algorithm'] = algorithm;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt;
    }
    if (_enabledSet || _apiMapResponse.containsKey('enabled')) {
      json['enabled'] = enabled;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_secretSet || _apiMapResponse.containsKey('secret')) {
      json['secret'] = secret;
    }
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    return json;
  }
}

class EmbedSsoParams {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _targetUrl;
  bool _targetUrlSet = false;

  int _sessionLength;
  bool _sessionLengthSet = false;

  bool _forceLogoutLogin;
  bool _forceLogoutLoginSet = false;

  String _externalUserId;
  bool _externalUserIdSet = false;

  String _firstName;
  bool _firstNameSet = false;

  String _lastName;
  bool _lastNameSet = false;

  String _userTimezone;
  bool _userTimezoneSet = false;

  List<String> _permissions;
  bool _permissionsSet = false;

  List<String> _models;
  bool _modelsSet = false;

  List<int> _groupIds;
  bool _groupIdsSet = false;

  String _externalGroupId;
  bool _externalGroupIdSet = false;

  Map<String, dynamic> _userAttributes;
  bool _userAttributesSet = false;

  int _secretId;
  bool _secretIdSet = false;

  /// The complete URL of the Looker UI page to display in the embed context. For example, to display the dashboard with id 34, `target_url` would look like: `https://mycompany.looker.com:9999/dashboards/34`. `target_uri` MUST contain a scheme (HTTPS), domain name, and URL path. Port must be included if it is required to reach the Looker server from browser clients. If the Looker instance is behind a load balancer or other proxy, `target_uri` must be the public-facing domain name and port required to reach the Looker instance, not the actual internal network machine name of the Looker instance.

  String get targetUrl {
    if (!_targetUrlSet && _apiMapResponse.containsKey('target_url')) {
      _targetUrl = _apiMapResponse['target_url']?.toString();
      _targetUrlSet = true;
    }
    return _targetUrl;
  }

  set targetUrl(String v) {
    _targetUrl = v;
    _targetUrlSet = true;
  }

  /// Number of seconds the SSO embed session will be valid after the embed session is started. Defaults to 300 seconds. Maximum session length accepted is 2592000 seconds (30 days).

  int get sessionLength {
    if (!_sessionLengthSet && _apiMapResponse.containsKey('session_length')) {
      _sessionLength = _apiMapResponse['session_length'];
      _sessionLengthSet = true;
    }
    return _sessionLength;
  }

  set sessionLength(int v) {
    _sessionLength = v;
    _sessionLengthSet = true;
  }

  /// When true, the embed session will purge any residual Looker login state (such as in browser cookies) before creating a new login state with the given embed user info. Defaults to true.

  bool get forceLogoutLogin {
    if (!_forceLogoutLoginSet &&
        _apiMapResponse.containsKey('force_logout_login')) {
      _forceLogoutLogin = _apiMapResponse['force_logout_login'];
      _forceLogoutLoginSet = true;
    }
    return _forceLogoutLogin;
  }

  set forceLogoutLogin(bool v) {
    _forceLogoutLogin = v;
    _forceLogoutLoginSet = true;
  }

  /// A value from an external system that uniquely identifies the embed user. Since the user_ids of Looker embed users may change with every embed session, external_user_id provides a way to assign a known, stable user identifier across multiple embed sessions.

  String get externalUserId {
    if (!_externalUserIdSet &&
        _apiMapResponse.containsKey('external_user_id')) {
      _externalUserId = _apiMapResponse['external_user_id']?.toString();
      _externalUserIdSet = true;
    }
    return _externalUserId;
  }

  set externalUserId(String v) {
    _externalUserId = v;
    _externalUserIdSet = true;
  }

  /// First name of the embed user. Defaults to 'Embed' if not specified

  String get firstName {
    if (!_firstNameSet && _apiMapResponse.containsKey('first_name')) {
      _firstName = _apiMapResponse['first_name']?.toString();
      _firstNameSet = true;
    }
    return _firstName;
  }

  set firstName(String v) {
    _firstName = v;
    _firstNameSet = true;
  }

  /// Last name of the embed user. Defaults to 'User' if not specified

  String get lastName {
    if (!_lastNameSet && _apiMapResponse.containsKey('last_name')) {
      _lastName = _apiMapResponse['last_name']?.toString();
      _lastNameSet = true;
    }
    return _lastName;
  }

  set lastName(String v) {
    _lastName = v;
    _lastNameSet = true;
  }

  /// Sets the user timezone for the embed user session, if the User Specific Timezones setting is enabled in the Looker admin settings. A value of `null` forces the embed user to use the Looker Application Default Timezone. You MUST omit this property from the request if the User Specific Timezones setting is disabled. Timezone values are validated against the IANA Timezone standard and can be seen in the Application Time Zone dropdown list on the Looker General Settings admin page.

  String get userTimezone {
    if (!_userTimezoneSet && _apiMapResponse.containsKey('user_timezone')) {
      _userTimezone = _apiMapResponse['user_timezone']?.toString();
      _userTimezoneSet = true;
    }
    return _userTimezone;
  }

  set userTimezone(String v) {
    _userTimezone = v;
    _userTimezoneSet = true;
  }

  /// List of Looker permission names to grant to the embed user. Requested permissions will be filtered to permissions allowed for embed sessions.

  List<String> get permissions {
    if (!_permissionsSet && _apiMapResponse.containsKey('permissions')) {
      _permissions = _apiMapResponse['permissions']
          ?.map<String>((i) => i as String)
          ?.toList();
      _permissionsSet = true;
    }
    return _permissions;
  }

  set permissions(List<String> v) {
    _permissions = v;
    _permissionsSet = true;
  }

  /// List of model names that the embed user may access

  List<String> get models {
    if (!_modelsSet && _apiMapResponse.containsKey('models')) {
      _models =
          _apiMapResponse['models']?.map<String>((i) => i as String)?.toList();
      _modelsSet = true;
    }
    return _models;
  }

  set models(List<String> v) {
    _models = v;
    _modelsSet = true;
  }

  /// List of Looker group ids in which to enroll the embed user

  List<int> get groupIds {
    if (!_groupIdsSet && _apiMapResponse.containsKey('group_ids')) {
      _groupIds =
          _apiMapResponse['group_ids']?.map<int>((i) => i as int)?.toList();
      _groupIdsSet = true;
    }
    return _groupIds;
  }

  set groupIds(List<int> v) {
    _groupIds = v;
    _groupIdsSet = true;
  }

  /// A unique value identifying an embed-exclusive group. Multiple embed users using the same `external_group_id` value will be able to share Looker content with each other. Content and embed users associated with the `external_group_id` will not be accessible to normal Looker users or embed users not associated with this `external_group_id`.

  String get externalGroupId {
    if (!_externalGroupIdSet &&
        _apiMapResponse.containsKey('external_group_id')) {
      _externalGroupId = _apiMapResponse['external_group_id']?.toString();
      _externalGroupIdSet = true;
    }
    return _externalGroupId;
  }

  set externalGroupId(String v) {
    _externalGroupId = v;
    _externalGroupIdSet = true;
  }

  /// A dictionary of name-value pairs associating a Looker user attribute name with a value.

  Map<String, dynamic> get userAttributes {
    if (!_userAttributesSet && _apiMapResponse.containsKey('user_attributes')) {
      _userAttributes = _apiMapResponse['user_attributes'];
      _userAttributesSet = true;
    }
    return _userAttributes;
  }

  set userAttributes(Map<String, dynamic> v) {
    _userAttributes = v;
    _userAttributesSet = true;
  }

  /// Id of the embed secret to use to sign this SSO url. If specified, the value must be an id of a valid (active) secret defined in the Looker instance. If not specified, the URL will be signed with the newest active embed secret defined in the Looker instance.

  int get secretId {
    if (!_secretIdSet && _apiMapResponse.containsKey('secret_id')) {
      _secretId = _apiMapResponse['secret_id'];
      _secretIdSet = true;
    }
    return _secretId;
  }

  set secretId(int v) {
    _secretId = v;
    _secretIdSet = true;
  }

  EmbedSsoParams() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  EmbedSsoParams.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_targetUrlSet || _apiMapResponse.containsKey('target_url')) {
      json['target_url'] = targetUrl;
    }
    if (_sessionLengthSet || _apiMapResponse.containsKey('session_length')) {
      json['session_length'] = sessionLength;
    }
    if (_forceLogoutLoginSet ||
        _apiMapResponse.containsKey('force_logout_login')) {
      json['force_logout_login'] = forceLogoutLogin;
    }
    if (_externalUserIdSet || _apiMapResponse.containsKey('external_user_id')) {
      json['external_user_id'] = externalUserId;
    }
    if (_firstNameSet || _apiMapResponse.containsKey('first_name')) {
      json['first_name'] = firstName;
    }
    if (_lastNameSet || _apiMapResponse.containsKey('last_name')) {
      json['last_name'] = lastName;
    }
    if (_userTimezoneSet || _apiMapResponse.containsKey('user_timezone')) {
      json['user_timezone'] = userTimezone;
    }
    if (_permissionsSet || _apiMapResponse.containsKey('permissions')) {
      json['permissions'] = permissions;
    }
    if (_modelsSet || _apiMapResponse.containsKey('models')) {
      json['models'] = models;
    }
    if (_groupIdsSet || _apiMapResponse.containsKey('group_ids')) {
      json['group_ids'] = groupIds;
    }
    if (_externalGroupIdSet ||
        _apiMapResponse.containsKey('external_group_id')) {
      json['external_group_id'] = externalGroupId;
    }
    if (_userAttributesSet || _apiMapResponse.containsKey('user_attributes')) {
      json['user_attributes'] = userAttributes;
    }
    if (_secretIdSet || _apiMapResponse.containsKey('secret_id')) {
      json['secret_id'] = secretId;
    }
    return json;
  }
}

class EmbedUrlResponse {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _url;
  bool _urlSet = false;

  /// The embed URL. Any modification to this string will make the URL unusable. (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  EmbedUrlResponse() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  EmbedUrlResponse.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class Error {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _message;
  bool _messageSet = false;

  String _documentationUrl;
  bool _documentationUrlSet = false;

  /// Error details (read-only)

  String get message {
    if (!_messageSet && _apiMapResponse.containsKey('message')) {
      _message = _apiMapResponse['message']?.toString();
      _messageSet = true;
    }
    return _message;
  }

  set message(String v) {
    _message = v;
    _messageSet = true;
  }

  /// Documentation link (read-only)

  String get documentationUrl {
    if (!_documentationUrlSet &&
        _apiMapResponse.containsKey('documentation_url')) {
      _documentationUrl = _apiMapResponse['documentation_url']?.toString();
      _documentationUrlSet = true;
    }
    return _documentationUrl;
  }

  set documentationUrl(String v) {
    _documentationUrl = v;
    _documentationUrlSet = true;
  }

  Error() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Error.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_messageSet || _apiMapResponse.containsKey('message')) {
      json['message'] = message;
    }
    if (_documentationUrlSet ||
        _apiMapResponse.containsKey('documentation_url')) {
      json['documentation_url'] = documentationUrl;
    }
    return json;
  }
}

class ExternalOauthApplication {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _id;
  bool _idSet = false;

  String _name;
  bool _nameSet = false;

  String _clientId;
  bool _clientIdSet = false;

  String _clientSecret;
  bool _clientSecretSet = false;

  String _dialectName;
  bool _dialectNameSet = false;

  DateTime _createdAt;
  bool _createdAtSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// ID of this OAuth Application (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// The name of this application.  For Snowflake connections, this should be the name of the host database.

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// The OAuth Client ID for this application

  String get clientId {
    if (!_clientIdSet && _apiMapResponse.containsKey('client_id')) {
      _clientId = _apiMapResponse['client_id']?.toString();
      _clientIdSet = true;
    }
    return _clientId;
  }

  set clientId(String v) {
    _clientId = v;
    _clientIdSet = true;
  }

  /// (Write-Only) The OAuth Client Secret for this application

  String get clientSecret {
    if (!_clientSecretSet && _apiMapResponse.containsKey('client_secret')) {
      _clientSecret = _apiMapResponse['client_secret']?.toString();
      _clientSecretSet = true;
    }
    return _clientSecret;
  }

  set clientSecret(String v) {
    _clientSecret = v;
    _clientSecretSet = true;
  }

  /// The database dialect for this application.

  String get dialectName {
    if (!_dialectNameSet && _apiMapResponse.containsKey('dialect_name')) {
      _dialectName = _apiMapResponse['dialect_name']?.toString();
      _dialectNameSet = true;
    }
    return _dialectName;
  }

  set dialectName(String v) {
    _dialectName = v;
    _dialectNameSet = true;
  }

  /// Creation time for this application (read-only)

  DateTime get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['created_at']);
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(DateTime v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  ExternalOauthApplication() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ExternalOauthApplication.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_clientIdSet || _apiMapResponse.containsKey('client_id')) {
      json['client_id'] = clientId;
    }
    if (_clientSecretSet || _apiMapResponse.containsKey('client_secret')) {
      json['client_secret'] = clientSecret;
    }
    if (_dialectNameSet || _apiMapResponse.containsKey('dialect_name')) {
      json['dialect_name'] = dialectName;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt?.toIso8601String();
    }
    return json;
  }
}

/// The style of dimension fill that is possible for this field. Null if no dimension fill is possible. Valid values are: "enumeration", "range". (Enum defined in LookmlModelExploreField)
enum FillStyle { enumeration, range }

class FillStyleMapper {
  static String toStringValue(FillStyle e) {
    switch (e) {
      case FillStyle.enumeration:
        return 'enumeration';
      case FillStyle.range:
        return 'range';

      default:
        return null;
    }
  }

  static FillStyle fromStringValue(String s) {
    if (s == 'enumeration') {
      return FillStyle.enumeration;
    }
    if (s == 'range') {
      return FillStyle.range;
    }
    return null;
  }
}

class Folder {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _parentId;
  bool _parentIdSet = false;

  String _id;
  bool _idSet = false;

  int _contentMetadataId;
  bool _contentMetadataIdSet = false;

  DateTime _createdAt;
  bool _createdAtSet = false;

  int _creatorId;
  bool _creatorIdSet = false;

  int _childCount;
  bool _childCountSet = false;

  String _externalId;
  bool _externalIdSet = false;

  bool _isEmbed;
  bool _isEmbedSet = false;

  bool _isEmbedSharedRoot;
  bool _isEmbedSharedRootSet = false;

  bool _isEmbedUsersRoot;
  bool _isEmbedUsersRootSet = false;

  bool _isPersonal;
  bool _isPersonalSet = false;

  bool _isPersonalDescendant;
  bool _isPersonalDescendantSet = false;

  bool _isSharedRoot;
  bool _isSharedRootSet = false;

  bool _isUsersRoot;
  bool _isUsersRootSet = false;

  Map<String, dynamic> _can;
  bool _canSet = false;

  List<DashboardBase> _dashboards;
  bool _dashboardsSet = false;

  List<LookWithDashboards> _looks;
  bool _looksSet = false;

  /// Unique Name

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Id of Parent. If the parent id is null, this is a root-level entry

  String get parentId {
    if (!_parentIdSet && _apiMapResponse.containsKey('parent_id')) {
      _parentId = _apiMapResponse['parent_id']?.toString();
      _parentIdSet = true;
    }
    return _parentId;
  }

  set parentId(String v) {
    _parentId = v;
    _parentIdSet = true;
  }

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Id of content metadata (read-only)

  int get contentMetadataId {
    if (!_contentMetadataIdSet &&
        _apiMapResponse.containsKey('content_metadata_id')) {
      _contentMetadataId = _apiMapResponse['content_metadata_id'];
      _contentMetadataIdSet = true;
    }
    return _contentMetadataId;
  }

  set contentMetadataId(int v) {
    _contentMetadataId = v;
    _contentMetadataIdSet = true;
  }

  /// Time the space was created (read-only)

  DateTime get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['created_at']);
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(DateTime v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// User Id of Creator (read-only)

  int get creatorId {
    if (!_creatorIdSet && _apiMapResponse.containsKey('creator_id')) {
      _creatorId = _apiMapResponse['creator_id'];
      _creatorIdSet = true;
    }
    return _creatorId;
  }

  set creatorId(int v) {
    _creatorId = v;
    _creatorIdSet = true;
  }

  /// Children Count (read-only)

  int get childCount {
    if (!_childCountSet && _apiMapResponse.containsKey('child_count')) {
      _childCount = _apiMapResponse['child_count'];
      _childCountSet = true;
    }
    return _childCount;
  }

  set childCount(int v) {
    _childCount = v;
    _childCountSet = true;
  }

  /// Embedder's Id if this folder was autogenerated as an embedding shared folder via 'external_group_id' in an SSO embed login (read-only)

  String get externalId {
    if (!_externalIdSet && _apiMapResponse.containsKey('external_id')) {
      _externalId = _apiMapResponse['external_id']?.toString();
      _externalIdSet = true;
    }
    return _externalId;
  }

  set externalId(String v) {
    _externalId = v;
    _externalIdSet = true;
  }

  /// Folder is an embed folder (read-only)

  bool get isEmbed {
    if (!_isEmbedSet && _apiMapResponse.containsKey('is_embed')) {
      _isEmbed = _apiMapResponse['is_embed'];
      _isEmbedSet = true;
    }
    return _isEmbed;
  }

  set isEmbed(bool v) {
    _isEmbed = v;
    _isEmbedSet = true;
  }

  /// Folder is the root embed shared folder (read-only)

  bool get isEmbedSharedRoot {
    if (!_isEmbedSharedRootSet &&
        _apiMapResponse.containsKey('is_embed_shared_root')) {
      _isEmbedSharedRoot = _apiMapResponse['is_embed_shared_root'];
      _isEmbedSharedRootSet = true;
    }
    return _isEmbedSharedRoot;
  }

  set isEmbedSharedRoot(bool v) {
    _isEmbedSharedRoot = v;
    _isEmbedSharedRootSet = true;
  }

  /// Folder is the root embed users folder (read-only)

  bool get isEmbedUsersRoot {
    if (!_isEmbedUsersRootSet &&
        _apiMapResponse.containsKey('is_embed_users_root')) {
      _isEmbedUsersRoot = _apiMapResponse['is_embed_users_root'];
      _isEmbedUsersRootSet = true;
    }
    return _isEmbedUsersRoot;
  }

  set isEmbedUsersRoot(bool v) {
    _isEmbedUsersRoot = v;
    _isEmbedUsersRootSet = true;
  }

  /// Folder is a user's personal folder (read-only)

  bool get isPersonal {
    if (!_isPersonalSet && _apiMapResponse.containsKey('is_personal')) {
      _isPersonal = _apiMapResponse['is_personal'];
      _isPersonalSet = true;
    }
    return _isPersonal;
  }

  set isPersonal(bool v) {
    _isPersonal = v;
    _isPersonalSet = true;
  }

  /// Folder is descendant of a user's personal folder (read-only)

  bool get isPersonalDescendant {
    if (!_isPersonalDescendantSet &&
        _apiMapResponse.containsKey('is_personal_descendant')) {
      _isPersonalDescendant = _apiMapResponse['is_personal_descendant'];
      _isPersonalDescendantSet = true;
    }
    return _isPersonalDescendant;
  }

  set isPersonalDescendant(bool v) {
    _isPersonalDescendant = v;
    _isPersonalDescendantSet = true;
  }

  /// Folder is the root shared folder (read-only)

  bool get isSharedRoot {
    if (!_isSharedRootSet && _apiMapResponse.containsKey('is_shared_root')) {
      _isSharedRoot = _apiMapResponse['is_shared_root'];
      _isSharedRootSet = true;
    }
    return _isSharedRoot;
  }

  set isSharedRoot(bool v) {
    _isSharedRoot = v;
    _isSharedRootSet = true;
  }

  /// Folder is the root user folder (read-only)

  bool get isUsersRoot {
    if (!_isUsersRootSet && _apiMapResponse.containsKey('is_users_root')) {
      _isUsersRoot = _apiMapResponse['is_users_root'];
      _isUsersRootSet = true;
    }
    return _isUsersRoot;
  }

  set isUsersRoot(bool v) {
    _isUsersRoot = v;
    _isUsersRootSet = true;
  }

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Dashboards (read-only)

  List<DashboardBase> get dashboards {
    if (!_dashboardsSet && _apiMapResponse.containsKey('dashboards')) {
      _dashboards = _apiMapResponse['dashboards'] == null
          ? null
          : (_apiMapResponse['dashboards'] as List)
              .map((i) => DashboardBase.fromResponse(i, apiResponseContentType))
              .toList();
      _dashboardsSet = true;
    }
    return _dashboards;
  }

  set dashboards(List<DashboardBase> v) {
    _dashboards = v;
    _dashboardsSet = true;
  }

  /// Looks (read-only)

  List<LookWithDashboards> get looks {
    if (!_looksSet && _apiMapResponse.containsKey('looks')) {
      _looks = _apiMapResponse['looks'] == null
          ? null
          : (_apiMapResponse['looks'] as List)
              .map((i) =>
                  LookWithDashboards.fromResponse(i, apiResponseContentType))
              .toList();
      _looksSet = true;
    }
    return _looks;
  }

  set looks(List<LookWithDashboards> v) {
    _looks = v;
    _looksSet = true;
  }

  Folder() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Folder.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_parentIdSet || _apiMapResponse.containsKey('parent_id')) {
      json['parent_id'] = parentId;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_contentMetadataIdSet ||
        _apiMapResponse.containsKey('content_metadata_id')) {
      json['content_metadata_id'] = contentMetadataId;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt?.toIso8601String();
    }
    if (_creatorIdSet || _apiMapResponse.containsKey('creator_id')) {
      json['creator_id'] = creatorId;
    }
    if (_childCountSet || _apiMapResponse.containsKey('child_count')) {
      json['child_count'] = childCount;
    }
    if (_externalIdSet || _apiMapResponse.containsKey('external_id')) {
      json['external_id'] = externalId;
    }
    if (_isEmbedSet || _apiMapResponse.containsKey('is_embed')) {
      json['is_embed'] = isEmbed;
    }
    if (_isEmbedSharedRootSet ||
        _apiMapResponse.containsKey('is_embed_shared_root')) {
      json['is_embed_shared_root'] = isEmbedSharedRoot;
    }
    if (_isEmbedUsersRootSet ||
        _apiMapResponse.containsKey('is_embed_users_root')) {
      json['is_embed_users_root'] = isEmbedUsersRoot;
    }
    if (_isPersonalSet || _apiMapResponse.containsKey('is_personal')) {
      json['is_personal'] = isPersonal;
    }
    if (_isPersonalDescendantSet ||
        _apiMapResponse.containsKey('is_personal_descendant')) {
      json['is_personal_descendant'] = isPersonalDescendant;
    }
    if (_isSharedRootSet || _apiMapResponse.containsKey('is_shared_root')) {
      json['is_shared_root'] = isSharedRoot;
    }
    if (_isUsersRootSet || _apiMapResponse.containsKey('is_users_root')) {
      json['is_users_root'] = isUsersRoot;
    }
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_dashboardsSet || _apiMapResponse.containsKey('dashboards')) {
      json['dashboards'] = dashboards?.map((i) => i.toJson())?.toList();
    }
    if (_looksSet || _apiMapResponse.containsKey('looks')) {
      json['looks'] = looks?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class FolderBase {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _parentId;
  bool _parentIdSet = false;

  String _id;
  bool _idSet = false;

  int _contentMetadataId;
  bool _contentMetadataIdSet = false;

  DateTime _createdAt;
  bool _createdAtSet = false;

  int _creatorId;
  bool _creatorIdSet = false;

  int _childCount;
  bool _childCountSet = false;

  String _externalId;
  bool _externalIdSet = false;

  bool _isEmbed;
  bool _isEmbedSet = false;

  bool _isEmbedSharedRoot;
  bool _isEmbedSharedRootSet = false;

  bool _isEmbedUsersRoot;
  bool _isEmbedUsersRootSet = false;

  bool _isPersonal;
  bool _isPersonalSet = false;

  bool _isPersonalDescendant;
  bool _isPersonalDescendantSet = false;

  bool _isSharedRoot;
  bool _isSharedRootSet = false;

  bool _isUsersRoot;
  bool _isUsersRootSet = false;

  Map<String, dynamic> _can;
  bool _canSet = false;

  /// Unique Name

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Id of Parent. If the parent id is null, this is a root-level entry

  String get parentId {
    if (!_parentIdSet && _apiMapResponse.containsKey('parent_id')) {
      _parentId = _apiMapResponse['parent_id']?.toString();
      _parentIdSet = true;
    }
    return _parentId;
  }

  set parentId(String v) {
    _parentId = v;
    _parentIdSet = true;
  }

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Id of content metadata (read-only)

  int get contentMetadataId {
    if (!_contentMetadataIdSet &&
        _apiMapResponse.containsKey('content_metadata_id')) {
      _contentMetadataId = _apiMapResponse['content_metadata_id'];
      _contentMetadataIdSet = true;
    }
    return _contentMetadataId;
  }

  set contentMetadataId(int v) {
    _contentMetadataId = v;
    _contentMetadataIdSet = true;
  }

  /// Time the folder was created (read-only)

  DateTime get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['created_at']);
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(DateTime v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// User Id of Creator (read-only)

  int get creatorId {
    if (!_creatorIdSet && _apiMapResponse.containsKey('creator_id')) {
      _creatorId = _apiMapResponse['creator_id'];
      _creatorIdSet = true;
    }
    return _creatorId;
  }

  set creatorId(int v) {
    _creatorId = v;
    _creatorIdSet = true;
  }

  /// Children Count (read-only)

  int get childCount {
    if (!_childCountSet && _apiMapResponse.containsKey('child_count')) {
      _childCount = _apiMapResponse['child_count'];
      _childCountSet = true;
    }
    return _childCount;
  }

  set childCount(int v) {
    _childCount = v;
    _childCountSet = true;
  }

  /// Embedder's Id if this folder was autogenerated as an embedding shared folder via 'external_group_id' in an SSO embed login (read-only)

  String get externalId {
    if (!_externalIdSet && _apiMapResponse.containsKey('external_id')) {
      _externalId = _apiMapResponse['external_id']?.toString();
      _externalIdSet = true;
    }
    return _externalId;
  }

  set externalId(String v) {
    _externalId = v;
    _externalIdSet = true;
  }

  /// Folder is an embed folder (read-only)

  bool get isEmbed {
    if (!_isEmbedSet && _apiMapResponse.containsKey('is_embed')) {
      _isEmbed = _apiMapResponse['is_embed'];
      _isEmbedSet = true;
    }
    return _isEmbed;
  }

  set isEmbed(bool v) {
    _isEmbed = v;
    _isEmbedSet = true;
  }

  /// Folder is the root embed shared folder (read-only)

  bool get isEmbedSharedRoot {
    if (!_isEmbedSharedRootSet &&
        _apiMapResponse.containsKey('is_embed_shared_root')) {
      _isEmbedSharedRoot = _apiMapResponse['is_embed_shared_root'];
      _isEmbedSharedRootSet = true;
    }
    return _isEmbedSharedRoot;
  }

  set isEmbedSharedRoot(bool v) {
    _isEmbedSharedRoot = v;
    _isEmbedSharedRootSet = true;
  }

  /// Folder is the root embed users folder (read-only)

  bool get isEmbedUsersRoot {
    if (!_isEmbedUsersRootSet &&
        _apiMapResponse.containsKey('is_embed_users_root')) {
      _isEmbedUsersRoot = _apiMapResponse['is_embed_users_root'];
      _isEmbedUsersRootSet = true;
    }
    return _isEmbedUsersRoot;
  }

  set isEmbedUsersRoot(bool v) {
    _isEmbedUsersRoot = v;
    _isEmbedUsersRootSet = true;
  }

  /// Folder is a user's personal folder (read-only)

  bool get isPersonal {
    if (!_isPersonalSet && _apiMapResponse.containsKey('is_personal')) {
      _isPersonal = _apiMapResponse['is_personal'];
      _isPersonalSet = true;
    }
    return _isPersonal;
  }

  set isPersonal(bool v) {
    _isPersonal = v;
    _isPersonalSet = true;
  }

  /// Folder is descendant of a user's personal folder (read-only)

  bool get isPersonalDescendant {
    if (!_isPersonalDescendantSet &&
        _apiMapResponse.containsKey('is_personal_descendant')) {
      _isPersonalDescendant = _apiMapResponse['is_personal_descendant'];
      _isPersonalDescendantSet = true;
    }
    return _isPersonalDescendant;
  }

  set isPersonalDescendant(bool v) {
    _isPersonalDescendant = v;
    _isPersonalDescendantSet = true;
  }

  /// Folder is the root shared folder (read-only)

  bool get isSharedRoot {
    if (!_isSharedRootSet && _apiMapResponse.containsKey('is_shared_root')) {
      _isSharedRoot = _apiMapResponse['is_shared_root'];
      _isSharedRootSet = true;
    }
    return _isSharedRoot;
  }

  set isSharedRoot(bool v) {
    _isSharedRoot = v;
    _isSharedRootSet = true;
  }

  /// Folder is the root user folder (read-only)

  bool get isUsersRoot {
    if (!_isUsersRootSet && _apiMapResponse.containsKey('is_users_root')) {
      _isUsersRoot = _apiMapResponse['is_users_root'];
      _isUsersRootSet = true;
    }
    return _isUsersRoot;
  }

  set isUsersRoot(bool v) {
    _isUsersRoot = v;
    _isUsersRootSet = true;
  }

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  FolderBase() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  FolderBase.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_parentIdSet || _apiMapResponse.containsKey('parent_id')) {
      json['parent_id'] = parentId;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_contentMetadataIdSet ||
        _apiMapResponse.containsKey('content_metadata_id')) {
      json['content_metadata_id'] = contentMetadataId;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt?.toIso8601String();
    }
    if (_creatorIdSet || _apiMapResponse.containsKey('creator_id')) {
      json['creator_id'] = creatorId;
    }
    if (_childCountSet || _apiMapResponse.containsKey('child_count')) {
      json['child_count'] = childCount;
    }
    if (_externalIdSet || _apiMapResponse.containsKey('external_id')) {
      json['external_id'] = externalId;
    }
    if (_isEmbedSet || _apiMapResponse.containsKey('is_embed')) {
      json['is_embed'] = isEmbed;
    }
    if (_isEmbedSharedRootSet ||
        _apiMapResponse.containsKey('is_embed_shared_root')) {
      json['is_embed_shared_root'] = isEmbedSharedRoot;
    }
    if (_isEmbedUsersRootSet ||
        _apiMapResponse.containsKey('is_embed_users_root')) {
      json['is_embed_users_root'] = isEmbedUsersRoot;
    }
    if (_isPersonalSet || _apiMapResponse.containsKey('is_personal')) {
      json['is_personal'] = isPersonal;
    }
    if (_isPersonalDescendantSet ||
        _apiMapResponse.containsKey('is_personal_descendant')) {
      json['is_personal_descendant'] = isPersonalDescendant;
    }
    if (_isSharedRootSet || _apiMapResponse.containsKey('is_shared_root')) {
      json['is_shared_root'] = isSharedRoot;
    }
    if (_isUsersRootSet || _apiMapResponse.containsKey('is_users_root')) {
      json['is_users_root'] = isUsersRoot;
    }
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    return json;
  }
}

/// Specifies the data format of the region information. Valid values are: "topojson", "vector_tile_region". (Enum defined in LookmlModelExploreFieldMapLayer)
enum Format { topojson, vectorTileRegion }

class FormatMapper {
  static String toStringValue(Format e) {
    switch (e) {
      case Format.topojson:
        return 'topojson';
      case Format.vectorTileRegion:
        return 'vector_tile_region';

      default:
        return null;
    }
  }

  static Format fromStringValue(String s) {
    if (s == 'topojson') {
      return Format.topojson;
    }
    if (s == 'vector_tile_region') {
      return Format.vectorTileRegion;
    }
    return null;
  }
}

class GitBranch {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _name;
  bool _nameSet = false;

  String _remote;
  bool _remoteSet = false;

  String _remoteName;
  bool _remoteNameSet = false;

  String _error;
  bool _errorSet = false;

  String _message;
  bool _messageSet = false;

  String _ownerName;
  bool _ownerNameSet = false;

  bool _readonly;
  bool _readonlySet = false;

  bool _personal;
  bool _personalSet = false;

  bool _isLocal;
  bool _isLocalSet = false;

  bool _isRemote;
  bool _isRemoteSet = false;

  bool _isProduction;
  bool _isProductionSet = false;

  int _aheadCount;
  bool _aheadCountSet = false;

  int _behindCount;
  bool _behindCountSet = false;

  int _commitAt;
  bool _commitAtSet = false;

  String _ref;
  bool _refSet = false;

  String _remoteRef;
  bool _remoteRefSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// The short name on the local. Updating `name` results in `git checkout <new_name>`

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// The name of the remote (read-only)

  String get remote {
    if (!_remoteSet && _apiMapResponse.containsKey('remote')) {
      _remote = _apiMapResponse['remote']?.toString();
      _remoteSet = true;
    }
    return _remote;
  }

  set remote(String v) {
    _remote = v;
    _remoteSet = true;
  }

  /// The short name on the remote (read-only)

  String get remoteName {
    if (!_remoteNameSet && _apiMapResponse.containsKey('remote_name')) {
      _remoteName = _apiMapResponse['remote_name']?.toString();
      _remoteNameSet = true;
    }
    return _remoteName;
  }

  set remoteName(String v) {
    _remoteName = v;
    _remoteNameSet = true;
  }

  /// Name of error (read-only)

  String get error {
    if (!_errorSet && _apiMapResponse.containsKey('error')) {
      _error = _apiMapResponse['error']?.toString();
      _errorSet = true;
    }
    return _error;
  }

  set error(String v) {
    _error = v;
    _errorSet = true;
  }

  /// Message describing an error if present (read-only)

  String get message {
    if (!_messageSet && _apiMapResponse.containsKey('message')) {
      _message = _apiMapResponse['message']?.toString();
      _messageSet = true;
    }
    return _message;
  }

  set message(String v) {
    _message = v;
    _messageSet = true;
  }

  /// Name of the owner of a personal branch (read-only)

  String get ownerName {
    if (!_ownerNameSet && _apiMapResponse.containsKey('owner_name')) {
      _ownerName = _apiMapResponse['owner_name']?.toString();
      _ownerNameSet = true;
    }
    return _ownerName;
  }

  set ownerName(String v) {
    _ownerName = v;
    _ownerNameSet = true;
  }

  /// Whether or not this branch is readonly (read-only)

  bool get readonly {
    if (!_readonlySet && _apiMapResponse.containsKey('readonly')) {
      _readonly = _apiMapResponse['readonly'];
      _readonlySet = true;
    }
    return _readonly;
  }

  set readonly(bool v) {
    _readonly = v;
    _readonlySet = true;
  }

  /// Whether or not this branch is a personal branch - readonly for all developers except the owner (read-only)

  bool get personal {
    if (!_personalSet && _apiMapResponse.containsKey('personal')) {
      _personal = _apiMapResponse['personal'];
      _personalSet = true;
    }
    return _personal;
  }

  set personal(bool v) {
    _personal = v;
    _personalSet = true;
  }

  /// Whether or not a local ref exists for the branch (read-only)

  bool get isLocal {
    if (!_isLocalSet && _apiMapResponse.containsKey('is_local')) {
      _isLocal = _apiMapResponse['is_local'];
      _isLocalSet = true;
    }
    return _isLocal;
  }

  set isLocal(bool v) {
    _isLocal = v;
    _isLocalSet = true;
  }

  /// Whether or not a remote ref exists for the branch (read-only)

  bool get isRemote {
    if (!_isRemoteSet && _apiMapResponse.containsKey('is_remote')) {
      _isRemote = _apiMapResponse['is_remote'];
      _isRemoteSet = true;
    }
    return _isRemote;
  }

  set isRemote(bool v) {
    _isRemote = v;
    _isRemoteSet = true;
  }

  /// Whether or not this is the production branch (read-only)

  bool get isProduction {
    if (!_isProductionSet && _apiMapResponse.containsKey('is_production')) {
      _isProduction = _apiMapResponse['is_production'];
      _isProductionSet = true;
    }
    return _isProduction;
  }

  set isProduction(bool v) {
    _isProduction = v;
    _isProductionSet = true;
  }

  /// Number of commits the local branch is ahead of the remote (read-only)

  int get aheadCount {
    if (!_aheadCountSet && _apiMapResponse.containsKey('ahead_count')) {
      _aheadCount = _apiMapResponse['ahead_count'];
      _aheadCountSet = true;
    }
    return _aheadCount;
  }

  set aheadCount(int v) {
    _aheadCount = v;
    _aheadCountSet = true;
  }

  /// Number of commits the local branch is behind the remote (read-only)

  int get behindCount {
    if (!_behindCountSet && _apiMapResponse.containsKey('behind_count')) {
      _behindCount = _apiMapResponse['behind_count'];
      _behindCountSet = true;
    }
    return _behindCount;
  }

  set behindCount(int v) {
    _behindCount = v;
    _behindCountSet = true;
  }

  /// UNIX timestamp at which this branch was last committed. (read-only)

  int get commitAt {
    if (!_commitAtSet && _apiMapResponse.containsKey('commit_at')) {
      _commitAt = _apiMapResponse['commit_at'];
      _commitAtSet = true;
    }
    return _commitAt;
  }

  set commitAt(int v) {
    _commitAt = v;
    _commitAtSet = true;
  }

  /// The resolved ref of this branch. Updating `ref` results in `git reset --hard <new_ref>``.

  String get ref {
    if (!_refSet && _apiMapResponse.containsKey('ref')) {
      _ref = _apiMapResponse['ref']?.toString();
      _refSet = true;
    }
    return _ref;
  }

  set ref(String v) {
    _ref = v;
    _refSet = true;
  }

  /// The resolved ref of this branch remote. (read-only)

  String get remoteRef {
    if (!_remoteRefSet && _apiMapResponse.containsKey('remote_ref')) {
      _remoteRef = _apiMapResponse['remote_ref']?.toString();
      _remoteRefSet = true;
    }
    return _remoteRef;
  }

  set remoteRef(String v) {
    _remoteRef = v;
    _remoteRefSet = true;
  }

  GitBranch() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  GitBranch.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_remoteSet || _apiMapResponse.containsKey('remote')) {
      json['remote'] = remote;
    }
    if (_remoteNameSet || _apiMapResponse.containsKey('remote_name')) {
      json['remote_name'] = remoteName;
    }
    if (_errorSet || _apiMapResponse.containsKey('error')) {
      json['error'] = error;
    }
    if (_messageSet || _apiMapResponse.containsKey('message')) {
      json['message'] = message;
    }
    if (_ownerNameSet || _apiMapResponse.containsKey('owner_name')) {
      json['owner_name'] = ownerName;
    }
    if (_readonlySet || _apiMapResponse.containsKey('readonly')) {
      json['readonly'] = readonly;
    }
    if (_personalSet || _apiMapResponse.containsKey('personal')) {
      json['personal'] = personal;
    }
    if (_isLocalSet || _apiMapResponse.containsKey('is_local')) {
      json['is_local'] = isLocal;
    }
    if (_isRemoteSet || _apiMapResponse.containsKey('is_remote')) {
      json['is_remote'] = isRemote;
    }
    if (_isProductionSet || _apiMapResponse.containsKey('is_production')) {
      json['is_production'] = isProduction;
    }
    if (_aheadCountSet || _apiMapResponse.containsKey('ahead_count')) {
      json['ahead_count'] = aheadCount;
    }
    if (_behindCountSet || _apiMapResponse.containsKey('behind_count')) {
      json['behind_count'] = behindCount;
    }
    if (_commitAtSet || _apiMapResponse.containsKey('commit_at')) {
      json['commit_at'] = commitAt;
    }
    if (_refSet || _apiMapResponse.containsKey('ref')) {
      json['ref'] = ref;
    }
    if (_remoteRefSet || _apiMapResponse.containsKey('remote_ref')) {
      json['remote_ref'] = remoteRef;
    }
    return json;
  }
}

class GitConnectionTest {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _description;
  bool _descriptionSet = false;

  String _id;
  bool _idSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Human readable string describing the test (read-only)

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// A short string, uniquely naming this test (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  GitConnectionTest() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  GitConnectionTest.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    return json;
  }
}

class GitConnectionTestResult {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _id;
  bool _idSet = false;

  String _message;
  bool _messageSet = false;

  String _status;
  bool _statusSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// A short string, uniquely naming this test (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Additional data from the test (read-only)

  String get message {
    if (!_messageSet && _apiMapResponse.containsKey('message')) {
      _message = _apiMapResponse['message']?.toString();
      _messageSet = true;
    }
    return _message;
  }

  set message(String v) {
    _message = v;
    _messageSet = true;
  }

  /// Either 'pass' or 'fail' (read-only)

  String get status {
    if (!_statusSet && _apiMapResponse.containsKey('status')) {
      _status = _apiMapResponse['status']?.toString();
      _statusSet = true;
    }
    return _status;
  }

  set status(String v) {
    _status = v;
    _statusSet = true;
  }

  GitConnectionTestResult() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  GitConnectionTestResult.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_messageSet || _apiMapResponse.containsKey('message')) {
      json['message'] = message;
    }
    if (_statusSet || _apiMapResponse.containsKey('status')) {
      json['status'] = status;
    }
    return json;
  }
}

class GitStatus {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _action;
  bool _actionSet = false;

  bool _conflict;
  bool _conflictSet = false;

  bool _revertable;
  bool _revertableSet = false;

  String _text;
  bool _textSet = false;

  /// Git action: add, delete, etc (read-only)

  String get action {
    if (!_actionSet && _apiMapResponse.containsKey('action')) {
      _action = _apiMapResponse['action']?.toString();
      _actionSet = true;
    }
    return _action;
  }

  set action(String v) {
    _action = v;
    _actionSet = true;
  }

  /// When true, changes to the local file conflict with the remote repository (read-only)

  bool get conflict {
    if (!_conflictSet && _apiMapResponse.containsKey('conflict')) {
      _conflict = _apiMapResponse['conflict'];
      _conflictSet = true;
    }
    return _conflict;
  }

  set conflict(bool v) {
    _conflict = v;
    _conflictSet = true;
  }

  /// When true, the file can be reverted to an earlier state (read-only)

  bool get revertable {
    if (!_revertableSet && _apiMapResponse.containsKey('revertable')) {
      _revertable = _apiMapResponse['revertable'];
      _revertableSet = true;
    }
    return _revertable;
  }

  set revertable(bool v) {
    _revertable = v;
    _revertableSet = true;
  }

  /// Git description of the action (read-only)

  String get text {
    if (!_textSet && _apiMapResponse.containsKey('text')) {
      _text = _apiMapResponse['text']?.toString();
      _textSet = true;
    }
    return _text;
  }

  set text(String v) {
    _text = v;
    _textSet = true;
  }

  GitStatus() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  GitStatus.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_actionSet || _apiMapResponse.containsKey('action')) {
      json['action'] = action;
    }
    if (_conflictSet || _apiMapResponse.containsKey('conflict')) {
      json['conflict'] = conflict;
    }
    if (_revertableSet || _apiMapResponse.containsKey('revertable')) {
      json['revertable'] = revertable;
    }
    if (_textSet || _apiMapResponse.containsKey('text')) {
      json['text'] = text;
    }
    return json;
  }
}

class Group {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  bool _canAddToContentMetadata;
  bool _canAddToContentMetadataSet = false;

  bool _containsCurrentUser;
  bool _containsCurrentUserSet = false;

  String _externalGroupId;
  bool _externalGroupIdSet = false;

  bool _externallyManaged;
  bool _externallyManagedSet = false;

  int _id;
  bool _idSet = false;

  bool _includeByDefault;
  bool _includeByDefaultSet = false;

  String _name;
  bool _nameSet = false;

  int _userCount;
  bool _userCountSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Group can be used in content access controls

  bool get canAddToContentMetadata {
    if (!_canAddToContentMetadataSet &&
        _apiMapResponse.containsKey('can_add_to_content_metadata')) {
      _canAddToContentMetadata = _apiMapResponse['can_add_to_content_metadata'];
      _canAddToContentMetadataSet = true;
    }
    return _canAddToContentMetadata;
  }

  set canAddToContentMetadata(bool v) {
    _canAddToContentMetadata = v;
    _canAddToContentMetadataSet = true;
  }

  /// Currently logged in user is group member (read-only)

  bool get containsCurrentUser {
    if (!_containsCurrentUserSet &&
        _apiMapResponse.containsKey('contains_current_user')) {
      _containsCurrentUser = _apiMapResponse['contains_current_user'];
      _containsCurrentUserSet = true;
    }
    return _containsCurrentUser;
  }

  set containsCurrentUser(bool v) {
    _containsCurrentUser = v;
    _containsCurrentUserSet = true;
  }

  /// External Id group if embed group (read-only)

  String get externalGroupId {
    if (!_externalGroupIdSet &&
        _apiMapResponse.containsKey('external_group_id')) {
      _externalGroupId = _apiMapResponse['external_group_id']?.toString();
      _externalGroupIdSet = true;
    }
    return _externalGroupId;
  }

  set externalGroupId(String v) {
    _externalGroupId = v;
    _externalGroupIdSet = true;
  }

  /// Group membership controlled outside of Looker (read-only)

  bool get externallyManaged {
    if (!_externallyManagedSet &&
        _apiMapResponse.containsKey('externally_managed')) {
      _externallyManaged = _apiMapResponse['externally_managed'];
      _externallyManagedSet = true;
    }
    return _externallyManaged;
  }

  set externallyManaged(bool v) {
    _externallyManaged = v;
    _externallyManagedSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// New users are added to this group by default (read-only)

  bool get includeByDefault {
    if (!_includeByDefaultSet &&
        _apiMapResponse.containsKey('include_by_default')) {
      _includeByDefault = _apiMapResponse['include_by_default'];
      _includeByDefaultSet = true;
    }
    return _includeByDefault;
  }

  set includeByDefault(bool v) {
    _includeByDefault = v;
    _includeByDefaultSet = true;
  }

  /// Name of group

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Number of users included in this group (read-only)

  int get userCount {
    if (!_userCountSet && _apiMapResponse.containsKey('user_count')) {
      _userCount = _apiMapResponse['user_count'];
      _userCountSet = true;
    }
    return _userCount;
  }

  set userCount(int v) {
    _userCount = v;
    _userCountSet = true;
  }

  Group() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Group.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_canAddToContentMetadataSet ||
        _apiMapResponse.containsKey('can_add_to_content_metadata')) {
      json['can_add_to_content_metadata'] = canAddToContentMetadata;
    }
    if (_containsCurrentUserSet ||
        _apiMapResponse.containsKey('contains_current_user')) {
      json['contains_current_user'] = containsCurrentUser;
    }
    if (_externalGroupIdSet ||
        _apiMapResponse.containsKey('external_group_id')) {
      json['external_group_id'] = externalGroupId;
    }
    if (_externallyManagedSet ||
        _apiMapResponse.containsKey('externally_managed')) {
      json['externally_managed'] = externallyManaged;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_includeByDefaultSet ||
        _apiMapResponse.containsKey('include_by_default')) {
      json['include_by_default'] = includeByDefault;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_userCountSet || _apiMapResponse.containsKey('user_count')) {
      json['user_count'] = userCount;
    }
    return json;
  }
}

class GroupHierarchy {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  bool _canAddToContentMetadata;
  bool _canAddToContentMetadataSet = false;

  bool _containsCurrentUser;
  bool _containsCurrentUserSet = false;

  String _externalGroupId;
  bool _externalGroupIdSet = false;

  bool _externallyManaged;
  bool _externallyManagedSet = false;

  int _id;
  bool _idSet = false;

  bool _includeByDefault;
  bool _includeByDefaultSet = false;

  String _name;
  bool _nameSet = false;

  int _userCount;
  bool _userCountSet = false;

  List<int> _parentGroupIds;
  bool _parentGroupIdsSet = false;

  List<int> _roleIds;
  bool _roleIdsSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Group can be used in content access controls

  bool get canAddToContentMetadata {
    if (!_canAddToContentMetadataSet &&
        _apiMapResponse.containsKey('can_add_to_content_metadata')) {
      _canAddToContentMetadata = _apiMapResponse['can_add_to_content_metadata'];
      _canAddToContentMetadataSet = true;
    }
    return _canAddToContentMetadata;
  }

  set canAddToContentMetadata(bool v) {
    _canAddToContentMetadata = v;
    _canAddToContentMetadataSet = true;
  }

  /// Currently logged in user is group member (read-only)

  bool get containsCurrentUser {
    if (!_containsCurrentUserSet &&
        _apiMapResponse.containsKey('contains_current_user')) {
      _containsCurrentUser = _apiMapResponse['contains_current_user'];
      _containsCurrentUserSet = true;
    }
    return _containsCurrentUser;
  }

  set containsCurrentUser(bool v) {
    _containsCurrentUser = v;
    _containsCurrentUserSet = true;
  }

  /// External Id group if embed group (read-only)

  String get externalGroupId {
    if (!_externalGroupIdSet &&
        _apiMapResponse.containsKey('external_group_id')) {
      _externalGroupId = _apiMapResponse['external_group_id']?.toString();
      _externalGroupIdSet = true;
    }
    return _externalGroupId;
  }

  set externalGroupId(String v) {
    _externalGroupId = v;
    _externalGroupIdSet = true;
  }

  /// Group membership controlled outside of Looker (read-only)

  bool get externallyManaged {
    if (!_externallyManagedSet &&
        _apiMapResponse.containsKey('externally_managed')) {
      _externallyManaged = _apiMapResponse['externally_managed'];
      _externallyManagedSet = true;
    }
    return _externallyManaged;
  }

  set externallyManaged(bool v) {
    _externallyManaged = v;
    _externallyManagedSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// New users are added to this group by default (read-only)

  bool get includeByDefault {
    if (!_includeByDefaultSet &&
        _apiMapResponse.containsKey('include_by_default')) {
      _includeByDefault = _apiMapResponse['include_by_default'];
      _includeByDefaultSet = true;
    }
    return _includeByDefault;
  }

  set includeByDefault(bool v) {
    _includeByDefault = v;
    _includeByDefaultSet = true;
  }

  /// Name of group

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Number of users included in this group (read-only)

  int get userCount {
    if (!_userCountSet && _apiMapResponse.containsKey('user_count')) {
      _userCount = _apiMapResponse['user_count'];
      _userCountSet = true;
    }
    return _userCount;
  }

  set userCount(int v) {
    _userCount = v;
    _userCountSet = true;
  }

  /// IDs of parents of this group (read-only)

  List<int> get parentGroupIds {
    if (!_parentGroupIdsSet &&
        _apiMapResponse.containsKey('parent_group_ids')) {
      _parentGroupIds = _apiMapResponse['parent_group_ids']
          ?.map<int>((i) => i as int)
          ?.toList();
      _parentGroupIdsSet = true;
    }
    return _parentGroupIds;
  }

  set parentGroupIds(List<int> v) {
    _parentGroupIds = v;
    _parentGroupIdsSet = true;
  }

  /// Role IDs assigned to group (read-only)

  List<int> get roleIds {
    if (!_roleIdsSet && _apiMapResponse.containsKey('role_ids')) {
      _roleIds =
          _apiMapResponse['role_ids']?.map<int>((i) => i as int)?.toList();
      _roleIdsSet = true;
    }
    return _roleIds;
  }

  set roleIds(List<int> v) {
    _roleIds = v;
    _roleIdsSet = true;
  }

  GroupHierarchy() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  GroupHierarchy.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_canAddToContentMetadataSet ||
        _apiMapResponse.containsKey('can_add_to_content_metadata')) {
      json['can_add_to_content_metadata'] = canAddToContentMetadata;
    }
    if (_containsCurrentUserSet ||
        _apiMapResponse.containsKey('contains_current_user')) {
      json['contains_current_user'] = containsCurrentUser;
    }
    if (_externalGroupIdSet ||
        _apiMapResponse.containsKey('external_group_id')) {
      json['external_group_id'] = externalGroupId;
    }
    if (_externallyManagedSet ||
        _apiMapResponse.containsKey('externally_managed')) {
      json['externally_managed'] = externallyManaged;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_includeByDefaultSet ||
        _apiMapResponse.containsKey('include_by_default')) {
      json['include_by_default'] = includeByDefault;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_userCountSet || _apiMapResponse.containsKey('user_count')) {
      json['user_count'] = userCount;
    }
    if (_parentGroupIdsSet || _apiMapResponse.containsKey('parent_group_ids')) {
      json['parent_group_ids'] = parentGroupIds;
    }
    if (_roleIdsSet || _apiMapResponse.containsKey('role_ids')) {
      json['role_ids'] = roleIds;
    }
    return json;
  }
}

/// WARNING: no writeable properties found for POST, PUT, or PATCH
class GroupIdForGroupInclusion {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _groupId;
  bool _groupIdSet = false;

  /// Id of group (read-only)

  int get groupId {
    if (!_groupIdSet && _apiMapResponse.containsKey('group_id')) {
      _groupId = _apiMapResponse['group_id'];
      _groupIdSet = true;
    }
    return _groupId;
  }

  set groupId(int v) {
    _groupId = v;
    _groupIdSet = true;
  }

  GroupIdForGroupInclusion() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  GroupIdForGroupInclusion.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_groupIdSet || _apiMapResponse.containsKey('group_id')) {
      json['group_id'] = groupId;
    }
    return json;
  }
}

/// WARNING: no writeable properties found for POST, PUT, or PATCH
class GroupIdForGroupUserInclusion {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _userId;
  bool _userIdSet = false;

  /// Id of user (read-only)

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  GroupIdForGroupUserInclusion() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  GroupIdForGroupUserInclusion.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    return json;
  }
}

class GroupSearch {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  bool _canAddToContentMetadata;
  bool _canAddToContentMetadataSet = false;

  bool _containsCurrentUser;
  bool _containsCurrentUserSet = false;

  String _externalGroupId;
  bool _externalGroupIdSet = false;

  bool _externallyManaged;
  bool _externallyManagedSet = false;

  int _id;
  bool _idSet = false;

  bool _includeByDefault;
  bool _includeByDefaultSet = false;

  String _name;
  bool _nameSet = false;

  int _userCount;
  bool _userCountSet = false;

  List<Role> _roles;
  bool _rolesSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Group can be used in content access controls

  bool get canAddToContentMetadata {
    if (!_canAddToContentMetadataSet &&
        _apiMapResponse.containsKey('can_add_to_content_metadata')) {
      _canAddToContentMetadata = _apiMapResponse['can_add_to_content_metadata'];
      _canAddToContentMetadataSet = true;
    }
    return _canAddToContentMetadata;
  }

  set canAddToContentMetadata(bool v) {
    _canAddToContentMetadata = v;
    _canAddToContentMetadataSet = true;
  }

  /// Currently logged in user is group member (read-only)

  bool get containsCurrentUser {
    if (!_containsCurrentUserSet &&
        _apiMapResponse.containsKey('contains_current_user')) {
      _containsCurrentUser = _apiMapResponse['contains_current_user'];
      _containsCurrentUserSet = true;
    }
    return _containsCurrentUser;
  }

  set containsCurrentUser(bool v) {
    _containsCurrentUser = v;
    _containsCurrentUserSet = true;
  }

  /// External Id group if embed group (read-only)

  String get externalGroupId {
    if (!_externalGroupIdSet &&
        _apiMapResponse.containsKey('external_group_id')) {
      _externalGroupId = _apiMapResponse['external_group_id']?.toString();
      _externalGroupIdSet = true;
    }
    return _externalGroupId;
  }

  set externalGroupId(String v) {
    _externalGroupId = v;
    _externalGroupIdSet = true;
  }

  /// Group membership controlled outside of Looker (read-only)

  bool get externallyManaged {
    if (!_externallyManagedSet &&
        _apiMapResponse.containsKey('externally_managed')) {
      _externallyManaged = _apiMapResponse['externally_managed'];
      _externallyManagedSet = true;
    }
    return _externallyManaged;
  }

  set externallyManaged(bool v) {
    _externallyManaged = v;
    _externallyManagedSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// New users are added to this group by default (read-only)

  bool get includeByDefault {
    if (!_includeByDefaultSet &&
        _apiMapResponse.containsKey('include_by_default')) {
      _includeByDefault = _apiMapResponse['include_by_default'];
      _includeByDefaultSet = true;
    }
    return _includeByDefault;
  }

  set includeByDefault(bool v) {
    _includeByDefault = v;
    _includeByDefaultSet = true;
  }

  /// Name of group

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Number of users included in this group (read-only)

  int get userCount {
    if (!_userCountSet && _apiMapResponse.containsKey('user_count')) {
      _userCount = _apiMapResponse['user_count'];
      _userCountSet = true;
    }
    return _userCount;
  }

  set userCount(int v) {
    _userCount = v;
    _userCountSet = true;
  }

  /// Roles assigned to group (read-only)

  List<Role> get roles {
    if (!_rolesSet && _apiMapResponse.containsKey('roles')) {
      _roles = _apiMapResponse['roles'] == null
          ? null
          : (_apiMapResponse['roles'] as List)
              .map((i) => Role.fromResponse(i, apiResponseContentType))
              .toList();
      _rolesSet = true;
    }
    return _roles;
  }

  set roles(List<Role> v) {
    _roles = v;
    _rolesSet = true;
  }

  GroupSearch() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  GroupSearch.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_canAddToContentMetadataSet ||
        _apiMapResponse.containsKey('can_add_to_content_metadata')) {
      json['can_add_to_content_metadata'] = canAddToContentMetadata;
    }
    if (_containsCurrentUserSet ||
        _apiMapResponse.containsKey('contains_current_user')) {
      json['contains_current_user'] = containsCurrentUser;
    }
    if (_externalGroupIdSet ||
        _apiMapResponse.containsKey('external_group_id')) {
      json['external_group_id'] = externalGroupId;
    }
    if (_externallyManagedSet ||
        _apiMapResponse.containsKey('externally_managed')) {
      json['externally_managed'] = externallyManaged;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_includeByDefaultSet ||
        _apiMapResponse.containsKey('include_by_default')) {
      json['include_by_default'] = includeByDefault;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_userCountSet || _apiMapResponse.containsKey('user_count')) {
      json['user_count'] = userCount;
    }
    if (_rolesSet || _apiMapResponse.containsKey('roles')) {
      json['roles'] = roles?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class HomepageItem {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _contentCreatedBy;
  bool _contentCreatedBySet = false;

  int _contentFavoriteId;
  bool _contentFavoriteIdSet = false;

  int _contentMetadataId;
  bool _contentMetadataIdSet = false;

  String _contentUpdatedAt;
  bool _contentUpdatedAtSet = false;

  String _customDescription;
  bool _customDescriptionSet = false;

  String _customImageDataBase64;
  bool _customImageDataBase64Set = false;

  String _customImageUrl;
  bool _customImageUrlSet = false;

  String _customTitle;
  bool _customTitleSet = false;

  String _customUrl;
  bool _customUrlSet = false;

  int _dashboardId;
  bool _dashboardIdSet = false;

  String _description;
  bool _descriptionSet = false;

  int _favoriteCount;
  bool _favoriteCountSet = false;

  int _homepageSectionId;
  bool _homepageSectionIdSet = false;

  int _id;
  bool _idSet = false;

  String _imageUrl;
  bool _imageUrlSet = false;

  String _location;
  bool _locationSet = false;

  String _lookId;
  bool _lookIdSet = false;

  String _lookmlDashboardId;
  bool _lookmlDashboardIdSet = false;

  int _order;
  bool _orderSet = false;

  double _sectionFetchTime;
  bool _sectionFetchTimeSet = false;

  String _title;
  bool _titleSet = false;

  String _url;
  bool _urlSet = false;

  bool _useCustomDescription;
  bool _useCustomDescriptionSet = false;

  bool _useCustomImage;
  bool _useCustomImageSet = false;

  bool _useCustomTitle;
  bool _useCustomTitleSet = false;

  bool _useCustomUrl;
  bool _useCustomUrlSet = false;

  int _viewCount;
  bool _viewCountSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Name of user who created the content this item is based on (read-only)

  String get contentCreatedBy {
    if (!_contentCreatedBySet &&
        _apiMapResponse.containsKey('content_created_by')) {
      _contentCreatedBy = _apiMapResponse['content_created_by']?.toString();
      _contentCreatedBySet = true;
    }
    return _contentCreatedBy;
  }

  set contentCreatedBy(String v) {
    _contentCreatedBy = v;
    _contentCreatedBySet = true;
  }

  /// Content favorite id associated with the item this content is based on (read-only)

  int get contentFavoriteId {
    if (!_contentFavoriteIdSet &&
        _apiMapResponse.containsKey('content_favorite_id')) {
      _contentFavoriteId = _apiMapResponse['content_favorite_id'];
      _contentFavoriteIdSet = true;
    }
    return _contentFavoriteId;
  }

  set contentFavoriteId(int v) {
    _contentFavoriteId = v;
    _contentFavoriteIdSet = true;
  }

  /// Content metadata id associated with the item this content is based on (read-only)

  int get contentMetadataId {
    if (!_contentMetadataIdSet &&
        _apiMapResponse.containsKey('content_metadata_id')) {
      _contentMetadataId = _apiMapResponse['content_metadata_id'];
      _contentMetadataIdSet = true;
    }
    return _contentMetadataId;
  }

  set contentMetadataId(int v) {
    _contentMetadataId = v;
    _contentMetadataIdSet = true;
  }

  /// Last time the content that this item is based on was updated (read-only)

  String get contentUpdatedAt {
    if (!_contentUpdatedAtSet &&
        _apiMapResponse.containsKey('content_updated_at')) {
      _contentUpdatedAt = _apiMapResponse['content_updated_at']?.toString();
      _contentUpdatedAtSet = true;
    }
    return _contentUpdatedAt;
  }

  set contentUpdatedAt(String v) {
    _contentUpdatedAt = v;
    _contentUpdatedAtSet = true;
  }

  /// Custom description entered by the user, if present

  String get customDescription {
    if (!_customDescriptionSet &&
        _apiMapResponse.containsKey('custom_description')) {
      _customDescription = _apiMapResponse['custom_description']?.toString();
      _customDescriptionSet = true;
    }
    return _customDescription;
  }

  set customDescription(String v) {
    _customDescription = v;
    _customDescriptionSet = true;
  }

  /// (Write-Only) base64 encoded image data

  String get customImageDataBase64 {
    if (!_customImageDataBase64Set &&
        _apiMapResponse.containsKey('custom_image_data_base64')) {
      _customImageDataBase64 =
          _apiMapResponse['custom_image_data_base64']?.toString();
      _customImageDataBase64Set = true;
    }
    return _customImageDataBase64;
  }

  set customImageDataBase64(String v) {
    _customImageDataBase64 = v;
    _customImageDataBase64Set = true;
  }

  /// Custom image_url entered by the user, if present (read-only)

  String get customImageUrl {
    if (!_customImageUrlSet &&
        _apiMapResponse.containsKey('custom_image_url')) {
      _customImageUrl = _apiMapResponse['custom_image_url']?.toString();
      _customImageUrlSet = true;
    }
    return _customImageUrl;
  }

  set customImageUrl(String v) {
    _customImageUrl = v;
    _customImageUrlSet = true;
  }

  /// Custom title entered by the user, if present

  String get customTitle {
    if (!_customTitleSet && _apiMapResponse.containsKey('custom_title')) {
      _customTitle = _apiMapResponse['custom_title']?.toString();
      _customTitleSet = true;
    }
    return _customTitle;
  }

  set customTitle(String v) {
    _customTitle = v;
    _customTitleSet = true;
  }

  /// Custom url entered by the user, if present

  String get customUrl {
    if (!_customUrlSet && _apiMapResponse.containsKey('custom_url')) {
      _customUrl = _apiMapResponse['custom_url']?.toString();
      _customUrlSet = true;
    }
    return _customUrl;
  }

  set customUrl(String v) {
    _customUrl = v;
    _customUrlSet = true;
  }

  /// Dashboard to base this item on

  int get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id'];
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(int v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// The actual description for display (read-only)

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Number of times content has been favorited, if present (read-only)

  int get favoriteCount {
    if (!_favoriteCountSet && _apiMapResponse.containsKey('favorite_count')) {
      _favoriteCount = _apiMapResponse['favorite_count'];
      _favoriteCountSet = true;
    }
    return _favoriteCount;
  }

  set favoriteCount(int v) {
    _favoriteCount = v;
    _favoriteCountSet = true;
  }

  /// Associated Homepage Section

  int get homepageSectionId {
    if (!_homepageSectionIdSet &&
        _apiMapResponse.containsKey('homepage_section_id')) {
      _homepageSectionId = _apiMapResponse['homepage_section_id'];
      _homepageSectionIdSet = true;
    }
    return _homepageSectionId;
  }

  set homepageSectionId(int v) {
    _homepageSectionId = v;
    _homepageSectionIdSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// The actual image_url for display (read-only)

  String get imageUrl {
    if (!_imageUrlSet && _apiMapResponse.containsKey('image_url')) {
      _imageUrl = _apiMapResponse['image_url']?.toString();
      _imageUrlSet = true;
    }
    return _imageUrl;
  }

  set imageUrl(String v) {
    _imageUrl = v;
    _imageUrlSet = true;
  }

  /// The container folder name of the content (read-only)

  String get location {
    if (!_locationSet && _apiMapResponse.containsKey('location')) {
      _location = _apiMapResponse['location']?.toString();
      _locationSet = true;
    }
    return _location;
  }

  set location(String v) {
    _location = v;
    _locationSet = true;
  }

  /// Look to base this item on

  String get lookId {
    if (!_lookIdSet && _apiMapResponse.containsKey('look_id')) {
      _lookId = _apiMapResponse['look_id']?.toString();
      _lookIdSet = true;
    }
    return _lookId;
  }

  set lookId(String v) {
    _lookId = v;
    _lookIdSet = true;
  }

  /// LookML Dashboard to base this item on

  String get lookmlDashboardId {
    if (!_lookmlDashboardIdSet &&
        _apiMapResponse.containsKey('lookml_dashboard_id')) {
      _lookmlDashboardId = _apiMapResponse['lookml_dashboard_id']?.toString();
      _lookmlDashboardIdSet = true;
    }
    return _lookmlDashboardId;
  }

  set lookmlDashboardId(String v) {
    _lookmlDashboardId = v;
    _lookmlDashboardIdSet = true;
  }

  /// An arbitrary integer representing the sort order within the section

  int get order {
    if (!_orderSet && _apiMapResponse.containsKey('order')) {
      _order = _apiMapResponse['order'];
      _orderSet = true;
    }
    return _order;
  }

  set order(int v) {
    _order = v;
    _orderSet = true;
  }

  /// Number of seconds it took to fetch the section this item is in (read-only)

  double get sectionFetchTime {
    if (!_sectionFetchTimeSet &&
        _apiMapResponse.containsKey('section_fetch_time')) {
      _sectionFetchTime = _apiMapResponse['section_fetch_time'];
      _sectionFetchTimeSet = true;
    }
    return _sectionFetchTime;
  }

  set sectionFetchTime(double v) {
    _sectionFetchTime = v;
    _sectionFetchTimeSet = true;
  }

  /// The actual title for display (read-only)

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// The actual url for display (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  /// Whether the custom description should be used instead of the content description, if the item is associated with content

  bool get useCustomDescription {
    if (!_useCustomDescriptionSet &&
        _apiMapResponse.containsKey('use_custom_description')) {
      _useCustomDescription = _apiMapResponse['use_custom_description'];
      _useCustomDescriptionSet = true;
    }
    return _useCustomDescription;
  }

  set useCustomDescription(bool v) {
    _useCustomDescription = v;
    _useCustomDescriptionSet = true;
  }

  /// Whether the custom image should be used instead of the content image, if the item is associated with content

  bool get useCustomImage {
    if (!_useCustomImageSet &&
        _apiMapResponse.containsKey('use_custom_image')) {
      _useCustomImage = _apiMapResponse['use_custom_image'];
      _useCustomImageSet = true;
    }
    return _useCustomImage;
  }

  set useCustomImage(bool v) {
    _useCustomImage = v;
    _useCustomImageSet = true;
  }

  /// Whether the custom title should be used instead of the content title, if the item is associated with content

  bool get useCustomTitle {
    if (!_useCustomTitleSet &&
        _apiMapResponse.containsKey('use_custom_title')) {
      _useCustomTitle = _apiMapResponse['use_custom_title'];
      _useCustomTitleSet = true;
    }
    return _useCustomTitle;
  }

  set useCustomTitle(bool v) {
    _useCustomTitle = v;
    _useCustomTitleSet = true;
  }

  /// Whether the custom url should be used instead of the content url, if the item is associated with content

  bool get useCustomUrl {
    if (!_useCustomUrlSet && _apiMapResponse.containsKey('use_custom_url')) {
      _useCustomUrl = _apiMapResponse['use_custom_url'];
      _useCustomUrlSet = true;
    }
    return _useCustomUrl;
  }

  set useCustomUrl(bool v) {
    _useCustomUrl = v;
    _useCustomUrlSet = true;
  }

  /// Number of times content has been viewed, if present (read-only)

  int get viewCount {
    if (!_viewCountSet && _apiMapResponse.containsKey('view_count')) {
      _viewCount = _apiMapResponse['view_count'];
      _viewCountSet = true;
    }
    return _viewCount;
  }

  set viewCount(int v) {
    _viewCount = v;
    _viewCountSet = true;
  }

  HomepageItem() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  HomepageItem.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_contentCreatedBySet ||
        _apiMapResponse.containsKey('content_created_by')) {
      json['content_created_by'] = contentCreatedBy;
    }
    if (_contentFavoriteIdSet ||
        _apiMapResponse.containsKey('content_favorite_id')) {
      json['content_favorite_id'] = contentFavoriteId;
    }
    if (_contentMetadataIdSet ||
        _apiMapResponse.containsKey('content_metadata_id')) {
      json['content_metadata_id'] = contentMetadataId;
    }
    if (_contentUpdatedAtSet ||
        _apiMapResponse.containsKey('content_updated_at')) {
      json['content_updated_at'] = contentUpdatedAt;
    }
    if (_customDescriptionSet ||
        _apiMapResponse.containsKey('custom_description')) {
      json['custom_description'] = customDescription;
    }
    if (_customImageDataBase64Set ||
        _apiMapResponse.containsKey('custom_image_data_base64')) {
      json['custom_image_data_base64'] = customImageDataBase64;
    }
    if (_customImageUrlSet || _apiMapResponse.containsKey('custom_image_url')) {
      json['custom_image_url'] = customImageUrl;
    }
    if (_customTitleSet || _apiMapResponse.containsKey('custom_title')) {
      json['custom_title'] = customTitle;
    }
    if (_customUrlSet || _apiMapResponse.containsKey('custom_url')) {
      json['custom_url'] = customUrl;
    }
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_favoriteCountSet || _apiMapResponse.containsKey('favorite_count')) {
      json['favorite_count'] = favoriteCount;
    }
    if (_homepageSectionIdSet ||
        _apiMapResponse.containsKey('homepage_section_id')) {
      json['homepage_section_id'] = homepageSectionId;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_imageUrlSet || _apiMapResponse.containsKey('image_url')) {
      json['image_url'] = imageUrl;
    }
    if (_locationSet || _apiMapResponse.containsKey('location')) {
      json['location'] = location;
    }
    if (_lookIdSet || _apiMapResponse.containsKey('look_id')) {
      json['look_id'] = lookId;
    }
    if (_lookmlDashboardIdSet ||
        _apiMapResponse.containsKey('lookml_dashboard_id')) {
      json['lookml_dashboard_id'] = lookmlDashboardId;
    }
    if (_orderSet || _apiMapResponse.containsKey('order')) {
      json['order'] = order;
    }
    if (_sectionFetchTimeSet ||
        _apiMapResponse.containsKey('section_fetch_time')) {
      json['section_fetch_time'] = sectionFetchTime;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    if (_useCustomDescriptionSet ||
        _apiMapResponse.containsKey('use_custom_description')) {
      json['use_custom_description'] = useCustomDescription;
    }
    if (_useCustomImageSet || _apiMapResponse.containsKey('use_custom_image')) {
      json['use_custom_image'] = useCustomImage;
    }
    if (_useCustomTitleSet || _apiMapResponse.containsKey('use_custom_title')) {
      json['use_custom_title'] = useCustomTitle;
    }
    if (_useCustomUrlSet || _apiMapResponse.containsKey('use_custom_url')) {
      json['use_custom_url'] = useCustomUrl;
    }
    if (_viewCountSet || _apiMapResponse.containsKey('view_count')) {
      json['view_count'] = viewCount;
    }
    return json;
  }
}

class HomepageSection {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  DateTime _createdAt;
  bool _createdAtSet = false;

  DateTime _deletedAt;
  bool _deletedAtSet = false;

  String _detailUrl;
  bool _detailUrlSet = false;

  int _homepageId;
  bool _homepageIdSet = false;

  List<HomepageItem> _homepageItems;
  bool _homepageItemsSet = false;

  int _id;
  bool _idSet = false;

  bool _isHeader;
  bool _isHeaderSet = false;

  List<int> _itemOrder;
  bool _itemOrderSet = false;

  String _title;
  bool _titleSet = false;

  DateTime _updatedAt;
  bool _updatedAtSet = false;

  String _description;
  bool _descriptionSet = false;

  List<int> _visibleItemOrder;
  bool _visibleItemOrderSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Time at which this section was created. (read-only)

  DateTime get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['created_at']);
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(DateTime v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// Time at which this section was deleted.

  DateTime get deletedAt {
    if (!_deletedAtSet && _apiMapResponse.containsKey('deleted_at')) {
      _deletedAt = _apiMapResponse['deleted_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['deleted_at']);
      _deletedAtSet = true;
    }
    return _deletedAt;
  }

  set deletedAt(DateTime v) {
    _deletedAt = v;
    _deletedAtSet = true;
  }

  /// A URL pointing to a page showing further information about the content in the section. (read-only)

  String get detailUrl {
    if (!_detailUrlSet && _apiMapResponse.containsKey('detail_url')) {
      _detailUrl = _apiMapResponse['detail_url']?.toString();
      _detailUrlSet = true;
    }
    return _detailUrl;
  }

  set detailUrl(String v) {
    _detailUrl = v;
    _detailUrlSet = true;
  }

  /// Id reference to parent homepage

  int get homepageId {
    if (!_homepageIdSet && _apiMapResponse.containsKey('homepage_id')) {
      _homepageId = _apiMapResponse['homepage_id'];
      _homepageIdSet = true;
    }
    return _homepageId;
  }

  set homepageId(int v) {
    _homepageId = v;
    _homepageIdSet = true;
  }

  /// Items in the homepage section (read-only)

  List<HomepageItem> get homepageItems {
    if (!_homepageItemsSet && _apiMapResponse.containsKey('homepage_items')) {
      _homepageItems = _apiMapResponse['homepage_items'] == null
          ? null
          : (_apiMapResponse['homepage_items'] as List)
              .map((i) => HomepageItem.fromResponse(i, apiResponseContentType))
              .toList();
      _homepageItemsSet = true;
    }
    return _homepageItems;
  }

  set homepageItems(List<HomepageItem> v) {
    _homepageItems = v;
    _homepageItemsSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Is this a header section (has no items) (read-only)

  bool get isHeader {
    if (!_isHeaderSet && _apiMapResponse.containsKey('is_header')) {
      _isHeader = _apiMapResponse['is_header'];
      _isHeaderSet = true;
    }
    return _isHeader;
  }

  set isHeader(bool v) {
    _isHeader = v;
    _isHeaderSet = true;
  }

  /// ids of the homepage items in the order they should be displayed

  List<int> get itemOrder {
    if (!_itemOrderSet && _apiMapResponse.containsKey('item_order')) {
      _itemOrder =
          _apiMapResponse['item_order']?.map<int>((i) => i as int)?.toList();
      _itemOrderSet = true;
    }
    return _itemOrder;
  }

  set itemOrder(List<int> v) {
    _itemOrder = v;
    _itemOrderSet = true;
  }

  /// Name of row

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Time at which this section was last updated. (read-only)

  DateTime get updatedAt {
    if (!_updatedAtSet && _apiMapResponse.containsKey('updated_at')) {
      _updatedAt = _apiMapResponse['updated_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['updated_at']);
      _updatedAtSet = true;
    }
    return _updatedAt;
  }

  set updatedAt(DateTime v) {
    _updatedAt = v;
    _updatedAtSet = true;
  }

  /// Description of the content found in this section.

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// ids of the homepage items the user can see in the order they should be displayed (read-only)

  List<int> get visibleItemOrder {
    if (!_visibleItemOrderSet &&
        _apiMapResponse.containsKey('visible_item_order')) {
      _visibleItemOrder = _apiMapResponse['visible_item_order']
          ?.map<int>((i) => i as int)
          ?.toList();
      _visibleItemOrderSet = true;
    }
    return _visibleItemOrder;
  }

  set visibleItemOrder(List<int> v) {
    _visibleItemOrder = v;
    _visibleItemOrderSet = true;
  }

  HomepageSection() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  HomepageSection.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt?.toIso8601String();
    }
    if (_deletedAtSet || _apiMapResponse.containsKey('deleted_at')) {
      json['deleted_at'] = deletedAt?.toIso8601String();
    }
    if (_detailUrlSet || _apiMapResponse.containsKey('detail_url')) {
      json['detail_url'] = detailUrl;
    }
    if (_homepageIdSet || _apiMapResponse.containsKey('homepage_id')) {
      json['homepage_id'] = homepageId;
    }
    if (_homepageItemsSet || _apiMapResponse.containsKey('homepage_items')) {
      json['homepage_items'] = homepageItems?.map((i) => i.toJson())?.toList();
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_isHeaderSet || _apiMapResponse.containsKey('is_header')) {
      json['is_header'] = isHeader;
    }
    if (_itemOrderSet || _apiMapResponse.containsKey('item_order')) {
      json['item_order'] = itemOrder;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_updatedAtSet || _apiMapResponse.containsKey('updated_at')) {
      json['updated_at'] = updatedAt?.toIso8601String();
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_visibleItemOrderSet ||
        _apiMapResponse.containsKey('visible_item_order')) {
      json['visible_item_order'] = visibleItemOrder;
    }
    return json;
  }
}

class ImportedProject {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _url;
  bool _urlSet = false;

  String _ref;
  bool _refSet = false;

  bool _isRemote;
  bool _isRemoteSet = false;

  /// Dependency name (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Url for a remote dependency (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  /// Ref for a remote dependency (read-only)

  String get ref {
    if (!_refSet && _apiMapResponse.containsKey('ref')) {
      _ref = _apiMapResponse['ref']?.toString();
      _refSet = true;
    }
    return _ref;
  }

  set ref(String v) {
    _ref = v;
    _refSet = true;
  }

  /// Flag signifying if a dependency is remote or local (read-only)

  bool get isRemote {
    if (!_isRemoteSet && _apiMapResponse.containsKey('is_remote')) {
      _isRemote = _apiMapResponse['is_remote'];
      _isRemoteSet = true;
    }
    return _isRemote;
  }

  set isRemote(bool v) {
    _isRemote = v;
    _isRemoteSet = true;
  }

  ImportedProject() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ImportedProject.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    if (_refSet || _apiMapResponse.containsKey('ref')) {
      json['ref'] = ref;
    }
    if (_isRemoteSet || _apiMapResponse.containsKey('is_remote')) {
      json['is_remote'] = isRemote;
    }
    return json;
  }
}

class Integration {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _id;
  bool _idSet = false;

  int _integrationHubId;
  bool _integrationHubIdSet = false;

  String _label;
  bool _labelSet = false;

  String _description;
  bool _descriptionSet = false;

  bool _enabled;
  bool _enabledSet = false;

  List<IntegrationParam> _params;
  bool _paramsSet = false;

  List<SupportedFormats> _supportedFormats;
  bool _supportedFormatsSet = false;

  List<SupportedActionTypes> _supportedActionTypes;
  bool _supportedActionTypesSet = false;

  List<SupportedFormattings> _supportedFormattings;
  bool _supportedFormattingsSet = false;

  List<SupportedVisualizationFormattings> _supportedVisualizationFormattings;
  bool _supportedVisualizationFormattingsSet = false;

  List<SupportedDownloadSettings> _supportedDownloadSettings;
  bool _supportedDownloadSettingsSet = false;

  String _iconUrl;
  bool _iconUrlSet = false;

  bool _usesOauth;
  bool _usesOauthSet = false;

  List<IntegrationRequiredField> _requiredFields;
  bool _requiredFieldsSet = false;

  bool _delegateOauth;
  bool _delegateOauthSet = false;

  List<int> _installedDelegateOauthTargets;
  bool _installedDelegateOauthTargetsSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// ID of the integration. (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// ID of the integration hub. (read-only)

  int get integrationHubId {
    if (!_integrationHubIdSet &&
        _apiMapResponse.containsKey('integration_hub_id')) {
      _integrationHubId = _apiMapResponse['integration_hub_id'];
      _integrationHubIdSet = true;
    }
    return _integrationHubId;
  }

  set integrationHubId(int v) {
    _integrationHubId = v;
    _integrationHubIdSet = true;
  }

  /// Label for the integration. (read-only)

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// Description of the integration. (read-only)

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Whether the integration is available to users.

  bool get enabled {
    if (!_enabledSet && _apiMapResponse.containsKey('enabled')) {
      _enabled = _apiMapResponse['enabled'];
      _enabledSet = true;
    }
    return _enabled;
  }

  set enabled(bool v) {
    _enabled = v;
    _enabledSet = true;
  }

  /// Array of params for the integration.

  List<IntegrationParam> get params {
    if (!_paramsSet && _apiMapResponse.containsKey('params')) {
      _params = _apiMapResponse['params'] == null
          ? null
          : (_apiMapResponse['params'] as List)
              .map((i) =>
                  IntegrationParam.fromResponse(i, apiResponseContentType))
              .toList();
      _paramsSet = true;
    }
    return _params;
  }

  set params(List<IntegrationParam> v) {
    _params = v;
    _paramsSet = true;
  }

  /// A list of data formats the integration supports. If unspecified, the default is all data formats. Valid values are: "txt", "csv", "inline_json", "json", "json_label", "json_detail", "json_detail_lite_stream", "xlsx", "html", "wysiwyg_pdf", "assembled_pdf", "wysiwyg_png", "csv_zip". (read-only)

  List<SupportedFormats> get supportedFormats {
    if (!_supportedFormatsSet &&
        _apiMapResponse.containsKey('supported_formats')) {
      _supportedFormats = _apiMapResponse['supported_formats']
          ?.map<SupportedFormats>((i) => i as SupportedFormats)
          ?.toList();
      _supportedFormatsSet = true;
    }
    return _supportedFormats;
  }

  set supportedFormats(List<SupportedFormats> v) {
    _supportedFormats = v;
    _supportedFormatsSet = true;
  }

  /// A list of action types the integration supports. Valid values are: "cell", "query", "dashboard". (read-only)

  List<SupportedActionTypes> get supportedActionTypes {
    if (!_supportedActionTypesSet &&
        _apiMapResponse.containsKey('supported_action_types')) {
      _supportedActionTypes = _apiMapResponse['supported_action_types']
          ?.map<SupportedActionTypes>((i) => i as SupportedActionTypes)
          ?.toList();
      _supportedActionTypesSet = true;
    }
    return _supportedActionTypes;
  }

  set supportedActionTypes(List<SupportedActionTypes> v) {
    _supportedActionTypes = v;
    _supportedActionTypesSet = true;
  }

  /// A list of formatting options the integration supports. If unspecified, defaults to all formats. Valid values are: "formatted", "unformatted". (read-only)

  List<SupportedFormattings> get supportedFormattings {
    if (!_supportedFormattingsSet &&
        _apiMapResponse.containsKey('supported_formattings')) {
      _supportedFormattings = _apiMapResponse['supported_formattings']
          ?.map<SupportedFormattings>((i) => i as SupportedFormattings)
          ?.toList();
      _supportedFormattingsSet = true;
    }
    return _supportedFormattings;
  }

  set supportedFormattings(List<SupportedFormattings> v) {
    _supportedFormattings = v;
    _supportedFormattingsSet = true;
  }

  /// A list of visualization formatting options the integration supports. If unspecified, defaults to all formats. Valid values are: "apply", "noapply". (read-only)

  List<SupportedVisualizationFormattings>
      get supportedVisualizationFormattings {
    if (!_supportedVisualizationFormattingsSet &&
        _apiMapResponse.containsKey('supported_visualization_formattings')) {
      _supportedVisualizationFormattings =
          _apiMapResponse['supported_visualization_formattings']
              ?.map<SupportedVisualizationFormattings>(
                  (i) => i as SupportedVisualizationFormattings)
              ?.toList();
      _supportedVisualizationFormattingsSet = true;
    }
    return _supportedVisualizationFormattings;
  }

  set supportedVisualizationFormattings(
      List<SupportedVisualizationFormattings> v) {
    _supportedVisualizationFormattings = v;
    _supportedVisualizationFormattingsSet = true;
  }

  /// A list of all the download mechanisms the integration supports. The order of values is not significant: Looker will select the most appropriate supported download mechanism for a given query. The integration must ensure it can handle any of the mechanisms it claims to support. If unspecified, this defaults to all download setting values. Valid values are: "push", "url". (read-only)

  List<SupportedDownloadSettings> get supportedDownloadSettings {
    if (!_supportedDownloadSettingsSet &&
        _apiMapResponse.containsKey('supported_download_settings')) {
      _supportedDownloadSettings =
          _apiMapResponse['supported_download_settings']
              ?.map<SupportedDownloadSettings>(
                  (i) => i as SupportedDownloadSettings)
              ?.toList();
      _supportedDownloadSettingsSet = true;
    }
    return _supportedDownloadSettings;
  }

  set supportedDownloadSettings(List<SupportedDownloadSettings> v) {
    _supportedDownloadSettings = v;
    _supportedDownloadSettingsSet = true;
  }

  /// URL to an icon for the integration. (read-only)

  String get iconUrl {
    if (!_iconUrlSet && _apiMapResponse.containsKey('icon_url')) {
      _iconUrl = _apiMapResponse['icon_url']?.toString();
      _iconUrlSet = true;
    }
    return _iconUrl;
  }

  set iconUrl(String v) {
    _iconUrl = v;
    _iconUrlSet = true;
  }

  /// Whether the integration uses oauth. (read-only)

  bool get usesOauth {
    if (!_usesOauthSet && _apiMapResponse.containsKey('uses_oauth')) {
      _usesOauth = _apiMapResponse['uses_oauth'];
      _usesOauthSet = true;
    }
    return _usesOauth;
  }

  set usesOauth(bool v) {
    _usesOauth = v;
    _usesOauthSet = true;
  }

  /// A list of descriptions of required fields that this integration is compatible with. If there are multiple entries in this list, the integration requires more than one field. If unspecified, no fields will be required. (read-only)

  List<IntegrationRequiredField> get requiredFields {
    if (!_requiredFieldsSet && _apiMapResponse.containsKey('required_fields')) {
      _requiredFields = _apiMapResponse['required_fields'] == null
          ? null
          : (_apiMapResponse['required_fields'] as List)
              .map((i) => IntegrationRequiredField.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _requiredFieldsSet = true;
    }
    return _requiredFields;
  }

  set requiredFields(List<IntegrationRequiredField> v) {
    _requiredFields = v;
    _requiredFieldsSet = true;
  }

  /// Whether the integration uses delegate oauth, which allows federation between an integration installation scope specific entity (like org, group, and team, etc.) and Looker. (read-only)

  bool get delegateOauth {
    if (!_delegateOauthSet && _apiMapResponse.containsKey('delegate_oauth')) {
      _delegateOauth = _apiMapResponse['delegate_oauth'];
      _delegateOauthSet = true;
    }
    return _delegateOauth;
  }

  set delegateOauth(bool v) {
    _delegateOauth = v;
    _delegateOauthSet = true;
  }

  /// Whether the integration is available to users.

  List<int> get installedDelegateOauthTargets {
    if (!_installedDelegateOauthTargetsSet &&
        _apiMapResponse.containsKey('installed_delegate_oauth_targets')) {
      _installedDelegateOauthTargets =
          _apiMapResponse['installed_delegate_oauth_targets']
              ?.map<int>((i) => i as int)
              ?.toList();
      _installedDelegateOauthTargetsSet = true;
    }
    return _installedDelegateOauthTargets;
  }

  set installedDelegateOauthTargets(List<int> v) {
    _installedDelegateOauthTargets = v;
    _installedDelegateOauthTargetsSet = true;
  }

  Integration() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Integration.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_integrationHubIdSet ||
        _apiMapResponse.containsKey('integration_hub_id')) {
      json['integration_hub_id'] = integrationHubId;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_enabledSet || _apiMapResponse.containsKey('enabled')) {
      json['enabled'] = enabled;
    }
    if (_paramsSet || _apiMapResponse.containsKey('params')) {
      json['params'] = params?.map((i) => i.toJson())?.toList();
    }
    if (_supportedFormatsSet ||
        _apiMapResponse.containsKey('supported_formats')) {
      json['supported_formats'] = supportedFormats;
    }
    if (_supportedActionTypesSet ||
        _apiMapResponse.containsKey('supported_action_types')) {
      json['supported_action_types'] = supportedActionTypes;
    }
    if (_supportedFormattingsSet ||
        _apiMapResponse.containsKey('supported_formattings')) {
      json['supported_formattings'] = supportedFormattings;
    }
    if (_supportedVisualizationFormattingsSet ||
        _apiMapResponse.containsKey('supported_visualization_formattings')) {
      json['supported_visualization_formattings'] =
          supportedVisualizationFormattings;
    }
    if (_supportedDownloadSettingsSet ||
        _apiMapResponse.containsKey('supported_download_settings')) {
      json['supported_download_settings'] = supportedDownloadSettings;
    }
    if (_iconUrlSet || _apiMapResponse.containsKey('icon_url')) {
      json['icon_url'] = iconUrl;
    }
    if (_usesOauthSet || _apiMapResponse.containsKey('uses_oauth')) {
      json['uses_oauth'] = usesOauth;
    }
    if (_requiredFieldsSet || _apiMapResponse.containsKey('required_fields')) {
      json['required_fields'] =
          requiredFields?.map((i) => i.toJson())?.toList();
    }
    if (_delegateOauthSet || _apiMapResponse.containsKey('delegate_oauth')) {
      json['delegate_oauth'] = delegateOauth;
    }
    if (_installedDelegateOauthTargetsSet ||
        _apiMapResponse.containsKey('installed_delegate_oauth_targets')) {
      json['installed_delegate_oauth_targets'] = installedDelegateOauthTargets;
    }
    return json;
  }
}

class IntegrationHub {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _id;
  bool _idSet = false;

  String _url;
  bool _urlSet = false;

  String _label;
  bool _labelSet = false;

  bool _official;
  bool _officialSet = false;

  String _fetchErrorMessage;
  bool _fetchErrorMessageSet = false;

  String _authorizationToken;
  bool _authorizationTokenSet = false;

  bool _hasAuthorizationToken;
  bool _hasAuthorizationTokenSet = false;

  bool _legalAgreementSigned;
  bool _legalAgreementSignedSet = false;

  bool _legalAgreementRequired;
  bool _legalAgreementRequiredSet = false;

  String _legalAgreementText;
  bool _legalAgreementTextSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// ID of the hub. (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// URL of the hub.

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  /// Label of the hub. (read-only)

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// Whether this hub is a first-party integration hub operated by Looker. (read-only)

  bool get official {
    if (!_officialSet && _apiMapResponse.containsKey('official')) {
      _official = _apiMapResponse['official'];
      _officialSet = true;
    }
    return _official;
  }

  set official(bool v) {
    _official = v;
    _officialSet = true;
  }

  /// An error message, present if the integration hub metadata could not be fetched. If this is present, the integration hub is unusable. (read-only)

  String get fetchErrorMessage {
    if (!_fetchErrorMessageSet &&
        _apiMapResponse.containsKey('fetch_error_message')) {
      _fetchErrorMessage = _apiMapResponse['fetch_error_message']?.toString();
      _fetchErrorMessageSet = true;
    }
    return _fetchErrorMessage;
  }

  set fetchErrorMessage(String v) {
    _fetchErrorMessage = v;
    _fetchErrorMessageSet = true;
  }

  /// (Write-Only) An authorization key that will be sent to the integration hub on every request.

  String get authorizationToken {
    if (!_authorizationTokenSet &&
        _apiMapResponse.containsKey('authorization_token')) {
      _authorizationToken = _apiMapResponse['authorization_token']?.toString();
      _authorizationTokenSet = true;
    }
    return _authorizationToken;
  }

  set authorizationToken(String v) {
    _authorizationToken = v;
    _authorizationTokenSet = true;
  }

  /// Whether the authorization_token is set for the hub. (read-only)

  bool get hasAuthorizationToken {
    if (!_hasAuthorizationTokenSet &&
        _apiMapResponse.containsKey('has_authorization_token')) {
      _hasAuthorizationToken = _apiMapResponse['has_authorization_token'];
      _hasAuthorizationTokenSet = true;
    }
    return _hasAuthorizationToken;
  }

  set hasAuthorizationToken(bool v) {
    _hasAuthorizationToken = v;
    _hasAuthorizationTokenSet = true;
  }

  /// Whether the legal agreement message has been signed by the user. This only matters if legal_agreement_required is true. (read-only)

  bool get legalAgreementSigned {
    if (!_legalAgreementSignedSet &&
        _apiMapResponse.containsKey('legal_agreement_signed')) {
      _legalAgreementSigned = _apiMapResponse['legal_agreement_signed'];
      _legalAgreementSignedSet = true;
    }
    return _legalAgreementSigned;
  }

  set legalAgreementSigned(bool v) {
    _legalAgreementSigned = v;
    _legalAgreementSignedSet = true;
  }

  /// Whether the legal terms for the integration hub are required before use. (read-only)

  bool get legalAgreementRequired {
    if (!_legalAgreementRequiredSet &&
        _apiMapResponse.containsKey('legal_agreement_required')) {
      _legalAgreementRequired = _apiMapResponse['legal_agreement_required'];
      _legalAgreementRequiredSet = true;
    }
    return _legalAgreementRequired;
  }

  set legalAgreementRequired(bool v) {
    _legalAgreementRequired = v;
    _legalAgreementRequiredSet = true;
  }

  /// The legal agreement text for this integration hub. (read-only)

  String get legalAgreementText {
    if (!_legalAgreementTextSet &&
        _apiMapResponse.containsKey('legal_agreement_text')) {
      _legalAgreementText = _apiMapResponse['legal_agreement_text']?.toString();
      _legalAgreementTextSet = true;
    }
    return _legalAgreementText;
  }

  set legalAgreementText(String v) {
    _legalAgreementText = v;
    _legalAgreementTextSet = true;
  }

  IntegrationHub() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  IntegrationHub.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_officialSet || _apiMapResponse.containsKey('official')) {
      json['official'] = official;
    }
    if (_fetchErrorMessageSet ||
        _apiMapResponse.containsKey('fetch_error_message')) {
      json['fetch_error_message'] = fetchErrorMessage;
    }
    if (_authorizationTokenSet ||
        _apiMapResponse.containsKey('authorization_token')) {
      json['authorization_token'] = authorizationToken;
    }
    if (_hasAuthorizationTokenSet ||
        _apiMapResponse.containsKey('has_authorization_token')) {
      json['has_authorization_token'] = hasAuthorizationToken;
    }
    if (_legalAgreementSignedSet ||
        _apiMapResponse.containsKey('legal_agreement_signed')) {
      json['legal_agreement_signed'] = legalAgreementSigned;
    }
    if (_legalAgreementRequiredSet ||
        _apiMapResponse.containsKey('legal_agreement_required')) {
      json['legal_agreement_required'] = legalAgreementRequired;
    }
    if (_legalAgreementTextSet ||
        _apiMapResponse.containsKey('legal_agreement_text')) {
      json['legal_agreement_text'] = legalAgreementText;
    }
    return json;
  }
}

class IntegrationParam {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _label;
  bool _labelSet = false;

  String _description;
  bool _descriptionSet = false;

  bool _required;
  bool _requiredSet = false;

  bool _hasValue;
  bool _hasValueSet = false;

  String _value;
  bool _valueSet = false;

  String _userAttributeName;
  bool _userAttributeNameSet = false;

  bool _sensitive;
  bool _sensitiveSet = false;

  bool _perUser;
  bool _perUserSet = false;

  String _delegateOauthUrl;
  bool _delegateOauthUrlSet = false;

  /// Name of the parameter.

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Label of the parameter. (read-only)

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// Short description of the parameter. (read-only)

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Whether the parameter is required to be set to use the destination. If unspecified, this defaults to false. (read-only)

  bool get required {
    if (!_requiredSet && _apiMapResponse.containsKey('required')) {
      _required = _apiMapResponse['required'];
      _requiredSet = true;
    }
    return _required;
  }

  set required(bool v) {
    _required = v;
    _requiredSet = true;
  }

  /// Whether the parameter has a value set. (read-only)

  bool get hasValue {
    if (!_hasValueSet && _apiMapResponse.containsKey('has_value')) {
      _hasValue = _apiMapResponse['has_value'];
      _hasValueSet = true;
    }
    return _hasValue;
  }

  set hasValue(bool v) {
    _hasValue = v;
    _hasValueSet = true;
  }

  /// The current value of the parameter. Always null if the value is sensitive. When writing, null values will be ignored. Set the value to an empty string to clear it.

  String get value {
    if (!_valueSet && _apiMapResponse.containsKey('value')) {
      _value = _apiMapResponse['value']?.toString();
      _valueSet = true;
    }
    return _value;
  }

  set value(String v) {
    _value = v;
    _valueSet = true;
  }

  /// When present, the param's value comes from this user attribute instead of the 'value' parameter. Set to null to use the 'value'.

  String get userAttributeName {
    if (!_userAttributeNameSet &&
        _apiMapResponse.containsKey('user_attribute_name')) {
      _userAttributeName = _apiMapResponse['user_attribute_name']?.toString();
      _userAttributeNameSet = true;
    }
    return _userAttributeName;
  }

  set userAttributeName(String v) {
    _userAttributeName = v;
    _userAttributeNameSet = true;
  }

  /// Whether the parameter contains sensitive data like API credentials. If unspecified, this defaults to true. (read-only)

  bool get sensitive {
    if (!_sensitiveSet && _apiMapResponse.containsKey('sensitive')) {
      _sensitive = _apiMapResponse['sensitive'];
      _sensitiveSet = true;
    }
    return _sensitive;
  }

  set sensitive(bool v) {
    _sensitive = v;
    _sensitiveSet = true;
  }

  /// When true, this parameter must be assigned to a user attribute in the admin panel (instead of a constant value), and that value may be updated by the user as part of the integration flow. (read-only)

  bool get perUser {
    if (!_perUserSet && _apiMapResponse.containsKey('per_user')) {
      _perUser = _apiMapResponse['per_user'];
      _perUserSet = true;
    }
    return _perUser;
  }

  set perUser(bool v) {
    _perUser = v;
    _perUserSet = true;
  }

  /// When present, the param represents the oauth url the user will be taken to. (read-only)

  String get delegateOauthUrl {
    if (!_delegateOauthUrlSet &&
        _apiMapResponse.containsKey('delegate_oauth_url')) {
      _delegateOauthUrl = _apiMapResponse['delegate_oauth_url']?.toString();
      _delegateOauthUrlSet = true;
    }
    return _delegateOauthUrl;
  }

  set delegateOauthUrl(String v) {
    _delegateOauthUrl = v;
    _delegateOauthUrlSet = true;
  }

  IntegrationParam() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  IntegrationParam.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_requiredSet || _apiMapResponse.containsKey('required')) {
      json['required'] = required;
    }
    if (_hasValueSet || _apiMapResponse.containsKey('has_value')) {
      json['has_value'] = hasValue;
    }
    if (_valueSet || _apiMapResponse.containsKey('value')) {
      json['value'] = value;
    }
    if (_userAttributeNameSet ||
        _apiMapResponse.containsKey('user_attribute_name')) {
      json['user_attribute_name'] = userAttributeName;
    }
    if (_sensitiveSet || _apiMapResponse.containsKey('sensitive')) {
      json['sensitive'] = sensitive;
    }
    if (_perUserSet || _apiMapResponse.containsKey('per_user')) {
      json['per_user'] = perUser;
    }
    if (_delegateOauthUrlSet ||
        _apiMapResponse.containsKey('delegate_oauth_url')) {
      json['delegate_oauth_url'] = delegateOauthUrl;
    }
    return json;
  }
}

class IntegrationRequiredField {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _tag;
  bool _tagSet = false;

  List<String> _anyTag;
  bool _anyTagSet = false;

  List<String> _allTags;
  bool _allTagsSet = false;

  /// Matches a field that has this tag. (read-only)

  String get tag {
    if (!_tagSet && _apiMapResponse.containsKey('tag')) {
      _tag = _apiMapResponse['tag']?.toString();
      _tagSet = true;
    }
    return _tag;
  }

  set tag(String v) {
    _tag = v;
    _tagSet = true;
  }

  /// If present, supercedes 'tag' and matches a field that has any of the provided tags. (read-only)

  List<String> get anyTag {
    if (!_anyTagSet && _apiMapResponse.containsKey('any_tag')) {
      _anyTag =
          _apiMapResponse['any_tag']?.map<String>((i) => i as String)?.toList();
      _anyTagSet = true;
    }
    return _anyTag;
  }

  set anyTag(List<String> v) {
    _anyTag = v;
    _anyTagSet = true;
  }

  /// If present, supercedes 'tag' and matches a field that has all of the provided tags. (read-only)

  List<String> get allTags {
    if (!_allTagsSet && _apiMapResponse.containsKey('all_tags')) {
      _allTags = _apiMapResponse['all_tags']
          ?.map<String>((i) => i as String)
          ?.toList();
      _allTagsSet = true;
    }
    return _allTags;
  }

  set allTags(List<String> v) {
    _allTags = v;
    _allTagsSet = true;
  }

  IntegrationRequiredField() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  IntegrationRequiredField.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_tagSet || _apiMapResponse.containsKey('tag')) {
      json['tag'] = tag;
    }
    if (_anyTagSet || _apiMapResponse.containsKey('any_tag')) {
      json['any_tag'] = anyTag;
    }
    if (_allTagsSet || _apiMapResponse.containsKey('all_tags')) {
      json['all_tags'] = allTags;
    }
    return json;
  }
}

class IntegrationTestResult {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _success;
  bool _successSet = false;

  String _message;
  bool _messageSet = false;

  List<DelegateOauthTest> _delegateOauthResult;
  bool _delegateOauthResultSet = false;

  /// Whether or not the test was successful (read-only)

  bool get success {
    if (!_successSet && _apiMapResponse.containsKey('success')) {
      _success = _apiMapResponse['success'];
      _successSet = true;
    }
    return _success;
  }

  set success(bool v) {
    _success = v;
    _successSet = true;
  }

  /// A message representing the results of the test. (read-only)

  String get message {
    if (!_messageSet && _apiMapResponse.containsKey('message')) {
      _message = _apiMapResponse['message']?.toString();
      _messageSet = true;
    }
    return _message;
  }

  set message(String v) {
    _message = v;
    _messageSet = true;
  }

  /// An array of connection test result for delegate oauth actions. (read-only)

  List<DelegateOauthTest> get delegateOauthResult {
    if (!_delegateOauthResultSet &&
        _apiMapResponse.containsKey('delegate_oauth_result')) {
      _delegateOauthResult = _apiMapResponse['delegate_oauth_result'] == null
          ? null
          : (_apiMapResponse['delegate_oauth_result'] as List)
              .map((i) =>
                  DelegateOauthTest.fromResponse(i, apiResponseContentType))
              .toList();
      _delegateOauthResultSet = true;
    }
    return _delegateOauthResult;
  }

  set delegateOauthResult(List<DelegateOauthTest> v) {
    _delegateOauthResult = v;
    _delegateOauthResultSet = true;
  }

  IntegrationTestResult() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  IntegrationTestResult.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_successSet || _apiMapResponse.containsKey('success')) {
      json['success'] = success;
    }
    if (_messageSet || _apiMapResponse.containsKey('message')) {
      json['message'] = message;
    }
    if (_delegateOauthResultSet ||
        _apiMapResponse.containsKey('delegate_oauth_result')) {
      json['delegate_oauth_result'] =
          delegateOauthResult?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class InternalHelpResources {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  bool _enabled;
  bool _enabledSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// If true and internal help resources content is not blank then the link for internal help resources will be shown in the help menu and the content displayed within Looker

  bool get enabled {
    if (!_enabledSet && _apiMapResponse.containsKey('enabled')) {
      _enabled = _apiMapResponse['enabled'];
      _enabledSet = true;
    }
    return _enabled;
  }

  set enabled(bool v) {
    _enabled = v;
    _enabledSet = true;
  }

  InternalHelpResources() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  InternalHelpResources.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_enabledSet || _apiMapResponse.containsKey('enabled')) {
      json['enabled'] = enabled;
    }
    return json;
  }
}

class InternalHelpResourcesContent {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _organizationName;
  bool _organizationNameSet = false;

  String _markdownContent;
  bool _markdownContentSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Text to display in the help menu item which will display the internal help resources

  String get organizationName {
    if (!_organizationNameSet &&
        _apiMapResponse.containsKey('organization_name')) {
      _organizationName = _apiMapResponse['organization_name']?.toString();
      _organizationNameSet = true;
    }
    return _organizationName;
  }

  set organizationName(String v) {
    _organizationName = v;
    _organizationNameSet = true;
  }

  /// Content to be displayed in the internal help resources page/modal

  String get markdownContent {
    if (!_markdownContentSet &&
        _apiMapResponse.containsKey('markdown_content')) {
      _markdownContent = _apiMapResponse['markdown_content']?.toString();
      _markdownContentSet = true;
    }
    return _markdownContent;
  }

  set markdownContent(String v) {
    _markdownContent = v;
    _markdownContentSet = true;
  }

  InternalHelpResourcesContent() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  InternalHelpResourcesContent.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_organizationNameSet ||
        _apiMapResponse.containsKey('organization_name')) {
      json['organization_name'] = organizationName;
    }
    if (_markdownContentSet ||
        _apiMapResponse.containsKey('markdown_content')) {
      json['markdown_content'] = markdownContent;
    }
    return json;
  }
}

/// The type of the investigative content Valid values are: "dashboard". (Enum defined in Alert)
enum InvestigativeContentType { dashboard }

class InvestigativeContentTypeMapper {
  static String toStringValue(InvestigativeContentType e) {
    switch (e) {
      case InvestigativeContentType.dashboard:
        return 'dashboard';

      default:
        return null;
    }
  }

  static InvestigativeContentType fromStringValue(String s) {
    if (s == 'dashboard') {
      return InvestigativeContentType.dashboard;
    }
    return null;
  }
}

class LDAPConfig {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  bool _alternateEmailLoginAllowed;
  bool _alternateEmailLoginAllowedSet = false;

  String _authPassword;
  bool _authPasswordSet = false;

  bool _authRequiresRole;
  bool _authRequiresRoleSet = false;

  String _authUsername;
  bool _authUsernameSet = false;

  String _connectionHost;
  bool _connectionHostSet = false;

  String _connectionPort;
  bool _connectionPortSet = false;

  bool _connectionTls;
  bool _connectionTlsSet = false;

  bool _connectionTlsNoVerify;
  bool _connectionTlsNoVerifySet = false;

  List<int> _defaultNewUserGroupIds;
  bool _defaultNewUserGroupIdsSet = false;

  List<Group> _defaultNewUserGroups;
  bool _defaultNewUserGroupsSet = false;

  List<int> _defaultNewUserRoleIds;
  bool _defaultNewUserRoleIdsSet = false;

  List<Role> _defaultNewUserRoles;
  bool _defaultNewUserRolesSet = false;

  bool _enabled;
  bool _enabledSet = false;

  bool _forceNoPage;
  bool _forceNoPageSet = false;

  List<LDAPGroupRead> _groups;
  bool _groupsSet = false;

  String _groupsBaseDn;
  bool _groupsBaseDnSet = false;

  String _groupsFinderType;
  bool _groupsFinderTypeSet = false;

  String _groupsMemberAttribute;
  bool _groupsMemberAttributeSet = false;

  String _groupsObjectclasses;
  bool _groupsObjectclassesSet = false;

  String _groupsUserAttribute;
  bool _groupsUserAttributeSet = false;

  List<LDAPGroupWrite> _groupsWithRoleIds;
  bool _groupsWithRoleIdsSet = false;

  bool _hasAuthPassword;
  bool _hasAuthPasswordSet = false;

  bool _mergeNewUsersByEmail;
  bool _mergeNewUsersByEmailSet = false;

  String _modifiedAt;
  bool _modifiedAtSet = false;

  String _modifiedBy;
  bool _modifiedBySet = false;

  bool _setRolesFromGroups;
  bool _setRolesFromGroupsSet = false;

  String _testLdapPassword;
  bool _testLdapPasswordSet = false;

  String _testLdapUser;
  bool _testLdapUserSet = false;

  String _userAttributeMapEmail;
  bool _userAttributeMapEmailSet = false;

  String _userAttributeMapFirstName;
  bool _userAttributeMapFirstNameSet = false;

  String _userAttributeMapLastName;
  bool _userAttributeMapLastNameSet = false;

  String _userAttributeMapLdapId;
  bool _userAttributeMapLdapIdSet = false;

  List<LDAPUserAttributeRead> _userAttributes;
  bool _userAttributesSet = false;

  List<LDAPUserAttributeWrite> _userAttributesWithIds;
  bool _userAttributesWithIdsSet = false;

  String _userBindBaseDn;
  bool _userBindBaseDnSet = false;

  String _userCustomFilter;
  bool _userCustomFilterSet = false;

  String _userIdAttributeNames;
  bool _userIdAttributeNamesSet = false;

  String _userObjectclass;
  bool _userObjectclassSet = false;

  bool _allowNormalGroupMembership;
  bool _allowNormalGroupMembershipSet = false;

  bool _allowRolesFromNormalGroups;
  bool _allowRolesFromNormalGroupsSet = false;

  bool _allowDirectRoles;
  bool _allowDirectRolesSet = false;

  String _url;
  bool _urlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.

  bool get alternateEmailLoginAllowed {
    if (!_alternateEmailLoginAllowedSet &&
        _apiMapResponse.containsKey('alternate_email_login_allowed')) {
      _alternateEmailLoginAllowed =
          _apiMapResponse['alternate_email_login_allowed'];
      _alternateEmailLoginAllowedSet = true;
    }
    return _alternateEmailLoginAllowed;
  }

  set alternateEmailLoginAllowed(bool v) {
    _alternateEmailLoginAllowed = v;
    _alternateEmailLoginAllowedSet = true;
  }

  /// (Write-Only)  Password for the LDAP account used to access the LDAP server

  String get authPassword {
    if (!_authPasswordSet && _apiMapResponse.containsKey('auth_password')) {
      _authPassword = _apiMapResponse['auth_password']?.toString();
      _authPasswordSet = true;
    }
    return _authPassword;
  }

  set authPassword(String v) {
    _authPassword = v;
    _authPasswordSet = true;
  }

  /// Users will not be allowed to login at all unless a role for them is found in LDAP if set to true

  bool get authRequiresRole {
    if (!_authRequiresRoleSet &&
        _apiMapResponse.containsKey('auth_requires_role')) {
      _authRequiresRole = _apiMapResponse['auth_requires_role'];
      _authRequiresRoleSet = true;
    }
    return _authRequiresRole;
  }

  set authRequiresRole(bool v) {
    _authRequiresRole = v;
    _authRequiresRoleSet = true;
  }

  /// Distinguished name of LDAP account used to access the LDAP server

  String get authUsername {
    if (!_authUsernameSet && _apiMapResponse.containsKey('auth_username')) {
      _authUsername = _apiMapResponse['auth_username']?.toString();
      _authUsernameSet = true;
    }
    return _authUsername;
  }

  set authUsername(String v) {
    _authUsername = v;
    _authUsernameSet = true;
  }

  /// LDAP server hostname

  String get connectionHost {
    if (!_connectionHostSet && _apiMapResponse.containsKey('connection_host')) {
      _connectionHost = _apiMapResponse['connection_host']?.toString();
      _connectionHostSet = true;
    }
    return _connectionHost;
  }

  set connectionHost(String v) {
    _connectionHost = v;
    _connectionHostSet = true;
  }

  /// LDAP host port

  String get connectionPort {
    if (!_connectionPortSet && _apiMapResponse.containsKey('connection_port')) {
      _connectionPort = _apiMapResponse['connection_port']?.toString();
      _connectionPortSet = true;
    }
    return _connectionPort;
  }

  set connectionPort(String v) {
    _connectionPort = v;
    _connectionPortSet = true;
  }

  /// Use Transport Layer Security

  bool get connectionTls {
    if (!_connectionTlsSet && _apiMapResponse.containsKey('connection_tls')) {
      _connectionTls = _apiMapResponse['connection_tls'];
      _connectionTlsSet = true;
    }
    return _connectionTls;
  }

  set connectionTls(bool v) {
    _connectionTls = v;
    _connectionTlsSet = true;
  }

  /// Do not verify peer when using TLS

  bool get connectionTlsNoVerify {
    if (!_connectionTlsNoVerifySet &&
        _apiMapResponse.containsKey('connection_tls_no_verify')) {
      _connectionTlsNoVerify = _apiMapResponse['connection_tls_no_verify'];
      _connectionTlsNoVerifySet = true;
    }
    return _connectionTlsNoVerify;
  }

  set connectionTlsNoVerify(bool v) {
    _connectionTlsNoVerify = v;
    _connectionTlsNoVerifySet = true;
  }

  /// (Write-Only)  Array of ids of groups that will be applied to new users the first time they login via LDAP

  List<int> get defaultNewUserGroupIds {
    if (!_defaultNewUserGroupIdsSet &&
        _apiMapResponse.containsKey('default_new_user_group_ids')) {
      _defaultNewUserGroupIds = _apiMapResponse['default_new_user_group_ids']
          ?.map<int>((i) => i as int)
          ?.toList();
      _defaultNewUserGroupIdsSet = true;
    }
    return _defaultNewUserGroupIds;
  }

  set defaultNewUserGroupIds(List<int> v) {
    _defaultNewUserGroupIds = v;
    _defaultNewUserGroupIdsSet = true;
  }

  /// (Read-only) Groups that will be applied to new users the first time they login via LDAP (read-only)

  List<Group> get defaultNewUserGroups {
    if (!_defaultNewUserGroupsSet &&
        _apiMapResponse.containsKey('default_new_user_groups')) {
      _defaultNewUserGroups = _apiMapResponse['default_new_user_groups'] == null
          ? null
          : (_apiMapResponse['default_new_user_groups'] as List)
              .map((i) => Group.fromResponse(i, apiResponseContentType))
              .toList();
      _defaultNewUserGroupsSet = true;
    }
    return _defaultNewUserGroups;
  }

  set defaultNewUserGroups(List<Group> v) {
    _defaultNewUserGroups = v;
    _defaultNewUserGroupsSet = true;
  }

  /// (Write-Only)  Array of ids of roles that will be applied to new users the first time they login via LDAP

  List<int> get defaultNewUserRoleIds {
    if (!_defaultNewUserRoleIdsSet &&
        _apiMapResponse.containsKey('default_new_user_role_ids')) {
      _defaultNewUserRoleIds = _apiMapResponse['default_new_user_role_ids']
          ?.map<int>((i) => i as int)
          ?.toList();
      _defaultNewUserRoleIdsSet = true;
    }
    return _defaultNewUserRoleIds;
  }

  set defaultNewUserRoleIds(List<int> v) {
    _defaultNewUserRoleIds = v;
    _defaultNewUserRoleIdsSet = true;
  }

  /// (Read-only) Roles that will be applied to new users the first time they login via LDAP (read-only)

  List<Role> get defaultNewUserRoles {
    if (!_defaultNewUserRolesSet &&
        _apiMapResponse.containsKey('default_new_user_roles')) {
      _defaultNewUserRoles = _apiMapResponse['default_new_user_roles'] == null
          ? null
          : (_apiMapResponse['default_new_user_roles'] as List)
              .map((i) => Role.fromResponse(i, apiResponseContentType))
              .toList();
      _defaultNewUserRolesSet = true;
    }
    return _defaultNewUserRoles;
  }

  set defaultNewUserRoles(List<Role> v) {
    _defaultNewUserRoles = v;
    _defaultNewUserRolesSet = true;
  }

  /// Enable/Disable LDAP authentication for the server

  bool get enabled {
    if (!_enabledSet && _apiMapResponse.containsKey('enabled')) {
      _enabled = _apiMapResponse['enabled'];
      _enabledSet = true;
    }
    return _enabled;
  }

  set enabled(bool v) {
    _enabled = v;
    _enabledSet = true;
  }

  /// Don't attempt to do LDAP search result paging (RFC 2696) even if the LDAP server claims to support it.

  bool get forceNoPage {
    if (!_forceNoPageSet && _apiMapResponse.containsKey('force_no_page')) {
      _forceNoPage = _apiMapResponse['force_no_page'];
      _forceNoPageSet = true;
    }
    return _forceNoPage;
  }

  set forceNoPage(bool v) {
    _forceNoPage = v;
    _forceNoPageSet = true;
  }

  /// (Read-only) Array of mappings between LDAP Groups and Looker Roles (read-only)

  List<LDAPGroupRead> get groups {
    if (!_groupsSet && _apiMapResponse.containsKey('groups')) {
      _groups = _apiMapResponse['groups'] == null
          ? null
          : (_apiMapResponse['groups'] as List)
              .map((i) => LDAPGroupRead.fromResponse(i, apiResponseContentType))
              .toList();
      _groupsSet = true;
    }
    return _groups;
  }

  set groups(List<LDAPGroupRead> v) {
    _groups = v;
    _groupsSet = true;
  }

  /// Base dn for finding groups in LDAP searches

  String get groupsBaseDn {
    if (!_groupsBaseDnSet && _apiMapResponse.containsKey('groups_base_dn')) {
      _groupsBaseDn = _apiMapResponse['groups_base_dn']?.toString();
      _groupsBaseDnSet = true;
    }
    return _groupsBaseDn;
  }

  set groupsBaseDn(String v) {
    _groupsBaseDn = v;
    _groupsBaseDnSet = true;
  }

  /// Identifier for a strategy for how Looker will search for groups in the LDAP server

  String get groupsFinderType {
    if (!_groupsFinderTypeSet &&
        _apiMapResponse.containsKey('groups_finder_type')) {
      _groupsFinderType = _apiMapResponse['groups_finder_type']?.toString();
      _groupsFinderTypeSet = true;
    }
    return _groupsFinderType;
  }

  set groupsFinderType(String v) {
    _groupsFinderType = v;
    _groupsFinderTypeSet = true;
  }

  /// LDAP Group attribute that signifies the members of the groups. Most commonly 'member'

  String get groupsMemberAttribute {
    if (!_groupsMemberAttributeSet &&
        _apiMapResponse.containsKey('groups_member_attribute')) {
      _groupsMemberAttribute =
          _apiMapResponse['groups_member_attribute']?.toString();
      _groupsMemberAttributeSet = true;
    }
    return _groupsMemberAttribute;
  }

  set groupsMemberAttribute(String v) {
    _groupsMemberAttribute = v;
    _groupsMemberAttributeSet = true;
  }

  /// Optional comma-separated list of supported LDAP objectclass for groups when doing groups searches

  String get groupsObjectclasses {
    if (!_groupsObjectclassesSet &&
        _apiMapResponse.containsKey('groups_objectclasses')) {
      _groupsObjectclasses =
          _apiMapResponse['groups_objectclasses']?.toString();
      _groupsObjectclassesSet = true;
    }
    return _groupsObjectclasses;
  }

  set groupsObjectclasses(String v) {
    _groupsObjectclasses = v;
    _groupsObjectclassesSet = true;
  }

  /// LDAP Group attribute that signifies the user in a group. Most commonly 'dn'

  String get groupsUserAttribute {
    if (!_groupsUserAttributeSet &&
        _apiMapResponse.containsKey('groups_user_attribute')) {
      _groupsUserAttribute =
          _apiMapResponse['groups_user_attribute']?.toString();
      _groupsUserAttributeSet = true;
    }
    return _groupsUserAttribute;
  }

  set groupsUserAttribute(String v) {
    _groupsUserAttribute = v;
    _groupsUserAttributeSet = true;
  }

  /// (Read/Write) Array of mappings between LDAP Groups and arrays of Looker Role ids

  List<LDAPGroupWrite> get groupsWithRoleIds {
    if (!_groupsWithRoleIdsSet &&
        _apiMapResponse.containsKey('groups_with_role_ids')) {
      _groupsWithRoleIds = _apiMapResponse['groups_with_role_ids'] == null
          ? null
          : (_apiMapResponse['groups_with_role_ids'] as List)
              .map(
                  (i) => LDAPGroupWrite.fromResponse(i, apiResponseContentType))
              .toList();
      _groupsWithRoleIdsSet = true;
    }
    return _groupsWithRoleIds;
  }

  set groupsWithRoleIds(List<LDAPGroupWrite> v) {
    _groupsWithRoleIds = v;
    _groupsWithRoleIdsSet = true;
  }

  /// (Read-only) Has the password been set for the LDAP account used to access the LDAP server (read-only)

  bool get hasAuthPassword {
    if (!_hasAuthPasswordSet &&
        _apiMapResponse.containsKey('has_auth_password')) {
      _hasAuthPassword = _apiMapResponse['has_auth_password'];
      _hasAuthPasswordSet = true;
    }
    return _hasAuthPassword;
  }

  set hasAuthPassword(bool v) {
    _hasAuthPassword = v;
    _hasAuthPasswordSet = true;
  }

  /// Merge first-time ldap login to existing user account by email addresses. When a user logs in for the first time via ldap this option will connect this user into their existing account by finding the account with a matching email address. Otherwise a new user account will be created for the user.

  bool get mergeNewUsersByEmail {
    if (!_mergeNewUsersByEmailSet &&
        _apiMapResponse.containsKey('merge_new_users_by_email')) {
      _mergeNewUsersByEmail = _apiMapResponse['merge_new_users_by_email'];
      _mergeNewUsersByEmailSet = true;
    }
    return _mergeNewUsersByEmail;
  }

  set mergeNewUsersByEmail(bool v) {
    _mergeNewUsersByEmail = v;
    _mergeNewUsersByEmailSet = true;
  }

  /// When this config was last modified (read-only)

  String get modifiedAt {
    if (!_modifiedAtSet && _apiMapResponse.containsKey('modified_at')) {
      _modifiedAt = _apiMapResponse['modified_at']?.toString();
      _modifiedAtSet = true;
    }
    return _modifiedAt;
  }

  set modifiedAt(String v) {
    _modifiedAt = v;
    _modifiedAtSet = true;
  }

  /// User id of user who last modified this config (read-only)

  String get modifiedBy {
    if (!_modifiedBySet && _apiMapResponse.containsKey('modified_by')) {
      _modifiedBy = _apiMapResponse['modified_by']?.toString();
      _modifiedBySet = true;
    }
    return _modifiedBy;
  }

  set modifiedBy(String v) {
    _modifiedBy = v;
    _modifiedBySet = true;
  }

  /// Set user roles in Looker based on groups from LDAP

  bool get setRolesFromGroups {
    if (!_setRolesFromGroupsSet &&
        _apiMapResponse.containsKey('set_roles_from_groups')) {
      _setRolesFromGroups = _apiMapResponse['set_roles_from_groups'];
      _setRolesFromGroupsSet = true;
    }
    return _setRolesFromGroups;
  }

  set setRolesFromGroups(bool v) {
    _setRolesFromGroups = v;
    _setRolesFromGroupsSet = true;
  }

  /// (Write-Only)  Test LDAP user password. For ldap tests only.

  String get testLdapPassword {
    if (!_testLdapPasswordSet &&
        _apiMapResponse.containsKey('test_ldap_password')) {
      _testLdapPassword = _apiMapResponse['test_ldap_password']?.toString();
      _testLdapPasswordSet = true;
    }
    return _testLdapPassword;
  }

  set testLdapPassword(String v) {
    _testLdapPassword = v;
    _testLdapPasswordSet = true;
  }

  /// (Write-Only)  Test LDAP user login id. For ldap tests only.

  String get testLdapUser {
    if (!_testLdapUserSet && _apiMapResponse.containsKey('test_ldap_user')) {
      _testLdapUser = _apiMapResponse['test_ldap_user']?.toString();
      _testLdapUserSet = true;
    }
    return _testLdapUser;
  }

  set testLdapUser(String v) {
    _testLdapUser = v;
    _testLdapUserSet = true;
  }

  /// Name of user record attributes used to indicate email address field

  String get userAttributeMapEmail {
    if (!_userAttributeMapEmailSet &&
        _apiMapResponse.containsKey('user_attribute_map_email')) {
      _userAttributeMapEmail =
          _apiMapResponse['user_attribute_map_email']?.toString();
      _userAttributeMapEmailSet = true;
    }
    return _userAttributeMapEmail;
  }

  set userAttributeMapEmail(String v) {
    _userAttributeMapEmail = v;
    _userAttributeMapEmailSet = true;
  }

  /// Name of user record attributes used to indicate first name

  String get userAttributeMapFirstName {
    if (!_userAttributeMapFirstNameSet &&
        _apiMapResponse.containsKey('user_attribute_map_first_name')) {
      _userAttributeMapFirstName =
          _apiMapResponse['user_attribute_map_first_name']?.toString();
      _userAttributeMapFirstNameSet = true;
    }
    return _userAttributeMapFirstName;
  }

  set userAttributeMapFirstName(String v) {
    _userAttributeMapFirstName = v;
    _userAttributeMapFirstNameSet = true;
  }

  /// Name of user record attributes used to indicate last name

  String get userAttributeMapLastName {
    if (!_userAttributeMapLastNameSet &&
        _apiMapResponse.containsKey('user_attribute_map_last_name')) {
      _userAttributeMapLastName =
          _apiMapResponse['user_attribute_map_last_name']?.toString();
      _userAttributeMapLastNameSet = true;
    }
    return _userAttributeMapLastName;
  }

  set userAttributeMapLastName(String v) {
    _userAttributeMapLastName = v;
    _userAttributeMapLastNameSet = true;
  }

  /// Name of user record attributes used to indicate unique record id

  String get userAttributeMapLdapId {
    if (!_userAttributeMapLdapIdSet &&
        _apiMapResponse.containsKey('user_attribute_map_ldap_id')) {
      _userAttributeMapLdapId =
          _apiMapResponse['user_attribute_map_ldap_id']?.toString();
      _userAttributeMapLdapIdSet = true;
    }
    return _userAttributeMapLdapId;
  }

  set userAttributeMapLdapId(String v) {
    _userAttributeMapLdapId = v;
    _userAttributeMapLdapIdSet = true;
  }

  /// (Read-only) Array of mappings between LDAP User Attributes and Looker User Attributes (read-only)

  List<LDAPUserAttributeRead> get userAttributes {
    if (!_userAttributesSet && _apiMapResponse.containsKey('user_attributes')) {
      _userAttributes = _apiMapResponse['user_attributes'] == null
          ? null
          : (_apiMapResponse['user_attributes'] as List)
              .map((i) =>
                  LDAPUserAttributeRead.fromResponse(i, apiResponseContentType))
              .toList();
      _userAttributesSet = true;
    }
    return _userAttributes;
  }

  set userAttributes(List<LDAPUserAttributeRead> v) {
    _userAttributes = v;
    _userAttributesSet = true;
  }

  /// (Read/Write) Array of mappings between LDAP User Attributes and arrays of Looker User Attribute ids

  List<LDAPUserAttributeWrite> get userAttributesWithIds {
    if (!_userAttributesWithIdsSet &&
        _apiMapResponse.containsKey('user_attributes_with_ids')) {
      _userAttributesWithIds =
          _apiMapResponse['user_attributes_with_ids'] == null
              ? null
              : (_apiMapResponse['user_attributes_with_ids'] as List)
                  .map((i) => LDAPUserAttributeWrite.fromResponse(
                      i, apiResponseContentType))
                  .toList();
      _userAttributesWithIdsSet = true;
    }
    return _userAttributesWithIds;
  }

  set userAttributesWithIds(List<LDAPUserAttributeWrite> v) {
    _userAttributesWithIds = v;
    _userAttributesWithIdsSet = true;
  }

  /// Distinguished name of LDAP node used as the base for user searches

  String get userBindBaseDn {
    if (!_userBindBaseDnSet &&
        _apiMapResponse.containsKey('user_bind_base_dn')) {
      _userBindBaseDn = _apiMapResponse['user_bind_base_dn']?.toString();
      _userBindBaseDnSet = true;
    }
    return _userBindBaseDn;
  }

  set userBindBaseDn(String v) {
    _userBindBaseDn = v;
    _userBindBaseDnSet = true;
  }

  /// (Optional) Custom RFC-2254 filter clause for use in finding user during login. Combined via 'and' with the other generated filter clauses.

  String get userCustomFilter {
    if (!_userCustomFilterSet &&
        _apiMapResponse.containsKey('user_custom_filter')) {
      _userCustomFilter = _apiMapResponse['user_custom_filter']?.toString();
      _userCustomFilterSet = true;
    }
    return _userCustomFilter;
  }

  set userCustomFilter(String v) {
    _userCustomFilter = v;
    _userCustomFilterSet = true;
  }

  /// Name(s) of user record attributes used for matching user login id (comma separated list)

  String get userIdAttributeNames {
    if (!_userIdAttributeNamesSet &&
        _apiMapResponse.containsKey('user_id_attribute_names')) {
      _userIdAttributeNames =
          _apiMapResponse['user_id_attribute_names']?.toString();
      _userIdAttributeNamesSet = true;
    }
    return _userIdAttributeNames;
  }

  set userIdAttributeNames(String v) {
    _userIdAttributeNames = v;
    _userIdAttributeNamesSet = true;
  }

  /// (Optional) Name of user record objectclass used for finding user during login id

  String get userObjectclass {
    if (!_userObjectclassSet &&
        _apiMapResponse.containsKey('user_objectclass')) {
      _userObjectclass = _apiMapResponse['user_objectclass']?.toString();
      _userObjectclassSet = true;
    }
    return _userObjectclass;
  }

  set userObjectclass(String v) {
    _userObjectclass = v;
    _userObjectclassSet = true;
  }

  /// Allow LDAP auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.

  bool get allowNormalGroupMembership {
    if (!_allowNormalGroupMembershipSet &&
        _apiMapResponse.containsKey('allow_normal_group_membership')) {
      _allowNormalGroupMembership =
          _apiMapResponse['allow_normal_group_membership'];
      _allowNormalGroupMembershipSet = true;
    }
    return _allowNormalGroupMembership;
  }

  set allowNormalGroupMembership(bool v) {
    _allowNormalGroupMembership = v;
    _allowNormalGroupMembershipSet = true;
  }

  /// LDAP auth'd users will be able to inherit roles from non-reflected Looker groups.

  bool get allowRolesFromNormalGroups {
    if (!_allowRolesFromNormalGroupsSet &&
        _apiMapResponse.containsKey('allow_roles_from_normal_groups')) {
      _allowRolesFromNormalGroups =
          _apiMapResponse['allow_roles_from_normal_groups'];
      _allowRolesFromNormalGroupsSet = true;
    }
    return _allowRolesFromNormalGroups;
  }

  set allowRolesFromNormalGroups(bool v) {
    _allowRolesFromNormalGroups = v;
    _allowRolesFromNormalGroupsSet = true;
  }

  /// Allows roles to be directly assigned to LDAP auth'd users.

  bool get allowDirectRoles {
    if (!_allowDirectRolesSet &&
        _apiMapResponse.containsKey('allow_direct_roles')) {
      _allowDirectRoles = _apiMapResponse['allow_direct_roles'];
      _allowDirectRolesSet = true;
    }
    return _allowDirectRoles;
  }

  set allowDirectRoles(bool v) {
    _allowDirectRoles = v;
    _allowDirectRolesSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  LDAPConfig() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LDAPConfig.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_alternateEmailLoginAllowedSet ||
        _apiMapResponse.containsKey('alternate_email_login_allowed')) {
      json['alternate_email_login_allowed'] = alternateEmailLoginAllowed;
    }
    if (_authPasswordSet || _apiMapResponse.containsKey('auth_password')) {
      json['auth_password'] = authPassword;
    }
    if (_authRequiresRoleSet ||
        _apiMapResponse.containsKey('auth_requires_role')) {
      json['auth_requires_role'] = authRequiresRole;
    }
    if (_authUsernameSet || _apiMapResponse.containsKey('auth_username')) {
      json['auth_username'] = authUsername;
    }
    if (_connectionHostSet || _apiMapResponse.containsKey('connection_host')) {
      json['connection_host'] = connectionHost;
    }
    if (_connectionPortSet || _apiMapResponse.containsKey('connection_port')) {
      json['connection_port'] = connectionPort;
    }
    if (_connectionTlsSet || _apiMapResponse.containsKey('connection_tls')) {
      json['connection_tls'] = connectionTls;
    }
    if (_connectionTlsNoVerifySet ||
        _apiMapResponse.containsKey('connection_tls_no_verify')) {
      json['connection_tls_no_verify'] = connectionTlsNoVerify;
    }
    if (_defaultNewUserGroupIdsSet ||
        _apiMapResponse.containsKey('default_new_user_group_ids')) {
      json['default_new_user_group_ids'] = defaultNewUserGroupIds;
    }
    if (_defaultNewUserGroupsSet ||
        _apiMapResponse.containsKey('default_new_user_groups')) {
      json['default_new_user_groups'] =
          defaultNewUserGroups?.map((i) => i.toJson())?.toList();
    }
    if (_defaultNewUserRoleIdsSet ||
        _apiMapResponse.containsKey('default_new_user_role_ids')) {
      json['default_new_user_role_ids'] = defaultNewUserRoleIds;
    }
    if (_defaultNewUserRolesSet ||
        _apiMapResponse.containsKey('default_new_user_roles')) {
      json['default_new_user_roles'] =
          defaultNewUserRoles?.map((i) => i.toJson())?.toList();
    }
    if (_enabledSet || _apiMapResponse.containsKey('enabled')) {
      json['enabled'] = enabled;
    }
    if (_forceNoPageSet || _apiMapResponse.containsKey('force_no_page')) {
      json['force_no_page'] = forceNoPage;
    }
    if (_groupsSet || _apiMapResponse.containsKey('groups')) {
      json['groups'] = groups?.map((i) => i.toJson())?.toList();
    }
    if (_groupsBaseDnSet || _apiMapResponse.containsKey('groups_base_dn')) {
      json['groups_base_dn'] = groupsBaseDn;
    }
    if (_groupsFinderTypeSet ||
        _apiMapResponse.containsKey('groups_finder_type')) {
      json['groups_finder_type'] = groupsFinderType;
    }
    if (_groupsMemberAttributeSet ||
        _apiMapResponse.containsKey('groups_member_attribute')) {
      json['groups_member_attribute'] = groupsMemberAttribute;
    }
    if (_groupsObjectclassesSet ||
        _apiMapResponse.containsKey('groups_objectclasses')) {
      json['groups_objectclasses'] = groupsObjectclasses;
    }
    if (_groupsUserAttributeSet ||
        _apiMapResponse.containsKey('groups_user_attribute')) {
      json['groups_user_attribute'] = groupsUserAttribute;
    }
    if (_groupsWithRoleIdsSet ||
        _apiMapResponse.containsKey('groups_with_role_ids')) {
      json['groups_with_role_ids'] =
          groupsWithRoleIds?.map((i) => i.toJson())?.toList();
    }
    if (_hasAuthPasswordSet ||
        _apiMapResponse.containsKey('has_auth_password')) {
      json['has_auth_password'] = hasAuthPassword;
    }
    if (_mergeNewUsersByEmailSet ||
        _apiMapResponse.containsKey('merge_new_users_by_email')) {
      json['merge_new_users_by_email'] = mergeNewUsersByEmail;
    }
    if (_modifiedAtSet || _apiMapResponse.containsKey('modified_at')) {
      json['modified_at'] = modifiedAt;
    }
    if (_modifiedBySet || _apiMapResponse.containsKey('modified_by')) {
      json['modified_by'] = modifiedBy;
    }
    if (_setRolesFromGroupsSet ||
        _apiMapResponse.containsKey('set_roles_from_groups')) {
      json['set_roles_from_groups'] = setRolesFromGroups;
    }
    if (_testLdapPasswordSet ||
        _apiMapResponse.containsKey('test_ldap_password')) {
      json['test_ldap_password'] = testLdapPassword;
    }
    if (_testLdapUserSet || _apiMapResponse.containsKey('test_ldap_user')) {
      json['test_ldap_user'] = testLdapUser;
    }
    if (_userAttributeMapEmailSet ||
        _apiMapResponse.containsKey('user_attribute_map_email')) {
      json['user_attribute_map_email'] = userAttributeMapEmail;
    }
    if (_userAttributeMapFirstNameSet ||
        _apiMapResponse.containsKey('user_attribute_map_first_name')) {
      json['user_attribute_map_first_name'] = userAttributeMapFirstName;
    }
    if (_userAttributeMapLastNameSet ||
        _apiMapResponse.containsKey('user_attribute_map_last_name')) {
      json['user_attribute_map_last_name'] = userAttributeMapLastName;
    }
    if (_userAttributeMapLdapIdSet ||
        _apiMapResponse.containsKey('user_attribute_map_ldap_id')) {
      json['user_attribute_map_ldap_id'] = userAttributeMapLdapId;
    }
    if (_userAttributesSet || _apiMapResponse.containsKey('user_attributes')) {
      json['user_attributes'] =
          userAttributes?.map((i) => i.toJson())?.toList();
    }
    if (_userAttributesWithIdsSet ||
        _apiMapResponse.containsKey('user_attributes_with_ids')) {
      json['user_attributes_with_ids'] =
          userAttributesWithIds?.map((i) => i.toJson())?.toList();
    }
    if (_userBindBaseDnSet ||
        _apiMapResponse.containsKey('user_bind_base_dn')) {
      json['user_bind_base_dn'] = userBindBaseDn;
    }
    if (_userCustomFilterSet ||
        _apiMapResponse.containsKey('user_custom_filter')) {
      json['user_custom_filter'] = userCustomFilter;
    }
    if (_userIdAttributeNamesSet ||
        _apiMapResponse.containsKey('user_id_attribute_names')) {
      json['user_id_attribute_names'] = userIdAttributeNames;
    }
    if (_userObjectclassSet ||
        _apiMapResponse.containsKey('user_objectclass')) {
      json['user_objectclass'] = userObjectclass;
    }
    if (_allowNormalGroupMembershipSet ||
        _apiMapResponse.containsKey('allow_normal_group_membership')) {
      json['allow_normal_group_membership'] = allowNormalGroupMembership;
    }
    if (_allowRolesFromNormalGroupsSet ||
        _apiMapResponse.containsKey('allow_roles_from_normal_groups')) {
      json['allow_roles_from_normal_groups'] = allowRolesFromNormalGroups;
    }
    if (_allowDirectRolesSet ||
        _apiMapResponse.containsKey('allow_direct_roles')) {
      json['allow_direct_roles'] = allowDirectRoles;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class LDAPConfigTestIssue {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _severity;
  bool _severitySet = false;

  String _message;
  bool _messageSet = false;

  /// Severity of the issue. Error or Warning (read-only)

  String get severity {
    if (!_severitySet && _apiMapResponse.containsKey('severity')) {
      _severity = _apiMapResponse['severity']?.toString();
      _severitySet = true;
    }
    return _severity;
  }

  set severity(String v) {
    _severity = v;
    _severitySet = true;
  }

  /// Message describing the issue (read-only)

  String get message {
    if (!_messageSet && _apiMapResponse.containsKey('message')) {
      _message = _apiMapResponse['message']?.toString();
      _messageSet = true;
    }
    return _message;
  }

  set message(String v) {
    _message = v;
    _messageSet = true;
  }

  LDAPConfigTestIssue() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LDAPConfigTestIssue.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_severitySet || _apiMapResponse.containsKey('severity')) {
      json['severity'] = severity;
    }
    if (_messageSet || _apiMapResponse.containsKey('message')) {
      json['message'] = message;
    }
    return json;
  }
}

class LDAPConfigTestResult {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _details;
  bool _detailsSet = false;

  List<LDAPConfigTestIssue> _issues;
  bool _issuesSet = false;

  String _message;
  bool _messageSet = false;

  String _status;
  bool _statusSet = false;

  String _trace;
  bool _traceSet = false;

  LDAPUser _user;
  bool _userSet = false;

  String _url;
  bool _urlSet = false;

  /// Additional details for error cases (read-only)

  String get details {
    if (!_detailsSet && _apiMapResponse.containsKey('details')) {
      _details = _apiMapResponse['details']?.toString();
      _detailsSet = true;
    }
    return _details;
  }

  set details(String v) {
    _details = v;
    _detailsSet = true;
  }

  /// Array of issues/considerations about the result (read-only)

  List<LDAPConfigTestIssue> get issues {
    if (!_issuesSet && _apiMapResponse.containsKey('issues')) {
      _issues = _apiMapResponse['issues'] == null
          ? null
          : (_apiMapResponse['issues'] as List)
              .map((i) =>
                  LDAPConfigTestIssue.fromResponse(i, apiResponseContentType))
              .toList();
      _issuesSet = true;
    }
    return _issues;
  }

  set issues(List<LDAPConfigTestIssue> v) {
    _issues = v;
    _issuesSet = true;
  }

  /// Short human readable test about the result (read-only)

  String get message {
    if (!_messageSet && _apiMapResponse.containsKey('message')) {
      _message = _apiMapResponse['message']?.toString();
      _messageSet = true;
    }
    return _message;
  }

  set message(String v) {
    _message = v;
    _messageSet = true;
  }

  /// Test status code: always 'success' or 'error' (read-only)

  String get status {
    if (!_statusSet && _apiMapResponse.containsKey('status')) {
      _status = _apiMapResponse['status']?.toString();
      _statusSet = true;
    }
    return _status;
  }

  set status(String v) {
    _status = v;
    _statusSet = true;
  }

  /// A more detailed trace of incremental results during auth tests (read-only)

  String get trace {
    if (!_traceSet && _apiMapResponse.containsKey('trace')) {
      _trace = _apiMapResponse['trace']?.toString();
      _traceSet = true;
    }
    return _trace;
  }

  set trace(String v) {
    _trace = v;
    _traceSet = true;
  }

  LDAPUser get user {
    if (!_userSet && _apiMapResponse.containsKey('user')) {
      _user = _apiMapResponse['user'] == null
          ? null
          : LDAPUser.fromResponse(
              _apiMapResponse['user'], apiResponseContentType);
      _userSet = true;
    }
    return _user;
  }

  set user(LDAPUser v) {
    _user = v;
    _userSet = true;
  }

  /// Link to ldap config (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  LDAPConfigTestResult() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LDAPConfigTestResult.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_detailsSet || _apiMapResponse.containsKey('details')) {
      json['details'] = details;
    }
    if (_issuesSet || _apiMapResponse.containsKey('issues')) {
      json['issues'] = issues?.map((i) => i.toJson())?.toList();
    }
    if (_messageSet || _apiMapResponse.containsKey('message')) {
      json['message'] = message;
    }
    if (_statusSet || _apiMapResponse.containsKey('status')) {
      json['status'] = status;
    }
    if (_traceSet || _apiMapResponse.containsKey('trace')) {
      json['trace'] = trace;
    }
    if (_userSet || _apiMapResponse.containsKey('user')) {
      json['user'] = user?.toJson();
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class LDAPGroupRead {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _id;
  bool _idSet = false;

  int _lookerGroupId;
  bool _lookerGroupIdSet = false;

  String _lookerGroupName;
  bool _lookerGroupNameSet = false;

  String _name;
  bool _nameSet = false;

  List<Role> _roles;
  bool _rolesSet = false;

  String _url;
  bool _urlSet = false;

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Unique Id of group in Looker (read-only)

  int get lookerGroupId {
    if (!_lookerGroupIdSet && _apiMapResponse.containsKey('looker_group_id')) {
      _lookerGroupId = _apiMapResponse['looker_group_id'];
      _lookerGroupIdSet = true;
    }
    return _lookerGroupId;
  }

  set lookerGroupId(int v) {
    _lookerGroupId = v;
    _lookerGroupIdSet = true;
  }

  /// Name of group in Looker (read-only)

  String get lookerGroupName {
    if (!_lookerGroupNameSet &&
        _apiMapResponse.containsKey('looker_group_name')) {
      _lookerGroupName = _apiMapResponse['looker_group_name']?.toString();
      _lookerGroupNameSet = true;
    }
    return _lookerGroupName;
  }

  set lookerGroupName(String v) {
    _lookerGroupName = v;
    _lookerGroupNameSet = true;
  }

  /// Name of group in LDAP (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Looker Roles (read-only)

  List<Role> get roles {
    if (!_rolesSet && _apiMapResponse.containsKey('roles')) {
      _roles = _apiMapResponse['roles'] == null
          ? null
          : (_apiMapResponse['roles'] as List)
              .map((i) => Role.fromResponse(i, apiResponseContentType))
              .toList();
      _rolesSet = true;
    }
    return _roles;
  }

  set roles(List<Role> v) {
    _roles = v;
    _rolesSet = true;
  }

  /// Link to ldap config (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  LDAPGroupRead() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LDAPGroupRead.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_lookerGroupIdSet || _apiMapResponse.containsKey('looker_group_id')) {
      json['looker_group_id'] = lookerGroupId;
    }
    if (_lookerGroupNameSet ||
        _apiMapResponse.containsKey('looker_group_name')) {
      json['looker_group_name'] = lookerGroupName;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_rolesSet || _apiMapResponse.containsKey('roles')) {
      json['roles'] = roles?.map((i) => i.toJson())?.toList();
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class LDAPGroupWrite {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _id;
  bool _idSet = false;

  int _lookerGroupId;
  bool _lookerGroupIdSet = false;

  String _lookerGroupName;
  bool _lookerGroupNameSet = false;

  String _name;
  bool _nameSet = false;

  List<int> _roleIds;
  bool _roleIdsSet = false;

  String _url;
  bool _urlSet = false;

  /// Unique Id

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Unique Id of group in Looker (read-only)

  int get lookerGroupId {
    if (!_lookerGroupIdSet && _apiMapResponse.containsKey('looker_group_id')) {
      _lookerGroupId = _apiMapResponse['looker_group_id'];
      _lookerGroupIdSet = true;
    }
    return _lookerGroupId;
  }

  set lookerGroupId(int v) {
    _lookerGroupId = v;
    _lookerGroupIdSet = true;
  }

  /// Name of group in Looker

  String get lookerGroupName {
    if (!_lookerGroupNameSet &&
        _apiMapResponse.containsKey('looker_group_name')) {
      _lookerGroupName = _apiMapResponse['looker_group_name']?.toString();
      _lookerGroupNameSet = true;
    }
    return _lookerGroupName;
  }

  set lookerGroupName(String v) {
    _lookerGroupName = v;
    _lookerGroupNameSet = true;
  }

  /// Name of group in LDAP

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Looker Role Ids

  List<int> get roleIds {
    if (!_roleIdsSet && _apiMapResponse.containsKey('role_ids')) {
      _roleIds =
          _apiMapResponse['role_ids']?.map<int>((i) => i as int)?.toList();
      _roleIdsSet = true;
    }
    return _roleIds;
  }

  set roleIds(List<int> v) {
    _roleIds = v;
    _roleIdsSet = true;
  }

  /// Link to ldap config (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  LDAPGroupWrite() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LDAPGroupWrite.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_lookerGroupIdSet || _apiMapResponse.containsKey('looker_group_id')) {
      json['looker_group_id'] = lookerGroupId;
    }
    if (_lookerGroupNameSet ||
        _apiMapResponse.containsKey('looker_group_name')) {
      json['looker_group_name'] = lookerGroupName;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_roleIdsSet || _apiMapResponse.containsKey('role_ids')) {
      json['role_ids'] = roleIds;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class LDAPUser {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  List<String> _allEmails;
  bool _allEmailsSet = false;

  Map<String, dynamic> _attributes;
  bool _attributesSet = false;

  String _email;
  bool _emailSet = false;

  String _firstName;
  bool _firstNameSet = false;

  List<String> _groups;
  bool _groupsSet = false;

  String _lastName;
  bool _lastNameSet = false;

  String _ldapDn;
  bool _ldapDnSet = false;

  String _ldapId;
  bool _ldapIdSet = false;

  List<String> _roles;
  bool _rolesSet = false;

  String _url;
  bool _urlSet = false;

  /// Array of user's email addresses and aliases for use in migration (read-only)

  List<String> get allEmails {
    if (!_allEmailsSet && _apiMapResponse.containsKey('all_emails')) {
      _allEmails = _apiMapResponse['all_emails']
          ?.map<String>((i) => i as String)
          ?.toList();
      _allEmailsSet = true;
    }
    return _allEmails;
  }

  set allEmails(List<String> v) {
    _allEmails = v;
    _allEmailsSet = true;
  }

  /// Dictionary of user's attributes (name/value) (read-only)

  Map<String, dynamic> get attributes {
    if (!_attributesSet && _apiMapResponse.containsKey('attributes')) {
      _attributes = _apiMapResponse['attributes'];
      _attributesSet = true;
    }
    return _attributes;
  }

  set attributes(Map<String, dynamic> v) {
    _attributes = v;
    _attributesSet = true;
  }

  /// Primary email address (read-only)

  String get email {
    if (!_emailSet && _apiMapResponse.containsKey('email')) {
      _email = _apiMapResponse['email']?.toString();
      _emailSet = true;
    }
    return _email;
  }

  set email(String v) {
    _email = v;
    _emailSet = true;
  }

  /// First name (read-only)

  String get firstName {
    if (!_firstNameSet && _apiMapResponse.containsKey('first_name')) {
      _firstName = _apiMapResponse['first_name']?.toString();
      _firstNameSet = true;
    }
    return _firstName;
  }

  set firstName(String v) {
    _firstName = v;
    _firstNameSet = true;
  }

  /// Array of user's groups (group names only) (read-only)

  List<String> get groups {
    if (!_groupsSet && _apiMapResponse.containsKey('groups')) {
      _groups =
          _apiMapResponse['groups']?.map<String>((i) => i as String)?.toList();
      _groupsSet = true;
    }
    return _groups;
  }

  set groups(List<String> v) {
    _groups = v;
    _groupsSet = true;
  }

  /// Last Name (read-only)

  String get lastName {
    if (!_lastNameSet && _apiMapResponse.containsKey('last_name')) {
      _lastName = _apiMapResponse['last_name']?.toString();
      _lastNameSet = true;
    }
    return _lastName;
  }

  set lastName(String v) {
    _lastName = v;
    _lastNameSet = true;
  }

  /// LDAP's distinguished name for the user record (read-only)

  String get ldapDn {
    if (!_ldapDnSet && _apiMapResponse.containsKey('ldap_dn')) {
      _ldapDn = _apiMapResponse['ldap_dn']?.toString();
      _ldapDnSet = true;
    }
    return _ldapDn;
  }

  set ldapDn(String v) {
    _ldapDn = v;
    _ldapDnSet = true;
  }

  /// LDAP's Unique ID for the user (read-only)

  String get ldapId {
    if (!_ldapIdSet && _apiMapResponse.containsKey('ldap_id')) {
      _ldapId = _apiMapResponse['ldap_id']?.toString();
      _ldapIdSet = true;
    }
    return _ldapId;
  }

  set ldapId(String v) {
    _ldapId = v;
    _ldapIdSet = true;
  }

  /// Array of user's roles (role names only) (read-only)

  List<String> get roles {
    if (!_rolesSet && _apiMapResponse.containsKey('roles')) {
      _roles =
          _apiMapResponse['roles']?.map<String>((i) => i as String)?.toList();
      _rolesSet = true;
    }
    return _roles;
  }

  set roles(List<String> v) {
    _roles = v;
    _rolesSet = true;
  }

  /// Link to ldap config (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  LDAPUser() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LDAPUser.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_allEmailsSet || _apiMapResponse.containsKey('all_emails')) {
      json['all_emails'] = allEmails;
    }
    if (_attributesSet || _apiMapResponse.containsKey('attributes')) {
      json['attributes'] = attributes;
    }
    if (_emailSet || _apiMapResponse.containsKey('email')) {
      json['email'] = email;
    }
    if (_firstNameSet || _apiMapResponse.containsKey('first_name')) {
      json['first_name'] = firstName;
    }
    if (_groupsSet || _apiMapResponse.containsKey('groups')) {
      json['groups'] = groups;
    }
    if (_lastNameSet || _apiMapResponse.containsKey('last_name')) {
      json['last_name'] = lastName;
    }
    if (_ldapDnSet || _apiMapResponse.containsKey('ldap_dn')) {
      json['ldap_dn'] = ldapDn;
    }
    if (_ldapIdSet || _apiMapResponse.containsKey('ldap_id')) {
      json['ldap_id'] = ldapId;
    }
    if (_rolesSet || _apiMapResponse.containsKey('roles')) {
      json['roles'] = roles;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class LDAPUserAttributeRead {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  bool _required;
  bool _requiredSet = false;

  List<UserAttribute> _userAttributes;
  bool _userAttributesSet = false;

  String _url;
  bool _urlSet = false;

  /// Name of User Attribute in LDAP (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Required to be in LDAP assertion for login to be allowed to succeed (read-only)

  bool get required {
    if (!_requiredSet && _apiMapResponse.containsKey('required')) {
      _required = _apiMapResponse['required'];
      _requiredSet = true;
    }
    return _required;
  }

  set required(bool v) {
    _required = v;
    _requiredSet = true;
  }

  /// Looker User Attributes (read-only)

  List<UserAttribute> get userAttributes {
    if (!_userAttributesSet && _apiMapResponse.containsKey('user_attributes')) {
      _userAttributes = _apiMapResponse['user_attributes'] == null
          ? null
          : (_apiMapResponse['user_attributes'] as List)
              .map((i) => UserAttribute.fromResponse(i, apiResponseContentType))
              .toList();
      _userAttributesSet = true;
    }
    return _userAttributes;
  }

  set userAttributes(List<UserAttribute> v) {
    _userAttributes = v;
    _userAttributesSet = true;
  }

  /// Link to ldap config (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  LDAPUserAttributeRead() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LDAPUserAttributeRead.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_requiredSet || _apiMapResponse.containsKey('required')) {
      json['required'] = required;
    }
    if (_userAttributesSet || _apiMapResponse.containsKey('user_attributes')) {
      json['user_attributes'] =
          userAttributes?.map((i) => i.toJson())?.toList();
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class LDAPUserAttributeWrite {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  bool _required;
  bool _requiredSet = false;

  List<int> _userAttributeIds;
  bool _userAttributeIdsSet = false;

  String _url;
  bool _urlSet = false;

  /// Name of User Attribute in LDAP

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Required to be in LDAP assertion for login to be allowed to succeed

  bool get required {
    if (!_requiredSet && _apiMapResponse.containsKey('required')) {
      _required = _apiMapResponse['required'];
      _requiredSet = true;
    }
    return _required;
  }

  set required(bool v) {
    _required = v;
    _requiredSet = true;
  }

  /// Looker User Attribute Ids

  List<int> get userAttributeIds {
    if (!_userAttributeIdsSet &&
        _apiMapResponse.containsKey('user_attribute_ids')) {
      _userAttributeIds = _apiMapResponse['user_attribute_ids']
          ?.map<int>((i) => i as int)
          ?.toList();
      _userAttributeIdsSet = true;
    }
    return _userAttributeIds;
  }

  set userAttributeIds(List<int> v) {
    _userAttributeIds = v;
    _userAttributeIdsSet = true;
  }

  /// Link to ldap config (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  LDAPUserAttributeWrite() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LDAPUserAttributeWrite.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_requiredSet || _apiMapResponse.containsKey('required')) {
      json['required'] = required;
    }
    if (_userAttributeIdsSet ||
        _apiMapResponse.containsKey('user_attribute_ids')) {
      json['user_attribute_ids'] = userAttributeIds;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class LegacyFeature {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _id;
  bool _idSet = false;

  String _name;
  bool _nameSet = false;

  String _description;
  bool _descriptionSet = false;

  bool _enabledLocally;
  bool _enabledLocallySet = false;

  bool _enabled;
  bool _enabledSet = false;

  String _disallowedAsOfVersion;
  bool _disallowedAsOfVersionSet = false;

  String _disableOnUpgradeToVersion;
  bool _disableOnUpgradeToVersionSet = false;

  String _endOfLifeVersion;
  bool _endOfLifeVersionSet = false;

  String _documentationUrl;
  bool _documentationUrlSet = false;

  DateTime _approximateDisableDate;
  bool _approximateDisableDateSet = false;

  DateTime _approximateEndOfLifeDate;
  bool _approximateEndOfLifeDateSet = false;

  bool _hasDisabledOnUpgrade;
  bool _hasDisabledOnUpgradeSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Name (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Description (read-only)

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Whether this feature has been enabled by a user

  bool get enabledLocally {
    if (!_enabledLocallySet && _apiMapResponse.containsKey('enabled_locally')) {
      _enabledLocally = _apiMapResponse['enabled_locally'];
      _enabledLocallySet = true;
    }
    return _enabledLocally;
  }

  set enabledLocally(bool v) {
    _enabledLocally = v;
    _enabledLocallySet = true;
  }

  /// Whether this feature is currently enabled (read-only)

  bool get enabled {
    if (!_enabledSet && _apiMapResponse.containsKey('enabled')) {
      _enabled = _apiMapResponse['enabled'];
      _enabledSet = true;
    }
    return _enabled;
  }

  set enabled(bool v) {
    _enabled = v;
    _enabledSet = true;
  }

  /// Looker version where this feature became a legacy feature (read-only)

  String get disallowedAsOfVersion {
    if (!_disallowedAsOfVersionSet &&
        _apiMapResponse.containsKey('disallowed_as_of_version')) {
      _disallowedAsOfVersion =
          _apiMapResponse['disallowed_as_of_version']?.toString();
      _disallowedAsOfVersionSet = true;
    }
    return _disallowedAsOfVersion;
  }

  set disallowedAsOfVersion(String v) {
    _disallowedAsOfVersion = v;
    _disallowedAsOfVersionSet = true;
  }

  /// Looker version where this feature will be automatically disabled (read-only)

  String get disableOnUpgradeToVersion {
    if (!_disableOnUpgradeToVersionSet &&
        _apiMapResponse.containsKey('disable_on_upgrade_to_version')) {
      _disableOnUpgradeToVersion =
          _apiMapResponse['disable_on_upgrade_to_version']?.toString();
      _disableOnUpgradeToVersionSet = true;
    }
    return _disableOnUpgradeToVersion;
  }

  set disableOnUpgradeToVersion(String v) {
    _disableOnUpgradeToVersion = v;
    _disableOnUpgradeToVersionSet = true;
  }

  /// Future Looker version where this feature will be removed (read-only)

  String get endOfLifeVersion {
    if (!_endOfLifeVersionSet &&
        _apiMapResponse.containsKey('end_of_life_version')) {
      _endOfLifeVersion = _apiMapResponse['end_of_life_version']?.toString();
      _endOfLifeVersionSet = true;
    }
    return _endOfLifeVersion;
  }

  set endOfLifeVersion(String v) {
    _endOfLifeVersion = v;
    _endOfLifeVersionSet = true;
  }

  /// URL for documentation about this feature (read-only)

  String get documentationUrl {
    if (!_documentationUrlSet &&
        _apiMapResponse.containsKey('documentation_url')) {
      _documentationUrl = _apiMapResponse['documentation_url']?.toString();
      _documentationUrlSet = true;
    }
    return _documentationUrl;
  }

  set documentationUrl(String v) {
    _documentationUrl = v;
    _documentationUrlSet = true;
  }

  /// Approximate date that this feature will be automatically disabled. (read-only)

  DateTime get approximateDisableDate {
    if (!_approximateDisableDateSet &&
        _apiMapResponse.containsKey('approximate_disable_date')) {
      _approximateDisableDate =
          _apiMapResponse['approximate_disable_date'] == null
              ? null
              : DateTime.parse(_apiMapResponse['approximate_disable_date']);
      _approximateDisableDateSet = true;
    }
    return _approximateDisableDate;
  }

  set approximateDisableDate(DateTime v) {
    _approximateDisableDate = v;
    _approximateDisableDateSet = true;
  }

  /// Approximate date that this feature will be removed. (read-only)

  DateTime get approximateEndOfLifeDate {
    if (!_approximateEndOfLifeDateSet &&
        _apiMapResponse.containsKey('approximate_end_of_life_date')) {
      _approximateEndOfLifeDate =
          _apiMapResponse['approximate_end_of_life_date'] == null
              ? null
              : DateTime.parse(_apiMapResponse['approximate_end_of_life_date']);
      _approximateEndOfLifeDateSet = true;
    }
    return _approximateEndOfLifeDate;
  }

  set approximateEndOfLifeDate(DateTime v) {
    _approximateEndOfLifeDate = v;
    _approximateEndOfLifeDateSet = true;
  }

  /// Whether this legacy feature may have been automatically disabled when upgrading to the current version. (read-only)

  bool get hasDisabledOnUpgrade {
    if (!_hasDisabledOnUpgradeSet &&
        _apiMapResponse.containsKey('has_disabled_on_upgrade')) {
      _hasDisabledOnUpgrade = _apiMapResponse['has_disabled_on_upgrade'];
      _hasDisabledOnUpgradeSet = true;
    }
    return _hasDisabledOnUpgrade;
  }

  set hasDisabledOnUpgrade(bool v) {
    _hasDisabledOnUpgrade = v;
    _hasDisabledOnUpgradeSet = true;
  }

  LegacyFeature() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LegacyFeature.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_enabledLocallySet || _apiMapResponse.containsKey('enabled_locally')) {
      json['enabled_locally'] = enabledLocally;
    }
    if (_enabledSet || _apiMapResponse.containsKey('enabled')) {
      json['enabled'] = enabled;
    }
    if (_disallowedAsOfVersionSet ||
        _apiMapResponse.containsKey('disallowed_as_of_version')) {
      json['disallowed_as_of_version'] = disallowedAsOfVersion;
    }
    if (_disableOnUpgradeToVersionSet ||
        _apiMapResponse.containsKey('disable_on_upgrade_to_version')) {
      json['disable_on_upgrade_to_version'] = disableOnUpgradeToVersion;
    }
    if (_endOfLifeVersionSet ||
        _apiMapResponse.containsKey('end_of_life_version')) {
      json['end_of_life_version'] = endOfLifeVersion;
    }
    if (_documentationUrlSet ||
        _apiMapResponse.containsKey('documentation_url')) {
      json['documentation_url'] = documentationUrl;
    }
    if (_approximateDisableDateSet ||
        _apiMapResponse.containsKey('approximate_disable_date')) {
      json['approximate_disable_date'] =
          approximateDisableDate?.toIso8601String();
    }
    if (_approximateEndOfLifeDateSet ||
        _apiMapResponse.containsKey('approximate_end_of_life_date')) {
      json['approximate_end_of_life_date'] =
          approximateEndOfLifeDate?.toIso8601String();
    }
    if (_hasDisabledOnUpgradeSet ||
        _apiMapResponse.containsKey('has_disabled_on_upgrade')) {
      json['has_disabled_on_upgrade'] = hasDisabledOnUpgrade;
    }
    return json;
  }
}

/// Name of the command Valid values are: "dashboard", "lookml_dashboard". (Enum defined in Command)
enum LinkedContentType { dashboard, lookmlDashboard }

class LinkedContentTypeMapper {
  static String toStringValue(LinkedContentType e) {
    switch (e) {
      case LinkedContentType.dashboard:
        return 'dashboard';
      case LinkedContentType.lookmlDashboard:
        return 'lookml_dashboard';

      default:
        return null;
    }
  }

  static LinkedContentType fromStringValue(String s) {
    if (s == 'dashboard') {
      return LinkedContentType.dashboard;
    }
    if (s == 'lookml_dashboard') {
      return LinkedContentType.lookmlDashboard;
    }
    return null;
  }
}

class Locale {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _code;
  bool _codeSet = false;

  String _nativeName;
  bool _nativeNameSet = false;

  String _englishName;
  bool _englishNameSet = false;

  /// Code for Locale (read-only)

  String get code {
    if (!_codeSet && _apiMapResponse.containsKey('code')) {
      _code = _apiMapResponse['code']?.toString();
      _codeSet = true;
    }
    return _code;
  }

  set code(String v) {
    _code = v;
    _codeSet = true;
  }

  /// Name of Locale in its own language (read-only)

  String get nativeName {
    if (!_nativeNameSet && _apiMapResponse.containsKey('native_name')) {
      _nativeName = _apiMapResponse['native_name']?.toString();
      _nativeNameSet = true;
    }
    return _nativeName;
  }

  set nativeName(String v) {
    _nativeName = v;
    _nativeNameSet = true;
  }

  /// Name of Locale in English (read-only)

  String get englishName {
    if (!_englishNameSet && _apiMapResponse.containsKey('english_name')) {
      _englishName = _apiMapResponse['english_name']?.toString();
      _englishNameSet = true;
    }
    return _englishName;
  }

  set englishName(String v) {
    _englishName = v;
    _englishNameSet = true;
  }

  Locale() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Locale.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_codeSet || _apiMapResponse.containsKey('code')) {
      json['code'] = code;
    }
    if (_nativeNameSet || _apiMapResponse.containsKey('native_name')) {
      json['native_name'] = nativeName;
    }
    if (_englishNameSet || _apiMapResponse.containsKey('english_name')) {
      json['english_name'] = englishName;
    }
    return json;
  }
}

class LocalizationSettings {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _defaultLocale;
  bool _defaultLocaleSet = false;

  String _localizationLevel;
  bool _localizationLevelSet = false;

  /// Default locale for localization (read-only)

  String get defaultLocale {
    if (!_defaultLocaleSet && _apiMapResponse.containsKey('default_locale')) {
      _defaultLocale = _apiMapResponse['default_locale']?.toString();
      _defaultLocaleSet = true;
    }
    return _defaultLocale;
  }

  set defaultLocale(String v) {
    _defaultLocale = v;
    _defaultLocaleSet = true;
  }

  /// Localization level - strict or permissive (read-only)

  String get localizationLevel {
    if (!_localizationLevelSet &&
        _apiMapResponse.containsKey('localization_level')) {
      _localizationLevel = _apiMapResponse['localization_level']?.toString();
      _localizationLevelSet = true;
    }
    return _localizationLevel;
  }

  set localizationLevel(String v) {
    _localizationLevel = v;
    _localizationLevelSet = true;
  }

  LocalizationSettings() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LocalizationSettings.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_defaultLocaleSet || _apiMapResponse.containsKey('default_locale')) {
      json['default_locale'] = defaultLocale;
    }
    if (_localizationLevelSet ||
        _apiMapResponse.containsKey('localization_level')) {
      json['localization_level'] = localizationLevel;
    }
    return json;
  }
}

class Look {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _contentMetadataId;
  bool _contentMetadataIdSet = false;

  String _id;
  bool _idSet = false;

  String _title;
  bool _titleSet = false;

  int _userId;
  bool _userIdSet = false;

  int _contentFavoriteId;
  bool _contentFavoriteIdSet = false;

  DateTime _createdAt;
  bool _createdAtSet = false;

  bool _deleted;
  bool _deletedSet = false;

  DateTime _deletedAt;
  bool _deletedAtSet = false;

  int _deleterId;
  bool _deleterIdSet = false;

  String _description;
  bool _descriptionSet = false;

  String _embedUrl;
  bool _embedUrlSet = false;

  String _excelFileUrl;
  bool _excelFileUrlSet = false;

  int _favoriteCount;
  bool _favoriteCountSet = false;

  String _googleSpreadsheetFormula;
  bool _googleSpreadsheetFormulaSet = false;

  String _imageEmbedUrl;
  bool _imageEmbedUrlSet = false;

  bool _isRunOnLoad;
  bool _isRunOnLoadSet = false;

  DateTime _lastAccessedAt;
  bool _lastAccessedAtSet = false;

  int _lastUpdaterId;
  bool _lastUpdaterIdSet = false;

  DateTime _lastViewedAt;
  bool _lastViewedAtSet = false;

  LookModel _model;
  bool _modelSet = false;

  bool _public;
  bool _publicSet = false;

  String _publicSlug;
  bool _publicSlugSet = false;

  String _publicUrl;
  bool _publicUrlSet = false;

  int _queryId;
  bool _queryIdSet = false;

  String _shortUrl;
  bool _shortUrlSet = false;

  FolderBase _folder;
  bool _folderSet = false;

  String _folderId;
  bool _folderIdSet = false;

  DateTime _updatedAt;
  bool _updatedAtSet = false;

  int _viewCount;
  bool _viewCountSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Id of content metadata (read-only)

  int get contentMetadataId {
    if (!_contentMetadataIdSet &&
        _apiMapResponse.containsKey('content_metadata_id')) {
      _contentMetadataId = _apiMapResponse['content_metadata_id'];
      _contentMetadataIdSet = true;
    }
    return _contentMetadataId;
  }

  set contentMetadataId(int v) {
    _contentMetadataId = v;
    _contentMetadataIdSet = true;
  }

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Look Title

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// User Id

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  /// Content Favorite Id (read-only)

  int get contentFavoriteId {
    if (!_contentFavoriteIdSet &&
        _apiMapResponse.containsKey('content_favorite_id')) {
      _contentFavoriteId = _apiMapResponse['content_favorite_id'];
      _contentFavoriteIdSet = true;
    }
    return _contentFavoriteId;
  }

  set contentFavoriteId(int v) {
    _contentFavoriteId = v;
    _contentFavoriteIdSet = true;
  }

  /// Time that the Look was created. (read-only)

  DateTime get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['created_at']);
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(DateTime v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// Whether or not a look is 'soft' deleted.

  bool get deleted {
    if (!_deletedSet && _apiMapResponse.containsKey('deleted')) {
      _deleted = _apiMapResponse['deleted'];
      _deletedSet = true;
    }
    return _deleted;
  }

  set deleted(bool v) {
    _deleted = v;
    _deletedSet = true;
  }

  /// Time that the Look was deleted. (read-only)

  DateTime get deletedAt {
    if (!_deletedAtSet && _apiMapResponse.containsKey('deleted_at')) {
      _deletedAt = _apiMapResponse['deleted_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['deleted_at']);
      _deletedAtSet = true;
    }
    return _deletedAt;
  }

  set deletedAt(DateTime v) {
    _deletedAt = v;
    _deletedAtSet = true;
  }

  /// Id of User that deleted the look. (read-only)

  int get deleterId {
    if (!_deleterIdSet && _apiMapResponse.containsKey('deleter_id')) {
      _deleterId = _apiMapResponse['deleter_id'];
      _deleterIdSet = true;
    }
    return _deleterId;
  }

  set deleterId(int v) {
    _deleterId = v;
    _deleterIdSet = true;
  }

  /// Description

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Embed Url (read-only)

  String get embedUrl {
    if (!_embedUrlSet && _apiMapResponse.containsKey('embed_url')) {
      _embedUrl = _apiMapResponse['embed_url']?.toString();
      _embedUrlSet = true;
    }
    return _embedUrl;
  }

  set embedUrl(String v) {
    _embedUrl = v;
    _embedUrlSet = true;
  }

  /// Excel File Url (read-only)

  String get excelFileUrl {
    if (!_excelFileUrlSet && _apiMapResponse.containsKey('excel_file_url')) {
      _excelFileUrl = _apiMapResponse['excel_file_url']?.toString();
      _excelFileUrlSet = true;
    }
    return _excelFileUrl;
  }

  set excelFileUrl(String v) {
    _excelFileUrl = v;
    _excelFileUrlSet = true;
  }

  /// Number of times favorited (read-only)

  int get favoriteCount {
    if (!_favoriteCountSet && _apiMapResponse.containsKey('favorite_count')) {
      _favoriteCount = _apiMapResponse['favorite_count'];
      _favoriteCountSet = true;
    }
    return _favoriteCount;
  }

  set favoriteCount(int v) {
    _favoriteCount = v;
    _favoriteCountSet = true;
  }

  /// Google Spreadsheet Formula (read-only)

  String get googleSpreadsheetFormula {
    if (!_googleSpreadsheetFormulaSet &&
        _apiMapResponse.containsKey('google_spreadsheet_formula')) {
      _googleSpreadsheetFormula =
          _apiMapResponse['google_spreadsheet_formula']?.toString();
      _googleSpreadsheetFormulaSet = true;
    }
    return _googleSpreadsheetFormula;
  }

  set googleSpreadsheetFormula(String v) {
    _googleSpreadsheetFormula = v;
    _googleSpreadsheetFormulaSet = true;
  }

  /// Image Embed Url (read-only)

  String get imageEmbedUrl {
    if (!_imageEmbedUrlSet && _apiMapResponse.containsKey('image_embed_url')) {
      _imageEmbedUrl = _apiMapResponse['image_embed_url']?.toString();
      _imageEmbedUrlSet = true;
    }
    return _imageEmbedUrl;
  }

  set imageEmbedUrl(String v) {
    _imageEmbedUrl = v;
    _imageEmbedUrlSet = true;
  }

  /// auto-run query when Look viewed

  bool get isRunOnLoad {
    if (!_isRunOnLoadSet && _apiMapResponse.containsKey('is_run_on_load')) {
      _isRunOnLoad = _apiMapResponse['is_run_on_load'];
      _isRunOnLoadSet = true;
    }
    return _isRunOnLoad;
  }

  set isRunOnLoad(bool v) {
    _isRunOnLoad = v;
    _isRunOnLoadSet = true;
  }

  /// Time that the Look was last accessed by any user (read-only)

  DateTime get lastAccessedAt {
    if (!_lastAccessedAtSet &&
        _apiMapResponse.containsKey('last_accessed_at')) {
      _lastAccessedAt = _apiMapResponse['last_accessed_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['last_accessed_at']);
      _lastAccessedAtSet = true;
    }
    return _lastAccessedAt;
  }

  set lastAccessedAt(DateTime v) {
    _lastAccessedAt = v;
    _lastAccessedAtSet = true;
  }

  /// Id of User that last updated the look. (read-only)

  int get lastUpdaterId {
    if (!_lastUpdaterIdSet && _apiMapResponse.containsKey('last_updater_id')) {
      _lastUpdaterId = _apiMapResponse['last_updater_id'];
      _lastUpdaterIdSet = true;
    }
    return _lastUpdaterId;
  }

  set lastUpdaterId(int v) {
    _lastUpdaterId = v;
    _lastUpdaterIdSet = true;
  }

  /// Time last viewed in the Looker web UI (read-only)

  DateTime get lastViewedAt {
    if (!_lastViewedAtSet && _apiMapResponse.containsKey('last_viewed_at')) {
      _lastViewedAt = _apiMapResponse['last_viewed_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['last_viewed_at']);
      _lastViewedAtSet = true;
    }
    return _lastViewedAt;
  }

  set lastViewedAt(DateTime v) {
    _lastViewedAt = v;
    _lastViewedAtSet = true;
  }

  LookModel get model {
    if (!_modelSet && _apiMapResponse.containsKey('model')) {
      _model = _apiMapResponse['model'] == null
          ? null
          : LookModel.fromResponse(
              _apiMapResponse['model'], apiResponseContentType);
      _modelSet = true;
    }
    return _model;
  }

  set model(LookModel v) {
    _model = v;
    _modelSet = true;
  }

  /// Is Public

  bool get public {
    if (!_publicSet && _apiMapResponse.containsKey('public')) {
      _public = _apiMapResponse['public'];
      _publicSet = true;
    }
    return _public;
  }

  set public(bool v) {
    _public = v;
    _publicSet = true;
  }

  /// Public Slug (read-only)

  String get publicSlug {
    if (!_publicSlugSet && _apiMapResponse.containsKey('public_slug')) {
      _publicSlug = _apiMapResponse['public_slug']?.toString();
      _publicSlugSet = true;
    }
    return _publicSlug;
  }

  set publicSlug(String v) {
    _publicSlug = v;
    _publicSlugSet = true;
  }

  /// Public Url (read-only)

  String get publicUrl {
    if (!_publicUrlSet && _apiMapResponse.containsKey('public_url')) {
      _publicUrl = _apiMapResponse['public_url']?.toString();
      _publicUrlSet = true;
    }
    return _publicUrl;
  }

  set publicUrl(String v) {
    _publicUrl = v;
    _publicUrlSet = true;
  }

  /// Query Id

  int get queryId {
    if (!_queryIdSet && _apiMapResponse.containsKey('query_id')) {
      _queryId = _apiMapResponse['query_id'];
      _queryIdSet = true;
    }
    return _queryId;
  }

  set queryId(int v) {
    _queryId = v;
    _queryIdSet = true;
  }

  /// Short Url (read-only)

  String get shortUrl {
    if (!_shortUrlSet && _apiMapResponse.containsKey('short_url')) {
      _shortUrl = _apiMapResponse['short_url']?.toString();
      _shortUrlSet = true;
    }
    return _shortUrl;
  }

  set shortUrl(String v) {
    _shortUrl = v;
    _shortUrlSet = true;
  }

  FolderBase get folder {
    if (!_folderSet && _apiMapResponse.containsKey('folder')) {
      _folder = _apiMapResponse['folder'] == null
          ? null
          : FolderBase.fromResponse(
              _apiMapResponse['folder'], apiResponseContentType);
      _folderSet = true;
    }
    return _folder;
  }

  set folder(FolderBase v) {
    _folder = v;
    _folderSet = true;
  }

  /// Folder Id

  String get folderId {
    if (!_folderIdSet && _apiMapResponse.containsKey('folder_id')) {
      _folderId = _apiMapResponse['folder_id']?.toString();
      _folderIdSet = true;
    }
    return _folderId;
  }

  set folderId(String v) {
    _folderId = v;
    _folderIdSet = true;
  }

  /// Time that the Look was updated. (read-only)

  DateTime get updatedAt {
    if (!_updatedAtSet && _apiMapResponse.containsKey('updated_at')) {
      _updatedAt = _apiMapResponse['updated_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['updated_at']);
      _updatedAtSet = true;
    }
    return _updatedAt;
  }

  set updatedAt(DateTime v) {
    _updatedAt = v;
    _updatedAtSet = true;
  }

  /// Number of times viewed in the Looker web UI (read-only)

  int get viewCount {
    if (!_viewCountSet && _apiMapResponse.containsKey('view_count')) {
      _viewCount = _apiMapResponse['view_count'];
      _viewCountSet = true;
    }
    return _viewCount;
  }

  set viewCount(int v) {
    _viewCount = v;
    _viewCountSet = true;
  }

  Look() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Look.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_contentMetadataIdSet ||
        _apiMapResponse.containsKey('content_metadata_id')) {
      json['content_metadata_id'] = contentMetadataId;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    if (_contentFavoriteIdSet ||
        _apiMapResponse.containsKey('content_favorite_id')) {
      json['content_favorite_id'] = contentFavoriteId;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt?.toIso8601String();
    }
    if (_deletedSet || _apiMapResponse.containsKey('deleted')) {
      json['deleted'] = deleted;
    }
    if (_deletedAtSet || _apiMapResponse.containsKey('deleted_at')) {
      json['deleted_at'] = deletedAt?.toIso8601String();
    }
    if (_deleterIdSet || _apiMapResponse.containsKey('deleter_id')) {
      json['deleter_id'] = deleterId;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_embedUrlSet || _apiMapResponse.containsKey('embed_url')) {
      json['embed_url'] = embedUrl;
    }
    if (_excelFileUrlSet || _apiMapResponse.containsKey('excel_file_url')) {
      json['excel_file_url'] = excelFileUrl;
    }
    if (_favoriteCountSet || _apiMapResponse.containsKey('favorite_count')) {
      json['favorite_count'] = favoriteCount;
    }
    if (_googleSpreadsheetFormulaSet ||
        _apiMapResponse.containsKey('google_spreadsheet_formula')) {
      json['google_spreadsheet_formula'] = googleSpreadsheetFormula;
    }
    if (_imageEmbedUrlSet || _apiMapResponse.containsKey('image_embed_url')) {
      json['image_embed_url'] = imageEmbedUrl;
    }
    if (_isRunOnLoadSet || _apiMapResponse.containsKey('is_run_on_load')) {
      json['is_run_on_load'] = isRunOnLoad;
    }
    if (_lastAccessedAtSet || _apiMapResponse.containsKey('last_accessed_at')) {
      json['last_accessed_at'] = lastAccessedAt?.toIso8601String();
    }
    if (_lastUpdaterIdSet || _apiMapResponse.containsKey('last_updater_id')) {
      json['last_updater_id'] = lastUpdaterId;
    }
    if (_lastViewedAtSet || _apiMapResponse.containsKey('last_viewed_at')) {
      json['last_viewed_at'] = lastViewedAt?.toIso8601String();
    }
    if (_modelSet || _apiMapResponse.containsKey('model')) {
      json['model'] = model?.toJson();
    }
    if (_publicSet || _apiMapResponse.containsKey('public')) {
      json['public'] = public;
    }
    if (_publicSlugSet || _apiMapResponse.containsKey('public_slug')) {
      json['public_slug'] = publicSlug;
    }
    if (_publicUrlSet || _apiMapResponse.containsKey('public_url')) {
      json['public_url'] = publicUrl;
    }
    if (_queryIdSet || _apiMapResponse.containsKey('query_id')) {
      json['query_id'] = queryId;
    }
    if (_shortUrlSet || _apiMapResponse.containsKey('short_url')) {
      json['short_url'] = shortUrl;
    }
    if (_folderSet || _apiMapResponse.containsKey('folder')) {
      json['folder'] = folder?.toJson();
    }
    if (_folderIdSet || _apiMapResponse.containsKey('folder_id')) {
      json['folder_id'] = folderId;
    }
    if (_updatedAtSet || _apiMapResponse.containsKey('updated_at')) {
      json['updated_at'] = updatedAt?.toIso8601String();
    }
    if (_viewCountSet || _apiMapResponse.containsKey('view_count')) {
      json['view_count'] = viewCount;
    }
    return json;
  }
}

class LookBasic {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _contentMetadataId;
  bool _contentMetadataIdSet = false;

  int _id;
  bool _idSet = false;

  String _title;
  bool _titleSet = false;

  int _userId;
  bool _userIdSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Id of content metadata (read-only)

  int get contentMetadataId {
    if (!_contentMetadataIdSet &&
        _apiMapResponse.containsKey('content_metadata_id')) {
      _contentMetadataId = _apiMapResponse['content_metadata_id'];
      _contentMetadataIdSet = true;
    }
    return _contentMetadataId;
  }

  set contentMetadataId(int v) {
    _contentMetadataId = v;
    _contentMetadataIdSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Look Title (read-only)

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// User Id

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  LookBasic() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookBasic.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_contentMetadataIdSet ||
        _apiMapResponse.containsKey('content_metadata_id')) {
      json['content_metadata_id'] = contentMetadataId;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    return json;
  }
}

class LookmlModel {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  List<String> _allowedDbConnectionNames;
  bool _allowedDbConnectionNamesSet = false;

  List<LookmlModelNavExplore> _explores;
  bool _exploresSet = false;

  bool _hasContent;
  bool _hasContentSet = false;

  String _label;
  bool _labelSet = false;

  String _name;
  bool _nameSet = false;

  String _projectName;
  bool _projectNameSet = false;

  bool _unlimitedDbConnections;
  bool _unlimitedDbConnectionsSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Array of names of connections this model is allowed to use

  List<String> get allowedDbConnectionNames {
    if (!_allowedDbConnectionNamesSet &&
        _apiMapResponse.containsKey('allowed_db_connection_names')) {
      _allowedDbConnectionNames = _apiMapResponse['allowed_db_connection_names']
          ?.map<String>((i) => i as String)
          ?.toList();
      _allowedDbConnectionNamesSet = true;
    }
    return _allowedDbConnectionNames;
  }

  set allowedDbConnectionNames(List<String> v) {
    _allowedDbConnectionNames = v;
    _allowedDbConnectionNamesSet = true;
  }

  /// Array of explores (if has_content) (read-only)

  List<LookmlModelNavExplore> get explores {
    if (!_exploresSet && _apiMapResponse.containsKey('explores')) {
      _explores = _apiMapResponse['explores'] == null
          ? null
          : (_apiMapResponse['explores'] as List)
              .map((i) =>
                  LookmlModelNavExplore.fromResponse(i, apiResponseContentType))
              .toList();
      _exploresSet = true;
    }
    return _explores;
  }

  set explores(List<LookmlModelNavExplore> v) {
    _explores = v;
    _exploresSet = true;
  }

  /// Does this model declaration have have lookml content? (read-only)

  bool get hasContent {
    if (!_hasContentSet && _apiMapResponse.containsKey('has_content')) {
      _hasContent = _apiMapResponse['has_content'];
      _hasContentSet = true;
    }
    return _hasContent;
  }

  set hasContent(bool v) {
    _hasContent = v;
    _hasContentSet = true;
  }

  /// UI-friendly name for this model (read-only)

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// Name of the model. Also used as the unique identifier

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Name of project containing the model

  String get projectName {
    if (!_projectNameSet && _apiMapResponse.containsKey('project_name')) {
      _projectName = _apiMapResponse['project_name']?.toString();
      _projectNameSet = true;
    }
    return _projectName;
  }

  set projectName(String v) {
    _projectName = v;
    _projectNameSet = true;
  }

  /// Is this model allowed to use all current and future connections

  bool get unlimitedDbConnections {
    if (!_unlimitedDbConnectionsSet &&
        _apiMapResponse.containsKey('unlimited_db_connections')) {
      _unlimitedDbConnections = _apiMapResponse['unlimited_db_connections'];
      _unlimitedDbConnectionsSet = true;
    }
    return _unlimitedDbConnections;
  }

  set unlimitedDbConnections(bool v) {
    _unlimitedDbConnections = v;
    _unlimitedDbConnectionsSet = true;
  }

  LookmlModel() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlModel.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_allowedDbConnectionNamesSet ||
        _apiMapResponse.containsKey('allowed_db_connection_names')) {
      json['allowed_db_connection_names'] = allowedDbConnectionNames;
    }
    if (_exploresSet || _apiMapResponse.containsKey('explores')) {
      json['explores'] = explores?.map((i) => i.toJson())?.toList();
    }
    if (_hasContentSet || _apiMapResponse.containsKey('has_content')) {
      json['has_content'] = hasContent;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_projectNameSet || _apiMapResponse.containsKey('project_name')) {
      json['project_name'] = projectName;
    }
    if (_unlimitedDbConnectionsSet ||
        _apiMapResponse.containsKey('unlimited_db_connections')) {
      json['unlimited_db_connections'] = unlimitedDbConnections;
    }
    return json;
  }
}

class LookmlModelExplore {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _id;
  bool _idSet = false;

  String _name;
  bool _nameSet = false;

  String _description;
  bool _descriptionSet = false;

  String _label;
  bool _labelSet = false;

  String _title;
  bool _titleSet = false;

  List<String> _scopes;
  bool _scopesSet = false;

  bool _canTotal;
  bool _canTotalSet = false;

  bool _canDevelop;
  bool _canDevelopSet = false;

  bool _canSeeLookml;
  bool _canSeeLookmlSet = false;

  String _lookmlLink;
  bool _lookmlLinkSet = false;

  bool _canSave;
  bool _canSaveSet = false;

  bool _canExplain;
  bool _canExplainSet = false;

  bool _canPivotInDb;
  bool _canPivotInDbSet = false;

  bool _canSubtotal;
  bool _canSubtotalSet = false;

  bool _hasTimezoneSupport;
  bool _hasTimezoneSupportSet = false;

  bool _supportsCostEstimate;
  bool _supportsCostEstimateSet = false;

  String _connectionName;
  bool _connectionNameSet = false;

  String _nullSortTreatment;
  bool _nullSortTreatmentSet = false;

  List<String> _files;
  bool _filesSet = false;

  String _sourceFile;
  bool _sourceFileSet = false;

  String _projectName;
  bool _projectNameSet = false;

  String _modelName;
  bool _modelNameSet = false;

  String _viewName;
  bool _viewNameSet = false;

  bool _hidden;
  bool _hiddenSet = false;

  String _sqlTableName;
  bool _sqlTableNameSet = false;

  List<String> _accessFilterFields;
  bool _accessFilterFieldsSet = false;

  List<LookmlModelExploreAccessFilter> _accessFilters;
  bool _accessFiltersSet = false;

  List<LookmlModelExploreAlias> _aliases;
  bool _aliasesSet = false;

  List<LookmlModelExploreAlwaysFilter> _alwaysFilter;
  bool _alwaysFilterSet = false;

  List<LookmlModelExploreConditionallyFilter> _conditionallyFilter;
  bool _conditionallyFilterSet = false;

  List<String> _indexFields;
  bool _indexFieldsSet = false;

  List<LookmlModelExploreSet> _sets;
  bool _setsSet = false;

  List<String> _tags;
  bool _tagsSet = false;

  List<LookmlModelExploreError> _errors;
  bool _errorsSet = false;

  LookmlModelExploreFieldset _fields;
  bool _fieldsSet = false;

  List<LookmlModelExploreJoins> _joins;
  bool _joinsSet = false;

  String _groupLabel;
  bool _groupLabelSet = false;

  List<LookmlModelExploreSupportedMeasureType> _supportedMeasureTypes;
  bool _supportedMeasureTypesSet = false;

  List<String> _alwaysJoin;
  bool _alwaysJoinSet = false;

  /// Fully qualified explore name (model name plus explore name) (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Explore name (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Description (read-only)

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Label (read-only)

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// Explore title (read-only)

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Scopes (read-only)

  List<String> get scopes {
    if (!_scopesSet && _apiMapResponse.containsKey('scopes')) {
      _scopes =
          _apiMapResponse['scopes']?.map<String>((i) => i as String)?.toList();
      _scopesSet = true;
    }
    return _scopes;
  }

  set scopes(List<String> v) {
    _scopes = v;
    _scopesSet = true;
  }

  /// Can Total (read-only)

  bool get canTotal {
    if (!_canTotalSet && _apiMapResponse.containsKey('can_total')) {
      _canTotal = _apiMapResponse['can_total'];
      _canTotalSet = true;
    }
    return _canTotal;
  }

  set canTotal(bool v) {
    _canTotal = v;
    _canTotalSet = true;
  }

  /// Can Develop LookML (read-only)

  bool get canDevelop {
    if (!_canDevelopSet && _apiMapResponse.containsKey('can_develop')) {
      _canDevelop = _apiMapResponse['can_develop'];
      _canDevelopSet = true;
    }
    return _canDevelop;
  }

  set canDevelop(bool v) {
    _canDevelop = v;
    _canDevelopSet = true;
  }

  /// Can See LookML (read-only)

  bool get canSeeLookml {
    if (!_canSeeLookmlSet && _apiMapResponse.containsKey('can_see_lookml')) {
      _canSeeLookml = _apiMapResponse['can_see_lookml'];
      _canSeeLookmlSet = true;
    }
    return _canSeeLookml;
  }

  set canSeeLookml(bool v) {
    _canSeeLookml = v;
    _canSeeLookmlSet = true;
  }

  /// A URL linking to the definition of this explore in the LookML IDE. (read-only)

  String get lookmlLink {
    if (!_lookmlLinkSet && _apiMapResponse.containsKey('lookml_link')) {
      _lookmlLink = _apiMapResponse['lookml_link']?.toString();
      _lookmlLinkSet = true;
    }
    return _lookmlLink;
  }

  set lookmlLink(String v) {
    _lookmlLink = v;
    _lookmlLinkSet = true;
  }

  /// Can Save (read-only)

  bool get canSave {
    if (!_canSaveSet && _apiMapResponse.containsKey('can_save')) {
      _canSave = _apiMapResponse['can_save'];
      _canSaveSet = true;
    }
    return _canSave;
  }

  set canSave(bool v) {
    _canSave = v;
    _canSaveSet = true;
  }

  /// Can Explain (read-only)

  bool get canExplain {
    if (!_canExplainSet && _apiMapResponse.containsKey('can_explain')) {
      _canExplain = _apiMapResponse['can_explain'];
      _canExplainSet = true;
    }
    return _canExplain;
  }

  set canExplain(bool v) {
    _canExplain = v;
    _canExplainSet = true;
  }

  /// Can pivot in the DB (read-only)

  bool get canPivotInDb {
    if (!_canPivotInDbSet && _apiMapResponse.containsKey('can_pivot_in_db')) {
      _canPivotInDb = _apiMapResponse['can_pivot_in_db'];
      _canPivotInDbSet = true;
    }
    return _canPivotInDb;
  }

  set canPivotInDb(bool v) {
    _canPivotInDb = v;
    _canPivotInDbSet = true;
  }

  /// Can use subtotals (read-only)

  bool get canSubtotal {
    if (!_canSubtotalSet && _apiMapResponse.containsKey('can_subtotal')) {
      _canSubtotal = _apiMapResponse['can_subtotal'];
      _canSubtotalSet = true;
    }
    return _canSubtotal;
  }

  set canSubtotal(bool v) {
    _canSubtotal = v;
    _canSubtotalSet = true;
  }

  /// Has timezone support (read-only)

  bool get hasTimezoneSupport {
    if (!_hasTimezoneSupportSet &&
        _apiMapResponse.containsKey('has_timezone_support')) {
      _hasTimezoneSupport = _apiMapResponse['has_timezone_support'];
      _hasTimezoneSupportSet = true;
    }
    return _hasTimezoneSupport;
  }

  set hasTimezoneSupport(bool v) {
    _hasTimezoneSupport = v;
    _hasTimezoneSupportSet = true;
  }

  /// Cost estimates supported (read-only)

  bool get supportsCostEstimate {
    if (!_supportsCostEstimateSet &&
        _apiMapResponse.containsKey('supports_cost_estimate')) {
      _supportsCostEstimate = _apiMapResponse['supports_cost_estimate'];
      _supportsCostEstimateSet = true;
    }
    return _supportsCostEstimate;
  }

  set supportsCostEstimate(bool v) {
    _supportsCostEstimate = v;
    _supportsCostEstimateSet = true;
  }

  /// Connection name (read-only)

  String get connectionName {
    if (!_connectionNameSet && _apiMapResponse.containsKey('connection_name')) {
      _connectionName = _apiMapResponse['connection_name']?.toString();
      _connectionNameSet = true;
    }
    return _connectionName;
  }

  set connectionName(String v) {
    _connectionName = v;
    _connectionNameSet = true;
  }

  /// How nulls are sorted, possible values are "low", "high", "first" and "last" (read-only)

  String get nullSortTreatment {
    if (!_nullSortTreatmentSet &&
        _apiMapResponse.containsKey('null_sort_treatment')) {
      _nullSortTreatment = _apiMapResponse['null_sort_treatment']?.toString();
      _nullSortTreatmentSet = true;
    }
    return _nullSortTreatment;
  }

  set nullSortTreatment(String v) {
    _nullSortTreatment = v;
    _nullSortTreatmentSet = true;
  }

  /// List of model source files (read-only)

  List<String> get files {
    if (!_filesSet && _apiMapResponse.containsKey('files')) {
      _files =
          _apiMapResponse['files']?.map<String>((i) => i as String)?.toList();
      _filesSet = true;
    }
    return _files;
  }

  set files(List<String> v) {
    _files = v;
    _filesSet = true;
  }

  /// Primary source_file file (read-only)

  String get sourceFile {
    if (!_sourceFileSet && _apiMapResponse.containsKey('source_file')) {
      _sourceFile = _apiMapResponse['source_file']?.toString();
      _sourceFileSet = true;
    }
    return _sourceFile;
  }

  set sourceFile(String v) {
    _sourceFile = v;
    _sourceFileSet = true;
  }

  /// Name of project (read-only)

  String get projectName {
    if (!_projectNameSet && _apiMapResponse.containsKey('project_name')) {
      _projectName = _apiMapResponse['project_name']?.toString();
      _projectNameSet = true;
    }
    return _projectName;
  }

  set projectName(String v) {
    _projectName = v;
    _projectNameSet = true;
  }

  /// Name of model (read-only)

  String get modelName {
    if (!_modelNameSet && _apiMapResponse.containsKey('model_name')) {
      _modelName = _apiMapResponse['model_name']?.toString();
      _modelNameSet = true;
    }
    return _modelName;
  }

  set modelName(String v) {
    _modelName = v;
    _modelNameSet = true;
  }

  /// Name of view (read-only)

  String get viewName {
    if (!_viewNameSet && _apiMapResponse.containsKey('view_name')) {
      _viewName = _apiMapResponse['view_name']?.toString();
      _viewNameSet = true;
    }
    return _viewName;
  }

  set viewName(String v) {
    _viewName = v;
    _viewNameSet = true;
  }

  /// Is hidden (read-only)

  bool get hidden {
    if (!_hiddenSet && _apiMapResponse.containsKey('hidden')) {
      _hidden = _apiMapResponse['hidden'];
      _hiddenSet = true;
    }
    return _hidden;
  }

  set hidden(bool v) {
    _hidden = v;
    _hiddenSet = true;
  }

  /// A sql_table_name expression that defines what sql table the view/explore maps onto. Example: "prod_orders2 AS orders" in a view named orders. (read-only)

  String get sqlTableName {
    if (!_sqlTableNameSet && _apiMapResponse.containsKey('sql_table_name')) {
      _sqlTableName = _apiMapResponse['sql_table_name']?.toString();
      _sqlTableNameSet = true;
    }
    return _sqlTableName;
  }

  set sqlTableName(String v) {
    _sqlTableName = v;
    _sqlTableNameSet = true;
  }

  /// (DEPRECATED) Array of access filter field names (read-only)

  List<String> get accessFilterFields {
    if (!_accessFilterFieldsSet &&
        _apiMapResponse.containsKey('access_filter_fields')) {
      _accessFilterFields = _apiMapResponse['access_filter_fields']
          ?.map<String>((i) => i as String)
          ?.toList();
      _accessFilterFieldsSet = true;
    }
    return _accessFilterFields;
  }

  set accessFilterFields(List<String> v) {
    _accessFilterFields = v;
    _accessFilterFieldsSet = true;
  }

  /// Access filters (read-only)

  List<LookmlModelExploreAccessFilter> get accessFilters {
    if (!_accessFiltersSet && _apiMapResponse.containsKey('access_filters')) {
      _accessFilters = _apiMapResponse['access_filters'] == null
          ? null
          : (_apiMapResponse['access_filters'] as List)
              .map((i) => LookmlModelExploreAccessFilter.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _accessFiltersSet = true;
    }
    return _accessFilters;
  }

  set accessFilters(List<LookmlModelExploreAccessFilter> v) {
    _accessFilters = v;
    _accessFiltersSet = true;
  }

  /// Aliases (read-only)

  List<LookmlModelExploreAlias> get aliases {
    if (!_aliasesSet && _apiMapResponse.containsKey('aliases')) {
      _aliases = _apiMapResponse['aliases'] == null
          ? null
          : (_apiMapResponse['aliases'] as List)
              .map((i) => LookmlModelExploreAlias.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _aliasesSet = true;
    }
    return _aliases;
  }

  set aliases(List<LookmlModelExploreAlias> v) {
    _aliases = v;
    _aliasesSet = true;
  }

  /// Always filter (read-only)

  List<LookmlModelExploreAlwaysFilter> get alwaysFilter {
    if (!_alwaysFilterSet && _apiMapResponse.containsKey('always_filter')) {
      _alwaysFilter = _apiMapResponse['always_filter'] == null
          ? null
          : (_apiMapResponse['always_filter'] as List)
              .map((i) => LookmlModelExploreAlwaysFilter.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _alwaysFilterSet = true;
    }
    return _alwaysFilter;
  }

  set alwaysFilter(List<LookmlModelExploreAlwaysFilter> v) {
    _alwaysFilter = v;
    _alwaysFilterSet = true;
  }

  /// Conditionally filter (read-only)

  List<LookmlModelExploreConditionallyFilter> get conditionallyFilter {
    if (!_conditionallyFilterSet &&
        _apiMapResponse.containsKey('conditionally_filter')) {
      _conditionallyFilter = _apiMapResponse['conditionally_filter'] == null
          ? null
          : (_apiMapResponse['conditionally_filter'] as List)
              .map((i) => LookmlModelExploreConditionallyFilter.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _conditionallyFilterSet = true;
    }
    return _conditionallyFilter;
  }

  set conditionallyFilter(List<LookmlModelExploreConditionallyFilter> v) {
    _conditionallyFilter = v;
    _conditionallyFilterSet = true;
  }

  /// Array of index fields (read-only)

  List<String> get indexFields {
    if (!_indexFieldsSet && _apiMapResponse.containsKey('index_fields')) {
      _indexFields = _apiMapResponse['index_fields']
          ?.map<String>((i) => i as String)
          ?.toList();
      _indexFieldsSet = true;
    }
    return _indexFields;
  }

  set indexFields(List<String> v) {
    _indexFields = v;
    _indexFieldsSet = true;
  }

  /// Sets (read-only)

  List<LookmlModelExploreSet> get sets {
    if (!_setsSet && _apiMapResponse.containsKey('sets')) {
      _sets = _apiMapResponse['sets'] == null
          ? null
          : (_apiMapResponse['sets'] as List)
              .map((i) =>
                  LookmlModelExploreSet.fromResponse(i, apiResponseContentType))
              .toList();
      _setsSet = true;
    }
    return _sets;
  }

  set sets(List<LookmlModelExploreSet> v) {
    _sets = v;
    _setsSet = true;
  }

  /// An array of arbitrary string tags provided in the model for this explore. (read-only)

  List<String> get tags {
    if (!_tagsSet && _apiMapResponse.containsKey('tags')) {
      _tags =
          _apiMapResponse['tags']?.map<String>((i) => i as String)?.toList();
      _tagsSet = true;
    }
    return _tags;
  }

  set tags(List<String> v) {
    _tags = v;
    _tagsSet = true;
  }

  /// Errors (read-only)

  List<LookmlModelExploreError> get errors {
    if (!_errorsSet && _apiMapResponse.containsKey('errors')) {
      _errors = _apiMapResponse['errors'] == null
          ? null
          : (_apiMapResponse['errors'] as List)
              .map((i) => LookmlModelExploreError.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _errorsSet = true;
    }
    return _errors;
  }

  set errors(List<LookmlModelExploreError> v) {
    _errors = v;
    _errorsSet = true;
  }

  LookmlModelExploreFieldset get fields {
    if (!_fieldsSet && _apiMapResponse.containsKey('fields')) {
      _fields = _apiMapResponse['fields'] == null
          ? null
          : LookmlModelExploreFieldset.fromResponse(
              _apiMapResponse['fields'], apiResponseContentType);
      _fieldsSet = true;
    }
    return _fields;
  }

  set fields(LookmlModelExploreFieldset v) {
    _fields = v;
    _fieldsSet = true;
  }

  /// Views joined into this explore (read-only)

  List<LookmlModelExploreJoins> get joins {
    if (!_joinsSet && _apiMapResponse.containsKey('joins')) {
      _joins = _apiMapResponse['joins'] == null
          ? null
          : (_apiMapResponse['joins'] as List)
              .map((i) => LookmlModelExploreJoins.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _joinsSet = true;
    }
    return _joins;
  }

  set joins(List<LookmlModelExploreJoins> v) {
    _joins = v;
    _joinsSet = true;
  }

  /// Label used to group explores in the navigation menus (read-only)

  String get groupLabel {
    if (!_groupLabelSet && _apiMapResponse.containsKey('group_label')) {
      _groupLabel = _apiMapResponse['group_label']?.toString();
      _groupLabelSet = true;
    }
    return _groupLabel;
  }

  set groupLabel(String v) {
    _groupLabel = v;
    _groupLabelSet = true;
  }

  /// An array of items describing which custom measure types are supported for creating a custom measure 'based_on' each possible dimension type. (read-only)

  List<LookmlModelExploreSupportedMeasureType> get supportedMeasureTypes {
    if (!_supportedMeasureTypesSet &&
        _apiMapResponse.containsKey('supported_measure_types')) {
      _supportedMeasureTypes = _apiMapResponse['supported_measure_types'] ==
              null
          ? null
          : (_apiMapResponse['supported_measure_types'] as List)
              .map((i) => LookmlModelExploreSupportedMeasureType.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _supportedMeasureTypesSet = true;
    }
    return _supportedMeasureTypes;
  }

  set supportedMeasureTypes(List<LookmlModelExploreSupportedMeasureType> v) {
    _supportedMeasureTypes = v;
    _supportedMeasureTypesSet = true;
  }

  /// An array of joins that will always be included in the SQL for this explore, even if the user has not selected a field from the joined view. (read-only)

  List<String> get alwaysJoin {
    if (!_alwaysJoinSet && _apiMapResponse.containsKey('always_join')) {
      _alwaysJoin = _apiMapResponse['always_join']
          ?.map<String>((i) => i as String)
          ?.toList();
      _alwaysJoinSet = true;
    }
    return _alwaysJoin;
  }

  set alwaysJoin(List<String> v) {
    _alwaysJoin = v;
    _alwaysJoinSet = true;
  }

  LookmlModelExplore() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlModelExplore.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_scopesSet || _apiMapResponse.containsKey('scopes')) {
      json['scopes'] = scopes;
    }
    if (_canTotalSet || _apiMapResponse.containsKey('can_total')) {
      json['can_total'] = canTotal;
    }
    if (_canDevelopSet || _apiMapResponse.containsKey('can_develop')) {
      json['can_develop'] = canDevelop;
    }
    if (_canSeeLookmlSet || _apiMapResponse.containsKey('can_see_lookml')) {
      json['can_see_lookml'] = canSeeLookml;
    }
    if (_lookmlLinkSet || _apiMapResponse.containsKey('lookml_link')) {
      json['lookml_link'] = lookmlLink;
    }
    if (_canSaveSet || _apiMapResponse.containsKey('can_save')) {
      json['can_save'] = canSave;
    }
    if (_canExplainSet || _apiMapResponse.containsKey('can_explain')) {
      json['can_explain'] = canExplain;
    }
    if (_canPivotInDbSet || _apiMapResponse.containsKey('can_pivot_in_db')) {
      json['can_pivot_in_db'] = canPivotInDb;
    }
    if (_canSubtotalSet || _apiMapResponse.containsKey('can_subtotal')) {
      json['can_subtotal'] = canSubtotal;
    }
    if (_hasTimezoneSupportSet ||
        _apiMapResponse.containsKey('has_timezone_support')) {
      json['has_timezone_support'] = hasTimezoneSupport;
    }
    if (_supportsCostEstimateSet ||
        _apiMapResponse.containsKey('supports_cost_estimate')) {
      json['supports_cost_estimate'] = supportsCostEstimate;
    }
    if (_connectionNameSet || _apiMapResponse.containsKey('connection_name')) {
      json['connection_name'] = connectionName;
    }
    if (_nullSortTreatmentSet ||
        _apiMapResponse.containsKey('null_sort_treatment')) {
      json['null_sort_treatment'] = nullSortTreatment;
    }
    if (_filesSet || _apiMapResponse.containsKey('files')) {
      json['files'] = files;
    }
    if (_sourceFileSet || _apiMapResponse.containsKey('source_file')) {
      json['source_file'] = sourceFile;
    }
    if (_projectNameSet || _apiMapResponse.containsKey('project_name')) {
      json['project_name'] = projectName;
    }
    if (_modelNameSet || _apiMapResponse.containsKey('model_name')) {
      json['model_name'] = modelName;
    }
    if (_viewNameSet || _apiMapResponse.containsKey('view_name')) {
      json['view_name'] = viewName;
    }
    if (_hiddenSet || _apiMapResponse.containsKey('hidden')) {
      json['hidden'] = hidden;
    }
    if (_sqlTableNameSet || _apiMapResponse.containsKey('sql_table_name')) {
      json['sql_table_name'] = sqlTableName;
    }
    if (_accessFilterFieldsSet ||
        _apiMapResponse.containsKey('access_filter_fields')) {
      json['access_filter_fields'] = accessFilterFields;
    }
    if (_accessFiltersSet || _apiMapResponse.containsKey('access_filters')) {
      json['access_filters'] = accessFilters?.map((i) => i.toJson())?.toList();
    }
    if (_aliasesSet || _apiMapResponse.containsKey('aliases')) {
      json['aliases'] = aliases?.map((i) => i.toJson())?.toList();
    }
    if (_alwaysFilterSet || _apiMapResponse.containsKey('always_filter')) {
      json['always_filter'] = alwaysFilter?.map((i) => i.toJson())?.toList();
    }
    if (_conditionallyFilterSet ||
        _apiMapResponse.containsKey('conditionally_filter')) {
      json['conditionally_filter'] =
          conditionallyFilter?.map((i) => i.toJson())?.toList();
    }
    if (_indexFieldsSet || _apiMapResponse.containsKey('index_fields')) {
      json['index_fields'] = indexFields;
    }
    if (_setsSet || _apiMapResponse.containsKey('sets')) {
      json['sets'] = sets?.map((i) => i.toJson())?.toList();
    }
    if (_tagsSet || _apiMapResponse.containsKey('tags')) {
      json['tags'] = tags;
    }
    if (_errorsSet || _apiMapResponse.containsKey('errors')) {
      json['errors'] = errors?.map((i) => i.toJson())?.toList();
    }
    if (_fieldsSet || _apiMapResponse.containsKey('fields')) {
      json['fields'] = fields?.toJson();
    }
    if (_joinsSet || _apiMapResponse.containsKey('joins')) {
      json['joins'] = joins?.map((i) => i.toJson())?.toList();
    }
    if (_groupLabelSet || _apiMapResponse.containsKey('group_label')) {
      json['group_label'] = groupLabel;
    }
    if (_supportedMeasureTypesSet ||
        _apiMapResponse.containsKey('supported_measure_types')) {
      json['supported_measure_types'] =
          supportedMeasureTypes?.map((i) => i.toJson())?.toList();
    }
    if (_alwaysJoinSet || _apiMapResponse.containsKey('always_join')) {
      json['always_join'] = alwaysJoin;
    }
    return json;
  }
}

class LookmlModelExploreAccessFilter {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _field;
  bool _fieldSet = false;

  String _userAttribute;
  bool _userAttributeSet = false;

  /// Field to be filtered (read-only)

  String get field {
    if (!_fieldSet && _apiMapResponse.containsKey('field')) {
      _field = _apiMapResponse['field']?.toString();
      _fieldSet = true;
    }
    return _field;
  }

  set field(String v) {
    _field = v;
    _fieldSet = true;
  }

  /// User attribute name (read-only)

  String get userAttribute {
    if (!_userAttributeSet && _apiMapResponse.containsKey('user_attribute')) {
      _userAttribute = _apiMapResponse['user_attribute']?.toString();
      _userAttributeSet = true;
    }
    return _userAttribute;
  }

  set userAttribute(String v) {
    _userAttribute = v;
    _userAttributeSet = true;
  }

  LookmlModelExploreAccessFilter() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlModelExploreAccessFilter.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_fieldSet || _apiMapResponse.containsKey('field')) {
      json['field'] = field;
    }
    if (_userAttributeSet || _apiMapResponse.containsKey('user_attribute')) {
      json['user_attribute'] = userAttribute;
    }
    return json;
  }
}

class LookmlModelExploreAlias {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _value;
  bool _valueSet = false;

  /// Name (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Value (read-only)

  String get value {
    if (!_valueSet && _apiMapResponse.containsKey('value')) {
      _value = _apiMapResponse['value']?.toString();
      _valueSet = true;
    }
    return _value;
  }

  set value(String v) {
    _value = v;
    _valueSet = true;
  }

  LookmlModelExploreAlias() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlModelExploreAlias.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_valueSet || _apiMapResponse.containsKey('value')) {
      json['value'] = value;
    }
    return json;
  }
}

class LookmlModelExploreAlwaysFilter {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _value;
  bool _valueSet = false;

  /// Name (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Value (read-only)

  String get value {
    if (!_valueSet && _apiMapResponse.containsKey('value')) {
      _value = _apiMapResponse['value']?.toString();
      _valueSet = true;
    }
    return _value;
  }

  set value(String v) {
    _value = v;
    _valueSet = true;
  }

  LookmlModelExploreAlwaysFilter() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlModelExploreAlwaysFilter.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_valueSet || _apiMapResponse.containsKey('value')) {
      json['value'] = value;
    }
    return json;
  }
}

class LookmlModelExploreConditionallyFilter {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _value;
  bool _valueSet = false;

  /// Name (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Value (read-only)

  String get value {
    if (!_valueSet && _apiMapResponse.containsKey('value')) {
      _value = _apiMapResponse['value']?.toString();
      _valueSet = true;
    }
    return _value;
  }

  set value(String v) {
    _value = v;
    _valueSet = true;
  }

  LookmlModelExploreConditionallyFilter() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlModelExploreConditionallyFilter.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_valueSet || _apiMapResponse.containsKey('value')) {
      json['value'] = value;
    }
    return json;
  }
}

class LookmlModelExploreError {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _message;
  bool _messageSet = false;

  dynamic _details;
  bool _detailsSet = false;

  String _errorPos;
  bool _errorPosSet = false;

  bool _fieldError;
  bool _fieldErrorSet = false;

  /// Error Message (read-only)

  String get message {
    if (!_messageSet && _apiMapResponse.containsKey('message')) {
      _message = _apiMapResponse['message']?.toString();
      _messageSet = true;
    }
    return _message;
  }

  set message(String v) {
    _message = v;
    _messageSet = true;
  }

  /// Details (read-only)

  dynamic get details {
    if (!_detailsSet && _apiMapResponse.containsKey('details')) {
      _details = _apiMapResponse['details'];
      _detailsSet = true;
    }
    return _details;
  }

  set details(dynamic v) {
    _details = v;
    _detailsSet = true;
  }

  /// Error source location (read-only)

  String get errorPos {
    if (!_errorPosSet && _apiMapResponse.containsKey('error_pos')) {
      _errorPos = _apiMapResponse['error_pos']?.toString();
      _errorPosSet = true;
    }
    return _errorPos;
  }

  set errorPos(String v) {
    _errorPos = v;
    _errorPosSet = true;
  }

  /// Is this a field error (read-only)

  bool get fieldError {
    if (!_fieldErrorSet && _apiMapResponse.containsKey('field_error')) {
      _fieldError = _apiMapResponse['field_error'];
      _fieldErrorSet = true;
    }
    return _fieldError;
  }

  set fieldError(bool v) {
    _fieldError = v;
    _fieldErrorSet = true;
  }

  LookmlModelExploreError() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlModelExploreError.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_messageSet || _apiMapResponse.containsKey('message')) {
      json['message'] = message;
    }
    if (_detailsSet || _apiMapResponse.containsKey('details')) {
      json['details'] = details;
    }
    if (_errorPosSet || _apiMapResponse.containsKey('error_pos')) {
      json['error_pos'] = errorPos;
    }
    if (_fieldErrorSet || _apiMapResponse.containsKey('field_error')) {
      json['field_error'] = fieldError;
    }
    return json;
  }
}

class LookmlModelExploreField {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Align _align;
  bool _alignSet = false;

  bool _canFilter;
  bool _canFilterSet = false;

  Category _category;
  bool _categorySet = false;

  String _defaultFilterValue;
  bool _defaultFilterValueSet = false;

  String _description;
  bool _descriptionSet = false;

  String _dimensionGroup;
  bool _dimensionGroupSet = false;

  List<LookmlModelExploreFieldEnumeration> _enumerations;
  bool _enumerationsSet = false;

  String _error;
  bool _errorSet = false;

  String _fieldGroupLabel;
  bool _fieldGroupLabelSet = false;

  String _fieldGroupVariant;
  bool _fieldGroupVariantSet = false;

  FillStyle _fillStyle;
  bool _fillStyleSet = false;

  int _fiscalMonthOffset;
  bool _fiscalMonthOffsetSet = false;

  bool _hasAllowedValues;
  bool _hasAllowedValuesSet = false;

  bool _hidden;
  bool _hiddenSet = false;

  bool _isFilter;
  bool _isFilterSet = false;

  bool _isFiscal;
  bool _isFiscalSet = false;

  bool _isNumeric;
  bool _isNumericSet = false;

  bool _isTimeframe;
  bool _isTimeframeSet = false;

  bool _canTimeFilter;
  bool _canTimeFilterSet = false;

  LookmlModelExploreFieldTimeInterval _timeInterval;
  bool _timeIntervalSet = false;

  String _label;
  bool _labelSet = false;

  String _labelFromParameter;
  bool _labelFromParameterSet = false;

  String _labelShort;
  bool _labelShortSet = false;

  String _lookmlLink;
  bool _lookmlLinkSet = false;

  LookmlModelExploreFieldMapLayer _mapLayer;
  bool _mapLayerSet = false;

  bool _measure;
  bool _measureSet = false;

  String _name;
  bool _nameSet = false;

  bool _strictValueFormat;
  bool _strictValueFormatSet = false;

  bool _parameter;
  bool _parameterSet = false;

  bool _permanent;
  bool _permanentSet = false;

  bool _primaryKey;
  bool _primaryKeySet = false;

  String _projectName;
  bool _projectNameSet = false;

  bool _requiresRefreshOnSort;
  bool _requiresRefreshOnSortSet = false;

  String _scope;
  bool _scopeSet = false;

  bool _sortable;
  bool _sortableSet = false;

  String _sourceFile;
  bool _sourceFileSet = false;

  String _sourceFilePath;
  bool _sourceFilePathSet = false;

  String _sql;
  bool _sqlSet = false;

  List<LookmlModelExploreFieldSqlCase> _sqlCase;
  bool _sqlCaseSet = false;

  List<LookmlModelExploreFieldMeasureFilters> _filters;
  bool _filtersSet = false;

  String _suggestDimension;
  bool _suggestDimensionSet = false;

  String _suggestExplore;
  bool _suggestExploreSet = false;

  bool _suggestable;
  bool _suggestableSet = false;

  List<String> _suggestions;
  bool _suggestionsSet = false;

  List<String> _tags;
  bool _tagsSet = false;

  String _type;
  bool _typeSet = false;

  List<UserAttributeFilterTypes> _userAttributeFilterTypes;
  bool _userAttributeFilterTypesSet = false;

  String _valueFormat;
  bool _valueFormatSet = false;

  String _view;
  bool _viewSet = false;

  String _viewLabel;
  bool _viewLabelSet = false;

  bool _dynamic;
  bool _dynamicSet = false;

  WeekStartDay _weekStartDay;
  bool _weekStartDaySet = false;

  int _timesUsed;
  bool _timesUsedSet = false;

  String _originalView;
  bool _originalViewSet = false;

  /// The appropriate horizontal text alignment the values of this field should be displayed in. Valid values are: "left", "right". (read-only)

  Align get align {
    if (!_alignSet && _apiMapResponse.containsKey('align')) {
      _align = AlignMapper.fromStringValue(_apiMapResponse['align']);
      _alignSet = true;
    }
    return _align;
  }

  set align(Align v) {
    _align = v;
    _alignSet = true;
  }

  /// Whether it's possible to filter on this field. (read-only)

  bool get canFilter {
    if (!_canFilterSet && _apiMapResponse.containsKey('can_filter')) {
      _canFilter = _apiMapResponse['can_filter'];
      _canFilterSet = true;
    }
    return _canFilter;
  }

  set canFilter(bool v) {
    _canFilter = v;
    _canFilterSet = true;
  }

  /// Field category Valid values are: "parameter", "filter", "measure", "dimension". (read-only)

  Category get category {
    if (!_categorySet && _apiMapResponse.containsKey('category')) {
      _category = CategoryMapper.fromStringValue(_apiMapResponse['category']);
      _categorySet = true;
    }
    return _category;
  }

  set category(Category v) {
    _category = v;
    _categorySet = true;
  }

  /// The default value that this field uses when filtering. Null if there is no default value. (read-only)

  String get defaultFilterValue {
    if (!_defaultFilterValueSet &&
        _apiMapResponse.containsKey('default_filter_value')) {
      _defaultFilterValue = _apiMapResponse['default_filter_value']?.toString();
      _defaultFilterValueSet = true;
    }
    return _defaultFilterValue;
  }

  set defaultFilterValue(String v) {
    _defaultFilterValue = v;
    _defaultFilterValueSet = true;
  }

  /// Description (read-only)

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Dimension group if this field is part of a dimension group. If not, this will be null. (read-only)

  String get dimensionGroup {
    if (!_dimensionGroupSet && _apiMapResponse.containsKey('dimension_group')) {
      _dimensionGroup = _apiMapResponse['dimension_group']?.toString();
      _dimensionGroupSet = true;
    }
    return _dimensionGroup;
  }

  set dimensionGroup(String v) {
    _dimensionGroup = v;
    _dimensionGroupSet = true;
  }

  /// An array enumerating all the possible values that this field can contain. When null, there is no limit to the set of possible values this field can contain. (read-only)

  List<LookmlModelExploreFieldEnumeration> get enumerations {
    if (!_enumerationsSet && _apiMapResponse.containsKey('enumerations')) {
      _enumerations = _apiMapResponse['enumerations'] == null
          ? null
          : (_apiMapResponse['enumerations'] as List)
              .map((i) => LookmlModelExploreFieldEnumeration.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _enumerationsSet = true;
    }
    return _enumerations;
  }

  set enumerations(List<LookmlModelExploreFieldEnumeration> v) {
    _enumerations = v;
    _enumerationsSet = true;
  }

  /// An error message indicating a problem with the definition of this field. If there are no errors, this will be null. (read-only)

  String get error {
    if (!_errorSet && _apiMapResponse.containsKey('error')) {
      _error = _apiMapResponse['error']?.toString();
      _errorSet = true;
    }
    return _error;
  }

  set error(String v) {
    _error = v;
    _errorSet = true;
  }

  /// A label creating a grouping of fields. All fields with this label should be presented together when displayed in a UI. (read-only)

  String get fieldGroupLabel {
    if (!_fieldGroupLabelSet &&
        _apiMapResponse.containsKey('field_group_label')) {
      _fieldGroupLabel = _apiMapResponse['field_group_label']?.toString();
      _fieldGroupLabelSet = true;
    }
    return _fieldGroupLabel;
  }

  set fieldGroupLabel(String v) {
    _fieldGroupLabel = v;
    _fieldGroupLabelSet = true;
  }

  /// When presented in a field group via field_group_label, a shorter name of the field to be displayed in that context. (read-only)

  String get fieldGroupVariant {
    if (!_fieldGroupVariantSet &&
        _apiMapResponse.containsKey('field_group_variant')) {
      _fieldGroupVariant = _apiMapResponse['field_group_variant']?.toString();
      _fieldGroupVariantSet = true;
    }
    return _fieldGroupVariant;
  }

  set fieldGroupVariant(String v) {
    _fieldGroupVariant = v;
    _fieldGroupVariantSet = true;
  }

  /// The style of dimension fill that is possible for this field. Null if no dimension fill is possible. Valid values are: "enumeration", "range". (read-only)

  FillStyle get fillStyle {
    if (!_fillStyleSet && _apiMapResponse.containsKey('fill_style')) {
      _fillStyle =
          FillStyleMapper.fromStringValue(_apiMapResponse['fill_style']);
      _fillStyleSet = true;
    }
    return _fillStyle;
  }

  set fillStyle(FillStyle v) {
    _fillStyle = v;
    _fillStyleSet = true;
  }

  /// An offset (in months) from the calendar start month to the fiscal start month defined in the LookML model this field belongs to. (read-only)

  int get fiscalMonthOffset {
    if (!_fiscalMonthOffsetSet &&
        _apiMapResponse.containsKey('fiscal_month_offset')) {
      _fiscalMonthOffset = _apiMapResponse['fiscal_month_offset'];
      _fiscalMonthOffsetSet = true;
    }
    return _fiscalMonthOffset;
  }

  set fiscalMonthOffset(int v) {
    _fiscalMonthOffset = v;
    _fiscalMonthOffsetSet = true;
  }

  /// Whether this field has a set of allowed_values specified in LookML. (read-only)

  bool get hasAllowedValues {
    if (!_hasAllowedValuesSet &&
        _apiMapResponse.containsKey('has_allowed_values')) {
      _hasAllowedValues = _apiMapResponse['has_allowed_values'];
      _hasAllowedValuesSet = true;
    }
    return _hasAllowedValues;
  }

  set hasAllowedValues(bool v) {
    _hasAllowedValues = v;
    _hasAllowedValuesSet = true;
  }

  /// Whether this field should be hidden from the user interface. (read-only)

  bool get hidden {
    if (!_hiddenSet && _apiMapResponse.containsKey('hidden')) {
      _hidden = _apiMapResponse['hidden'];
      _hiddenSet = true;
    }
    return _hidden;
  }

  set hidden(bool v) {
    _hidden = v;
    _hiddenSet = true;
  }

  /// Whether this field is a filter. (read-only)

  bool get isFilter {
    if (!_isFilterSet && _apiMapResponse.containsKey('is_filter')) {
      _isFilter = _apiMapResponse['is_filter'];
      _isFilterSet = true;
    }
    return _isFilter;
  }

  set isFilter(bool v) {
    _isFilter = v;
    _isFilterSet = true;
  }

  /// Whether this field represents a fiscal time value. (read-only)

  bool get isFiscal {
    if (!_isFiscalSet && _apiMapResponse.containsKey('is_fiscal')) {
      _isFiscal = _apiMapResponse['is_fiscal'];
      _isFiscalSet = true;
    }
    return _isFiscal;
  }

  set isFiscal(bool v) {
    _isFiscal = v;
    _isFiscalSet = true;
  }

  /// Whether this field is of a type that represents a numeric value. (read-only)

  bool get isNumeric {
    if (!_isNumericSet && _apiMapResponse.containsKey('is_numeric')) {
      _isNumeric = _apiMapResponse['is_numeric'];
      _isNumericSet = true;
    }
    return _isNumeric;
  }

  set isNumeric(bool v) {
    _isNumeric = v;
    _isNumericSet = true;
  }

  /// Whether this field is of a type that represents a time value. (read-only)

  bool get isTimeframe {
    if (!_isTimeframeSet && _apiMapResponse.containsKey('is_timeframe')) {
      _isTimeframe = _apiMapResponse['is_timeframe'];
      _isTimeframeSet = true;
    }
    return _isTimeframe;
  }

  set isTimeframe(bool v) {
    _isTimeframe = v;
    _isTimeframeSet = true;
  }

  /// Whether this field can be time filtered. (read-only)

  bool get canTimeFilter {
    if (!_canTimeFilterSet && _apiMapResponse.containsKey('can_time_filter')) {
      _canTimeFilter = _apiMapResponse['can_time_filter'];
      _canTimeFilterSet = true;
    }
    return _canTimeFilter;
  }

  set canTimeFilter(bool v) {
    _canTimeFilter = v;
    _canTimeFilterSet = true;
  }

  LookmlModelExploreFieldTimeInterval get timeInterval {
    if (!_timeIntervalSet && _apiMapResponse.containsKey('time_interval')) {
      _timeInterval = _apiMapResponse['time_interval'] == null
          ? null
          : LookmlModelExploreFieldTimeInterval.fromResponse(
              _apiMapResponse['time_interval'], apiResponseContentType);
      _timeIntervalSet = true;
    }
    return _timeInterval;
  }

  set timeInterval(LookmlModelExploreFieldTimeInterval v) {
    _timeInterval = v;
    _timeIntervalSet = true;
  }

  /// Fully-qualified human-readable label of the field. (read-only)

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// The name of the parameter that will provide a parameterized label for this field, if available in the current context. (read-only)

  String get labelFromParameter {
    if (!_labelFromParameterSet &&
        _apiMapResponse.containsKey('label_from_parameter')) {
      _labelFromParameter = _apiMapResponse['label_from_parameter']?.toString();
      _labelFromParameterSet = true;
    }
    return _labelFromParameter;
  }

  set labelFromParameter(String v) {
    _labelFromParameter = v;
    _labelFromParameterSet = true;
  }

  /// The human-readable label of the field, without the view label. (read-only)

  String get labelShort {
    if (!_labelShortSet && _apiMapResponse.containsKey('label_short')) {
      _labelShort = _apiMapResponse['label_short']?.toString();
      _labelShortSet = true;
    }
    return _labelShort;
  }

  set labelShort(String v) {
    _labelShort = v;
    _labelShortSet = true;
  }

  /// A URL linking to the definition of this field in the LookML IDE. (read-only)

  String get lookmlLink {
    if (!_lookmlLinkSet && _apiMapResponse.containsKey('lookml_link')) {
      _lookmlLink = _apiMapResponse['lookml_link']?.toString();
      _lookmlLinkSet = true;
    }
    return _lookmlLink;
  }

  set lookmlLink(String v) {
    _lookmlLink = v;
    _lookmlLinkSet = true;
  }

  LookmlModelExploreFieldMapLayer get mapLayer {
    if (!_mapLayerSet && _apiMapResponse.containsKey('map_layer')) {
      _mapLayer = _apiMapResponse['map_layer'] == null
          ? null
          : LookmlModelExploreFieldMapLayer.fromResponse(
              _apiMapResponse['map_layer'], apiResponseContentType);
      _mapLayerSet = true;
    }
    return _mapLayer;
  }

  set mapLayer(LookmlModelExploreFieldMapLayer v) {
    _mapLayer = v;
    _mapLayerSet = true;
  }

  /// Whether this field is a measure. (read-only)

  bool get measure {
    if (!_measureSet && _apiMapResponse.containsKey('measure')) {
      _measure = _apiMapResponse['measure'];
      _measureSet = true;
    }
    return _measure;
  }

  set measure(bool v) {
    _measure = v;
    _measureSet = true;
  }

  /// Fully-qualified name of the field. (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// If yes, the field will not be localized with the user attribute number_format. Defaults to no (read-only)

  bool get strictValueFormat {
    if (!_strictValueFormatSet &&
        _apiMapResponse.containsKey('strict_value_format')) {
      _strictValueFormat = _apiMapResponse['strict_value_format'];
      _strictValueFormatSet = true;
    }
    return _strictValueFormat;
  }

  set strictValueFormat(bool v) {
    _strictValueFormat = v;
    _strictValueFormatSet = true;
  }

  /// Whether this field is a parameter. (read-only)

  bool get parameter {
    if (!_parameterSet && _apiMapResponse.containsKey('parameter')) {
      _parameter = _apiMapResponse['parameter'];
      _parameterSet = true;
    }
    return _parameter;
  }

  set parameter(bool v) {
    _parameter = v;
    _parameterSet = true;
  }

  /// Whether this field can be removed from a query. (read-only)

  bool get permanent {
    if (!_permanentSet && _apiMapResponse.containsKey('permanent')) {
      _permanent = _apiMapResponse['permanent'];
      _permanentSet = true;
    }
    return _permanent;
  }

  set permanent(bool v) {
    _permanent = v;
    _permanentSet = true;
  }

  /// Whether or not the field represents a primary key. (read-only)

  bool get primaryKey {
    if (!_primaryKeySet && _apiMapResponse.containsKey('primary_key')) {
      _primaryKey = _apiMapResponse['primary_key'];
      _primaryKeySet = true;
    }
    return _primaryKey;
  }

  set primaryKey(bool v) {
    _primaryKey = v;
    _primaryKeySet = true;
  }

  /// The name of the project this field is defined in. (read-only)

  String get projectName {
    if (!_projectNameSet && _apiMapResponse.containsKey('project_name')) {
      _projectName = _apiMapResponse['project_name']?.toString();
      _projectNameSet = true;
    }
    return _projectName;
  }

  set projectName(String v) {
    _projectName = v;
    _projectNameSet = true;
  }

  /// When true, it's not possible to re-sort this field's values without re-running the SQL query, due to database logic that affects the sort. (read-only)

  bool get requiresRefreshOnSort {
    if (!_requiresRefreshOnSortSet &&
        _apiMapResponse.containsKey('requires_refresh_on_sort')) {
      _requiresRefreshOnSort = _apiMapResponse['requires_refresh_on_sort'];
      _requiresRefreshOnSortSet = true;
    }
    return _requiresRefreshOnSort;
  }

  set requiresRefreshOnSort(bool v) {
    _requiresRefreshOnSort = v;
    _requiresRefreshOnSortSet = true;
  }

  /// The LookML scope this field belongs to. The scope is typically the field's view. (read-only)

  String get scope {
    if (!_scopeSet && _apiMapResponse.containsKey('scope')) {
      _scope = _apiMapResponse['scope']?.toString();
      _scopeSet = true;
    }
    return _scope;
  }

  set scope(String v) {
    _scope = v;
    _scopeSet = true;
  }

  /// Whether this field can be sorted. (read-only)

  bool get sortable {
    if (!_sortableSet && _apiMapResponse.containsKey('sortable')) {
      _sortable = _apiMapResponse['sortable'];
      _sortableSet = true;
    }
    return _sortable;
  }

  set sortable(bool v) {
    _sortable = v;
    _sortableSet = true;
  }

  /// The path portion of source_file_path. (read-only)

  String get sourceFile {
    if (!_sourceFileSet && _apiMapResponse.containsKey('source_file')) {
      _sourceFile = _apiMapResponse['source_file']?.toString();
      _sourceFileSet = true;
    }
    return _sourceFile;
  }

  set sourceFile(String v) {
    _sourceFile = v;
    _sourceFileSet = true;
  }

  /// The fully-qualified path of the project file this field is defined in. (read-only)

  String get sourceFilePath {
    if (!_sourceFilePathSet &&
        _apiMapResponse.containsKey('source_file_path')) {
      _sourceFilePath = _apiMapResponse['source_file_path']?.toString();
      _sourceFilePathSet = true;
    }
    return _sourceFilePath;
  }

  set sourceFilePath(String v) {
    _sourceFilePath = v;
    _sourceFilePathSet = true;
  }

  /// SQL expression as defined in the LookML model. The SQL syntax shown here is a representation intended for auditability, and is not neccessarily an exact match for what will ultimately be run in the database. It may contain special LookML syntax or annotations that are not valid SQL. This will be null if the current user does not have the see_lookml permission for the field's model. (read-only)

  String get sql {
    if (!_sqlSet && _apiMapResponse.containsKey('sql')) {
      _sql = _apiMapResponse['sql']?.toString();
      _sqlSet = true;
    }
    return _sql;
  }

  set sql(String v) {
    _sql = v;
    _sqlSet = true;
  }

  /// An array of conditions and values that make up a SQL Case expression, as defined in the LookML model. The SQL syntax shown here is a representation intended for auditability, and is not neccessarily an exact match for what will ultimately be run in the database. It may contain special LookML syntax or annotations that are not valid SQL. This will be null if the current user does not have the see_lookml permission for the field's model. (read-only)

  List<LookmlModelExploreFieldSqlCase> get sqlCase {
    if (!_sqlCaseSet && _apiMapResponse.containsKey('sql_case')) {
      _sqlCase = _apiMapResponse['sql_case'] == null
          ? null
          : (_apiMapResponse['sql_case'] as List)
              .map((i) => LookmlModelExploreFieldSqlCase.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _sqlCaseSet = true;
    }
    return _sqlCase;
  }

  set sqlCase(List<LookmlModelExploreFieldSqlCase> v) {
    _sqlCase = v;
    _sqlCaseSet = true;
  }

  /// Array of filter conditions defined for the measure in LookML. (read-only)

  List<LookmlModelExploreFieldMeasureFilters> get filters {
    if (!_filtersSet && _apiMapResponse.containsKey('filters')) {
      _filters = _apiMapResponse['filters'] == null
          ? null
          : (_apiMapResponse['filters'] as List)
              .map((i) => LookmlModelExploreFieldMeasureFilters.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _filtersSet = true;
    }
    return _filters;
  }

  set filters(List<LookmlModelExploreFieldMeasureFilters> v) {
    _filters = v;
    _filtersSet = true;
  }

  /// The name of the dimension to base suggest queries from. (read-only)

  String get suggestDimension {
    if (!_suggestDimensionSet &&
        _apiMapResponse.containsKey('suggest_dimension')) {
      _suggestDimension = _apiMapResponse['suggest_dimension']?.toString();
      _suggestDimensionSet = true;
    }
    return _suggestDimension;
  }

  set suggestDimension(String v) {
    _suggestDimension = v;
    _suggestDimensionSet = true;
  }

  /// The name of the explore to base suggest queries from. (read-only)

  String get suggestExplore {
    if (!_suggestExploreSet && _apiMapResponse.containsKey('suggest_explore')) {
      _suggestExplore = _apiMapResponse['suggest_explore']?.toString();
      _suggestExploreSet = true;
    }
    return _suggestExplore;
  }

  set suggestExplore(String v) {
    _suggestExplore = v;
    _suggestExploreSet = true;
  }

  /// Whether or not suggestions are possible for this field. (read-only)

  bool get suggestable {
    if (!_suggestableSet && _apiMapResponse.containsKey('suggestable')) {
      _suggestable = _apiMapResponse['suggestable'];
      _suggestableSet = true;
    }
    return _suggestable;
  }

  set suggestable(bool v) {
    _suggestable = v;
    _suggestableSet = true;
  }

  /// If available, a list of suggestions for this field. For most fields, a suggest query is a more appropriate way to get an up-to-date list of suggestions. Or use enumerations to list all the possible values. (read-only)

  List<String> get suggestions {
    if (!_suggestionsSet && _apiMapResponse.containsKey('suggestions')) {
      _suggestions = _apiMapResponse['suggestions']
          ?.map<String>((i) => i as String)
          ?.toList();
      _suggestionsSet = true;
    }
    return _suggestions;
  }

  set suggestions(List<String> v) {
    _suggestions = v;
    _suggestionsSet = true;
  }

  /// An array of arbitrary string tags provided in the model for this field. (read-only)

  List<String> get tags {
    if (!_tagsSet && _apiMapResponse.containsKey('tags')) {
      _tags =
          _apiMapResponse['tags']?.map<String>((i) => i as String)?.toList();
      _tagsSet = true;
    }
    return _tags;
  }

  set tags(List<String> v) {
    _tags = v;
    _tagsSet = true;
  }

  /// The LookML type of the field. (read-only)

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// An array of user attribute types that are allowed to be used in filters on this field. Valid values are: "advanced_filter_string", "advanced_filter_number", "advanced_filter_datetime", "string", "number", "datetime", "relative_url", "yesno", "zipcode". (read-only)

  List<UserAttributeFilterTypes> get userAttributeFilterTypes {
    if (!_userAttributeFilterTypesSet &&
        _apiMapResponse.containsKey('user_attribute_filter_types')) {
      _userAttributeFilterTypes = _apiMapResponse['user_attribute_filter_types']
          ?.map<UserAttributeFilterTypes>((i) => i as UserAttributeFilterTypes)
          ?.toList();
      _userAttributeFilterTypesSet = true;
    }
    return _userAttributeFilterTypes;
  }

  set userAttributeFilterTypes(List<UserAttributeFilterTypes> v) {
    _userAttributeFilterTypes = v;
    _userAttributeFilterTypesSet = true;
  }

  /// If specified, the LookML value format string for formatting values of this field. (read-only)

  String get valueFormat {
    if (!_valueFormatSet && _apiMapResponse.containsKey('value_format')) {
      _valueFormat = _apiMapResponse['value_format']?.toString();
      _valueFormatSet = true;
    }
    return _valueFormat;
  }

  set valueFormat(String v) {
    _valueFormat = v;
    _valueFormatSet = true;
  }

  /// The name of the view this field belongs to. (read-only)

  String get view {
    if (!_viewSet && _apiMapResponse.containsKey('view')) {
      _view = _apiMapResponse['view']?.toString();
      _viewSet = true;
    }
    return _view;
  }

  set view(String v) {
    _view = v;
    _viewSet = true;
  }

  /// The human-readable label of the view the field belongs to. (read-only)

  String get viewLabel {
    if (!_viewLabelSet && _apiMapResponse.containsKey('view_label')) {
      _viewLabel = _apiMapResponse['view_label']?.toString();
      _viewLabelSet = true;
    }
    return _viewLabel;
  }

  set viewLabel(String v) {
    _viewLabel = v;
    _viewLabelSet = true;
  }

  /// Whether this field was specified in "dynamic_fields" and is not part of the model. (read-only)

  bool get dynamic {
    if (!_dynamicSet && _apiMapResponse.containsKey('dynamic')) {
      _dynamic = _apiMapResponse['dynamic'];
      _dynamicSet = true;
    }
    return _dynamic;
  }

  set dynamic(bool v) {
    _dynamic = v;
    _dynamicSet = true;
  }

  /// The name of the starting day of the week. Valid values are: "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday". (read-only)

  WeekStartDay get weekStartDay {
    if (!_weekStartDaySet && _apiMapResponse.containsKey('week_start_day')) {
      _weekStartDay =
          WeekStartDayMapper.fromStringValue(_apiMapResponse['week_start_day']);
      _weekStartDaySet = true;
    }
    return _weekStartDay;
  }

  set weekStartDay(WeekStartDay v) {
    _weekStartDay = v;
    _weekStartDaySet = true;
  }

  /// The number of times this field has been used in queries (read-only)

  int get timesUsed {
    if (!_timesUsedSet && _apiMapResponse.containsKey('times_used')) {
      _timesUsed = _apiMapResponse['times_used'];
      _timesUsedSet = true;
    }
    return _timesUsed;
  }

  set timesUsed(int v) {
    _timesUsed = v;
    _timesUsedSet = true;
  }

  /// The name of the view this field is defined in. This will be different than "view" when the view has been joined via a different name using the "from" parameter. (read-only)

  String get originalView {
    if (!_originalViewSet && _apiMapResponse.containsKey('original_view')) {
      _originalView = _apiMapResponse['original_view']?.toString();
      _originalViewSet = true;
    }
    return _originalView;
  }

  set originalView(String v) {
    _originalView = v;
    _originalViewSet = true;
  }

  LookmlModelExploreField() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlModelExploreField.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_alignSet || _apiMapResponse.containsKey('align')) {
      json['align'] = AlignMapper.toStringValue(align);
    }
    if (_canFilterSet || _apiMapResponse.containsKey('can_filter')) {
      json['can_filter'] = canFilter;
    }
    if (_categorySet || _apiMapResponse.containsKey('category')) {
      json['category'] = CategoryMapper.toStringValue(category);
    }
    if (_defaultFilterValueSet ||
        _apiMapResponse.containsKey('default_filter_value')) {
      json['default_filter_value'] = defaultFilterValue;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_dimensionGroupSet || _apiMapResponse.containsKey('dimension_group')) {
      json['dimension_group'] = dimensionGroup;
    }
    if (_enumerationsSet || _apiMapResponse.containsKey('enumerations')) {
      json['enumerations'] = enumerations?.map((i) => i.toJson())?.toList();
    }
    if (_errorSet || _apiMapResponse.containsKey('error')) {
      json['error'] = error;
    }
    if (_fieldGroupLabelSet ||
        _apiMapResponse.containsKey('field_group_label')) {
      json['field_group_label'] = fieldGroupLabel;
    }
    if (_fieldGroupVariantSet ||
        _apiMapResponse.containsKey('field_group_variant')) {
      json['field_group_variant'] = fieldGroupVariant;
    }
    if (_fillStyleSet || _apiMapResponse.containsKey('fill_style')) {
      json['fill_style'] = FillStyleMapper.toStringValue(fillStyle);
    }
    if (_fiscalMonthOffsetSet ||
        _apiMapResponse.containsKey('fiscal_month_offset')) {
      json['fiscal_month_offset'] = fiscalMonthOffset;
    }
    if (_hasAllowedValuesSet ||
        _apiMapResponse.containsKey('has_allowed_values')) {
      json['has_allowed_values'] = hasAllowedValues;
    }
    if (_hiddenSet || _apiMapResponse.containsKey('hidden')) {
      json['hidden'] = hidden;
    }
    if (_isFilterSet || _apiMapResponse.containsKey('is_filter')) {
      json['is_filter'] = isFilter;
    }
    if (_isFiscalSet || _apiMapResponse.containsKey('is_fiscal')) {
      json['is_fiscal'] = isFiscal;
    }
    if (_isNumericSet || _apiMapResponse.containsKey('is_numeric')) {
      json['is_numeric'] = isNumeric;
    }
    if (_isTimeframeSet || _apiMapResponse.containsKey('is_timeframe')) {
      json['is_timeframe'] = isTimeframe;
    }
    if (_canTimeFilterSet || _apiMapResponse.containsKey('can_time_filter')) {
      json['can_time_filter'] = canTimeFilter;
    }
    if (_timeIntervalSet || _apiMapResponse.containsKey('time_interval')) {
      json['time_interval'] = timeInterval?.toJson();
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_labelFromParameterSet ||
        _apiMapResponse.containsKey('label_from_parameter')) {
      json['label_from_parameter'] = labelFromParameter;
    }
    if (_labelShortSet || _apiMapResponse.containsKey('label_short')) {
      json['label_short'] = labelShort;
    }
    if (_lookmlLinkSet || _apiMapResponse.containsKey('lookml_link')) {
      json['lookml_link'] = lookmlLink;
    }
    if (_mapLayerSet || _apiMapResponse.containsKey('map_layer')) {
      json['map_layer'] = mapLayer?.toJson();
    }
    if (_measureSet || _apiMapResponse.containsKey('measure')) {
      json['measure'] = measure;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_strictValueFormatSet ||
        _apiMapResponse.containsKey('strict_value_format')) {
      json['strict_value_format'] = strictValueFormat;
    }
    if (_parameterSet || _apiMapResponse.containsKey('parameter')) {
      json['parameter'] = parameter;
    }
    if (_permanentSet || _apiMapResponse.containsKey('permanent')) {
      json['permanent'] = permanent;
    }
    if (_primaryKeySet || _apiMapResponse.containsKey('primary_key')) {
      json['primary_key'] = primaryKey;
    }
    if (_projectNameSet || _apiMapResponse.containsKey('project_name')) {
      json['project_name'] = projectName;
    }
    if (_requiresRefreshOnSortSet ||
        _apiMapResponse.containsKey('requires_refresh_on_sort')) {
      json['requires_refresh_on_sort'] = requiresRefreshOnSort;
    }
    if (_scopeSet || _apiMapResponse.containsKey('scope')) {
      json['scope'] = scope;
    }
    if (_sortableSet || _apiMapResponse.containsKey('sortable')) {
      json['sortable'] = sortable;
    }
    if (_sourceFileSet || _apiMapResponse.containsKey('source_file')) {
      json['source_file'] = sourceFile;
    }
    if (_sourceFilePathSet || _apiMapResponse.containsKey('source_file_path')) {
      json['source_file_path'] = sourceFilePath;
    }
    if (_sqlSet || _apiMapResponse.containsKey('sql')) {
      json['sql'] = sql;
    }
    if (_sqlCaseSet || _apiMapResponse.containsKey('sql_case')) {
      json['sql_case'] = sqlCase?.map((i) => i.toJson())?.toList();
    }
    if (_filtersSet || _apiMapResponse.containsKey('filters')) {
      json['filters'] = filters?.map((i) => i.toJson())?.toList();
    }
    if (_suggestDimensionSet ||
        _apiMapResponse.containsKey('suggest_dimension')) {
      json['suggest_dimension'] = suggestDimension;
    }
    if (_suggestExploreSet || _apiMapResponse.containsKey('suggest_explore')) {
      json['suggest_explore'] = suggestExplore;
    }
    if (_suggestableSet || _apiMapResponse.containsKey('suggestable')) {
      json['suggestable'] = suggestable;
    }
    if (_suggestionsSet || _apiMapResponse.containsKey('suggestions')) {
      json['suggestions'] = suggestions;
    }
    if (_tagsSet || _apiMapResponse.containsKey('tags')) {
      json['tags'] = tags;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_userAttributeFilterTypesSet ||
        _apiMapResponse.containsKey('user_attribute_filter_types')) {
      json['user_attribute_filter_types'] = userAttributeFilterTypes;
    }
    if (_valueFormatSet || _apiMapResponse.containsKey('value_format')) {
      json['value_format'] = valueFormat;
    }
    if (_viewSet || _apiMapResponse.containsKey('view')) {
      json['view'] = view;
    }
    if (_viewLabelSet || _apiMapResponse.containsKey('view_label')) {
      json['view_label'] = viewLabel;
    }
    if (_dynamicSet || _apiMapResponse.containsKey('dynamic')) {
      json['dynamic'] = dynamic;
    }
    if (_weekStartDaySet || _apiMapResponse.containsKey('week_start_day')) {
      json['week_start_day'] = WeekStartDayMapper.toStringValue(weekStartDay);
    }
    if (_timesUsedSet || _apiMapResponse.containsKey('times_used')) {
      json['times_used'] = timesUsed;
    }
    if (_originalViewSet || _apiMapResponse.containsKey('original_view')) {
      json['original_view'] = originalView;
    }
    return json;
  }
}

class LookmlModelExploreFieldEnumeration {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _label;
  bool _labelSet = false;

  dynamic _value;
  bool _valueSet = false;

  /// Label (read-only)

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// Value (read-only)

  dynamic get value {
    if (!_valueSet && _apiMapResponse.containsKey('value')) {
      _value = _apiMapResponse['value'];
      _valueSet = true;
    }
    return _value;
  }

  set value(dynamic v) {
    _value = v;
    _valueSet = true;
  }

  LookmlModelExploreFieldEnumeration() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlModelExploreFieldEnumeration.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_valueSet || _apiMapResponse.containsKey('value')) {
      json['value'] = value;
    }
    return json;
  }
}

class LookmlModelExploreFieldMapLayer {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _url;
  bool _urlSet = false;

  String _name;
  bool _nameSet = false;

  String _featureKey;
  bool _featureKeySet = false;

  String _propertyKey;
  bool _propertyKeySet = false;

  String _propertyLabelKey;
  bool _propertyLabelKeySet = false;

  String _projection;
  bool _projectionSet = false;

  Format _format;
  bool _formatSet = false;

  String _extentsJsonUrl;
  bool _extentsJsonUrlSet = false;

  int _maxZoomLevel;
  bool _maxZoomLevelSet = false;

  int _minZoomLevel;
  bool _minZoomLevelSet = false;

  /// URL to the map layer resource. (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  /// Name of the map layer, as defined in LookML. (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Specifies the name of the TopoJSON object that the map layer references. If not specified, use the first object.. (read-only)

  String get featureKey {
    if (!_featureKeySet && _apiMapResponse.containsKey('feature_key')) {
      _featureKey = _apiMapResponse['feature_key']?.toString();
      _featureKeySet = true;
    }
    return _featureKey;
  }

  set featureKey(String v) {
    _featureKey = v;
    _featureKeySet = true;
  }

  /// Selects which property from the TopoJSON data to plot against. TopoJSON supports arbitrary metadata for each region. When null, the first matching property should be used. (read-only)

  String get propertyKey {
    if (!_propertyKeySet && _apiMapResponse.containsKey('property_key')) {
      _propertyKey = _apiMapResponse['property_key']?.toString();
      _propertyKeySet = true;
    }
    return _propertyKey;
  }

  set propertyKey(String v) {
    _propertyKey = v;
    _propertyKeySet = true;
  }

  /// Which property from the TopoJSON data to use to label the region. When null, property_key should be used. (read-only)

  String get propertyLabelKey {
    if (!_propertyLabelKeySet &&
        _apiMapResponse.containsKey('property_label_key')) {
      _propertyLabelKey = _apiMapResponse['property_label_key']?.toString();
      _propertyLabelKeySet = true;
    }
    return _propertyLabelKey;
  }

  set propertyLabelKey(String v) {
    _propertyLabelKey = v;
    _propertyLabelKeySet = true;
  }

  /// The preferred geographic projection of the map layer when displayed in a visualization that supports multiple geographic projections. (read-only)

  String get projection {
    if (!_projectionSet && _apiMapResponse.containsKey('projection')) {
      _projection = _apiMapResponse['projection']?.toString();
      _projectionSet = true;
    }
    return _projection;
  }

  set projection(String v) {
    _projection = v;
    _projectionSet = true;
  }

  /// Specifies the data format of the region information. Valid values are: "topojson", "vector_tile_region". (read-only)

  Format get format {
    if (!_formatSet && _apiMapResponse.containsKey('format')) {
      _format = FormatMapper.fromStringValue(_apiMapResponse['format']);
      _formatSet = true;
    }
    return _format;
  }

  set format(Format v) {
    _format = v;
    _formatSet = true;
  }

  /// Specifies the URL to a JSON file that defines the geographic extents of each region available in the map layer. This data is used to automatically center the map on the available data for visualization purposes. The JSON file must be a JSON object where the keys are the mapping value of the feature (as specified by property_key) and the values are arrays of four numbers representing the west longitude, south latitude, east longitude, and north latitude extents of the region. The object must include a key for every possible value of property_key. (read-only)

  String get extentsJsonUrl {
    if (!_extentsJsonUrlSet &&
        _apiMapResponse.containsKey('extents_json_url')) {
      _extentsJsonUrl = _apiMapResponse['extents_json_url']?.toString();
      _extentsJsonUrlSet = true;
    }
    return _extentsJsonUrl;
  }

  set extentsJsonUrl(String v) {
    _extentsJsonUrl = v;
    _extentsJsonUrlSet = true;
  }

  /// The minimum zoom level that the map layer may be displayed at, for visualizations that support zooming. (read-only)

  int get maxZoomLevel {
    if (!_maxZoomLevelSet && _apiMapResponse.containsKey('max_zoom_level')) {
      _maxZoomLevel = _apiMapResponse['max_zoom_level'];
      _maxZoomLevelSet = true;
    }
    return _maxZoomLevel;
  }

  set maxZoomLevel(int v) {
    _maxZoomLevel = v;
    _maxZoomLevelSet = true;
  }

  /// The maximum zoom level that the map layer may be displayed at, for visualizations that support zooming. (read-only)

  int get minZoomLevel {
    if (!_minZoomLevelSet && _apiMapResponse.containsKey('min_zoom_level')) {
      _minZoomLevel = _apiMapResponse['min_zoom_level'];
      _minZoomLevelSet = true;
    }
    return _minZoomLevel;
  }

  set minZoomLevel(int v) {
    _minZoomLevel = v;
    _minZoomLevelSet = true;
  }

  LookmlModelExploreFieldMapLayer() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlModelExploreFieldMapLayer.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_featureKeySet || _apiMapResponse.containsKey('feature_key')) {
      json['feature_key'] = featureKey;
    }
    if (_propertyKeySet || _apiMapResponse.containsKey('property_key')) {
      json['property_key'] = propertyKey;
    }
    if (_propertyLabelKeySet ||
        _apiMapResponse.containsKey('property_label_key')) {
      json['property_label_key'] = propertyLabelKey;
    }
    if (_projectionSet || _apiMapResponse.containsKey('projection')) {
      json['projection'] = projection;
    }
    if (_formatSet || _apiMapResponse.containsKey('format')) {
      json['format'] = FormatMapper.toStringValue(format);
    }
    if (_extentsJsonUrlSet || _apiMapResponse.containsKey('extents_json_url')) {
      json['extents_json_url'] = extentsJsonUrl;
    }
    if (_maxZoomLevelSet || _apiMapResponse.containsKey('max_zoom_level')) {
      json['max_zoom_level'] = maxZoomLevel;
    }
    if (_minZoomLevelSet || _apiMapResponse.containsKey('min_zoom_level')) {
      json['min_zoom_level'] = minZoomLevel;
    }
    return json;
  }
}

class LookmlModelExploreFieldMeasureFilters {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _field;
  bool _fieldSet = false;

  String _condition;
  bool _conditionSet = false;

  /// Filter field name (read-only)

  String get field {
    if (!_fieldSet && _apiMapResponse.containsKey('field')) {
      _field = _apiMapResponse['field']?.toString();
      _fieldSet = true;
    }
    return _field;
  }

  set field(String v) {
    _field = v;
    _fieldSet = true;
  }

  /// Filter condition value (read-only)

  String get condition {
    if (!_conditionSet && _apiMapResponse.containsKey('condition')) {
      _condition = _apiMapResponse['condition']?.toString();
      _conditionSet = true;
    }
    return _condition;
  }

  set condition(String v) {
    _condition = v;
    _conditionSet = true;
  }

  LookmlModelExploreFieldMeasureFilters() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlModelExploreFieldMeasureFilters.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_fieldSet || _apiMapResponse.containsKey('field')) {
      json['field'] = field;
    }
    if (_conditionSet || _apiMapResponse.containsKey('condition')) {
      json['condition'] = condition;
    }
    return json;
  }
}

class LookmlModelExploreFieldset {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  List<LookmlModelExploreField> _dimensions;
  bool _dimensionsSet = false;

  List<LookmlModelExploreField> _measures;
  bool _measuresSet = false;

  List<LookmlModelExploreField> _filters;
  bool _filtersSet = false;

  List<LookmlModelExploreField> _parameters;
  bool _parametersSet = false;

  /// Array of dimensions (read-only)

  List<LookmlModelExploreField> get dimensions {
    if (!_dimensionsSet && _apiMapResponse.containsKey('dimensions')) {
      _dimensions = _apiMapResponse['dimensions'] == null
          ? null
          : (_apiMapResponse['dimensions'] as List)
              .map((i) => LookmlModelExploreField.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _dimensionsSet = true;
    }
    return _dimensions;
  }

  set dimensions(List<LookmlModelExploreField> v) {
    _dimensions = v;
    _dimensionsSet = true;
  }

  /// Array of measures (read-only)

  List<LookmlModelExploreField> get measures {
    if (!_measuresSet && _apiMapResponse.containsKey('measures')) {
      _measures = _apiMapResponse['measures'] == null
          ? null
          : (_apiMapResponse['measures'] as List)
              .map((i) => LookmlModelExploreField.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _measuresSet = true;
    }
    return _measures;
  }

  set measures(List<LookmlModelExploreField> v) {
    _measures = v;
    _measuresSet = true;
  }

  /// Array of filters (read-only)

  List<LookmlModelExploreField> get filters {
    if (!_filtersSet && _apiMapResponse.containsKey('filters')) {
      _filters = _apiMapResponse['filters'] == null
          ? null
          : (_apiMapResponse['filters'] as List)
              .map((i) => LookmlModelExploreField.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _filtersSet = true;
    }
    return _filters;
  }

  set filters(List<LookmlModelExploreField> v) {
    _filters = v;
    _filtersSet = true;
  }

  /// Array of parameters (read-only)

  List<LookmlModelExploreField> get parameters {
    if (!_parametersSet && _apiMapResponse.containsKey('parameters')) {
      _parameters = _apiMapResponse['parameters'] == null
          ? null
          : (_apiMapResponse['parameters'] as List)
              .map((i) => LookmlModelExploreField.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _parametersSet = true;
    }
    return _parameters;
  }

  set parameters(List<LookmlModelExploreField> v) {
    _parameters = v;
    _parametersSet = true;
  }

  LookmlModelExploreFieldset() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlModelExploreFieldset.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_dimensionsSet || _apiMapResponse.containsKey('dimensions')) {
      json['dimensions'] = dimensions?.map((i) => i.toJson())?.toList();
    }
    if (_measuresSet || _apiMapResponse.containsKey('measures')) {
      json['measures'] = measures?.map((i) => i.toJson())?.toList();
    }
    if (_filtersSet || _apiMapResponse.containsKey('filters')) {
      json['filters'] = filters?.map((i) => i.toJson())?.toList();
    }
    if (_parametersSet || _apiMapResponse.containsKey('parameters')) {
      json['parameters'] = parameters?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class LookmlModelExploreFieldSqlCase {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _value;
  bool _valueSet = false;

  String _condition;
  bool _conditionSet = false;

  /// SQL Case label value (read-only)

  String get value {
    if (!_valueSet && _apiMapResponse.containsKey('value')) {
      _value = _apiMapResponse['value']?.toString();
      _valueSet = true;
    }
    return _value;
  }

  set value(String v) {
    _value = v;
    _valueSet = true;
  }

  /// SQL Case condition expression (read-only)

  String get condition {
    if (!_conditionSet && _apiMapResponse.containsKey('condition')) {
      _condition = _apiMapResponse['condition']?.toString();
      _conditionSet = true;
    }
    return _condition;
  }

  set condition(String v) {
    _condition = v;
    _conditionSet = true;
  }

  LookmlModelExploreFieldSqlCase() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlModelExploreFieldSqlCase.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_valueSet || _apiMapResponse.containsKey('value')) {
      json['value'] = value;
    }
    if (_conditionSet || _apiMapResponse.containsKey('condition')) {
      json['condition'] = condition;
    }
    return json;
  }
}

class LookmlModelExploreFieldTimeInterval {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Name _name;
  bool _nameSet = false;

  int _count;
  bool _countSet = false;

  /// The type of time interval this field represents a grouping of. Valid values are: "day", "hour", "minute", "second", "millisecond", "microsecond", "week", "month", "quarter", "year". (read-only)

  Name get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = NameMapper.fromStringValue(_apiMapResponse['name']);
      _nameSet = true;
    }
    return _name;
  }

  set name(Name v) {
    _name = v;
    _nameSet = true;
  }

  /// The number of intervals this field represents a grouping of. (read-only)

  int get count {
    if (!_countSet && _apiMapResponse.containsKey('count')) {
      _count = _apiMapResponse['count'];
      _countSet = true;
    }
    return _count;
  }

  set count(int v) {
    _count = v;
    _countSet = true;
  }

  LookmlModelExploreFieldTimeInterval() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlModelExploreFieldTimeInterval.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = NameMapper.toStringValue(name);
    }
    if (_countSet || _apiMapResponse.containsKey('count')) {
      json['count'] = count;
    }
    return json;
  }
}

class LookmlModelExploreJoins {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  List<String> _dependentFields;
  bool _dependentFieldsSet = false;

  List<String> _fields;
  bool _fieldsSet = false;

  String _foreignKey;
  bool _foreignKeySet = false;

  String _from;
  bool _fromSet = false;

  bool _outerOnly;
  bool _outerOnlySet = false;

  String _relationship;
  bool _relationshipSet = false;

  List<String> _requiredJoins;
  bool _requiredJoinsSet = false;

  String _sqlForeignKey;
  bool _sqlForeignKeySet = false;

  String _sqlOn;
  bool _sqlOnSet = false;

  String _sqlTableName;
  bool _sqlTableNameSet = false;

  String _type;
  bool _typeSet = false;

  String _viewLabel;
  bool _viewLabelSet = false;

  /// Name of this join (and name of the view to join) (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Fields referenced by the join (read-only)

  List<String> get dependentFields {
    if (!_dependentFieldsSet &&
        _apiMapResponse.containsKey('dependent_fields')) {
      _dependentFields = _apiMapResponse['dependent_fields']
          ?.map<String>((i) => i as String)
          ?.toList();
      _dependentFieldsSet = true;
    }
    return _dependentFields;
  }

  set dependentFields(List<String> v) {
    _dependentFields = v;
    _dependentFieldsSet = true;
  }

  /// Fields of the joined view to pull into this explore (read-only)

  List<String> get fields {
    if (!_fieldsSet && _apiMapResponse.containsKey('fields')) {
      _fields =
          _apiMapResponse['fields']?.map<String>((i) => i as String)?.toList();
      _fieldsSet = true;
    }
    return _fields;
  }

  set fields(List<String> v) {
    _fields = v;
    _fieldsSet = true;
  }

  /// Name of the dimension in this explore whose value is in the primary key of the joined view (read-only)

  String get foreignKey {
    if (!_foreignKeySet && _apiMapResponse.containsKey('foreign_key')) {
      _foreignKey = _apiMapResponse['foreign_key']?.toString();
      _foreignKeySet = true;
    }
    return _foreignKey;
  }

  set foreignKey(String v) {
    _foreignKey = v;
    _foreignKeySet = true;
  }

  /// Name of view to join (read-only)

  String get from {
    if (!_fromSet && _apiMapResponse.containsKey('from')) {
      _from = _apiMapResponse['from']?.toString();
      _fromSet = true;
    }
    return _from;
  }

  set from(String v) {
    _from = v;
    _fromSet = true;
  }

  /// Specifies whether all queries must use an outer join (read-only)

  bool get outerOnly {
    if (!_outerOnlySet && _apiMapResponse.containsKey('outer_only')) {
      _outerOnly = _apiMapResponse['outer_only'];
      _outerOnlySet = true;
    }
    return _outerOnly;
  }

  set outerOnly(bool v) {
    _outerOnly = v;
    _outerOnlySet = true;
  }

  /// many_to_one, one_to_one, one_to_many, many_to_many (read-only)

  String get relationship {
    if (!_relationshipSet && _apiMapResponse.containsKey('relationship')) {
      _relationship = _apiMapResponse['relationship']?.toString();
      _relationshipSet = true;
    }
    return _relationship;
  }

  set relationship(String v) {
    _relationship = v;
    _relationshipSet = true;
  }

  /// Names of joins that must always be included in SQL queries (read-only)

  List<String> get requiredJoins {
    if (!_requiredJoinsSet && _apiMapResponse.containsKey('required_joins')) {
      _requiredJoins = _apiMapResponse['required_joins']
          ?.map<String>((i) => i as String)
          ?.toList();
      _requiredJoinsSet = true;
    }
    return _requiredJoins;
  }

  set requiredJoins(List<String> v) {
    _requiredJoins = v;
    _requiredJoinsSet = true;
  }

  /// SQL expression that produces a foreign key (read-only)

  String get sqlForeignKey {
    if (!_sqlForeignKeySet && _apiMapResponse.containsKey('sql_foreign_key')) {
      _sqlForeignKey = _apiMapResponse['sql_foreign_key']?.toString();
      _sqlForeignKeySet = true;
    }
    return _sqlForeignKey;
  }

  set sqlForeignKey(String v) {
    _sqlForeignKey = v;
    _sqlForeignKeySet = true;
  }

  /// SQL ON expression describing the join condition (read-only)

  String get sqlOn {
    if (!_sqlOnSet && _apiMapResponse.containsKey('sql_on')) {
      _sqlOn = _apiMapResponse['sql_on']?.toString();
      _sqlOnSet = true;
    }
    return _sqlOn;
  }

  set sqlOn(String v) {
    _sqlOn = v;
    _sqlOnSet = true;
  }

  /// SQL table name to join (read-only)

  String get sqlTableName {
    if (!_sqlTableNameSet && _apiMapResponse.containsKey('sql_table_name')) {
      _sqlTableName = _apiMapResponse['sql_table_name']?.toString();
      _sqlTableNameSet = true;
    }
    return _sqlTableName;
  }

  set sqlTableName(String v) {
    _sqlTableName = v;
    _sqlTableNameSet = true;
  }

  /// The join type: left_outer, full_outer, inner, or cross (read-only)

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Label to display in UI selectors (read-only)

  String get viewLabel {
    if (!_viewLabelSet && _apiMapResponse.containsKey('view_label')) {
      _viewLabel = _apiMapResponse['view_label']?.toString();
      _viewLabelSet = true;
    }
    return _viewLabel;
  }

  set viewLabel(String v) {
    _viewLabel = v;
    _viewLabelSet = true;
  }

  LookmlModelExploreJoins() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlModelExploreJoins.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_dependentFieldsSet ||
        _apiMapResponse.containsKey('dependent_fields')) {
      json['dependent_fields'] = dependentFields;
    }
    if (_fieldsSet || _apiMapResponse.containsKey('fields')) {
      json['fields'] = fields;
    }
    if (_foreignKeySet || _apiMapResponse.containsKey('foreign_key')) {
      json['foreign_key'] = foreignKey;
    }
    if (_fromSet || _apiMapResponse.containsKey('from')) {
      json['from'] = from;
    }
    if (_outerOnlySet || _apiMapResponse.containsKey('outer_only')) {
      json['outer_only'] = outerOnly;
    }
    if (_relationshipSet || _apiMapResponse.containsKey('relationship')) {
      json['relationship'] = relationship;
    }
    if (_requiredJoinsSet || _apiMapResponse.containsKey('required_joins')) {
      json['required_joins'] = requiredJoins;
    }
    if (_sqlForeignKeySet || _apiMapResponse.containsKey('sql_foreign_key')) {
      json['sql_foreign_key'] = sqlForeignKey;
    }
    if (_sqlOnSet || _apiMapResponse.containsKey('sql_on')) {
      json['sql_on'] = sqlOn;
    }
    if (_sqlTableNameSet || _apiMapResponse.containsKey('sql_table_name')) {
      json['sql_table_name'] = sqlTableName;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_viewLabelSet || _apiMapResponse.containsKey('view_label')) {
      json['view_label'] = viewLabel;
    }
    return json;
  }
}

class LookmlModelExploreSet {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  List<String> _value;
  bool _valueSet = false;

  /// Name (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Value set (read-only)

  List<String> get value {
    if (!_valueSet && _apiMapResponse.containsKey('value')) {
      _value =
          _apiMapResponse['value']?.map<String>((i) => i as String)?.toList();
      _valueSet = true;
    }
    return _value;
  }

  set value(List<String> v) {
    _value = v;
    _valueSet = true;
  }

  LookmlModelExploreSet() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlModelExploreSet.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_valueSet || _apiMapResponse.containsKey('value')) {
      json['value'] = value;
    }
    return json;
  }
}

class LookmlModelExploreSupportedMeasureType {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _dimensionType;
  bool _dimensionTypeSet = false;

  List<String> _measureTypes;
  bool _measureTypesSet = false;

  ///  (read-only)

  String get dimensionType {
    if (!_dimensionTypeSet && _apiMapResponse.containsKey('dimension_type')) {
      _dimensionType = _apiMapResponse['dimension_type']?.toString();
      _dimensionTypeSet = true;
    }
    return _dimensionType;
  }

  set dimensionType(String v) {
    _dimensionType = v;
    _dimensionTypeSet = true;
  }

  ///  (read-only)

  List<String> get measureTypes {
    if (!_measureTypesSet && _apiMapResponse.containsKey('measure_types')) {
      _measureTypes = _apiMapResponse['measure_types']
          ?.map<String>((i) => i as String)
          ?.toList();
      _measureTypesSet = true;
    }
    return _measureTypes;
  }

  set measureTypes(List<String> v) {
    _measureTypes = v;
    _measureTypesSet = true;
  }

  LookmlModelExploreSupportedMeasureType() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlModelExploreSupportedMeasureType.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_dimensionTypeSet || _apiMapResponse.containsKey('dimension_type')) {
      json['dimension_type'] = dimensionType;
    }
    if (_measureTypesSet || _apiMapResponse.containsKey('measure_types')) {
      json['measure_types'] = measureTypes;
    }
    return json;
  }
}

class LookmlModelNavExplore {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _description;
  bool _descriptionSet = false;

  String _label;
  bool _labelSet = false;

  bool _hidden;
  bool _hiddenSet = false;

  String _groupLabel;
  bool _groupLabelSet = false;

  /// Name of the explore (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Description for the explore (read-only)

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Label for the explore (read-only)

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// Is this explore marked as hidden (read-only)

  bool get hidden {
    if (!_hiddenSet && _apiMapResponse.containsKey('hidden')) {
      _hidden = _apiMapResponse['hidden'];
      _hiddenSet = true;
    }
    return _hidden;
  }

  set hidden(bool v) {
    _hidden = v;
    _hiddenSet = true;
  }

  /// Label used to group explores in the navigation menus (read-only)

  String get groupLabel {
    if (!_groupLabelSet && _apiMapResponse.containsKey('group_label')) {
      _groupLabel = _apiMapResponse['group_label']?.toString();
      _groupLabelSet = true;
    }
    return _groupLabel;
  }

  set groupLabel(String v) {
    _groupLabel = v;
    _groupLabelSet = true;
  }

  LookmlModelNavExplore() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlModelNavExplore.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_hiddenSet || _apiMapResponse.containsKey('hidden')) {
      json['hidden'] = hidden;
    }
    if (_groupLabelSet || _apiMapResponse.containsKey('group_label')) {
      json['group_label'] = groupLabel;
    }
    return json;
  }
}

class LookmlTest {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _modelName;
  bool _modelNameSet = false;

  String _name;
  bool _nameSet = false;

  String _exploreName;
  bool _exploreNameSet = false;

  String _queryUrlParams;
  bool _queryUrlParamsSet = false;

  String _file;
  bool _fileSet = false;

  int _line;
  bool _lineSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Name of model containing this test. (read-only)

  String get modelName {
    if (!_modelNameSet && _apiMapResponse.containsKey('model_name')) {
      _modelName = _apiMapResponse['model_name']?.toString();
      _modelNameSet = true;
    }
    return _modelName;
  }

  set modelName(String v) {
    _modelName = v;
    _modelNameSet = true;
  }

  /// Name of this test. (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Name of the explore this test runs a query against (read-only)

  String get exploreName {
    if (!_exploreNameSet && _apiMapResponse.containsKey('explore_name')) {
      _exploreName = _apiMapResponse['explore_name']?.toString();
      _exploreNameSet = true;
    }
    return _exploreName;
  }

  set exploreName(String v) {
    _exploreName = v;
    _exploreNameSet = true;
  }

  /// The url parameters that can be used to reproduce this test's query on an explore. (read-only)

  String get queryUrlParams {
    if (!_queryUrlParamsSet &&
        _apiMapResponse.containsKey('query_url_params')) {
      _queryUrlParams = _apiMapResponse['query_url_params']?.toString();
      _queryUrlParamsSet = true;
    }
    return _queryUrlParams;
  }

  set queryUrlParams(String v) {
    _queryUrlParams = v;
    _queryUrlParamsSet = true;
  }

  /// Name of the LookML file containing this test. (read-only)

  String get file {
    if (!_fileSet && _apiMapResponse.containsKey('file')) {
      _file = _apiMapResponse['file']?.toString();
      _fileSet = true;
    }
    return _file;
  }

  set file(String v) {
    _file = v;
    _fileSet = true;
  }

  /// Line number of this test in LookML. (read-only)

  int get line {
    if (!_lineSet && _apiMapResponse.containsKey('line')) {
      _line = _apiMapResponse['line'];
      _lineSet = true;
    }
    return _line;
  }

  set line(int v) {
    _line = v;
    _lineSet = true;
  }

  LookmlTest() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlTest.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_modelNameSet || _apiMapResponse.containsKey('model_name')) {
      json['model_name'] = modelName;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_exploreNameSet || _apiMapResponse.containsKey('explore_name')) {
      json['explore_name'] = exploreName;
    }
    if (_queryUrlParamsSet || _apiMapResponse.containsKey('query_url_params')) {
      json['query_url_params'] = queryUrlParams;
    }
    if (_fileSet || _apiMapResponse.containsKey('file')) {
      json['file'] = file;
    }
    if (_lineSet || _apiMapResponse.containsKey('line')) {
      json['line'] = line;
    }
    return json;
  }
}

class LookmlTestResult {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _modelName;
  bool _modelNameSet = false;

  String _testName;
  bool _testNameSet = false;

  int _assertionsCount;
  bool _assertionsCountSet = false;

  int _assertionsFailed;
  bool _assertionsFailedSet = false;

  List<ProjectError> _errors;
  bool _errorsSet = false;

  List<ProjectError> _warnings;
  bool _warningsSet = false;

  bool _success;
  bool _successSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Name of model containing this test. (read-only)

  String get modelName {
    if (!_modelNameSet && _apiMapResponse.containsKey('model_name')) {
      _modelName = _apiMapResponse['model_name']?.toString();
      _modelNameSet = true;
    }
    return _modelName;
  }

  set modelName(String v) {
    _modelName = v;
    _modelNameSet = true;
  }

  /// Name of this test. (read-only)

  String get testName {
    if (!_testNameSet && _apiMapResponse.containsKey('test_name')) {
      _testName = _apiMapResponse['test_name']?.toString();
      _testNameSet = true;
    }
    return _testName;
  }

  set testName(String v) {
    _testName = v;
    _testNameSet = true;
  }

  /// Number of assertions in this test (read-only)

  int get assertionsCount {
    if (!_assertionsCountSet &&
        _apiMapResponse.containsKey('assertions_count')) {
      _assertionsCount = _apiMapResponse['assertions_count'];
      _assertionsCountSet = true;
    }
    return _assertionsCount;
  }

  set assertionsCount(int v) {
    _assertionsCount = v;
    _assertionsCountSet = true;
  }

  /// Number of assertions passed in this test (read-only)

  int get assertionsFailed {
    if (!_assertionsFailedSet &&
        _apiMapResponse.containsKey('assertions_failed')) {
      _assertionsFailed = _apiMapResponse['assertions_failed'];
      _assertionsFailedSet = true;
    }
    return _assertionsFailed;
  }

  set assertionsFailed(int v) {
    _assertionsFailed = v;
    _assertionsFailedSet = true;
  }

  /// A list of any errors encountered by the test. (read-only)

  List<ProjectError> get errors {
    if (!_errorsSet && _apiMapResponse.containsKey('errors')) {
      _errors = _apiMapResponse['errors'] == null
          ? null
          : (_apiMapResponse['errors'] as List)
              .map((i) => ProjectError.fromResponse(i, apiResponseContentType))
              .toList();
      _errorsSet = true;
    }
    return _errors;
  }

  set errors(List<ProjectError> v) {
    _errors = v;
    _errorsSet = true;
  }

  /// A list of any warnings encountered by the test. (read-only)

  List<ProjectError> get warnings {
    if (!_warningsSet && _apiMapResponse.containsKey('warnings')) {
      _warnings = _apiMapResponse['warnings'] == null
          ? null
          : (_apiMapResponse['warnings'] as List)
              .map((i) => ProjectError.fromResponse(i, apiResponseContentType))
              .toList();
      _warningsSet = true;
    }
    return _warnings;
  }

  set warnings(List<ProjectError> v) {
    _warnings = v;
    _warningsSet = true;
  }

  /// True if this test passsed without errors. (read-only)

  bool get success {
    if (!_successSet && _apiMapResponse.containsKey('success')) {
      _success = _apiMapResponse['success'];
      _successSet = true;
    }
    return _success;
  }

  set success(bool v) {
    _success = v;
    _successSet = true;
  }

  LookmlTestResult() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookmlTestResult.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_modelNameSet || _apiMapResponse.containsKey('model_name')) {
      json['model_name'] = modelName;
    }
    if (_testNameSet || _apiMapResponse.containsKey('test_name')) {
      json['test_name'] = testName;
    }
    if (_assertionsCountSet ||
        _apiMapResponse.containsKey('assertions_count')) {
      json['assertions_count'] = assertionsCount;
    }
    if (_assertionsFailedSet ||
        _apiMapResponse.containsKey('assertions_failed')) {
      json['assertions_failed'] = assertionsFailed;
    }
    if (_errorsSet || _apiMapResponse.containsKey('errors')) {
      json['errors'] = errors?.map((i) => i.toJson())?.toList();
    }
    if (_warningsSet || _apiMapResponse.containsKey('warnings')) {
      json['warnings'] = warnings?.map((i) => i.toJson())?.toList();
    }
    if (_successSet || _apiMapResponse.containsKey('success')) {
      json['success'] = success;
    }
    return json;
  }
}

class LookModel {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _id;
  bool _idSet = false;

  String _label;
  bool _labelSet = false;

  /// Model Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Model Label (read-only)

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  LookModel() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookModel.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    return json;
  }
}

class LookWithDashboards {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _contentMetadataId;
  bool _contentMetadataIdSet = false;

  String _id;
  bool _idSet = false;

  String _title;
  bool _titleSet = false;

  int _userId;
  bool _userIdSet = false;

  int _contentFavoriteId;
  bool _contentFavoriteIdSet = false;

  DateTime _createdAt;
  bool _createdAtSet = false;

  bool _deleted;
  bool _deletedSet = false;

  DateTime _deletedAt;
  bool _deletedAtSet = false;

  int _deleterId;
  bool _deleterIdSet = false;

  String _description;
  bool _descriptionSet = false;

  String _embedUrl;
  bool _embedUrlSet = false;

  String _excelFileUrl;
  bool _excelFileUrlSet = false;

  int _favoriteCount;
  bool _favoriteCountSet = false;

  String _googleSpreadsheetFormula;
  bool _googleSpreadsheetFormulaSet = false;

  String _imageEmbedUrl;
  bool _imageEmbedUrlSet = false;

  bool _isRunOnLoad;
  bool _isRunOnLoadSet = false;

  DateTime _lastAccessedAt;
  bool _lastAccessedAtSet = false;

  int _lastUpdaterId;
  bool _lastUpdaterIdSet = false;

  DateTime _lastViewedAt;
  bool _lastViewedAtSet = false;

  LookModel _model;
  bool _modelSet = false;

  bool _public;
  bool _publicSet = false;

  String _publicSlug;
  bool _publicSlugSet = false;

  String _publicUrl;
  bool _publicUrlSet = false;

  int _queryId;
  bool _queryIdSet = false;

  String _shortUrl;
  bool _shortUrlSet = false;

  FolderBase _folder;
  bool _folderSet = false;

  String _folderId;
  bool _folderIdSet = false;

  DateTime _updatedAt;
  bool _updatedAtSet = false;

  int _viewCount;
  bool _viewCountSet = false;

  List<DashboardBase> _dashboards;
  bool _dashboardsSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Id of content metadata (read-only)

  int get contentMetadataId {
    if (!_contentMetadataIdSet &&
        _apiMapResponse.containsKey('content_metadata_id')) {
      _contentMetadataId = _apiMapResponse['content_metadata_id'];
      _contentMetadataIdSet = true;
    }
    return _contentMetadataId;
  }

  set contentMetadataId(int v) {
    _contentMetadataId = v;
    _contentMetadataIdSet = true;
  }

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Look Title

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// User Id

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  /// Content Favorite Id (read-only)

  int get contentFavoriteId {
    if (!_contentFavoriteIdSet &&
        _apiMapResponse.containsKey('content_favorite_id')) {
      _contentFavoriteId = _apiMapResponse['content_favorite_id'];
      _contentFavoriteIdSet = true;
    }
    return _contentFavoriteId;
  }

  set contentFavoriteId(int v) {
    _contentFavoriteId = v;
    _contentFavoriteIdSet = true;
  }

  /// Time that the Look was created. (read-only)

  DateTime get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['created_at']);
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(DateTime v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// Whether or not a look is 'soft' deleted.

  bool get deleted {
    if (!_deletedSet && _apiMapResponse.containsKey('deleted')) {
      _deleted = _apiMapResponse['deleted'];
      _deletedSet = true;
    }
    return _deleted;
  }

  set deleted(bool v) {
    _deleted = v;
    _deletedSet = true;
  }

  /// Time that the Look was deleted. (read-only)

  DateTime get deletedAt {
    if (!_deletedAtSet && _apiMapResponse.containsKey('deleted_at')) {
      _deletedAt = _apiMapResponse['deleted_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['deleted_at']);
      _deletedAtSet = true;
    }
    return _deletedAt;
  }

  set deletedAt(DateTime v) {
    _deletedAt = v;
    _deletedAtSet = true;
  }

  /// Id of User that deleted the look. (read-only)

  int get deleterId {
    if (!_deleterIdSet && _apiMapResponse.containsKey('deleter_id')) {
      _deleterId = _apiMapResponse['deleter_id'];
      _deleterIdSet = true;
    }
    return _deleterId;
  }

  set deleterId(int v) {
    _deleterId = v;
    _deleterIdSet = true;
  }

  /// Description

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Embed Url (read-only)

  String get embedUrl {
    if (!_embedUrlSet && _apiMapResponse.containsKey('embed_url')) {
      _embedUrl = _apiMapResponse['embed_url']?.toString();
      _embedUrlSet = true;
    }
    return _embedUrl;
  }

  set embedUrl(String v) {
    _embedUrl = v;
    _embedUrlSet = true;
  }

  /// Excel File Url (read-only)

  String get excelFileUrl {
    if (!_excelFileUrlSet && _apiMapResponse.containsKey('excel_file_url')) {
      _excelFileUrl = _apiMapResponse['excel_file_url']?.toString();
      _excelFileUrlSet = true;
    }
    return _excelFileUrl;
  }

  set excelFileUrl(String v) {
    _excelFileUrl = v;
    _excelFileUrlSet = true;
  }

  /// Number of times favorited (read-only)

  int get favoriteCount {
    if (!_favoriteCountSet && _apiMapResponse.containsKey('favorite_count')) {
      _favoriteCount = _apiMapResponse['favorite_count'];
      _favoriteCountSet = true;
    }
    return _favoriteCount;
  }

  set favoriteCount(int v) {
    _favoriteCount = v;
    _favoriteCountSet = true;
  }

  /// Google Spreadsheet Formula (read-only)

  String get googleSpreadsheetFormula {
    if (!_googleSpreadsheetFormulaSet &&
        _apiMapResponse.containsKey('google_spreadsheet_formula')) {
      _googleSpreadsheetFormula =
          _apiMapResponse['google_spreadsheet_formula']?.toString();
      _googleSpreadsheetFormulaSet = true;
    }
    return _googleSpreadsheetFormula;
  }

  set googleSpreadsheetFormula(String v) {
    _googleSpreadsheetFormula = v;
    _googleSpreadsheetFormulaSet = true;
  }

  /// Image Embed Url (read-only)

  String get imageEmbedUrl {
    if (!_imageEmbedUrlSet && _apiMapResponse.containsKey('image_embed_url')) {
      _imageEmbedUrl = _apiMapResponse['image_embed_url']?.toString();
      _imageEmbedUrlSet = true;
    }
    return _imageEmbedUrl;
  }

  set imageEmbedUrl(String v) {
    _imageEmbedUrl = v;
    _imageEmbedUrlSet = true;
  }

  /// auto-run query when Look viewed

  bool get isRunOnLoad {
    if (!_isRunOnLoadSet && _apiMapResponse.containsKey('is_run_on_load')) {
      _isRunOnLoad = _apiMapResponse['is_run_on_load'];
      _isRunOnLoadSet = true;
    }
    return _isRunOnLoad;
  }

  set isRunOnLoad(bool v) {
    _isRunOnLoad = v;
    _isRunOnLoadSet = true;
  }

  /// Time that the Look was last accessed by any user (read-only)

  DateTime get lastAccessedAt {
    if (!_lastAccessedAtSet &&
        _apiMapResponse.containsKey('last_accessed_at')) {
      _lastAccessedAt = _apiMapResponse['last_accessed_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['last_accessed_at']);
      _lastAccessedAtSet = true;
    }
    return _lastAccessedAt;
  }

  set lastAccessedAt(DateTime v) {
    _lastAccessedAt = v;
    _lastAccessedAtSet = true;
  }

  /// Id of User that last updated the look. (read-only)

  int get lastUpdaterId {
    if (!_lastUpdaterIdSet && _apiMapResponse.containsKey('last_updater_id')) {
      _lastUpdaterId = _apiMapResponse['last_updater_id'];
      _lastUpdaterIdSet = true;
    }
    return _lastUpdaterId;
  }

  set lastUpdaterId(int v) {
    _lastUpdaterId = v;
    _lastUpdaterIdSet = true;
  }

  /// Time last viewed in the Looker web UI (read-only)

  DateTime get lastViewedAt {
    if (!_lastViewedAtSet && _apiMapResponse.containsKey('last_viewed_at')) {
      _lastViewedAt = _apiMapResponse['last_viewed_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['last_viewed_at']);
      _lastViewedAtSet = true;
    }
    return _lastViewedAt;
  }

  set lastViewedAt(DateTime v) {
    _lastViewedAt = v;
    _lastViewedAtSet = true;
  }

  LookModel get model {
    if (!_modelSet && _apiMapResponse.containsKey('model')) {
      _model = _apiMapResponse['model'] == null
          ? null
          : LookModel.fromResponse(
              _apiMapResponse['model'], apiResponseContentType);
      _modelSet = true;
    }
    return _model;
  }

  set model(LookModel v) {
    _model = v;
    _modelSet = true;
  }

  /// Is Public

  bool get public {
    if (!_publicSet && _apiMapResponse.containsKey('public')) {
      _public = _apiMapResponse['public'];
      _publicSet = true;
    }
    return _public;
  }

  set public(bool v) {
    _public = v;
    _publicSet = true;
  }

  /// Public Slug (read-only)

  String get publicSlug {
    if (!_publicSlugSet && _apiMapResponse.containsKey('public_slug')) {
      _publicSlug = _apiMapResponse['public_slug']?.toString();
      _publicSlugSet = true;
    }
    return _publicSlug;
  }

  set publicSlug(String v) {
    _publicSlug = v;
    _publicSlugSet = true;
  }

  /// Public Url (read-only)

  String get publicUrl {
    if (!_publicUrlSet && _apiMapResponse.containsKey('public_url')) {
      _publicUrl = _apiMapResponse['public_url']?.toString();
      _publicUrlSet = true;
    }
    return _publicUrl;
  }

  set publicUrl(String v) {
    _publicUrl = v;
    _publicUrlSet = true;
  }

  /// Query Id

  int get queryId {
    if (!_queryIdSet && _apiMapResponse.containsKey('query_id')) {
      _queryId = _apiMapResponse['query_id'];
      _queryIdSet = true;
    }
    return _queryId;
  }

  set queryId(int v) {
    _queryId = v;
    _queryIdSet = true;
  }

  /// Short Url (read-only)

  String get shortUrl {
    if (!_shortUrlSet && _apiMapResponse.containsKey('short_url')) {
      _shortUrl = _apiMapResponse['short_url']?.toString();
      _shortUrlSet = true;
    }
    return _shortUrl;
  }

  set shortUrl(String v) {
    _shortUrl = v;
    _shortUrlSet = true;
  }

  FolderBase get folder {
    if (!_folderSet && _apiMapResponse.containsKey('folder')) {
      _folder = _apiMapResponse['folder'] == null
          ? null
          : FolderBase.fromResponse(
              _apiMapResponse['folder'], apiResponseContentType);
      _folderSet = true;
    }
    return _folder;
  }

  set folder(FolderBase v) {
    _folder = v;
    _folderSet = true;
  }

  /// Folder Id

  String get folderId {
    if (!_folderIdSet && _apiMapResponse.containsKey('folder_id')) {
      _folderId = _apiMapResponse['folder_id']?.toString();
      _folderIdSet = true;
    }
    return _folderId;
  }

  set folderId(String v) {
    _folderId = v;
    _folderIdSet = true;
  }

  /// Time that the Look was updated. (read-only)

  DateTime get updatedAt {
    if (!_updatedAtSet && _apiMapResponse.containsKey('updated_at')) {
      _updatedAt = _apiMapResponse['updated_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['updated_at']);
      _updatedAtSet = true;
    }
    return _updatedAt;
  }

  set updatedAt(DateTime v) {
    _updatedAt = v;
    _updatedAtSet = true;
  }

  /// Number of times viewed in the Looker web UI (read-only)

  int get viewCount {
    if (!_viewCountSet && _apiMapResponse.containsKey('view_count')) {
      _viewCount = _apiMapResponse['view_count'];
      _viewCountSet = true;
    }
    return _viewCount;
  }

  set viewCount(int v) {
    _viewCount = v;
    _viewCountSet = true;
  }

  /// Dashboards (read-only)

  List<DashboardBase> get dashboards {
    if (!_dashboardsSet && _apiMapResponse.containsKey('dashboards')) {
      _dashboards = _apiMapResponse['dashboards'] == null
          ? null
          : (_apiMapResponse['dashboards'] as List)
              .map((i) => DashboardBase.fromResponse(i, apiResponseContentType))
              .toList();
      _dashboardsSet = true;
    }
    return _dashboards;
  }

  set dashboards(List<DashboardBase> v) {
    _dashboards = v;
    _dashboardsSet = true;
  }

  LookWithDashboards() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookWithDashboards.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_contentMetadataIdSet ||
        _apiMapResponse.containsKey('content_metadata_id')) {
      json['content_metadata_id'] = contentMetadataId;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    if (_contentFavoriteIdSet ||
        _apiMapResponse.containsKey('content_favorite_id')) {
      json['content_favorite_id'] = contentFavoriteId;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt?.toIso8601String();
    }
    if (_deletedSet || _apiMapResponse.containsKey('deleted')) {
      json['deleted'] = deleted;
    }
    if (_deletedAtSet || _apiMapResponse.containsKey('deleted_at')) {
      json['deleted_at'] = deletedAt?.toIso8601String();
    }
    if (_deleterIdSet || _apiMapResponse.containsKey('deleter_id')) {
      json['deleter_id'] = deleterId;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_embedUrlSet || _apiMapResponse.containsKey('embed_url')) {
      json['embed_url'] = embedUrl;
    }
    if (_excelFileUrlSet || _apiMapResponse.containsKey('excel_file_url')) {
      json['excel_file_url'] = excelFileUrl;
    }
    if (_favoriteCountSet || _apiMapResponse.containsKey('favorite_count')) {
      json['favorite_count'] = favoriteCount;
    }
    if (_googleSpreadsheetFormulaSet ||
        _apiMapResponse.containsKey('google_spreadsheet_formula')) {
      json['google_spreadsheet_formula'] = googleSpreadsheetFormula;
    }
    if (_imageEmbedUrlSet || _apiMapResponse.containsKey('image_embed_url')) {
      json['image_embed_url'] = imageEmbedUrl;
    }
    if (_isRunOnLoadSet || _apiMapResponse.containsKey('is_run_on_load')) {
      json['is_run_on_load'] = isRunOnLoad;
    }
    if (_lastAccessedAtSet || _apiMapResponse.containsKey('last_accessed_at')) {
      json['last_accessed_at'] = lastAccessedAt?.toIso8601String();
    }
    if (_lastUpdaterIdSet || _apiMapResponse.containsKey('last_updater_id')) {
      json['last_updater_id'] = lastUpdaterId;
    }
    if (_lastViewedAtSet || _apiMapResponse.containsKey('last_viewed_at')) {
      json['last_viewed_at'] = lastViewedAt?.toIso8601String();
    }
    if (_modelSet || _apiMapResponse.containsKey('model')) {
      json['model'] = model?.toJson();
    }
    if (_publicSet || _apiMapResponse.containsKey('public')) {
      json['public'] = public;
    }
    if (_publicSlugSet || _apiMapResponse.containsKey('public_slug')) {
      json['public_slug'] = publicSlug;
    }
    if (_publicUrlSet || _apiMapResponse.containsKey('public_url')) {
      json['public_url'] = publicUrl;
    }
    if (_queryIdSet || _apiMapResponse.containsKey('query_id')) {
      json['query_id'] = queryId;
    }
    if (_shortUrlSet || _apiMapResponse.containsKey('short_url')) {
      json['short_url'] = shortUrl;
    }
    if (_folderSet || _apiMapResponse.containsKey('folder')) {
      json['folder'] = folder?.toJson();
    }
    if (_folderIdSet || _apiMapResponse.containsKey('folder_id')) {
      json['folder_id'] = folderId;
    }
    if (_updatedAtSet || _apiMapResponse.containsKey('updated_at')) {
      json['updated_at'] = updatedAt?.toIso8601String();
    }
    if (_viewCountSet || _apiMapResponse.containsKey('view_count')) {
      json['view_count'] = viewCount;
    }
    if (_dashboardsSet || _apiMapResponse.containsKey('dashboards')) {
      json['dashboards'] = dashboards?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class LookWithQuery {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _contentMetadataId;
  bool _contentMetadataIdSet = false;

  String _id;
  bool _idSet = false;

  String _title;
  bool _titleSet = false;

  int _userId;
  bool _userIdSet = false;

  int _contentFavoriteId;
  bool _contentFavoriteIdSet = false;

  DateTime _createdAt;
  bool _createdAtSet = false;

  bool _deleted;
  bool _deletedSet = false;

  DateTime _deletedAt;
  bool _deletedAtSet = false;

  int _deleterId;
  bool _deleterIdSet = false;

  String _description;
  bool _descriptionSet = false;

  String _embedUrl;
  bool _embedUrlSet = false;

  String _excelFileUrl;
  bool _excelFileUrlSet = false;

  int _favoriteCount;
  bool _favoriteCountSet = false;

  String _googleSpreadsheetFormula;
  bool _googleSpreadsheetFormulaSet = false;

  String _imageEmbedUrl;
  bool _imageEmbedUrlSet = false;

  bool _isRunOnLoad;
  bool _isRunOnLoadSet = false;

  DateTime _lastAccessedAt;
  bool _lastAccessedAtSet = false;

  int _lastUpdaterId;
  bool _lastUpdaterIdSet = false;

  DateTime _lastViewedAt;
  bool _lastViewedAtSet = false;

  LookModel _model;
  bool _modelSet = false;

  bool _public;
  bool _publicSet = false;

  String _publicSlug;
  bool _publicSlugSet = false;

  String _publicUrl;
  bool _publicUrlSet = false;

  int _queryId;
  bool _queryIdSet = false;

  String _shortUrl;
  bool _shortUrlSet = false;

  FolderBase _folder;
  bool _folderSet = false;

  String _folderId;
  bool _folderIdSet = false;

  DateTime _updatedAt;
  bool _updatedAtSet = false;

  int _viewCount;
  bool _viewCountSet = false;

  Query _query;
  bool _querySet = false;

  String _url;
  bool _urlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Id of content metadata (read-only)

  int get contentMetadataId {
    if (!_contentMetadataIdSet &&
        _apiMapResponse.containsKey('content_metadata_id')) {
      _contentMetadataId = _apiMapResponse['content_metadata_id'];
      _contentMetadataIdSet = true;
    }
    return _contentMetadataId;
  }

  set contentMetadataId(int v) {
    _contentMetadataId = v;
    _contentMetadataIdSet = true;
  }

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Look Title

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// User Id

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  /// Content Favorite Id (read-only)

  int get contentFavoriteId {
    if (!_contentFavoriteIdSet &&
        _apiMapResponse.containsKey('content_favorite_id')) {
      _contentFavoriteId = _apiMapResponse['content_favorite_id'];
      _contentFavoriteIdSet = true;
    }
    return _contentFavoriteId;
  }

  set contentFavoriteId(int v) {
    _contentFavoriteId = v;
    _contentFavoriteIdSet = true;
  }

  /// Time that the Look was created. (read-only)

  DateTime get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['created_at']);
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(DateTime v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// Whether or not a look is 'soft' deleted.

  bool get deleted {
    if (!_deletedSet && _apiMapResponse.containsKey('deleted')) {
      _deleted = _apiMapResponse['deleted'];
      _deletedSet = true;
    }
    return _deleted;
  }

  set deleted(bool v) {
    _deleted = v;
    _deletedSet = true;
  }

  /// Time that the Look was deleted. (read-only)

  DateTime get deletedAt {
    if (!_deletedAtSet && _apiMapResponse.containsKey('deleted_at')) {
      _deletedAt = _apiMapResponse['deleted_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['deleted_at']);
      _deletedAtSet = true;
    }
    return _deletedAt;
  }

  set deletedAt(DateTime v) {
    _deletedAt = v;
    _deletedAtSet = true;
  }

  /// Id of User that deleted the look. (read-only)

  int get deleterId {
    if (!_deleterIdSet && _apiMapResponse.containsKey('deleter_id')) {
      _deleterId = _apiMapResponse['deleter_id'];
      _deleterIdSet = true;
    }
    return _deleterId;
  }

  set deleterId(int v) {
    _deleterId = v;
    _deleterIdSet = true;
  }

  /// Description

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Embed Url (read-only)

  String get embedUrl {
    if (!_embedUrlSet && _apiMapResponse.containsKey('embed_url')) {
      _embedUrl = _apiMapResponse['embed_url']?.toString();
      _embedUrlSet = true;
    }
    return _embedUrl;
  }

  set embedUrl(String v) {
    _embedUrl = v;
    _embedUrlSet = true;
  }

  /// Excel File Url (read-only)

  String get excelFileUrl {
    if (!_excelFileUrlSet && _apiMapResponse.containsKey('excel_file_url')) {
      _excelFileUrl = _apiMapResponse['excel_file_url']?.toString();
      _excelFileUrlSet = true;
    }
    return _excelFileUrl;
  }

  set excelFileUrl(String v) {
    _excelFileUrl = v;
    _excelFileUrlSet = true;
  }

  /// Number of times favorited (read-only)

  int get favoriteCount {
    if (!_favoriteCountSet && _apiMapResponse.containsKey('favorite_count')) {
      _favoriteCount = _apiMapResponse['favorite_count'];
      _favoriteCountSet = true;
    }
    return _favoriteCount;
  }

  set favoriteCount(int v) {
    _favoriteCount = v;
    _favoriteCountSet = true;
  }

  /// Google Spreadsheet Formula (read-only)

  String get googleSpreadsheetFormula {
    if (!_googleSpreadsheetFormulaSet &&
        _apiMapResponse.containsKey('google_spreadsheet_formula')) {
      _googleSpreadsheetFormula =
          _apiMapResponse['google_spreadsheet_formula']?.toString();
      _googleSpreadsheetFormulaSet = true;
    }
    return _googleSpreadsheetFormula;
  }

  set googleSpreadsheetFormula(String v) {
    _googleSpreadsheetFormula = v;
    _googleSpreadsheetFormulaSet = true;
  }

  /// Image Embed Url (read-only)

  String get imageEmbedUrl {
    if (!_imageEmbedUrlSet && _apiMapResponse.containsKey('image_embed_url')) {
      _imageEmbedUrl = _apiMapResponse['image_embed_url']?.toString();
      _imageEmbedUrlSet = true;
    }
    return _imageEmbedUrl;
  }

  set imageEmbedUrl(String v) {
    _imageEmbedUrl = v;
    _imageEmbedUrlSet = true;
  }

  /// auto-run query when Look viewed

  bool get isRunOnLoad {
    if (!_isRunOnLoadSet && _apiMapResponse.containsKey('is_run_on_load')) {
      _isRunOnLoad = _apiMapResponse['is_run_on_load'];
      _isRunOnLoadSet = true;
    }
    return _isRunOnLoad;
  }

  set isRunOnLoad(bool v) {
    _isRunOnLoad = v;
    _isRunOnLoadSet = true;
  }

  /// Time that the Look was last accessed by any user (read-only)

  DateTime get lastAccessedAt {
    if (!_lastAccessedAtSet &&
        _apiMapResponse.containsKey('last_accessed_at')) {
      _lastAccessedAt = _apiMapResponse['last_accessed_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['last_accessed_at']);
      _lastAccessedAtSet = true;
    }
    return _lastAccessedAt;
  }

  set lastAccessedAt(DateTime v) {
    _lastAccessedAt = v;
    _lastAccessedAtSet = true;
  }

  /// Id of User that last updated the look. (read-only)

  int get lastUpdaterId {
    if (!_lastUpdaterIdSet && _apiMapResponse.containsKey('last_updater_id')) {
      _lastUpdaterId = _apiMapResponse['last_updater_id'];
      _lastUpdaterIdSet = true;
    }
    return _lastUpdaterId;
  }

  set lastUpdaterId(int v) {
    _lastUpdaterId = v;
    _lastUpdaterIdSet = true;
  }

  /// Time last viewed in the Looker web UI (read-only)

  DateTime get lastViewedAt {
    if (!_lastViewedAtSet && _apiMapResponse.containsKey('last_viewed_at')) {
      _lastViewedAt = _apiMapResponse['last_viewed_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['last_viewed_at']);
      _lastViewedAtSet = true;
    }
    return _lastViewedAt;
  }

  set lastViewedAt(DateTime v) {
    _lastViewedAt = v;
    _lastViewedAtSet = true;
  }

  LookModel get model {
    if (!_modelSet && _apiMapResponse.containsKey('model')) {
      _model = _apiMapResponse['model'] == null
          ? null
          : LookModel.fromResponse(
              _apiMapResponse['model'], apiResponseContentType);
      _modelSet = true;
    }
    return _model;
  }

  set model(LookModel v) {
    _model = v;
    _modelSet = true;
  }

  /// Is Public

  bool get public {
    if (!_publicSet && _apiMapResponse.containsKey('public')) {
      _public = _apiMapResponse['public'];
      _publicSet = true;
    }
    return _public;
  }

  set public(bool v) {
    _public = v;
    _publicSet = true;
  }

  /// Public Slug (read-only)

  String get publicSlug {
    if (!_publicSlugSet && _apiMapResponse.containsKey('public_slug')) {
      _publicSlug = _apiMapResponse['public_slug']?.toString();
      _publicSlugSet = true;
    }
    return _publicSlug;
  }

  set publicSlug(String v) {
    _publicSlug = v;
    _publicSlugSet = true;
  }

  /// Public Url (read-only)

  String get publicUrl {
    if (!_publicUrlSet && _apiMapResponse.containsKey('public_url')) {
      _publicUrl = _apiMapResponse['public_url']?.toString();
      _publicUrlSet = true;
    }
    return _publicUrl;
  }

  set publicUrl(String v) {
    _publicUrl = v;
    _publicUrlSet = true;
  }

  /// Query Id

  int get queryId {
    if (!_queryIdSet && _apiMapResponse.containsKey('query_id')) {
      _queryId = _apiMapResponse['query_id'];
      _queryIdSet = true;
    }
    return _queryId;
  }

  set queryId(int v) {
    _queryId = v;
    _queryIdSet = true;
  }

  /// Short Url (read-only)

  String get shortUrl {
    if (!_shortUrlSet && _apiMapResponse.containsKey('short_url')) {
      _shortUrl = _apiMapResponse['short_url']?.toString();
      _shortUrlSet = true;
    }
    return _shortUrl;
  }

  set shortUrl(String v) {
    _shortUrl = v;
    _shortUrlSet = true;
  }

  FolderBase get folder {
    if (!_folderSet && _apiMapResponse.containsKey('folder')) {
      _folder = _apiMapResponse['folder'] == null
          ? null
          : FolderBase.fromResponse(
              _apiMapResponse['folder'], apiResponseContentType);
      _folderSet = true;
    }
    return _folder;
  }

  set folder(FolderBase v) {
    _folder = v;
    _folderSet = true;
  }

  /// Folder Id

  String get folderId {
    if (!_folderIdSet && _apiMapResponse.containsKey('folder_id')) {
      _folderId = _apiMapResponse['folder_id']?.toString();
      _folderIdSet = true;
    }
    return _folderId;
  }

  set folderId(String v) {
    _folderId = v;
    _folderIdSet = true;
  }

  /// Time that the Look was updated. (read-only)

  DateTime get updatedAt {
    if (!_updatedAtSet && _apiMapResponse.containsKey('updated_at')) {
      _updatedAt = _apiMapResponse['updated_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['updated_at']);
      _updatedAtSet = true;
    }
    return _updatedAt;
  }

  set updatedAt(DateTime v) {
    _updatedAt = v;
    _updatedAtSet = true;
  }

  /// Number of times viewed in the Looker web UI (read-only)

  int get viewCount {
    if (!_viewCountSet && _apiMapResponse.containsKey('view_count')) {
      _viewCount = _apiMapResponse['view_count'];
      _viewCountSet = true;
    }
    return _viewCount;
  }

  set viewCount(int v) {
    _viewCount = v;
    _viewCountSet = true;
  }

  Query get query {
    if (!_querySet && _apiMapResponse.containsKey('query')) {
      _query = _apiMapResponse['query'] == null
          ? null
          : Query.fromResponse(
              _apiMapResponse['query'], apiResponseContentType);
      _querySet = true;
    }
    return _query;
  }

  set query(Query v) {
    _query = v;
    _querySet = true;
  }

  /// Url (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  LookWithQuery() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  LookWithQuery.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_contentMetadataIdSet ||
        _apiMapResponse.containsKey('content_metadata_id')) {
      json['content_metadata_id'] = contentMetadataId;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    if (_contentFavoriteIdSet ||
        _apiMapResponse.containsKey('content_favorite_id')) {
      json['content_favorite_id'] = contentFavoriteId;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt?.toIso8601String();
    }
    if (_deletedSet || _apiMapResponse.containsKey('deleted')) {
      json['deleted'] = deleted;
    }
    if (_deletedAtSet || _apiMapResponse.containsKey('deleted_at')) {
      json['deleted_at'] = deletedAt?.toIso8601String();
    }
    if (_deleterIdSet || _apiMapResponse.containsKey('deleter_id')) {
      json['deleter_id'] = deleterId;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_embedUrlSet || _apiMapResponse.containsKey('embed_url')) {
      json['embed_url'] = embedUrl;
    }
    if (_excelFileUrlSet || _apiMapResponse.containsKey('excel_file_url')) {
      json['excel_file_url'] = excelFileUrl;
    }
    if (_favoriteCountSet || _apiMapResponse.containsKey('favorite_count')) {
      json['favorite_count'] = favoriteCount;
    }
    if (_googleSpreadsheetFormulaSet ||
        _apiMapResponse.containsKey('google_spreadsheet_formula')) {
      json['google_spreadsheet_formula'] = googleSpreadsheetFormula;
    }
    if (_imageEmbedUrlSet || _apiMapResponse.containsKey('image_embed_url')) {
      json['image_embed_url'] = imageEmbedUrl;
    }
    if (_isRunOnLoadSet || _apiMapResponse.containsKey('is_run_on_load')) {
      json['is_run_on_load'] = isRunOnLoad;
    }
    if (_lastAccessedAtSet || _apiMapResponse.containsKey('last_accessed_at')) {
      json['last_accessed_at'] = lastAccessedAt?.toIso8601String();
    }
    if (_lastUpdaterIdSet || _apiMapResponse.containsKey('last_updater_id')) {
      json['last_updater_id'] = lastUpdaterId;
    }
    if (_lastViewedAtSet || _apiMapResponse.containsKey('last_viewed_at')) {
      json['last_viewed_at'] = lastViewedAt?.toIso8601String();
    }
    if (_modelSet || _apiMapResponse.containsKey('model')) {
      json['model'] = model?.toJson();
    }
    if (_publicSet || _apiMapResponse.containsKey('public')) {
      json['public'] = public;
    }
    if (_publicSlugSet || _apiMapResponse.containsKey('public_slug')) {
      json['public_slug'] = publicSlug;
    }
    if (_publicUrlSet || _apiMapResponse.containsKey('public_url')) {
      json['public_url'] = publicUrl;
    }
    if (_queryIdSet || _apiMapResponse.containsKey('query_id')) {
      json['query_id'] = queryId;
    }
    if (_shortUrlSet || _apiMapResponse.containsKey('short_url')) {
      json['short_url'] = shortUrl;
    }
    if (_folderSet || _apiMapResponse.containsKey('folder')) {
      json['folder'] = folder?.toJson();
    }
    if (_folderIdSet || _apiMapResponse.containsKey('folder_id')) {
      json['folder_id'] = folderId;
    }
    if (_updatedAtSet || _apiMapResponse.containsKey('updated_at')) {
      json['updated_at'] = updatedAt?.toIso8601String();
    }
    if (_viewCountSet || _apiMapResponse.containsKey('view_count')) {
      json['view_count'] = viewCount;
    }
    if (_querySet || _apiMapResponse.containsKey('query')) {
      json['query'] = query?.toJson();
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class Manifest {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _name;
  bool _nameSet = false;

  List<ImportedProject> _imports;
  bool _importsSet = false;

  LocalizationSettings _localizationSettings;
  bool _localizationSettingsSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Manifest project name (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Imports for a project (read-only)

  List<ImportedProject> get imports {
    if (!_importsSet && _apiMapResponse.containsKey('imports')) {
      _imports = _apiMapResponse['imports'] == null
          ? null
          : (_apiMapResponse['imports'] as List)
              .map((i) =>
                  ImportedProject.fromResponse(i, apiResponseContentType))
              .toList();
      _importsSet = true;
    }
    return _imports;
  }

  set imports(List<ImportedProject> v) {
    _imports = v;
    _importsSet = true;
  }

  LocalizationSettings get localizationSettings {
    if (!_localizationSettingsSet &&
        _apiMapResponse.containsKey('localization_settings')) {
      _localizationSettings = _apiMapResponse['localization_settings'] == null
          ? null
          : LocalizationSettings.fromResponse(
              _apiMapResponse['localization_settings'], apiResponseContentType);
      _localizationSettingsSet = true;
    }
    return _localizationSettings;
  }

  set localizationSettings(LocalizationSettings v) {
    _localizationSettings = v;
    _localizationSettingsSet = true;
  }

  Manifest() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Manifest.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_importsSet || _apiMapResponse.containsKey('imports')) {
      json['imports'] = imports?.map((i) => i.toJson())?.toList();
    }
    if (_localizationSettingsSet ||
        _apiMapResponse.containsKey('localization_settings')) {
      json['localization_settings'] = localizationSettings?.toJson();
    }
    return json;
  }
}

class MergeFields {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _fieldName;
  bool _fieldNameSet = false;

  String _sourceFieldName;
  bool _sourceFieldNameSet = false;

  /// Field name to map onto in the merged results

  String get fieldName {
    if (!_fieldNameSet && _apiMapResponse.containsKey('field_name')) {
      _fieldName = _apiMapResponse['field_name']?.toString();
      _fieldNameSet = true;
    }
    return _fieldName;
  }

  set fieldName(String v) {
    _fieldName = v;
    _fieldNameSet = true;
  }

  /// Field name from the source query

  String get sourceFieldName {
    if (!_sourceFieldNameSet &&
        _apiMapResponse.containsKey('source_field_name')) {
      _sourceFieldName = _apiMapResponse['source_field_name']?.toString();
      _sourceFieldNameSet = true;
    }
    return _sourceFieldName;
  }

  set sourceFieldName(String v) {
    _sourceFieldName = v;
    _sourceFieldNameSet = true;
  }

  MergeFields() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  MergeFields.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_fieldNameSet || _apiMapResponse.containsKey('field_name')) {
      json['field_name'] = fieldName;
    }
    if (_sourceFieldNameSet ||
        _apiMapResponse.containsKey('source_field_name')) {
      json['source_field_name'] = sourceFieldName;
    }
    return json;
  }
}

class MergeQuery {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _columnLimit;
  bool _columnLimitSet = false;

  String _dynamicFields;
  bool _dynamicFieldsSet = false;

  String _id;
  bool _idSet = false;

  List<String> _pivots;
  bool _pivotsSet = false;

  int _resultMakerId;
  bool _resultMakerIdSet = false;

  List<String> _sorts;
  bool _sortsSet = false;

  List<MergeQuerySourceQuery> _sourceQueries;
  bool _sourceQueriesSet = false;

  bool _total;
  bool _totalSet = false;

  Map<String, dynamic> _visConfig;
  bool _visConfigSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Column Limit

  String get columnLimit {
    if (!_columnLimitSet && _apiMapResponse.containsKey('column_limit')) {
      _columnLimit = _apiMapResponse['column_limit']?.toString();
      _columnLimitSet = true;
    }
    return _columnLimit;
  }

  set columnLimit(String v) {
    _columnLimit = v;
    _columnLimitSet = true;
  }

  /// Dynamic Fields

  String get dynamicFields {
    if (!_dynamicFieldsSet && _apiMapResponse.containsKey('dynamic_fields')) {
      _dynamicFields = _apiMapResponse['dynamic_fields']?.toString();
      _dynamicFieldsSet = true;
    }
    return _dynamicFields;
  }

  set dynamicFields(String v) {
    _dynamicFields = v;
    _dynamicFieldsSet = true;
  }

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Pivots

  List<String> get pivots {
    if (!_pivotsSet && _apiMapResponse.containsKey('pivots')) {
      _pivots =
          _apiMapResponse['pivots']?.map<String>((i) => i as String)?.toList();
      _pivotsSet = true;
    }
    return _pivots;
  }

  set pivots(List<String> v) {
    _pivots = v;
    _pivotsSet = true;
  }

  /// Unique to get results (read-only)

  int get resultMakerId {
    if (!_resultMakerIdSet && _apiMapResponse.containsKey('result_maker_id')) {
      _resultMakerId = _apiMapResponse['result_maker_id'];
      _resultMakerIdSet = true;
    }
    return _resultMakerId;
  }

  set resultMakerId(int v) {
    _resultMakerId = v;
    _resultMakerIdSet = true;
  }

  /// Sorts

  List<String> get sorts {
    if (!_sortsSet && _apiMapResponse.containsKey('sorts')) {
      _sorts =
          _apiMapResponse['sorts']?.map<String>((i) => i as String)?.toList();
      _sortsSet = true;
    }
    return _sorts;
  }

  set sorts(List<String> v) {
    _sorts = v;
    _sortsSet = true;
  }

  /// Source Queries defining the results to be merged.

  List<MergeQuerySourceQuery> get sourceQueries {
    if (!_sourceQueriesSet && _apiMapResponse.containsKey('source_queries')) {
      _sourceQueries = _apiMapResponse['source_queries'] == null
          ? null
          : (_apiMapResponse['source_queries'] as List)
              .map((i) =>
                  MergeQuerySourceQuery.fromResponse(i, apiResponseContentType))
              .toList();
      _sourceQueriesSet = true;
    }
    return _sourceQueries;
  }

  set sourceQueries(List<MergeQuerySourceQuery> v) {
    _sourceQueries = v;
    _sourceQueriesSet = true;
  }

  /// Total

  bool get total {
    if (!_totalSet && _apiMapResponse.containsKey('total')) {
      _total = _apiMapResponse['total'];
      _totalSet = true;
    }
    return _total;
  }

  set total(bool v) {
    _total = v;
    _totalSet = true;
  }

  /// Visualization Config

  Map<String, dynamic> get visConfig {
    if (!_visConfigSet && _apiMapResponse.containsKey('vis_config')) {
      _visConfig = _apiMapResponse['vis_config'];
      _visConfigSet = true;
    }
    return _visConfig;
  }

  set visConfig(Map<String, dynamic> v) {
    _visConfig = v;
    _visConfigSet = true;
  }

  MergeQuery() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  MergeQuery.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_columnLimitSet || _apiMapResponse.containsKey('column_limit')) {
      json['column_limit'] = columnLimit;
    }
    if (_dynamicFieldsSet || _apiMapResponse.containsKey('dynamic_fields')) {
      json['dynamic_fields'] = dynamicFields;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_pivotsSet || _apiMapResponse.containsKey('pivots')) {
      json['pivots'] = pivots;
    }
    if (_resultMakerIdSet || _apiMapResponse.containsKey('result_maker_id')) {
      json['result_maker_id'] = resultMakerId;
    }
    if (_sortsSet || _apiMapResponse.containsKey('sorts')) {
      json['sorts'] = sorts;
    }
    if (_sourceQueriesSet || _apiMapResponse.containsKey('source_queries')) {
      json['source_queries'] = sourceQueries?.map((i) => i.toJson())?.toList();
    }
    if (_totalSet || _apiMapResponse.containsKey('total')) {
      json['total'] = total;
    }
    if (_visConfigSet || _apiMapResponse.containsKey('vis_config')) {
      json['vis_config'] = visConfig;
    }
    return json;
  }
}

class MergeQuerySourceQuery {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  List<MergeFields> _mergeFields;
  bool _mergeFieldsSet = false;

  String _name;
  bool _nameSet = false;

  int _queryId;
  bool _queryIdSet = false;

  /// An array defining which fields of the source query are mapped onto fields of the merge query

  List<MergeFields> get mergeFields {
    if (!_mergeFieldsSet && _apiMapResponse.containsKey('merge_fields')) {
      _mergeFields = _apiMapResponse['merge_fields'] == null
          ? null
          : (_apiMapResponse['merge_fields'] as List)
              .map((i) => MergeFields.fromResponse(i, apiResponseContentType))
              .toList();
      _mergeFieldsSet = true;
    }
    return _mergeFields;
  }

  set mergeFields(List<MergeFields> v) {
    _mergeFields = v;
    _mergeFieldsSet = true;
  }

  /// Display name

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Id of the query to merge

  int get queryId {
    if (!_queryIdSet && _apiMapResponse.containsKey('query_id')) {
      _queryId = _apiMapResponse['query_id'];
      _queryIdSet = true;
    }
    return _queryId;
  }

  set queryId(int v) {
    _queryId = v;
    _queryIdSet = true;
  }

  MergeQuerySourceQuery() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  MergeQuerySourceQuery.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_mergeFieldsSet || _apiMapResponse.containsKey('merge_fields')) {
      json['merge_fields'] = mergeFields?.map((i) => i.toJson())?.toList();
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_queryIdSet || _apiMapResponse.containsKey('query_id')) {
      json['query_id'] = queryId;
    }
    return json;
  }
}

class MobileSettings {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _mobileForceAuthentication;
  bool _mobileForceAuthenticationSet = false;

  bool _mobileAppIntegration;
  bool _mobileAppIntegrationSet = false;

  /// Specifies whether the force authentication option is enabled for mobile (read-only)

  bool get mobileForceAuthentication {
    if (!_mobileForceAuthenticationSet &&
        _apiMapResponse.containsKey('mobile_force_authentication')) {
      _mobileForceAuthentication =
          _apiMapResponse['mobile_force_authentication'];
      _mobileForceAuthenticationSet = true;
    }
    return _mobileForceAuthentication;
  }

  set mobileForceAuthentication(bool v) {
    _mobileForceAuthentication = v;
    _mobileForceAuthenticationSet = true;
  }

  /// Specifies whether mobile access for this instance is enabled. (read-only)

  bool get mobileAppIntegration {
    if (!_mobileAppIntegrationSet &&
        _apiMapResponse.containsKey('mobile_app_integration')) {
      _mobileAppIntegration = _apiMapResponse['mobile_app_integration'];
      _mobileAppIntegrationSet = true;
    }
    return _mobileAppIntegration;
  }

  set mobileAppIntegration(bool v) {
    _mobileAppIntegration = v;
    _mobileAppIntegrationSet = true;
  }

  MobileSettings() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  MobileSettings.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_mobileForceAuthenticationSet ||
        _apiMapResponse.containsKey('mobile_force_authentication')) {
      json['mobile_force_authentication'] = mobileForceAuthentication;
    }
    if (_mobileAppIntegrationSet ||
        _apiMapResponse.containsKey('mobile_app_integration')) {
      json['mobile_app_integration'] = mobileAppIntegration;
    }
    return json;
  }
}

class Model {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _connection;
  bool _connectionSet = false;

  String _name;
  bool _nameSet = false;

  List<ModelNamedValueFormats> _valueFormats;
  bool _valueFormatsSet = false;

  ///  (read-only)

  String get connection {
    if (!_connectionSet && _apiMapResponse.containsKey('connection')) {
      _connection = _apiMapResponse['connection']?.toString();
      _connectionSet = true;
    }
    return _connection;
  }

  set connection(String v) {
    _connection = v;
    _connectionSet = true;
  }

  ///  (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Array of named value formats (read-only)

  List<ModelNamedValueFormats> get valueFormats {
    if (!_valueFormatsSet && _apiMapResponse.containsKey('value_formats')) {
      _valueFormats = _apiMapResponse['value_formats'] == null
          ? null
          : (_apiMapResponse['value_formats'] as List)
              .map((i) => ModelNamedValueFormats.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _valueFormatsSet = true;
    }
    return _valueFormats;
  }

  set valueFormats(List<ModelNamedValueFormats> v) {
    _valueFormats = v;
    _valueFormatsSet = true;
  }

  Model() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Model.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_connectionSet || _apiMapResponse.containsKey('connection')) {
      json['connection'] = connection;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_valueFormatsSet || _apiMapResponse.containsKey('value_formats')) {
      json['value_formats'] = valueFormats?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class ModelFieldSuggestions {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  List<String> _suggestions;
  bool _suggestionsSet = false;

  String _error;
  bool _errorSet = false;

  bool _fromCache;
  bool _fromCacheSet = false;

  bool _hitLimit;
  bool _hitLimitSet = false;

  bool _usedCalciteMaterialization;
  bool _usedCalciteMaterializationSet = false;

  /// List of suggestions (read-only)

  List<String> get suggestions {
    if (!_suggestionsSet && _apiMapResponse.containsKey('suggestions')) {
      _suggestions = _apiMapResponse['suggestions']
          ?.map<String>((i) => i as String)
          ?.toList();
      _suggestionsSet = true;
    }
    return _suggestions;
  }

  set suggestions(List<String> v) {
    _suggestions = v;
    _suggestionsSet = true;
  }

  /// Error message (read-only)

  String get error {
    if (!_errorSet && _apiMapResponse.containsKey('error')) {
      _error = _apiMapResponse['error']?.toString();
      _errorSet = true;
    }
    return _error;
  }

  set error(String v) {
    _error = v;
    _errorSet = true;
  }

  /// True if result came from the cache (read-only)

  bool get fromCache {
    if (!_fromCacheSet && _apiMapResponse.containsKey('from_cache')) {
      _fromCache = _apiMapResponse['from_cache'];
      _fromCacheSet = true;
    }
    return _fromCache;
  }

  set fromCache(bool v) {
    _fromCache = v;
    _fromCacheSet = true;
  }

  /// True if this was a hit limit (read-only)

  bool get hitLimit {
    if (!_hitLimitSet && _apiMapResponse.containsKey('hit_limit')) {
      _hitLimit = _apiMapResponse['hit_limit'];
      _hitLimitSet = true;
    }
    return _hitLimit;
  }

  set hitLimit(bool v) {
    _hitLimit = v;
    _hitLimitSet = true;
  }

  /// True if calcite was used (read-only)

  bool get usedCalciteMaterialization {
    if (!_usedCalciteMaterializationSet &&
        _apiMapResponse.containsKey('used_calcite_materialization')) {
      _usedCalciteMaterialization =
          _apiMapResponse['used_calcite_materialization'];
      _usedCalciteMaterializationSet = true;
    }
    return _usedCalciteMaterialization;
  }

  set usedCalciteMaterialization(bool v) {
    _usedCalciteMaterialization = v;
    _usedCalciteMaterializationSet = true;
  }

  ModelFieldSuggestions() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ModelFieldSuggestions.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_suggestionsSet || _apiMapResponse.containsKey('suggestions')) {
      json['suggestions'] = suggestions;
    }
    if (_errorSet || _apiMapResponse.containsKey('error')) {
      json['error'] = error;
    }
    if (_fromCacheSet || _apiMapResponse.containsKey('from_cache')) {
      json['from_cache'] = fromCache;
    }
    if (_hitLimitSet || _apiMapResponse.containsKey('hit_limit')) {
      json['hit_limit'] = hitLimit;
    }
    if (_usedCalciteMaterializationSet ||
        _apiMapResponse.containsKey('used_calcite_materialization')) {
      json['used_calcite_materialization'] = usedCalciteMaterialization;
    }
    return json;
  }
}

class ModelNamedValueFormats {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _formatString;
  bool _formatStringSet = false;

  String _label;
  bool _labelSet = false;

  String _name;
  bool _nameSet = false;

  bool _strictValueFormat;
  bool _strictValueFormatSet = false;

  ///  (read-only)

  String get formatString {
    if (!_formatStringSet && _apiMapResponse.containsKey('format_string')) {
      _formatString = _apiMapResponse['format_string']?.toString();
      _formatStringSet = true;
    }
    return _formatString;
  }

  set formatString(String v) {
    _formatString = v;
    _formatStringSet = true;
  }

  ///  (read-only)

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  ///  (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  ///  (read-only)

  bool get strictValueFormat {
    if (!_strictValueFormatSet &&
        _apiMapResponse.containsKey('strict_value_format')) {
      _strictValueFormat = _apiMapResponse['strict_value_format'];
      _strictValueFormatSet = true;
    }
    return _strictValueFormat;
  }

  set strictValueFormat(bool v) {
    _strictValueFormat = v;
    _strictValueFormatSet = true;
  }

  ModelNamedValueFormats() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ModelNamedValueFormats.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_formatStringSet || _apiMapResponse.containsKey('format_string')) {
      json['format_string'] = formatString;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_strictValueFormatSet ||
        _apiMapResponse.containsKey('strict_value_format')) {
      json['strict_value_format'] = strictValueFormat;
    }
    return json;
  }
}

class ModelSet {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  bool _allAccess;
  bool _allAccessSet = false;

  bool _builtIn;
  bool _builtInSet = false;

  int _id;
  bool _idSet = false;

  List<String> _models;
  bool _modelsSet = false;

  String _name;
  bool _nameSet = false;

  String _url;
  bool _urlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  ///  (read-only)

  bool get allAccess {
    if (!_allAccessSet && _apiMapResponse.containsKey('all_access')) {
      _allAccess = _apiMapResponse['all_access'];
      _allAccessSet = true;
    }
    return _allAccess;
  }

  set allAccess(bool v) {
    _allAccess = v;
    _allAccessSet = true;
  }

  ///  (read-only)

  bool get builtIn {
    if (!_builtInSet && _apiMapResponse.containsKey('built_in')) {
      _builtIn = _apiMapResponse['built_in'];
      _builtInSet = true;
    }
    return _builtIn;
  }

  set builtIn(bool v) {
    _builtIn = v;
    _builtInSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  List<String> get models {
    if (!_modelsSet && _apiMapResponse.containsKey('models')) {
      _models =
          _apiMapResponse['models']?.map<String>((i) => i as String)?.toList();
      _modelsSet = true;
    }
    return _models;
  }

  set models(List<String> v) {
    _models = v;
    _modelsSet = true;
  }

  /// Name of ModelSet

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  ModelSet() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ModelSet.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_allAccessSet || _apiMapResponse.containsKey('all_access')) {
      json['all_access'] = allAccess;
    }
    if (_builtInSet || _apiMapResponse.containsKey('built_in')) {
      json['built_in'] = builtIn;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_modelsSet || _apiMapResponse.containsKey('models')) {
      json['models'] = models;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class ModelsNotValidated {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _projectFileId;
  bool _projectFileIdSet = false;

  /// Model name (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Project file (read-only)

  String get projectFileId {
    if (!_projectFileIdSet && _apiMapResponse.containsKey('project_file_id')) {
      _projectFileId = _apiMapResponse['project_file_id']?.toString();
      _projectFileIdSet = true;
    }
    return _projectFileId;
  }

  set projectFileId(String v) {
    _projectFileId = v;
    _projectFileIdSet = true;
  }

  ModelsNotValidated() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ModelsNotValidated.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_projectFileIdSet || _apiMapResponse.containsKey('project_file_id')) {
      json['project_file_id'] = projectFileId;
    }
    return json;
  }
}

/// The type of time interval this field represents a grouping of. Valid values are: "day", "hour", "minute", "second", "millisecond", "microsecond", "week", "month", "quarter", "year". (Enum defined in LookmlModelExploreFieldTimeInterval)
enum Name {
  day,
  hour,
  minute,
  second,
  millisecond,
  microsecond,
  week,
  month,
  quarter,
  year
}

class NameMapper {
  static String toStringValue(Name e) {
    switch (e) {
      case Name.day:
        return 'day';
      case Name.hour:
        return 'hour';
      case Name.minute:
        return 'minute';
      case Name.second:
        return 'second';
      case Name.millisecond:
        return 'millisecond';
      case Name.microsecond:
        return 'microsecond';
      case Name.week:
        return 'week';
      case Name.month:
        return 'month';
      case Name.quarter:
        return 'quarter';
      case Name.year:
        return 'year';

      default:
        return null;
    }
  }

  static Name fromStringValue(String s) {
    if (s == 'day') {
      return Name.day;
    }
    if (s == 'hour') {
      return Name.hour;
    }
    if (s == 'minute') {
      return Name.minute;
    }
    if (s == 'second') {
      return Name.second;
    }
    if (s == 'millisecond') {
      return Name.millisecond;
    }
    if (s == 'microsecond') {
      return Name.microsecond;
    }
    if (s == 'week') {
      return Name.week;
    }
    if (s == 'month') {
      return Name.month;
    }
    if (s == 'quarter') {
      return Name.quarter;
    }
    if (s == 'year') {
      return Name.year;
    }
    return null;
  }
}

class OauthClientApp {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _clientGuid;
  bool _clientGuidSet = false;

  String _redirectUri;
  bool _redirectUriSet = false;

  String _displayName;
  bool _displayNameSet = false;

  String _description;
  bool _descriptionSet = false;

  bool _enabled;
  bool _enabledSet = false;

  int _groupId;
  bool _groupIdSet = false;

  DateTime _tokensInvalidBefore;
  bool _tokensInvalidBeforeSet = false;

  List<UserPublic> _activatedUsers;
  bool _activatedUsersSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// The globally unique id of this application (read-only)

  String get clientGuid {
    if (!_clientGuidSet && _apiMapResponse.containsKey('client_guid')) {
      _clientGuid = _apiMapResponse['client_guid']?.toString();
      _clientGuidSet = true;
    }
    return _clientGuid;
  }

  set clientGuid(String v) {
    _clientGuid = v;
    _clientGuidSet = true;
  }

  /// The uri with which this application will receive an auth code by browser redirect.

  String get redirectUri {
    if (!_redirectUriSet && _apiMapResponse.containsKey('redirect_uri')) {
      _redirectUri = _apiMapResponse['redirect_uri']?.toString();
      _redirectUriSet = true;
    }
    return _redirectUri;
  }

  set redirectUri(String v) {
    _redirectUri = v;
    _redirectUriSet = true;
  }

  /// The application's display name

  String get displayName {
    if (!_displayNameSet && _apiMapResponse.containsKey('display_name')) {
      _displayName = _apiMapResponse['display_name']?.toString();
      _displayNameSet = true;
    }
    return _displayName;
  }

  set displayName(String v) {
    _displayName = v;
    _displayNameSet = true;
  }

  /// A description of the application that will be displayed to users

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// When enabled is true, OAuth2 and API requests will be accepted from this app. When false, all requests from this app will be refused.

  bool get enabled {
    if (!_enabledSet && _apiMapResponse.containsKey('enabled')) {
      _enabled = _apiMapResponse['enabled'];
      _enabledSet = true;
    }
    return _enabled;
  }

  set enabled(bool v) {
    _enabled = v;
    _enabledSet = true;
  }

  /// If set, only Looker users who are members of this group can use this web app with Looker. If group_id is not set, any Looker user may use this app to access this Looker instance

  int get groupId {
    if (!_groupIdSet && _apiMapResponse.containsKey('group_id')) {
      _groupId = _apiMapResponse['group_id'];
      _groupIdSet = true;
    }
    return _groupId;
  }

  set groupId(int v) {
    _groupId = v;
    _groupIdSet = true;
  }

  /// All auth codes, access tokens, and refresh tokens issued for this application prior to this date-time for ALL USERS will be invalid. (read-only)

  DateTime get tokensInvalidBefore {
    if (!_tokensInvalidBeforeSet &&
        _apiMapResponse.containsKey('tokens_invalid_before')) {
      _tokensInvalidBefore = _apiMapResponse['tokens_invalid_before'] == null
          ? null
          : DateTime.parse(_apiMapResponse['tokens_invalid_before']);
      _tokensInvalidBeforeSet = true;
    }
    return _tokensInvalidBefore;
  }

  set tokensInvalidBefore(DateTime v) {
    _tokensInvalidBefore = v;
    _tokensInvalidBeforeSet = true;
  }

  /// All users who have been activated to use this app (read-only)

  List<UserPublic> get activatedUsers {
    if (!_activatedUsersSet && _apiMapResponse.containsKey('activated_users')) {
      _activatedUsers = _apiMapResponse['activated_users'] == null
          ? null
          : (_apiMapResponse['activated_users'] as List)
              .map((i) => UserPublic.fromResponse(i, apiResponseContentType))
              .toList();
      _activatedUsersSet = true;
    }
    return _activatedUsers;
  }

  set activatedUsers(List<UserPublic> v) {
    _activatedUsers = v;
    _activatedUsersSet = true;
  }

  OauthClientApp() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  OauthClientApp.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_clientGuidSet || _apiMapResponse.containsKey('client_guid')) {
      json['client_guid'] = clientGuid;
    }
    if (_redirectUriSet || _apiMapResponse.containsKey('redirect_uri')) {
      json['redirect_uri'] = redirectUri;
    }
    if (_displayNameSet || _apiMapResponse.containsKey('display_name')) {
      json['display_name'] = displayName;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_enabledSet || _apiMapResponse.containsKey('enabled')) {
      json['enabled'] = enabled;
    }
    if (_groupIdSet || _apiMapResponse.containsKey('group_id')) {
      json['group_id'] = groupId;
    }
    if (_tokensInvalidBeforeSet ||
        _apiMapResponse.containsKey('tokens_invalid_before')) {
      json['tokens_invalid_before'] = tokensInvalidBefore?.toIso8601String();
    }
    if (_activatedUsersSet || _apiMapResponse.containsKey('activated_users')) {
      json['activated_users'] =
          activatedUsers?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class OIDCConfig {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  bool _alternateEmailLoginAllowed;
  bool _alternateEmailLoginAllowedSet = false;

  String _audience;
  bool _audienceSet = false;

  bool _authRequiresRole;
  bool _authRequiresRoleSet = false;

  String _authorizationEndpoint;
  bool _authorizationEndpointSet = false;

  List<int> _defaultNewUserGroupIds;
  bool _defaultNewUserGroupIdsSet = false;

  List<Group> _defaultNewUserGroups;
  bool _defaultNewUserGroupsSet = false;

  List<int> _defaultNewUserRoleIds;
  bool _defaultNewUserRoleIdsSet = false;

  List<Role> _defaultNewUserRoles;
  bool _defaultNewUserRolesSet = false;

  bool _enabled;
  bool _enabledSet = false;

  List<OIDCGroupRead> _groups;
  bool _groupsSet = false;

  String _groupsAttribute;
  bool _groupsAttributeSet = false;

  List<OIDCGroupWrite> _groupsWithRoleIds;
  bool _groupsWithRoleIdsSet = false;

  String _identifier;
  bool _identifierSet = false;

  String _issuer;
  bool _issuerSet = false;

  DateTime _modifiedAt;
  bool _modifiedAtSet = false;

  int _modifiedBy;
  bool _modifiedBySet = false;

  String _newUserMigrationTypes;
  bool _newUserMigrationTypesSet = false;

  List<String> _scopes;
  bool _scopesSet = false;

  String _secret;
  bool _secretSet = false;

  bool _setRolesFromGroups;
  bool _setRolesFromGroupsSet = false;

  String _testSlug;
  bool _testSlugSet = false;

  String _tokenEndpoint;
  bool _tokenEndpointSet = false;

  String _userAttributeMapEmail;
  bool _userAttributeMapEmailSet = false;

  String _userAttributeMapFirstName;
  bool _userAttributeMapFirstNameSet = false;

  String _userAttributeMapLastName;
  bool _userAttributeMapLastNameSet = false;

  List<OIDCUserAttributeRead> _userAttributes;
  bool _userAttributesSet = false;

  List<OIDCUserAttributeWrite> _userAttributesWithIds;
  bool _userAttributesWithIdsSet = false;

  String _userinfoEndpoint;
  bool _userinfoEndpointSet = false;

  bool _allowNormalGroupMembership;
  bool _allowNormalGroupMembershipSet = false;

  bool _allowRolesFromNormalGroups;
  bool _allowRolesFromNormalGroupsSet = false;

  bool _allowDirectRoles;
  bool _allowDirectRolesSet = false;

  String _url;
  bool _urlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.

  bool get alternateEmailLoginAllowed {
    if (!_alternateEmailLoginAllowedSet &&
        _apiMapResponse.containsKey('alternate_email_login_allowed')) {
      _alternateEmailLoginAllowed =
          _apiMapResponse['alternate_email_login_allowed'];
      _alternateEmailLoginAllowedSet = true;
    }
    return _alternateEmailLoginAllowed;
  }

  set alternateEmailLoginAllowed(bool v) {
    _alternateEmailLoginAllowed = v;
    _alternateEmailLoginAllowedSet = true;
  }

  /// OpenID Provider Audience

  String get audience {
    if (!_audienceSet && _apiMapResponse.containsKey('audience')) {
      _audience = _apiMapResponse['audience']?.toString();
      _audienceSet = true;
    }
    return _audience;
  }

  set audience(String v) {
    _audience = v;
    _audienceSet = true;
  }

  /// Users will not be allowed to login at all unless a role for them is found in OIDC if set to true

  bool get authRequiresRole {
    if (!_authRequiresRoleSet &&
        _apiMapResponse.containsKey('auth_requires_role')) {
      _authRequiresRole = _apiMapResponse['auth_requires_role'];
      _authRequiresRoleSet = true;
    }
    return _authRequiresRole;
  }

  set authRequiresRole(bool v) {
    _authRequiresRole = v;
    _authRequiresRoleSet = true;
  }

  /// OpenID Provider Authorization Url

  String get authorizationEndpoint {
    if (!_authorizationEndpointSet &&
        _apiMapResponse.containsKey('authorization_endpoint')) {
      _authorizationEndpoint =
          _apiMapResponse['authorization_endpoint']?.toString();
      _authorizationEndpointSet = true;
    }
    return _authorizationEndpoint;
  }

  set authorizationEndpoint(String v) {
    _authorizationEndpoint = v;
    _authorizationEndpointSet = true;
  }

  /// (Write-Only) Array of ids of groups that will be applied to new users the first time they login via OIDC

  List<int> get defaultNewUserGroupIds {
    if (!_defaultNewUserGroupIdsSet &&
        _apiMapResponse.containsKey('default_new_user_group_ids')) {
      _defaultNewUserGroupIds = _apiMapResponse['default_new_user_group_ids']
          ?.map<int>((i) => i as int)
          ?.toList();
      _defaultNewUserGroupIdsSet = true;
    }
    return _defaultNewUserGroupIds;
  }

  set defaultNewUserGroupIds(List<int> v) {
    _defaultNewUserGroupIds = v;
    _defaultNewUserGroupIdsSet = true;
  }

  /// (Read-only) Groups that will be applied to new users the first time they login via OIDC (read-only)

  List<Group> get defaultNewUserGroups {
    if (!_defaultNewUserGroupsSet &&
        _apiMapResponse.containsKey('default_new_user_groups')) {
      _defaultNewUserGroups = _apiMapResponse['default_new_user_groups'] == null
          ? null
          : (_apiMapResponse['default_new_user_groups'] as List)
              .map((i) => Group.fromResponse(i, apiResponseContentType))
              .toList();
      _defaultNewUserGroupsSet = true;
    }
    return _defaultNewUserGroups;
  }

  set defaultNewUserGroups(List<Group> v) {
    _defaultNewUserGroups = v;
    _defaultNewUserGroupsSet = true;
  }

  /// (Write-Only) Array of ids of roles that will be applied to new users the first time they login via OIDC

  List<int> get defaultNewUserRoleIds {
    if (!_defaultNewUserRoleIdsSet &&
        _apiMapResponse.containsKey('default_new_user_role_ids')) {
      _defaultNewUserRoleIds = _apiMapResponse['default_new_user_role_ids']
          ?.map<int>((i) => i as int)
          ?.toList();
      _defaultNewUserRoleIdsSet = true;
    }
    return _defaultNewUserRoleIds;
  }

  set defaultNewUserRoleIds(List<int> v) {
    _defaultNewUserRoleIds = v;
    _defaultNewUserRoleIdsSet = true;
  }

  /// (Read-only) Roles that will be applied to new users the first time they login via OIDC (read-only)

  List<Role> get defaultNewUserRoles {
    if (!_defaultNewUserRolesSet &&
        _apiMapResponse.containsKey('default_new_user_roles')) {
      _defaultNewUserRoles = _apiMapResponse['default_new_user_roles'] == null
          ? null
          : (_apiMapResponse['default_new_user_roles'] as List)
              .map((i) => Role.fromResponse(i, apiResponseContentType))
              .toList();
      _defaultNewUserRolesSet = true;
    }
    return _defaultNewUserRoles;
  }

  set defaultNewUserRoles(List<Role> v) {
    _defaultNewUserRoles = v;
    _defaultNewUserRolesSet = true;
  }

  /// Enable/Disable OIDC authentication for the server

  bool get enabled {
    if (!_enabledSet && _apiMapResponse.containsKey('enabled')) {
      _enabled = _apiMapResponse['enabled'];
      _enabledSet = true;
    }
    return _enabled;
  }

  set enabled(bool v) {
    _enabled = v;
    _enabledSet = true;
  }

  /// (Read-only) Array of mappings between OIDC Groups and Looker Roles (read-only)

  List<OIDCGroupRead> get groups {
    if (!_groupsSet && _apiMapResponse.containsKey('groups')) {
      _groups = _apiMapResponse['groups'] == null
          ? null
          : (_apiMapResponse['groups'] as List)
              .map((i) => OIDCGroupRead.fromResponse(i, apiResponseContentType))
              .toList();
      _groupsSet = true;
    }
    return _groups;
  }

  set groups(List<OIDCGroupRead> v) {
    _groups = v;
    _groupsSet = true;
  }

  /// Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'

  String get groupsAttribute {
    if (!_groupsAttributeSet &&
        _apiMapResponse.containsKey('groups_attribute')) {
      _groupsAttribute = _apiMapResponse['groups_attribute']?.toString();
      _groupsAttributeSet = true;
    }
    return _groupsAttribute;
  }

  set groupsAttribute(String v) {
    _groupsAttribute = v;
    _groupsAttributeSet = true;
  }

  /// (Read/Write) Array of mappings between OIDC Groups and arrays of Looker Role ids

  List<OIDCGroupWrite> get groupsWithRoleIds {
    if (!_groupsWithRoleIdsSet &&
        _apiMapResponse.containsKey('groups_with_role_ids')) {
      _groupsWithRoleIds = _apiMapResponse['groups_with_role_ids'] == null
          ? null
          : (_apiMapResponse['groups_with_role_ids'] as List)
              .map(
                  (i) => OIDCGroupWrite.fromResponse(i, apiResponseContentType))
              .toList();
      _groupsWithRoleIdsSet = true;
    }
    return _groupsWithRoleIds;
  }

  set groupsWithRoleIds(List<OIDCGroupWrite> v) {
    _groupsWithRoleIds = v;
    _groupsWithRoleIdsSet = true;
  }

  /// Relying Party Identifier (provided by OpenID Provider)

  String get identifier {
    if (!_identifierSet && _apiMapResponse.containsKey('identifier')) {
      _identifier = _apiMapResponse['identifier']?.toString();
      _identifierSet = true;
    }
    return _identifier;
  }

  set identifier(String v) {
    _identifier = v;
    _identifierSet = true;
  }

  /// OpenID Provider Issuer

  String get issuer {
    if (!_issuerSet && _apiMapResponse.containsKey('issuer')) {
      _issuer = _apiMapResponse['issuer']?.toString();
      _issuerSet = true;
    }
    return _issuer;
  }

  set issuer(String v) {
    _issuer = v;
    _issuerSet = true;
  }

  /// When this config was last modified (read-only)

  DateTime get modifiedAt {
    if (!_modifiedAtSet && _apiMapResponse.containsKey('modified_at')) {
      _modifiedAt = _apiMapResponse['modified_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['modified_at']);
      _modifiedAtSet = true;
    }
    return _modifiedAt;
  }

  set modifiedAt(DateTime v) {
    _modifiedAt = v;
    _modifiedAtSet = true;
  }

  /// User id of user who last modified this config (read-only)

  int get modifiedBy {
    if (!_modifiedBySet && _apiMapResponse.containsKey('modified_by')) {
      _modifiedBy = _apiMapResponse['modified_by'];
      _modifiedBySet = true;
    }
    return _modifiedBy;
  }

  set modifiedBy(int v) {
    _modifiedBy = v;
    _modifiedBySet = true;
  }

  /// Merge first-time oidc login to existing user account by email addresses. When a user logs in for the first time via oidc this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'

  String get newUserMigrationTypes {
    if (!_newUserMigrationTypesSet &&
        _apiMapResponse.containsKey('new_user_migration_types')) {
      _newUserMigrationTypes =
          _apiMapResponse['new_user_migration_types']?.toString();
      _newUserMigrationTypesSet = true;
    }
    return _newUserMigrationTypes;
  }

  set newUserMigrationTypes(String v) {
    _newUserMigrationTypes = v;
    _newUserMigrationTypesSet = true;
  }

  /// Array of scopes to request.

  List<String> get scopes {
    if (!_scopesSet && _apiMapResponse.containsKey('scopes')) {
      _scopes =
          _apiMapResponse['scopes']?.map<String>((i) => i as String)?.toList();
      _scopesSet = true;
    }
    return _scopes;
  }

  set scopes(List<String> v) {
    _scopes = v;
    _scopesSet = true;
  }

  /// (Write-Only) Relying Party Secret (provided by OpenID Provider)

  String get secret {
    if (!_secretSet && _apiMapResponse.containsKey('secret')) {
      _secret = _apiMapResponse['secret']?.toString();
      _secretSet = true;
    }
    return _secret;
  }

  set secret(String v) {
    _secret = v;
    _secretSet = true;
  }

  /// Set user roles in Looker based on groups from OIDC

  bool get setRolesFromGroups {
    if (!_setRolesFromGroupsSet &&
        _apiMapResponse.containsKey('set_roles_from_groups')) {
      _setRolesFromGroups = _apiMapResponse['set_roles_from_groups'];
      _setRolesFromGroupsSet = true;
    }
    return _setRolesFromGroups;
  }

  set setRolesFromGroups(bool v) {
    _setRolesFromGroups = v;
    _setRolesFromGroupsSet = true;
  }

  /// Slug to identify configurations that are created in order to run a OIDC config test (read-only)

  String get testSlug {
    if (!_testSlugSet && _apiMapResponse.containsKey('test_slug')) {
      _testSlug = _apiMapResponse['test_slug']?.toString();
      _testSlugSet = true;
    }
    return _testSlug;
  }

  set testSlug(String v) {
    _testSlug = v;
    _testSlugSet = true;
  }

  /// OpenID Provider Token Url

  String get tokenEndpoint {
    if (!_tokenEndpointSet && _apiMapResponse.containsKey('token_endpoint')) {
      _tokenEndpoint = _apiMapResponse['token_endpoint']?.toString();
      _tokenEndpointSet = true;
    }
    return _tokenEndpoint;
  }

  set tokenEndpoint(String v) {
    _tokenEndpoint = v;
    _tokenEndpointSet = true;
  }

  /// Name of user record attributes used to indicate email address field

  String get userAttributeMapEmail {
    if (!_userAttributeMapEmailSet &&
        _apiMapResponse.containsKey('user_attribute_map_email')) {
      _userAttributeMapEmail =
          _apiMapResponse['user_attribute_map_email']?.toString();
      _userAttributeMapEmailSet = true;
    }
    return _userAttributeMapEmail;
  }

  set userAttributeMapEmail(String v) {
    _userAttributeMapEmail = v;
    _userAttributeMapEmailSet = true;
  }

  /// Name of user record attributes used to indicate first name

  String get userAttributeMapFirstName {
    if (!_userAttributeMapFirstNameSet &&
        _apiMapResponse.containsKey('user_attribute_map_first_name')) {
      _userAttributeMapFirstName =
          _apiMapResponse['user_attribute_map_first_name']?.toString();
      _userAttributeMapFirstNameSet = true;
    }
    return _userAttributeMapFirstName;
  }

  set userAttributeMapFirstName(String v) {
    _userAttributeMapFirstName = v;
    _userAttributeMapFirstNameSet = true;
  }

  /// Name of user record attributes used to indicate last name

  String get userAttributeMapLastName {
    if (!_userAttributeMapLastNameSet &&
        _apiMapResponse.containsKey('user_attribute_map_last_name')) {
      _userAttributeMapLastName =
          _apiMapResponse['user_attribute_map_last_name']?.toString();
      _userAttributeMapLastNameSet = true;
    }
    return _userAttributeMapLastName;
  }

  set userAttributeMapLastName(String v) {
    _userAttributeMapLastName = v;
    _userAttributeMapLastNameSet = true;
  }

  /// (Read-only) Array of mappings between OIDC User Attributes and Looker User Attributes (read-only)

  List<OIDCUserAttributeRead> get userAttributes {
    if (!_userAttributesSet && _apiMapResponse.containsKey('user_attributes')) {
      _userAttributes = _apiMapResponse['user_attributes'] == null
          ? null
          : (_apiMapResponse['user_attributes'] as List)
              .map((i) =>
                  OIDCUserAttributeRead.fromResponse(i, apiResponseContentType))
              .toList();
      _userAttributesSet = true;
    }
    return _userAttributes;
  }

  set userAttributes(List<OIDCUserAttributeRead> v) {
    _userAttributes = v;
    _userAttributesSet = true;
  }

  /// (Read/Write) Array of mappings between OIDC User Attributes and arrays of Looker User Attribute ids

  List<OIDCUserAttributeWrite> get userAttributesWithIds {
    if (!_userAttributesWithIdsSet &&
        _apiMapResponse.containsKey('user_attributes_with_ids')) {
      _userAttributesWithIds =
          _apiMapResponse['user_attributes_with_ids'] == null
              ? null
              : (_apiMapResponse['user_attributes_with_ids'] as List)
                  .map((i) => OIDCUserAttributeWrite.fromResponse(
                      i, apiResponseContentType))
                  .toList();
      _userAttributesWithIdsSet = true;
    }
    return _userAttributesWithIds;
  }

  set userAttributesWithIds(List<OIDCUserAttributeWrite> v) {
    _userAttributesWithIds = v;
    _userAttributesWithIdsSet = true;
  }

  /// OpenID Provider User Information Url

  String get userinfoEndpoint {
    if (!_userinfoEndpointSet &&
        _apiMapResponse.containsKey('userinfo_endpoint')) {
      _userinfoEndpoint = _apiMapResponse['userinfo_endpoint']?.toString();
      _userinfoEndpointSet = true;
    }
    return _userinfoEndpoint;
  }

  set userinfoEndpoint(String v) {
    _userinfoEndpoint = v;
    _userinfoEndpointSet = true;
  }

  /// Allow OIDC auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.

  bool get allowNormalGroupMembership {
    if (!_allowNormalGroupMembershipSet &&
        _apiMapResponse.containsKey('allow_normal_group_membership')) {
      _allowNormalGroupMembership =
          _apiMapResponse['allow_normal_group_membership'];
      _allowNormalGroupMembershipSet = true;
    }
    return _allowNormalGroupMembership;
  }

  set allowNormalGroupMembership(bool v) {
    _allowNormalGroupMembership = v;
    _allowNormalGroupMembershipSet = true;
  }

  /// OIDC auth'd users will inherit roles from non-reflected Looker groups.

  bool get allowRolesFromNormalGroups {
    if (!_allowRolesFromNormalGroupsSet &&
        _apiMapResponse.containsKey('allow_roles_from_normal_groups')) {
      _allowRolesFromNormalGroups =
          _apiMapResponse['allow_roles_from_normal_groups'];
      _allowRolesFromNormalGroupsSet = true;
    }
    return _allowRolesFromNormalGroups;
  }

  set allowRolesFromNormalGroups(bool v) {
    _allowRolesFromNormalGroups = v;
    _allowRolesFromNormalGroupsSet = true;
  }

  /// Allows roles to be directly assigned to OIDC auth'd users.

  bool get allowDirectRoles {
    if (!_allowDirectRolesSet &&
        _apiMapResponse.containsKey('allow_direct_roles')) {
      _allowDirectRoles = _apiMapResponse['allow_direct_roles'];
      _allowDirectRolesSet = true;
    }
    return _allowDirectRoles;
  }

  set allowDirectRoles(bool v) {
    _allowDirectRoles = v;
    _allowDirectRolesSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  OIDCConfig() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  OIDCConfig.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_alternateEmailLoginAllowedSet ||
        _apiMapResponse.containsKey('alternate_email_login_allowed')) {
      json['alternate_email_login_allowed'] = alternateEmailLoginAllowed;
    }
    if (_audienceSet || _apiMapResponse.containsKey('audience')) {
      json['audience'] = audience;
    }
    if (_authRequiresRoleSet ||
        _apiMapResponse.containsKey('auth_requires_role')) {
      json['auth_requires_role'] = authRequiresRole;
    }
    if (_authorizationEndpointSet ||
        _apiMapResponse.containsKey('authorization_endpoint')) {
      json['authorization_endpoint'] = authorizationEndpoint;
    }
    if (_defaultNewUserGroupIdsSet ||
        _apiMapResponse.containsKey('default_new_user_group_ids')) {
      json['default_new_user_group_ids'] = defaultNewUserGroupIds;
    }
    if (_defaultNewUserGroupsSet ||
        _apiMapResponse.containsKey('default_new_user_groups')) {
      json['default_new_user_groups'] =
          defaultNewUserGroups?.map((i) => i.toJson())?.toList();
    }
    if (_defaultNewUserRoleIdsSet ||
        _apiMapResponse.containsKey('default_new_user_role_ids')) {
      json['default_new_user_role_ids'] = defaultNewUserRoleIds;
    }
    if (_defaultNewUserRolesSet ||
        _apiMapResponse.containsKey('default_new_user_roles')) {
      json['default_new_user_roles'] =
          defaultNewUserRoles?.map((i) => i.toJson())?.toList();
    }
    if (_enabledSet || _apiMapResponse.containsKey('enabled')) {
      json['enabled'] = enabled;
    }
    if (_groupsSet || _apiMapResponse.containsKey('groups')) {
      json['groups'] = groups?.map((i) => i.toJson())?.toList();
    }
    if (_groupsAttributeSet ||
        _apiMapResponse.containsKey('groups_attribute')) {
      json['groups_attribute'] = groupsAttribute;
    }
    if (_groupsWithRoleIdsSet ||
        _apiMapResponse.containsKey('groups_with_role_ids')) {
      json['groups_with_role_ids'] =
          groupsWithRoleIds?.map((i) => i.toJson())?.toList();
    }
    if (_identifierSet || _apiMapResponse.containsKey('identifier')) {
      json['identifier'] = identifier;
    }
    if (_issuerSet || _apiMapResponse.containsKey('issuer')) {
      json['issuer'] = issuer;
    }
    if (_modifiedAtSet || _apiMapResponse.containsKey('modified_at')) {
      json['modified_at'] = modifiedAt?.toIso8601String();
    }
    if (_modifiedBySet || _apiMapResponse.containsKey('modified_by')) {
      json['modified_by'] = modifiedBy;
    }
    if (_newUserMigrationTypesSet ||
        _apiMapResponse.containsKey('new_user_migration_types')) {
      json['new_user_migration_types'] = newUserMigrationTypes;
    }
    if (_scopesSet || _apiMapResponse.containsKey('scopes')) {
      json['scopes'] = scopes;
    }
    if (_secretSet || _apiMapResponse.containsKey('secret')) {
      json['secret'] = secret;
    }
    if (_setRolesFromGroupsSet ||
        _apiMapResponse.containsKey('set_roles_from_groups')) {
      json['set_roles_from_groups'] = setRolesFromGroups;
    }
    if (_testSlugSet || _apiMapResponse.containsKey('test_slug')) {
      json['test_slug'] = testSlug;
    }
    if (_tokenEndpointSet || _apiMapResponse.containsKey('token_endpoint')) {
      json['token_endpoint'] = tokenEndpoint;
    }
    if (_userAttributeMapEmailSet ||
        _apiMapResponse.containsKey('user_attribute_map_email')) {
      json['user_attribute_map_email'] = userAttributeMapEmail;
    }
    if (_userAttributeMapFirstNameSet ||
        _apiMapResponse.containsKey('user_attribute_map_first_name')) {
      json['user_attribute_map_first_name'] = userAttributeMapFirstName;
    }
    if (_userAttributeMapLastNameSet ||
        _apiMapResponse.containsKey('user_attribute_map_last_name')) {
      json['user_attribute_map_last_name'] = userAttributeMapLastName;
    }
    if (_userAttributesSet || _apiMapResponse.containsKey('user_attributes')) {
      json['user_attributes'] =
          userAttributes?.map((i) => i.toJson())?.toList();
    }
    if (_userAttributesWithIdsSet ||
        _apiMapResponse.containsKey('user_attributes_with_ids')) {
      json['user_attributes_with_ids'] =
          userAttributesWithIds?.map((i) => i.toJson())?.toList();
    }
    if (_userinfoEndpointSet ||
        _apiMapResponse.containsKey('userinfo_endpoint')) {
      json['userinfo_endpoint'] = userinfoEndpoint;
    }
    if (_allowNormalGroupMembershipSet ||
        _apiMapResponse.containsKey('allow_normal_group_membership')) {
      json['allow_normal_group_membership'] = allowNormalGroupMembership;
    }
    if (_allowRolesFromNormalGroupsSet ||
        _apiMapResponse.containsKey('allow_roles_from_normal_groups')) {
      json['allow_roles_from_normal_groups'] = allowRolesFromNormalGroups;
    }
    if (_allowDirectRolesSet ||
        _apiMapResponse.containsKey('allow_direct_roles')) {
      json['allow_direct_roles'] = allowDirectRoles;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class OIDCGroupRead {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _id;
  bool _idSet = false;

  int _lookerGroupId;
  bool _lookerGroupIdSet = false;

  String _lookerGroupName;
  bool _lookerGroupNameSet = false;

  String _name;
  bool _nameSet = false;

  List<Role> _roles;
  bool _rolesSet = false;

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Unique Id of group in Looker (read-only)

  int get lookerGroupId {
    if (!_lookerGroupIdSet && _apiMapResponse.containsKey('looker_group_id')) {
      _lookerGroupId = _apiMapResponse['looker_group_id'];
      _lookerGroupIdSet = true;
    }
    return _lookerGroupId;
  }

  set lookerGroupId(int v) {
    _lookerGroupId = v;
    _lookerGroupIdSet = true;
  }

  /// Name of group in Looker (read-only)

  String get lookerGroupName {
    if (!_lookerGroupNameSet &&
        _apiMapResponse.containsKey('looker_group_name')) {
      _lookerGroupName = _apiMapResponse['looker_group_name']?.toString();
      _lookerGroupNameSet = true;
    }
    return _lookerGroupName;
  }

  set lookerGroupName(String v) {
    _lookerGroupName = v;
    _lookerGroupNameSet = true;
  }

  /// Name of group in OIDC (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Looker Roles (read-only)

  List<Role> get roles {
    if (!_rolesSet && _apiMapResponse.containsKey('roles')) {
      _roles = _apiMapResponse['roles'] == null
          ? null
          : (_apiMapResponse['roles'] as List)
              .map((i) => Role.fromResponse(i, apiResponseContentType))
              .toList();
      _rolesSet = true;
    }
    return _roles;
  }

  set roles(List<Role> v) {
    _roles = v;
    _rolesSet = true;
  }

  OIDCGroupRead() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  OIDCGroupRead.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_lookerGroupIdSet || _apiMapResponse.containsKey('looker_group_id')) {
      json['looker_group_id'] = lookerGroupId;
    }
    if (_lookerGroupNameSet ||
        _apiMapResponse.containsKey('looker_group_name')) {
      json['looker_group_name'] = lookerGroupName;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_rolesSet || _apiMapResponse.containsKey('roles')) {
      json['roles'] = roles?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class OIDCGroupWrite {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _id;
  bool _idSet = false;

  int _lookerGroupId;
  bool _lookerGroupIdSet = false;

  String _lookerGroupName;
  bool _lookerGroupNameSet = false;

  String _name;
  bool _nameSet = false;

  List<int> _roleIds;
  bool _roleIdsSet = false;

  /// Unique Id

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Unique Id of group in Looker (read-only)

  int get lookerGroupId {
    if (!_lookerGroupIdSet && _apiMapResponse.containsKey('looker_group_id')) {
      _lookerGroupId = _apiMapResponse['looker_group_id'];
      _lookerGroupIdSet = true;
    }
    return _lookerGroupId;
  }

  set lookerGroupId(int v) {
    _lookerGroupId = v;
    _lookerGroupIdSet = true;
  }

  /// Name of group in Looker

  String get lookerGroupName {
    if (!_lookerGroupNameSet &&
        _apiMapResponse.containsKey('looker_group_name')) {
      _lookerGroupName = _apiMapResponse['looker_group_name']?.toString();
      _lookerGroupNameSet = true;
    }
    return _lookerGroupName;
  }

  set lookerGroupName(String v) {
    _lookerGroupName = v;
    _lookerGroupNameSet = true;
  }

  /// Name of group in OIDC

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Looker Role Ids

  List<int> get roleIds {
    if (!_roleIdsSet && _apiMapResponse.containsKey('role_ids')) {
      _roleIds =
          _apiMapResponse['role_ids']?.map<int>((i) => i as int)?.toList();
      _roleIdsSet = true;
    }
    return _roleIds;
  }

  set roleIds(List<int> v) {
    _roleIds = v;
    _roleIdsSet = true;
  }

  OIDCGroupWrite() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  OIDCGroupWrite.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_lookerGroupIdSet || _apiMapResponse.containsKey('looker_group_id')) {
      json['looker_group_id'] = lookerGroupId;
    }
    if (_lookerGroupNameSet ||
        _apiMapResponse.containsKey('looker_group_name')) {
      json['looker_group_name'] = lookerGroupName;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_roleIdsSet || _apiMapResponse.containsKey('role_ids')) {
      json['role_ids'] = roleIds;
    }
    return json;
  }
}

class OIDCUserAttributeRead {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  bool _required;
  bool _requiredSet = false;

  List<UserAttribute> _userAttributes;
  bool _userAttributesSet = false;

  /// Name of User Attribute in OIDC (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Required to be in OIDC assertion for login to be allowed to succeed (read-only)

  bool get required {
    if (!_requiredSet && _apiMapResponse.containsKey('required')) {
      _required = _apiMapResponse['required'];
      _requiredSet = true;
    }
    return _required;
  }

  set required(bool v) {
    _required = v;
    _requiredSet = true;
  }

  /// Looker User Attributes (read-only)

  List<UserAttribute> get userAttributes {
    if (!_userAttributesSet && _apiMapResponse.containsKey('user_attributes')) {
      _userAttributes = _apiMapResponse['user_attributes'] == null
          ? null
          : (_apiMapResponse['user_attributes'] as List)
              .map((i) => UserAttribute.fromResponse(i, apiResponseContentType))
              .toList();
      _userAttributesSet = true;
    }
    return _userAttributes;
  }

  set userAttributes(List<UserAttribute> v) {
    _userAttributes = v;
    _userAttributesSet = true;
  }

  OIDCUserAttributeRead() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  OIDCUserAttributeRead.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_requiredSet || _apiMapResponse.containsKey('required')) {
      json['required'] = required;
    }
    if (_userAttributesSet || _apiMapResponse.containsKey('user_attributes')) {
      json['user_attributes'] =
          userAttributes?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class OIDCUserAttributeWrite {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  bool _required;
  bool _requiredSet = false;

  List<int> _userAttributeIds;
  bool _userAttributeIdsSet = false;

  /// Name of User Attribute in OIDC

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Required to be in OIDC assertion for login to be allowed to succeed

  bool get required {
    if (!_requiredSet && _apiMapResponse.containsKey('required')) {
      _required = _apiMapResponse['required'];
      _requiredSet = true;
    }
    return _required;
  }

  set required(bool v) {
    _required = v;
    _requiredSet = true;
  }

  /// Looker User Attribute Ids

  List<int> get userAttributeIds {
    if (!_userAttributeIdsSet &&
        _apiMapResponse.containsKey('user_attribute_ids')) {
      _userAttributeIds = _apiMapResponse['user_attribute_ids']
          ?.map<int>((i) => i as int)
          ?.toList();
      _userAttributeIdsSet = true;
    }
    return _userAttributeIds;
  }

  set userAttributeIds(List<int> v) {
    _userAttributeIds = v;
    _userAttributeIdsSet = true;
  }

  OIDCUserAttributeWrite() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  OIDCUserAttributeWrite.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_requiredSet || _apiMapResponse.containsKey('required')) {
      json['required'] = required;
    }
    if (_userAttributeIdsSet ||
        _apiMapResponse.containsKey('user_attribute_ids')) {
      json['user_attribute_ids'] = userAttributeIds;
    }
    return json;
  }
}

class PasswordConfig {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _minLength;
  bool _minLengthSet = false;

  bool _requireNumeric;
  bool _requireNumericSet = false;

  bool _requireUpperlower;
  bool _requireUpperlowerSet = false;

  bool _requireSpecial;
  bool _requireSpecialSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Minimum number of characters required for a new password.  Must be between 7 and 100

  int get minLength {
    if (!_minLengthSet && _apiMapResponse.containsKey('min_length')) {
      _minLength = _apiMapResponse['min_length'];
      _minLengthSet = true;
    }
    return _minLength;
  }

  set minLength(int v) {
    _minLength = v;
    _minLengthSet = true;
  }

  /// Require at least one numeric character

  bool get requireNumeric {
    if (!_requireNumericSet && _apiMapResponse.containsKey('require_numeric')) {
      _requireNumeric = _apiMapResponse['require_numeric'];
      _requireNumericSet = true;
    }
    return _requireNumeric;
  }

  set requireNumeric(bool v) {
    _requireNumeric = v;
    _requireNumericSet = true;
  }

  /// Require at least one uppercase and one lowercase letter

  bool get requireUpperlower {
    if (!_requireUpperlowerSet &&
        _apiMapResponse.containsKey('require_upperlower')) {
      _requireUpperlower = _apiMapResponse['require_upperlower'];
      _requireUpperlowerSet = true;
    }
    return _requireUpperlower;
  }

  set requireUpperlower(bool v) {
    _requireUpperlower = v;
    _requireUpperlowerSet = true;
  }

  /// Require at least one special character

  bool get requireSpecial {
    if (!_requireSpecialSet && _apiMapResponse.containsKey('require_special')) {
      _requireSpecial = _apiMapResponse['require_special'];
      _requireSpecialSet = true;
    }
    return _requireSpecial;
  }

  set requireSpecial(bool v) {
    _requireSpecial = v;
    _requireSpecialSet = true;
  }

  PasswordConfig() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  PasswordConfig.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_minLengthSet || _apiMapResponse.containsKey('min_length')) {
      json['min_length'] = minLength;
    }
    if (_requireNumericSet || _apiMapResponse.containsKey('require_numeric')) {
      json['require_numeric'] = requireNumeric;
    }
    if (_requireUpperlowerSet ||
        _apiMapResponse.containsKey('require_upperlower')) {
      json['require_upperlower'] = requireUpperlower;
    }
    if (_requireSpecialSet || _apiMapResponse.containsKey('require_special')) {
      json['require_special'] = requireSpecial;
    }
    return json;
  }
}

class Permission {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _permission;
  bool _permissionSet = false;

  String _parent;
  bool _parentSet = false;

  String _description;
  bool _descriptionSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Permission symbol (read-only)

  String get permission {
    if (!_permissionSet && _apiMapResponse.containsKey('permission')) {
      _permission = _apiMapResponse['permission']?.toString();
      _permissionSet = true;
    }
    return _permission;
  }

  set permission(String v) {
    _permission = v;
    _permissionSet = true;
  }

  /// Dependency parent symbol (read-only)

  String get parent {
    if (!_parentSet && _apiMapResponse.containsKey('parent')) {
      _parent = _apiMapResponse['parent']?.toString();
      _parentSet = true;
    }
    return _parent;
  }

  set parent(String v) {
    _parent = v;
    _parentSet = true;
  }

  /// Description (read-only)

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  Permission() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Permission.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_permissionSet || _apiMapResponse.containsKey('permission')) {
      json['permission'] = permission;
    }
    if (_parentSet || _apiMapResponse.containsKey('parent')) {
      json['parent'] = parent;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    return json;
  }
}

class PermissionSet {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  bool _allAccess;
  bool _allAccessSet = false;

  bool _builtIn;
  bool _builtInSet = false;

  int _id;
  bool _idSet = false;

  String _name;
  bool _nameSet = false;

  List<String> _permissions;
  bool _permissionsSet = false;

  String _url;
  bool _urlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  ///  (read-only)

  bool get allAccess {
    if (!_allAccessSet && _apiMapResponse.containsKey('all_access')) {
      _allAccess = _apiMapResponse['all_access'];
      _allAccessSet = true;
    }
    return _allAccess;
  }

  set allAccess(bool v) {
    _allAccess = v;
    _allAccessSet = true;
  }

  ///  (read-only)

  bool get builtIn {
    if (!_builtInSet && _apiMapResponse.containsKey('built_in')) {
      _builtIn = _apiMapResponse['built_in'];
      _builtInSet = true;
    }
    return _builtIn;
  }

  set builtIn(bool v) {
    _builtIn = v;
    _builtInSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Name of PermissionSet

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  List<String> get permissions {
    if (!_permissionsSet && _apiMapResponse.containsKey('permissions')) {
      _permissions = _apiMapResponse['permissions']
          ?.map<String>((i) => i as String)
          ?.toList();
      _permissionsSet = true;
    }
    return _permissions;
  }

  set permissions(List<String> v) {
    _permissions = v;
    _permissionsSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  PermissionSet() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  PermissionSet.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_allAccessSet || _apiMapResponse.containsKey('all_access')) {
      json['all_access'] = allAccess;
    }
    if (_builtInSet || _apiMapResponse.containsKey('built_in')) {
      json['built_in'] = builtIn;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_permissionsSet || _apiMapResponse.containsKey('permissions')) {
      json['permissions'] = permissions;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

/// Type of permission: "view" or "edit" Valid values are: "view", "edit". (Enum defined in ContentMetaGroupUser)
enum PermissionType { view, edit }

class PermissionTypeMapper {
  static String toStringValue(PermissionType e) {
    switch (e) {
      case PermissionType.view:
        return 'view';
      case PermissionType.edit:
        return 'edit';

      default:
        return null;
    }
  }

  static PermissionType fromStringValue(String s) {
    if (s == 'view') {
      return PermissionType.view;
    }
    if (s == 'edit') {
      return PermissionType.edit;
    }
    return null;
  }
}

class Project {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _id;
  bool _idSet = false;

  String _name;
  bool _nameSet = false;

  bool _usesGit;
  bool _usesGitSet = false;

  String _gitRemoteUrl;
  bool _gitRemoteUrlSet = false;

  String _gitUsername;
  bool _gitUsernameSet = false;

  String _gitPassword;
  bool _gitPasswordSet = false;

  String _gitProductionBranchName;
  bool _gitProductionBranchNameSet = false;

  bool _useGitCookieAuth;
  bool _useGitCookieAuthSet = false;

  String _gitUsernameUserAttribute;
  bool _gitUsernameUserAttributeSet = false;

  String _gitPasswordUserAttribute;
  bool _gitPasswordUserAttributeSet = false;

  String _gitServiceName;
  bool _gitServiceNameSet = false;

  int _gitApplicationServerHttpPort;
  bool _gitApplicationServerHttpPortSet = false;

  String _gitApplicationServerHttpScheme;
  bool _gitApplicationServerHttpSchemeSet = false;

  String _deploySecret;
  bool _deploySecretSet = false;

  bool _unsetDeploySecret;
  bool _unsetDeploySecretSet = false;

  PullRequestMode _pullRequestMode;
  bool _pullRequestModeSet = false;

  bool _validationRequired;
  bool _validationRequiredSet = false;

  bool _gitReleaseMgmtEnabled;
  bool _gitReleaseMgmtEnabledSet = false;

  bool _allowWarnings;
  bool _allowWarningsSet = false;

  bool _isExample;
  bool _isExampleSet = false;

  String _dependencyStatus;
  bool _dependencyStatusSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Project Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Project display name

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// If true the project is configured with a git repository (read-only)

  bool get usesGit {
    if (!_usesGitSet && _apiMapResponse.containsKey('uses_git')) {
      _usesGit = _apiMapResponse['uses_git'];
      _usesGitSet = true;
    }
    return _usesGit;
  }

  set usesGit(bool v) {
    _usesGit = v;
    _usesGitSet = true;
  }

  /// Git remote repository url

  String get gitRemoteUrl {
    if (!_gitRemoteUrlSet && _apiMapResponse.containsKey('git_remote_url')) {
      _gitRemoteUrl = _apiMapResponse['git_remote_url']?.toString();
      _gitRemoteUrlSet = true;
    }
    return _gitRemoteUrl;
  }

  set gitRemoteUrl(String v) {
    _gitRemoteUrl = v;
    _gitRemoteUrlSet = true;
  }

  /// Git username for HTTPS authentication. (For production only, if using user attributes.)

  String get gitUsername {
    if (!_gitUsernameSet && _apiMapResponse.containsKey('git_username')) {
      _gitUsername = _apiMapResponse['git_username']?.toString();
      _gitUsernameSet = true;
    }
    return _gitUsername;
  }

  set gitUsername(String v) {
    _gitUsername = v;
    _gitUsernameSet = true;
  }

  /// (Write-Only) Git password for HTTPS authentication. (For production only, if using user attributes.)

  String get gitPassword {
    if (!_gitPasswordSet && _apiMapResponse.containsKey('git_password')) {
      _gitPassword = _apiMapResponse['git_password']?.toString();
      _gitPasswordSet = true;
    }
    return _gitPassword;
  }

  set gitPassword(String v) {
    _gitPassword = v;
    _gitPasswordSet = true;
  }

  /// Git production branch name. Defaults to master. Supported only in Looker 21.0 and higher.

  String get gitProductionBranchName {
    if (!_gitProductionBranchNameSet &&
        _apiMapResponse.containsKey('git_production_branch_name')) {
      _gitProductionBranchName =
          _apiMapResponse['git_production_branch_name']?.toString();
      _gitProductionBranchNameSet = true;
    }
    return _gitProductionBranchName;
  }

  set gitProductionBranchName(String v) {
    _gitProductionBranchName = v;
    _gitProductionBranchNameSet = true;
  }

  /// If true, the project uses a git cookie for authentication.

  bool get useGitCookieAuth {
    if (!_useGitCookieAuthSet &&
        _apiMapResponse.containsKey('use_git_cookie_auth')) {
      _useGitCookieAuth = _apiMapResponse['use_git_cookie_auth'];
      _useGitCookieAuthSet = true;
    }
    return _useGitCookieAuth;
  }

  set useGitCookieAuth(bool v) {
    _useGitCookieAuth = v;
    _useGitCookieAuthSet = true;
  }

  /// User attribute name for username in per-user HTTPS authentication.

  String get gitUsernameUserAttribute {
    if (!_gitUsernameUserAttributeSet &&
        _apiMapResponse.containsKey('git_username_user_attribute')) {
      _gitUsernameUserAttribute =
          _apiMapResponse['git_username_user_attribute']?.toString();
      _gitUsernameUserAttributeSet = true;
    }
    return _gitUsernameUserAttribute;
  }

  set gitUsernameUserAttribute(String v) {
    _gitUsernameUserAttribute = v;
    _gitUsernameUserAttributeSet = true;
  }

  /// User attribute name for password in per-user HTTPS authentication.

  String get gitPasswordUserAttribute {
    if (!_gitPasswordUserAttributeSet &&
        _apiMapResponse.containsKey('git_password_user_attribute')) {
      _gitPasswordUserAttribute =
          _apiMapResponse['git_password_user_attribute']?.toString();
      _gitPasswordUserAttributeSet = true;
    }
    return _gitPasswordUserAttribute;
  }

  set gitPasswordUserAttribute(String v) {
    _gitPasswordUserAttribute = v;
    _gitPasswordUserAttributeSet = true;
  }

  /// Name of the git service provider

  String get gitServiceName {
    if (!_gitServiceNameSet &&
        _apiMapResponse.containsKey('git_service_name')) {
      _gitServiceName = _apiMapResponse['git_service_name']?.toString();
      _gitServiceNameSet = true;
    }
    return _gitServiceName;
  }

  set gitServiceName(String v) {
    _gitServiceName = v;
    _gitServiceNameSet = true;
  }

  /// Port that HTTP(S) application server is running on (for PRs, file browsing, etc.)

  int get gitApplicationServerHttpPort {
    if (!_gitApplicationServerHttpPortSet &&
        _apiMapResponse.containsKey('git_application_server_http_port')) {
      _gitApplicationServerHttpPort =
          _apiMapResponse['git_application_server_http_port'];
      _gitApplicationServerHttpPortSet = true;
    }
    return _gitApplicationServerHttpPort;
  }

  set gitApplicationServerHttpPort(int v) {
    _gitApplicationServerHttpPort = v;
    _gitApplicationServerHttpPortSet = true;
  }

  /// Scheme that is running on application server (for PRs, file browsing, etc.)

  String get gitApplicationServerHttpScheme {
    if (!_gitApplicationServerHttpSchemeSet &&
        _apiMapResponse.containsKey('git_application_server_http_scheme')) {
      _gitApplicationServerHttpScheme =
          _apiMapResponse['git_application_server_http_scheme']?.toString();
      _gitApplicationServerHttpSchemeSet = true;
    }
    return _gitApplicationServerHttpScheme;
  }

  set gitApplicationServerHttpScheme(String v) {
    _gitApplicationServerHttpScheme = v;
    _gitApplicationServerHttpSchemeSet = true;
  }

  /// (Write-Only) Optional secret token with which to authenticate requests to the webhook deploy endpoint. If not set, endpoint is unauthenticated.

  String get deploySecret {
    if (!_deploySecretSet && _apiMapResponse.containsKey('deploy_secret')) {
      _deploySecret = _apiMapResponse['deploy_secret']?.toString();
      _deploySecretSet = true;
    }
    return _deploySecret;
  }

  set deploySecret(String v) {
    _deploySecret = v;
    _deploySecretSet = true;
  }

  /// (Write-Only) When true, unsets the deploy secret to allow unauthenticated access to the webhook deploy endpoint.

  bool get unsetDeploySecret {
    if (!_unsetDeploySecretSet &&
        _apiMapResponse.containsKey('unset_deploy_secret')) {
      _unsetDeploySecret = _apiMapResponse['unset_deploy_secret'];
      _unsetDeploySecretSet = true;
    }
    return _unsetDeploySecret;
  }

  set unsetDeploySecret(bool v) {
    _unsetDeploySecret = v;
    _unsetDeploySecretSet = true;
  }

  /// The git pull request policy for this project. Valid values are: "off", "links", "recommended", "required".

  PullRequestMode get pullRequestMode {
    if (!_pullRequestModeSet &&
        _apiMapResponse.containsKey('pull_request_mode')) {
      _pullRequestMode = PullRequestModeMapper.fromStringValue(
          _apiMapResponse['pull_request_mode']);
      _pullRequestModeSet = true;
    }
    return _pullRequestMode;
  }

  set pullRequestMode(PullRequestMode v) {
    _pullRequestMode = v;
    _pullRequestModeSet = true;
  }

  /// Validation policy: If true, the project must pass validation checks before project changes can be committed to the git repository

  bool get validationRequired {
    if (!_validationRequiredSet &&
        _apiMapResponse.containsKey('validation_required')) {
      _validationRequired = _apiMapResponse['validation_required'];
      _validationRequiredSet = true;
    }
    return _validationRequired;
  }

  set validationRequired(bool v) {
    _validationRequired = v;
    _validationRequiredSet = true;
  }

  /// If true, advanced git release management is enabled for this project

  bool get gitReleaseMgmtEnabled {
    if (!_gitReleaseMgmtEnabledSet &&
        _apiMapResponse.containsKey('git_release_mgmt_enabled')) {
      _gitReleaseMgmtEnabled = _apiMapResponse['git_release_mgmt_enabled'];
      _gitReleaseMgmtEnabledSet = true;
    }
    return _gitReleaseMgmtEnabled;
  }

  set gitReleaseMgmtEnabled(bool v) {
    _gitReleaseMgmtEnabled = v;
    _gitReleaseMgmtEnabledSet = true;
  }

  /// Validation policy: If true, the project can be committed with warnings when `validation_required` is true. (`allow_warnings` does nothing if `validation_required` is false).

  bool get allowWarnings {
    if (!_allowWarningsSet && _apiMapResponse.containsKey('allow_warnings')) {
      _allowWarnings = _apiMapResponse['allow_warnings'];
      _allowWarningsSet = true;
    }
    return _allowWarnings;
  }

  set allowWarnings(bool v) {
    _allowWarnings = v;
    _allowWarningsSet = true;
  }

  /// If true the project is an example project and cannot be modified (read-only)

  bool get isExample {
    if (!_isExampleSet && _apiMapResponse.containsKey('is_example')) {
      _isExample = _apiMapResponse['is_example'];
      _isExampleSet = true;
    }
    return _isExample;
  }

  set isExample(bool v) {
    _isExample = v;
    _isExampleSet = true;
  }

  /// Status of dependencies in your manifest & lockfile

  String get dependencyStatus {
    if (!_dependencyStatusSet &&
        _apiMapResponse.containsKey('dependency_status')) {
      _dependencyStatus = _apiMapResponse['dependency_status']?.toString();
      _dependencyStatusSet = true;
    }
    return _dependencyStatus;
  }

  set dependencyStatus(String v) {
    _dependencyStatus = v;
    _dependencyStatusSet = true;
  }

  Project() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Project.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_usesGitSet || _apiMapResponse.containsKey('uses_git')) {
      json['uses_git'] = usesGit;
    }
    if (_gitRemoteUrlSet || _apiMapResponse.containsKey('git_remote_url')) {
      json['git_remote_url'] = gitRemoteUrl;
    }
    if (_gitUsernameSet || _apiMapResponse.containsKey('git_username')) {
      json['git_username'] = gitUsername;
    }
    if (_gitPasswordSet || _apiMapResponse.containsKey('git_password')) {
      json['git_password'] = gitPassword;
    }
    if (_gitProductionBranchNameSet ||
        _apiMapResponse.containsKey('git_production_branch_name')) {
      json['git_production_branch_name'] = gitProductionBranchName;
    }
    if (_useGitCookieAuthSet ||
        _apiMapResponse.containsKey('use_git_cookie_auth')) {
      json['use_git_cookie_auth'] = useGitCookieAuth;
    }
    if (_gitUsernameUserAttributeSet ||
        _apiMapResponse.containsKey('git_username_user_attribute')) {
      json['git_username_user_attribute'] = gitUsernameUserAttribute;
    }
    if (_gitPasswordUserAttributeSet ||
        _apiMapResponse.containsKey('git_password_user_attribute')) {
      json['git_password_user_attribute'] = gitPasswordUserAttribute;
    }
    if (_gitServiceNameSet || _apiMapResponse.containsKey('git_service_name')) {
      json['git_service_name'] = gitServiceName;
    }
    if (_gitApplicationServerHttpPortSet ||
        _apiMapResponse.containsKey('git_application_server_http_port')) {
      json['git_application_server_http_port'] = gitApplicationServerHttpPort;
    }
    if (_gitApplicationServerHttpSchemeSet ||
        _apiMapResponse.containsKey('git_application_server_http_scheme')) {
      json['git_application_server_http_scheme'] =
          gitApplicationServerHttpScheme;
    }
    if (_deploySecretSet || _apiMapResponse.containsKey('deploy_secret')) {
      json['deploy_secret'] = deploySecret;
    }
    if (_unsetDeploySecretSet ||
        _apiMapResponse.containsKey('unset_deploy_secret')) {
      json['unset_deploy_secret'] = unsetDeploySecret;
    }
    if (_pullRequestModeSet ||
        _apiMapResponse.containsKey('pull_request_mode')) {
      json['pull_request_mode'] =
          PullRequestModeMapper.toStringValue(pullRequestMode);
    }
    if (_validationRequiredSet ||
        _apiMapResponse.containsKey('validation_required')) {
      json['validation_required'] = validationRequired;
    }
    if (_gitReleaseMgmtEnabledSet ||
        _apiMapResponse.containsKey('git_release_mgmt_enabled')) {
      json['git_release_mgmt_enabled'] = gitReleaseMgmtEnabled;
    }
    if (_allowWarningsSet || _apiMapResponse.containsKey('allow_warnings')) {
      json['allow_warnings'] = allowWarnings;
    }
    if (_isExampleSet || _apiMapResponse.containsKey('is_example')) {
      json['is_example'] = isExample;
    }
    if (_dependencyStatusSet ||
        _apiMapResponse.containsKey('dependency_status')) {
      json['dependency_status'] = dependencyStatus;
    }
    return json;
  }
}

class ProjectError {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _code;
  bool _codeSet = false;

  String _severity;
  bool _severitySet = false;

  String _kind;
  bool _kindSet = false;

  String _message;
  bool _messageSet = false;

  String _fieldName;
  bool _fieldNameSet = false;

  String _filePath;
  bool _filePathSet = false;

  int _lineNumber;
  bool _lineNumberSet = false;

  String _modelId;
  bool _modelIdSet = false;

  String _explore;
  bool _exploreSet = false;

  String _helpUrl;
  bool _helpUrlSet = false;

  Map<String, dynamic> _params;
  bool _paramsSet = false;

  String _sanitizedMessage;
  bool _sanitizedMessageSet = false;

  /// A stable token that uniquely identifies this class of error, ignoring parameter values. Error message text may vary due to parameters or localization, but error codes do not. For example, a "File not found" error will have the same error code regardless of the filename in question or the user's display language (read-only)

  String get code {
    if (!_codeSet && _apiMapResponse.containsKey('code')) {
      _code = _apiMapResponse['code']?.toString();
      _codeSet = true;
    }
    return _code;
  }

  set code(String v) {
    _code = v;
    _codeSet = true;
  }

  /// Severity: fatal, error, warning, info, success (read-only)

  String get severity {
    if (!_severitySet && _apiMapResponse.containsKey('severity')) {
      _severity = _apiMapResponse['severity']?.toString();
      _severitySet = true;
    }
    return _severity;
  }

  set severity(String v) {
    _severity = v;
    _severitySet = true;
  }

  /// Error classification: syntax, deprecation, model_configuration, etc (read-only)

  String get kind {
    if (!_kindSet && _apiMapResponse.containsKey('kind')) {
      _kind = _apiMapResponse['kind']?.toString();
      _kindSet = true;
    }
    return _kind;
  }

  set kind(String v) {
    _kind = v;
    _kindSet = true;
  }

  /// Error message which may contain information such as dashboard or model names that may be considered sensitive in some use cases. Avoid storing or sending this message outside of Looker (read-only)

  String get message {
    if (!_messageSet && _apiMapResponse.containsKey('message')) {
      _message = _apiMapResponse['message']?.toString();
      _messageSet = true;
    }
    return _message;
  }

  set message(String v) {
    _message = v;
    _messageSet = true;
  }

  /// The field associated with this error (read-only)

  String get fieldName {
    if (!_fieldNameSet && _apiMapResponse.containsKey('field_name')) {
      _fieldName = _apiMapResponse['field_name']?.toString();
      _fieldNameSet = true;
    }
    return _fieldName;
  }

  set fieldName(String v) {
    _fieldName = v;
    _fieldNameSet = true;
  }

  /// Name of the file containing this error (read-only)

  String get filePath {
    if (!_filePathSet && _apiMapResponse.containsKey('file_path')) {
      _filePath = _apiMapResponse['file_path']?.toString();
      _filePathSet = true;
    }
    return _filePath;
  }

  set filePath(String v) {
    _filePath = v;
    _filePathSet = true;
  }

  /// Line number in the file of this error (read-only)

  int get lineNumber {
    if (!_lineNumberSet && _apiMapResponse.containsKey('line_number')) {
      _lineNumber = _apiMapResponse['line_number'];
      _lineNumberSet = true;
    }
    return _lineNumber;
  }

  set lineNumber(int v) {
    _lineNumber = v;
    _lineNumberSet = true;
  }

  /// The model associated with this error (read-only)

  String get modelId {
    if (!_modelIdSet && _apiMapResponse.containsKey('model_id')) {
      _modelId = _apiMapResponse['model_id']?.toString();
      _modelIdSet = true;
    }
    return _modelId;
  }

  set modelId(String v) {
    _modelId = v;
    _modelIdSet = true;
  }

  /// The explore associated with this error (read-only)

  String get explore {
    if (!_exploreSet && _apiMapResponse.containsKey('explore')) {
      _explore = _apiMapResponse['explore']?.toString();
      _exploreSet = true;
    }
    return _explore;
  }

  set explore(String v) {
    _explore = v;
    _exploreSet = true;
  }

  /// A link to Looker documentation about this error (read-only)

  String get helpUrl {
    if (!_helpUrlSet && _apiMapResponse.containsKey('help_url')) {
      _helpUrl = _apiMapResponse['help_url']?.toString();
      _helpUrlSet = true;
    }
    return _helpUrl;
  }

  set helpUrl(String v) {
    _helpUrl = v;
    _helpUrlSet = true;
  }

  /// Error parameters (read-only)

  Map<String, dynamic> get params {
    if (!_paramsSet && _apiMapResponse.containsKey('params')) {
      _params = _apiMapResponse['params'];
      _paramsSet = true;
    }
    return _params;
  }

  set params(Map<String, dynamic> v) {
    _params = v;
    _paramsSet = true;
  }

  /// A version of the error message that does not contain potentially sensitive information. Suitable for situations in which messages are stored or sent to consumers outside of Looker, such as external logs. Sanitized messages will display "(?)" where sensitive information would appear in the corresponding non-sanitized message (read-only)

  String get sanitizedMessage {
    if (!_sanitizedMessageSet &&
        _apiMapResponse.containsKey('sanitized_message')) {
      _sanitizedMessage = _apiMapResponse['sanitized_message']?.toString();
      _sanitizedMessageSet = true;
    }
    return _sanitizedMessage;
  }

  set sanitizedMessage(String v) {
    _sanitizedMessage = v;
    _sanitizedMessageSet = true;
  }

  ProjectError() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ProjectError.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_codeSet || _apiMapResponse.containsKey('code')) {
      json['code'] = code;
    }
    if (_severitySet || _apiMapResponse.containsKey('severity')) {
      json['severity'] = severity;
    }
    if (_kindSet || _apiMapResponse.containsKey('kind')) {
      json['kind'] = kind;
    }
    if (_messageSet || _apiMapResponse.containsKey('message')) {
      json['message'] = message;
    }
    if (_fieldNameSet || _apiMapResponse.containsKey('field_name')) {
      json['field_name'] = fieldName;
    }
    if (_filePathSet || _apiMapResponse.containsKey('file_path')) {
      json['file_path'] = filePath;
    }
    if (_lineNumberSet || _apiMapResponse.containsKey('line_number')) {
      json['line_number'] = lineNumber;
    }
    if (_modelIdSet || _apiMapResponse.containsKey('model_id')) {
      json['model_id'] = modelId;
    }
    if (_exploreSet || _apiMapResponse.containsKey('explore')) {
      json['explore'] = explore;
    }
    if (_helpUrlSet || _apiMapResponse.containsKey('help_url')) {
      json['help_url'] = helpUrl;
    }
    if (_paramsSet || _apiMapResponse.containsKey('params')) {
      json['params'] = params;
    }
    if (_sanitizedMessageSet ||
        _apiMapResponse.containsKey('sanitized_message')) {
      json['sanitized_message'] = sanitizedMessage;
    }
    return json;
  }
}

class ProjectFile {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _id;
  bool _idSet = false;

  String _path;
  bool _pathSet = false;

  String _title;
  bool _titleSet = false;

  String _type;
  bool _typeSet = false;

  String _extension;
  bool _extensionSet = false;

  String _mimeType;
  bool _mimeTypeSet = false;

  bool _editable;
  bool _editableSet = false;

  GitStatus _gitStatus;
  bool _gitStatusSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// An opaque token uniquely identifying a file within a project. Avoid parsing or decomposing the text of this token. This token is stable within a Looker release but may change between Looker releases (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Path, file name, and extension of the file relative to the project root directory (read-only)

  String get path {
    if (!_pathSet && _apiMapResponse.containsKey('path')) {
      _path = _apiMapResponse['path']?.toString();
      _pathSet = true;
    }
    return _path;
  }

  set path(String v) {
    _path = v;
    _pathSet = true;
  }

  /// Display name (read-only)

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// File type: model, view, etc (read-only)

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// The extension of the file: .view.lkml, .model.lkml, etc (read-only)

  String get extension {
    if (!_extensionSet && _apiMapResponse.containsKey('extension')) {
      _extension = _apiMapResponse['extension']?.toString();
      _extensionSet = true;
    }
    return _extension;
  }

  set extension(String v) {
    _extension = v;
    _extensionSet = true;
  }

  /// File mime type (read-only)

  String get mimeType {
    if (!_mimeTypeSet && _apiMapResponse.containsKey('mime_type')) {
      _mimeType = _apiMapResponse['mime_type']?.toString();
      _mimeTypeSet = true;
    }
    return _mimeType;
  }

  set mimeType(String v) {
    _mimeType = v;
    _mimeTypeSet = true;
  }

  /// State of editability for the file. (read-only)

  bool get editable {
    if (!_editableSet && _apiMapResponse.containsKey('editable')) {
      _editable = _apiMapResponse['editable'];
      _editableSet = true;
    }
    return _editable;
  }

  set editable(bool v) {
    _editable = v;
    _editableSet = true;
  }

  GitStatus get gitStatus {
    if (!_gitStatusSet && _apiMapResponse.containsKey('git_status')) {
      _gitStatus = _apiMapResponse['git_status'] == null
          ? null
          : GitStatus.fromResponse(
              _apiMapResponse['git_status'], apiResponseContentType);
      _gitStatusSet = true;
    }
    return _gitStatus;
  }

  set gitStatus(GitStatus v) {
    _gitStatus = v;
    _gitStatusSet = true;
  }

  ProjectFile() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ProjectFile.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_pathSet || _apiMapResponse.containsKey('path')) {
      json['path'] = path;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_extensionSet || _apiMapResponse.containsKey('extension')) {
      json['extension'] = extension;
    }
    if (_mimeTypeSet || _apiMapResponse.containsKey('mime_type')) {
      json['mime_type'] = mimeType;
    }
    if (_editableSet || _apiMapResponse.containsKey('editable')) {
      json['editable'] = editable;
    }
    if (_gitStatusSet || _apiMapResponse.containsKey('git_status')) {
      json['git_status'] = gitStatus?.toJson();
    }
    return json;
  }
}

class ProjectValidation {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  List<ProjectError> _errors;
  bool _errorsSet = false;

  String _projectDigest;
  bool _projectDigestSet = false;

  List<ModelsNotValidated> _modelsNotValidated;
  bool _modelsNotValidatedSet = false;

  double _computationTime;
  bool _computationTimeSet = false;

  /// A list of project errors (read-only)

  List<ProjectError> get errors {
    if (!_errorsSet && _apiMapResponse.containsKey('errors')) {
      _errors = _apiMapResponse['errors'] == null
          ? null
          : (_apiMapResponse['errors'] as List)
              .map((i) => ProjectError.fromResponse(i, apiResponseContentType))
              .toList();
      _errorsSet = true;
    }
    return _errors;
  }

  set errors(List<ProjectError> v) {
    _errors = v;
    _errorsSet = true;
  }

  /// A hash value computed from the project's current state (read-only)

  String get projectDigest {
    if (!_projectDigestSet && _apiMapResponse.containsKey('project_digest')) {
      _projectDigest = _apiMapResponse['project_digest']?.toString();
      _projectDigestSet = true;
    }
    return _projectDigest;
  }

  set projectDigest(String v) {
    _projectDigest = v;
    _projectDigestSet = true;
  }

  /// A list of models which were not fully validated (read-only)

  List<ModelsNotValidated> get modelsNotValidated {
    if (!_modelsNotValidatedSet &&
        _apiMapResponse.containsKey('models_not_validated')) {
      _modelsNotValidated = _apiMapResponse['models_not_validated'] == null
          ? null
          : (_apiMapResponse['models_not_validated'] as List)
              .map((i) =>
                  ModelsNotValidated.fromResponse(i, apiResponseContentType))
              .toList();
      _modelsNotValidatedSet = true;
    }
    return _modelsNotValidated;
  }

  set modelsNotValidated(List<ModelsNotValidated> v) {
    _modelsNotValidated = v;
    _modelsNotValidatedSet = true;
  }

  /// Duration of project validation in seconds (read-only)

  double get computationTime {
    if (!_computationTimeSet &&
        _apiMapResponse.containsKey('computation_time')) {
      _computationTime = _apiMapResponse['computation_time'];
      _computationTimeSet = true;
    }
    return _computationTime;
  }

  set computationTime(double v) {
    _computationTime = v;
    _computationTimeSet = true;
  }

  ProjectValidation() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ProjectValidation.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_errorsSet || _apiMapResponse.containsKey('errors')) {
      json['errors'] = errors?.map((i) => i.toJson())?.toList();
    }
    if (_projectDigestSet || _apiMapResponse.containsKey('project_digest')) {
      json['project_digest'] = projectDigest;
    }
    if (_modelsNotValidatedSet ||
        _apiMapResponse.containsKey('models_not_validated')) {
      json['models_not_validated'] =
          modelsNotValidated?.map((i) => i.toJson())?.toList();
    }
    if (_computationTimeSet ||
        _apiMapResponse.containsKey('computation_time')) {
      json['computation_time'] = computationTime;
    }
    return json;
  }
}

class ProjectValidationCache {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  List<ProjectError> _errors;
  bool _errorsSet = false;

  String _projectDigest;
  bool _projectDigestSet = false;

  List<ModelsNotValidated> _modelsNotValidated;
  bool _modelsNotValidatedSet = false;

  double _computationTime;
  bool _computationTimeSet = false;

  bool _stale;
  bool _staleSet = false;

  /// A list of project errors (read-only)

  List<ProjectError> get errors {
    if (!_errorsSet && _apiMapResponse.containsKey('errors')) {
      _errors = _apiMapResponse['errors'] == null
          ? null
          : (_apiMapResponse['errors'] as List)
              .map((i) => ProjectError.fromResponse(i, apiResponseContentType))
              .toList();
      _errorsSet = true;
    }
    return _errors;
  }

  set errors(List<ProjectError> v) {
    _errors = v;
    _errorsSet = true;
  }

  /// A hash value computed from the project's current state (read-only)

  String get projectDigest {
    if (!_projectDigestSet && _apiMapResponse.containsKey('project_digest')) {
      _projectDigest = _apiMapResponse['project_digest']?.toString();
      _projectDigestSet = true;
    }
    return _projectDigest;
  }

  set projectDigest(String v) {
    _projectDigest = v;
    _projectDigestSet = true;
  }

  /// A list of models which were not fully validated (read-only)

  List<ModelsNotValidated> get modelsNotValidated {
    if (!_modelsNotValidatedSet &&
        _apiMapResponse.containsKey('models_not_validated')) {
      _modelsNotValidated = _apiMapResponse['models_not_validated'] == null
          ? null
          : (_apiMapResponse['models_not_validated'] as List)
              .map((i) =>
                  ModelsNotValidated.fromResponse(i, apiResponseContentType))
              .toList();
      _modelsNotValidatedSet = true;
    }
    return _modelsNotValidated;
  }

  set modelsNotValidated(List<ModelsNotValidated> v) {
    _modelsNotValidated = v;
    _modelsNotValidatedSet = true;
  }

  /// Duration of project validation in seconds (read-only)

  double get computationTime {
    if (!_computationTimeSet &&
        _apiMapResponse.containsKey('computation_time')) {
      _computationTime = _apiMapResponse['computation_time'];
      _computationTimeSet = true;
    }
    return _computationTime;
  }

  set computationTime(double v) {
    _computationTime = v;
    _computationTimeSet = true;
  }

  /// If true, the cached project validation results are no longer accurate because the project has changed since the cached results were calculated (read-only)

  bool get stale {
    if (!_staleSet && _apiMapResponse.containsKey('stale')) {
      _stale = _apiMapResponse['stale'];
      _staleSet = true;
    }
    return _stale;
  }

  set stale(bool v) {
    _stale = v;
    _staleSet = true;
  }

  ProjectValidationCache() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ProjectValidationCache.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_errorsSet || _apiMapResponse.containsKey('errors')) {
      json['errors'] = errors?.map((i) => i.toJson())?.toList();
    }
    if (_projectDigestSet || _apiMapResponse.containsKey('project_digest')) {
      json['project_digest'] = projectDigest;
    }
    if (_modelsNotValidatedSet ||
        _apiMapResponse.containsKey('models_not_validated')) {
      json['models_not_validated'] =
          modelsNotValidated?.map((i) => i.toJson())?.toList();
    }
    if (_computationTimeSet ||
        _apiMapResponse.containsKey('computation_time')) {
      json['computation_time'] = computationTime;
    }
    if (_staleSet || _apiMapResponse.containsKey('stale')) {
      json['stale'] = stale;
    }
    return json;
  }
}

class ProjectWorkspace {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _projectId;
  bool _projectIdSet = false;

  String _workspaceId;
  bool _workspaceIdSet = false;

  String _gitStatus;
  bool _gitStatusSet = false;

  String _gitHead;
  bool _gitHeadSet = false;

  DependencyStatus _dependencyStatus;
  bool _dependencyStatusSet = false;

  GitBranch _gitBranch;
  bool _gitBranchSet = false;

  String _lookmlType;
  bool _lookmlTypeSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// The id of the project (read-only)

  String get projectId {
    if (!_projectIdSet && _apiMapResponse.containsKey('project_id')) {
      _projectId = _apiMapResponse['project_id']?.toString();
      _projectIdSet = true;
    }
    return _projectId;
  }

  set projectId(String v) {
    _projectId = v;
    _projectIdSet = true;
  }

  /// The id of the local workspace containing the project files (read-only)

  String get workspaceId {
    if (!_workspaceIdSet && _apiMapResponse.containsKey('workspace_id')) {
      _workspaceId = _apiMapResponse['workspace_id']?.toString();
      _workspaceIdSet = true;
    }
    return _workspaceId;
  }

  set workspaceId(String v) {
    _workspaceId = v;
    _workspaceIdSet = true;
  }

  /// The status of the local git directory (read-only)

  String get gitStatus {
    if (!_gitStatusSet && _apiMapResponse.containsKey('git_status')) {
      _gitStatus = _apiMapResponse['git_status']?.toString();
      _gitStatusSet = true;
    }
    return _gitStatus;
  }

  set gitStatus(String v) {
    _gitStatus = v;
    _gitStatusSet = true;
  }

  /// Git head revision name (read-only)

  String get gitHead {
    if (!_gitHeadSet && _apiMapResponse.containsKey('git_head')) {
      _gitHead = _apiMapResponse['git_head']?.toString();
      _gitHeadSet = true;
    }
    return _gitHead;
  }

  set gitHead(String v) {
    _gitHead = v;
    _gitHeadSet = true;
  }

  /// Status of the dependencies in your project. Valid values are: "lock_optional", "lock_required", "lock_error", "install_none". (read-only)

  DependencyStatus get dependencyStatus {
    if (!_dependencyStatusSet &&
        _apiMapResponse.containsKey('dependency_status')) {
      _dependencyStatus = DependencyStatusMapper.fromStringValue(
          _apiMapResponse['dependency_status']);
      _dependencyStatusSet = true;
    }
    return _dependencyStatus;
  }

  set dependencyStatus(DependencyStatus v) {
    _dependencyStatus = v;
    _dependencyStatusSet = true;
  }

  GitBranch get gitBranch {
    if (!_gitBranchSet && _apiMapResponse.containsKey('git_branch')) {
      _gitBranch = _apiMapResponse['git_branch'] == null
          ? null
          : GitBranch.fromResponse(
              _apiMapResponse['git_branch'], apiResponseContentType);
      _gitBranchSet = true;
    }
    return _gitBranch;
  }

  set gitBranch(GitBranch v) {
    _gitBranch = v;
    _gitBranchSet = true;
  }

  /// The lookml syntax used by all files in this project (read-only)

  String get lookmlType {
    if (!_lookmlTypeSet && _apiMapResponse.containsKey('lookml_type')) {
      _lookmlType = _apiMapResponse['lookml_type']?.toString();
      _lookmlTypeSet = true;
    }
    return _lookmlType;
  }

  set lookmlType(String v) {
    _lookmlType = v;
    _lookmlTypeSet = true;
  }

  ProjectWorkspace() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ProjectWorkspace.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_projectIdSet || _apiMapResponse.containsKey('project_id')) {
      json['project_id'] = projectId;
    }
    if (_workspaceIdSet || _apiMapResponse.containsKey('workspace_id')) {
      json['workspace_id'] = workspaceId;
    }
    if (_gitStatusSet || _apiMapResponse.containsKey('git_status')) {
      json['git_status'] = gitStatus;
    }
    if (_gitHeadSet || _apiMapResponse.containsKey('git_head')) {
      json['git_head'] = gitHead;
    }
    if (_dependencyStatusSet ||
        _apiMapResponse.containsKey('dependency_status')) {
      json['dependency_status'] =
          DependencyStatusMapper.toStringValue(dependencyStatus);
    }
    if (_gitBranchSet || _apiMapResponse.containsKey('git_branch')) {
      json['git_branch'] = gitBranch?.toJson();
    }
    if (_lookmlTypeSet || _apiMapResponse.containsKey('lookml_type')) {
      json['lookml_type'] = lookmlType;
    }
    return json;
  }
}

/// The git pull request policy for this project. Valid values are: "off", "links", "recommended", "required". (Enum defined in Project)
enum PullRequestMode { off, links, recommended, required }

class PullRequestModeMapper {
  static String toStringValue(PullRequestMode e) {
    switch (e) {
      case PullRequestMode.off:
        return 'off';
      case PullRequestMode.links:
        return 'links';
      case PullRequestMode.recommended:
        return 'recommended';
      case PullRequestMode.required:
        return 'required';

      default:
        return null;
    }
  }

  static PullRequestMode fromStringValue(String s) {
    if (s == 'off') {
      return PullRequestMode.off;
    }
    if (s == 'links') {
      return PullRequestMode.links;
    }
    if (s == 'recommended') {
      return PullRequestMode.recommended;
    }
    if (s == 'required') {
      return PullRequestMode.required;
    }
    return null;
  }
}

class Query {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _id;
  bool _idSet = false;

  String _model;
  bool _modelSet = false;

  String _view;
  bool _viewSet = false;

  List<String> _fields;
  bool _fieldsSet = false;

  List<String> _pivots;
  bool _pivotsSet = false;

  List<String> _fillFields;
  bool _fillFieldsSet = false;

  Map<String, dynamic> _filters;
  bool _filtersSet = false;

  String _filterExpression;
  bool _filterExpressionSet = false;

  List<String> _sorts;
  bool _sortsSet = false;

  String _limit;
  bool _limitSet = false;

  String _columnLimit;
  bool _columnLimitSet = false;

  bool _total;
  bool _totalSet = false;

  String _rowTotal;
  bool _rowTotalSet = false;

  List<String> _subtotals;
  bool _subtotalsSet = false;

  Map<String, dynamic> _visConfig;
  bool _visConfigSet = false;

  Map<String, dynamic> _filterConfig;
  bool _filterConfigSet = false;

  String _visibleUiSections;
  bool _visibleUiSectionsSet = false;

  String _slug;
  bool _slugSet = false;

  String _dynamicFields;
  bool _dynamicFieldsSet = false;

  String _clientId;
  bool _clientIdSet = false;

  String _shareUrl;
  bool _shareUrlSet = false;

  String _expandedShareUrl;
  bool _expandedShareUrlSet = false;

  String _url;
  bool _urlSet = false;

  String _queryTimezone;
  bool _queryTimezoneSet = false;

  bool _hasTableCalculations;
  bool _hasTableCalculationsSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Model

  String get model {
    if (!_modelSet && _apiMapResponse.containsKey('model')) {
      _model = _apiMapResponse['model']?.toString();
      _modelSet = true;
    }
    return _model;
  }

  set model(String v) {
    _model = v;
    _modelSet = true;
  }

  /// Explore Name

  String get view {
    if (!_viewSet && _apiMapResponse.containsKey('view')) {
      _view = _apiMapResponse['view']?.toString();
      _viewSet = true;
    }
    return _view;
  }

  set view(String v) {
    _view = v;
    _viewSet = true;
  }

  /// Fields

  List<String> get fields {
    if (!_fieldsSet && _apiMapResponse.containsKey('fields')) {
      _fields =
          _apiMapResponse['fields']?.map<String>((i) => i as String)?.toList();
      _fieldsSet = true;
    }
    return _fields;
  }

  set fields(List<String> v) {
    _fields = v;
    _fieldsSet = true;
  }

  /// Pivots

  List<String> get pivots {
    if (!_pivotsSet && _apiMapResponse.containsKey('pivots')) {
      _pivots =
          _apiMapResponse['pivots']?.map<String>((i) => i as String)?.toList();
      _pivotsSet = true;
    }
    return _pivots;
  }

  set pivots(List<String> v) {
    _pivots = v;
    _pivotsSet = true;
  }

  /// Fill Fields

  List<String> get fillFields {
    if (!_fillFieldsSet && _apiMapResponse.containsKey('fill_fields')) {
      _fillFields = _apiMapResponse['fill_fields']
          ?.map<String>((i) => i as String)
          ?.toList();
      _fillFieldsSet = true;
    }
    return _fillFields;
  }

  set fillFields(List<String> v) {
    _fillFields = v;
    _fillFieldsSet = true;
  }

  /// Filters

  Map<String, dynamic> get filters {
    if (!_filtersSet && _apiMapResponse.containsKey('filters')) {
      _filters = _apiMapResponse['filters'];
      _filtersSet = true;
    }
    return _filters;
  }

  set filters(Map<String, dynamic> v) {
    _filters = v;
    _filtersSet = true;
  }

  /// Filter Expression

  String get filterExpression {
    if (!_filterExpressionSet &&
        _apiMapResponse.containsKey('filter_expression')) {
      _filterExpression = _apiMapResponse['filter_expression']?.toString();
      _filterExpressionSet = true;
    }
    return _filterExpression;
  }

  set filterExpression(String v) {
    _filterExpression = v;
    _filterExpressionSet = true;
  }

  /// Sorting for the query results. Use the format `["view.field", ...]` to sort on fields in ascending order. Use the format `["view.field desc", ...]` to sort on fields in descending order. Use `["__UNSORTED__"]` (2 underscores before and after) to disable sorting entirely. Empty sorts `[]` will trigger a default sort.

  List<String> get sorts {
    if (!_sortsSet && _apiMapResponse.containsKey('sorts')) {
      _sorts =
          _apiMapResponse['sorts']?.map<String>((i) => i as String)?.toList();
      _sortsSet = true;
    }
    return _sorts;
  }

  set sorts(List<String> v) {
    _sorts = v;
    _sortsSet = true;
  }

  /// Limit

  String get limit {
    if (!_limitSet && _apiMapResponse.containsKey('limit')) {
      _limit = _apiMapResponse['limit']?.toString();
      _limitSet = true;
    }
    return _limit;
  }

  set limit(String v) {
    _limit = v;
    _limitSet = true;
  }

  /// Column Limit

  String get columnLimit {
    if (!_columnLimitSet && _apiMapResponse.containsKey('column_limit')) {
      _columnLimit = _apiMapResponse['column_limit']?.toString();
      _columnLimitSet = true;
    }
    return _columnLimit;
  }

  set columnLimit(String v) {
    _columnLimit = v;
    _columnLimitSet = true;
  }

  /// Total

  bool get total {
    if (!_totalSet && _apiMapResponse.containsKey('total')) {
      _total = _apiMapResponse['total'];
      _totalSet = true;
    }
    return _total;
  }

  set total(bool v) {
    _total = v;
    _totalSet = true;
  }

  /// Raw Total

  String get rowTotal {
    if (!_rowTotalSet && _apiMapResponse.containsKey('row_total')) {
      _rowTotal = _apiMapResponse['row_total']?.toString();
      _rowTotalSet = true;
    }
    return _rowTotal;
  }

  set rowTotal(String v) {
    _rowTotal = v;
    _rowTotalSet = true;
  }

  /// Fields on which to run subtotals

  List<String> get subtotals {
    if (!_subtotalsSet && _apiMapResponse.containsKey('subtotals')) {
      _subtotals = _apiMapResponse['subtotals']
          ?.map<String>((i) => i as String)
          ?.toList();
      _subtotalsSet = true;
    }
    return _subtotals;
  }

  set subtotals(List<String> v) {
    _subtotals = v;
    _subtotalsSet = true;
  }

  /// Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.

  Map<String, dynamic> get visConfig {
    if (!_visConfigSet && _apiMapResponse.containsKey('vis_config')) {
      _visConfig = _apiMapResponse['vis_config'];
      _visConfigSet = true;
    }
    return _visConfig;
  }

  set visConfig(Map<String, dynamic> v) {
    _visConfig = v;
    _visConfigSet = true;
  }

  /// The filter_config represents the state of the filter UI on the explore page for a given query. When running a query via the Looker UI, this parameter takes precedence over "filters". When creating a query or modifying an existing query, "filter_config" should be set to null. Setting it to any other value could cause unexpected filtering behavior. The format should be considered opaque.

  Map<String, dynamic> get filterConfig {
    if (!_filterConfigSet && _apiMapResponse.containsKey('filter_config')) {
      _filterConfig = _apiMapResponse['filter_config'];
      _filterConfigSet = true;
    }
    return _filterConfig;
  }

  set filterConfig(Map<String, dynamic> v) {
    _filterConfig = v;
    _filterConfigSet = true;
  }

  /// Visible UI Sections

  String get visibleUiSections {
    if (!_visibleUiSectionsSet &&
        _apiMapResponse.containsKey('visible_ui_sections')) {
      _visibleUiSections = _apiMapResponse['visible_ui_sections']?.toString();
      _visibleUiSectionsSet = true;
    }
    return _visibleUiSections;
  }

  set visibleUiSections(String v) {
    _visibleUiSections = v;
    _visibleUiSectionsSet = true;
  }

  /// Slug (read-only)

  String get slug {
    if (!_slugSet && _apiMapResponse.containsKey('slug')) {
      _slug = _apiMapResponse['slug']?.toString();
      _slugSet = true;
    }
    return _slug;
  }

  set slug(String v) {
    _slug = v;
    _slugSet = true;
  }

  /// Dynamic Fields

  String get dynamicFields {
    if (!_dynamicFieldsSet && _apiMapResponse.containsKey('dynamic_fields')) {
      _dynamicFields = _apiMapResponse['dynamic_fields']?.toString();
      _dynamicFieldsSet = true;
    }
    return _dynamicFields;
  }

  set dynamicFields(String v) {
    _dynamicFields = v;
    _dynamicFieldsSet = true;
  }

  /// Client Id: used to generate shortened explore URLs. If set by client, must be a unique 22 character alphanumeric string. Otherwise one will be generated.

  String get clientId {
    if (!_clientIdSet && _apiMapResponse.containsKey('client_id')) {
      _clientId = _apiMapResponse['client_id']?.toString();
      _clientIdSet = true;
    }
    return _clientId;
  }

  set clientId(String v) {
    _clientId = v;
    _clientIdSet = true;
  }

  /// Share Url (read-only)

  String get shareUrl {
    if (!_shareUrlSet && _apiMapResponse.containsKey('share_url')) {
      _shareUrl = _apiMapResponse['share_url']?.toString();
      _shareUrlSet = true;
    }
    return _shareUrl;
  }

  set shareUrl(String v) {
    _shareUrl = v;
    _shareUrlSet = true;
  }

  /// Expanded Share Url (read-only)

  String get expandedShareUrl {
    if (!_expandedShareUrlSet &&
        _apiMapResponse.containsKey('expanded_share_url')) {
      _expandedShareUrl = _apiMapResponse['expanded_share_url']?.toString();
      _expandedShareUrlSet = true;
    }
    return _expandedShareUrl;
  }

  set expandedShareUrl(String v) {
    _expandedShareUrl = v;
    _expandedShareUrlSet = true;
  }

  /// Expanded Url (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  /// Query Timezone

  String get queryTimezone {
    if (!_queryTimezoneSet && _apiMapResponse.containsKey('query_timezone')) {
      _queryTimezone = _apiMapResponse['query_timezone']?.toString();
      _queryTimezoneSet = true;
    }
    return _queryTimezone;
  }

  set queryTimezone(String v) {
    _queryTimezone = v;
    _queryTimezoneSet = true;
  }

  /// Has Table Calculations (read-only)

  bool get hasTableCalculations {
    if (!_hasTableCalculationsSet &&
        _apiMapResponse.containsKey('has_table_calculations')) {
      _hasTableCalculations = _apiMapResponse['has_table_calculations'];
      _hasTableCalculationsSet = true;
    }
    return _hasTableCalculations;
  }

  set hasTableCalculations(bool v) {
    _hasTableCalculations = v;
    _hasTableCalculationsSet = true;
  }

  Query() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Query.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_modelSet || _apiMapResponse.containsKey('model')) {
      json['model'] = model;
    }
    if (_viewSet || _apiMapResponse.containsKey('view')) {
      json['view'] = view;
    }
    if (_fieldsSet || _apiMapResponse.containsKey('fields')) {
      json['fields'] = fields;
    }
    if (_pivotsSet || _apiMapResponse.containsKey('pivots')) {
      json['pivots'] = pivots;
    }
    if (_fillFieldsSet || _apiMapResponse.containsKey('fill_fields')) {
      json['fill_fields'] = fillFields;
    }
    if (_filtersSet || _apiMapResponse.containsKey('filters')) {
      json['filters'] = filters;
    }
    if (_filterExpressionSet ||
        _apiMapResponse.containsKey('filter_expression')) {
      json['filter_expression'] = filterExpression;
    }
    if (_sortsSet || _apiMapResponse.containsKey('sorts')) {
      json['sorts'] = sorts;
    }
    if (_limitSet || _apiMapResponse.containsKey('limit')) {
      json['limit'] = limit;
    }
    if (_columnLimitSet || _apiMapResponse.containsKey('column_limit')) {
      json['column_limit'] = columnLimit;
    }
    if (_totalSet || _apiMapResponse.containsKey('total')) {
      json['total'] = total;
    }
    if (_rowTotalSet || _apiMapResponse.containsKey('row_total')) {
      json['row_total'] = rowTotal;
    }
    if (_subtotalsSet || _apiMapResponse.containsKey('subtotals')) {
      json['subtotals'] = subtotals;
    }
    if (_visConfigSet || _apiMapResponse.containsKey('vis_config')) {
      json['vis_config'] = visConfig;
    }
    if (_filterConfigSet || _apiMapResponse.containsKey('filter_config')) {
      json['filter_config'] = filterConfig;
    }
    if (_visibleUiSectionsSet ||
        _apiMapResponse.containsKey('visible_ui_sections')) {
      json['visible_ui_sections'] = visibleUiSections;
    }
    if (_slugSet || _apiMapResponse.containsKey('slug')) {
      json['slug'] = slug;
    }
    if (_dynamicFieldsSet || _apiMapResponse.containsKey('dynamic_fields')) {
      json['dynamic_fields'] = dynamicFields;
    }
    if (_clientIdSet || _apiMapResponse.containsKey('client_id')) {
      json['client_id'] = clientId;
    }
    if (_shareUrlSet || _apiMapResponse.containsKey('share_url')) {
      json['share_url'] = shareUrl;
    }
    if (_expandedShareUrlSet ||
        _apiMapResponse.containsKey('expanded_share_url')) {
      json['expanded_share_url'] = expandedShareUrl;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    if (_queryTimezoneSet || _apiMapResponse.containsKey('query_timezone')) {
      json['query_timezone'] = queryTimezone;
    }
    if (_hasTableCalculationsSet ||
        _apiMapResponse.containsKey('has_table_calculations')) {
      json['has_table_calculations'] = hasTableCalculations;
    }
    return json;
  }
}

class QueryTask {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _id;
  bool _idSet = false;

  int _queryId;
  bool _queryIdSet = false;

  Query _query;
  bool _querySet = false;

  bool _generateLinks;
  bool _generateLinksSet = false;

  bool _forceProduction;
  bool _forceProductionSet = false;

  String _pathPrefix;
  bool _pathPrefixSet = false;

  bool _cache;
  bool _cacheSet = false;

  bool _serverTableCalcs;
  bool _serverTableCalcsSet = false;

  bool _cacheOnly;
  bool _cacheOnlySet = false;

  String _cacheKey;
  bool _cacheKeySet = false;

  String _status;
  bool _statusSet = false;

  String _source;
  bool _sourceSet = false;

  double _runtime;
  bool _runtimeSet = false;

  bool _rebuildPdts;
  bool _rebuildPdtsSet = false;

  String _resultSource;
  bool _resultSourceSet = false;

  String _lookId;
  bool _lookIdSet = false;

  String _dashboardId;
  bool _dashboardIdSet = false;

  String _resultFormat;
  bool _resultFormatSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Id of query

  int get queryId {
    if (!_queryIdSet && _apiMapResponse.containsKey('query_id')) {
      _queryId = _apiMapResponse['query_id'];
      _queryIdSet = true;
    }
    return _queryId;
  }

  set queryId(int v) {
    _queryId = v;
    _queryIdSet = true;
  }

  Query get query {
    if (!_querySet && _apiMapResponse.containsKey('query')) {
      _query = _apiMapResponse['query'] == null
          ? null
          : Query.fromResponse(
              _apiMapResponse['query'], apiResponseContentType);
      _querySet = true;
    }
    return _query;
  }

  set query(Query v) {
    _query = v;
    _querySet = true;
  }

  /// whether or not to generate links in the query response.

  bool get generateLinks {
    if (!_generateLinksSet && _apiMapResponse.containsKey('generate_links')) {
      _generateLinks = _apiMapResponse['generate_links'];
      _generateLinksSet = true;
    }
    return _generateLinks;
  }

  set generateLinks(bool v) {
    _generateLinks = v;
    _generateLinksSet = true;
  }

  /// Use production models to run query (even is user is in dev mode).

  bool get forceProduction {
    if (!_forceProductionSet &&
        _apiMapResponse.containsKey('force_production')) {
      _forceProduction = _apiMapResponse['force_production'];
      _forceProductionSet = true;
    }
    return _forceProduction;
  }

  set forceProduction(bool v) {
    _forceProduction = v;
    _forceProductionSet = true;
  }

  /// Prefix to use for drill links.

  String get pathPrefix {
    if (!_pathPrefixSet && _apiMapResponse.containsKey('path_prefix')) {
      _pathPrefix = _apiMapResponse['path_prefix']?.toString();
      _pathPrefixSet = true;
    }
    return _pathPrefix;
  }

  set pathPrefix(String v) {
    _pathPrefix = v;
    _pathPrefixSet = true;
  }

  /// Whether or not to use the cache

  bool get cache {
    if (!_cacheSet && _apiMapResponse.containsKey('cache')) {
      _cache = _apiMapResponse['cache'];
      _cacheSet = true;
    }
    return _cache;
  }

  set cache(bool v) {
    _cache = v;
    _cacheSet = true;
  }

  /// Whether or not to run table calculations on the server

  bool get serverTableCalcs {
    if (!_serverTableCalcsSet &&
        _apiMapResponse.containsKey('server_table_calcs')) {
      _serverTableCalcs = _apiMapResponse['server_table_calcs'];
      _serverTableCalcsSet = true;
    }
    return _serverTableCalcs;
  }

  set serverTableCalcs(bool v) {
    _serverTableCalcs = v;
    _serverTableCalcsSet = true;
  }

  /// Retrieve any results from cache even if the results have expired.

  bool get cacheOnly {
    if (!_cacheOnlySet && _apiMapResponse.containsKey('cache_only')) {
      _cacheOnly = _apiMapResponse['cache_only'];
      _cacheOnlySet = true;
    }
    return _cacheOnly;
  }

  set cacheOnly(bool v) {
    _cacheOnly = v;
    _cacheOnlySet = true;
  }

  /// cache key used to cache query. (read-only)

  String get cacheKey {
    if (!_cacheKeySet && _apiMapResponse.containsKey('cache_key')) {
      _cacheKey = _apiMapResponse['cache_key']?.toString();
      _cacheKeySet = true;
    }
    return _cacheKey;
  }

  set cacheKey(String v) {
    _cacheKey = v;
    _cacheKeySet = true;
  }

  /// Status of query task.

  String get status {
    if (!_statusSet && _apiMapResponse.containsKey('status')) {
      _status = _apiMapResponse['status']?.toString();
      _statusSet = true;
    }
    return _status;
  }

  set status(String v) {
    _status = v;
    _statusSet = true;
  }

  /// Source of query task.

  String get source {
    if (!_sourceSet && _apiMapResponse.containsKey('source')) {
      _source = _apiMapResponse['source']?.toString();
      _sourceSet = true;
    }
    return _source;
  }

  set source(String v) {
    _source = v;
    _sourceSet = true;
  }

  /// Runtime of prior queries. (read-only)

  double get runtime {
    if (!_runtimeSet && _apiMapResponse.containsKey('runtime')) {
      _runtime = _apiMapResponse['runtime'];
      _runtimeSet = true;
    }
    return _runtime;
  }

  set runtime(double v) {
    _runtime = v;
    _runtimeSet = true;
  }

  /// Rebuild PDTS used in query.

  bool get rebuildPdts {
    if (!_rebuildPdtsSet && _apiMapResponse.containsKey('rebuild_pdts')) {
      _rebuildPdts = _apiMapResponse['rebuild_pdts'];
      _rebuildPdtsSet = true;
    }
    return _rebuildPdts;
  }

  set rebuildPdts(bool v) {
    _rebuildPdts = v;
    _rebuildPdtsSet = true;
  }

  /// Source of the results of the query. (read-only)

  String get resultSource {
    if (!_resultSourceSet && _apiMapResponse.containsKey('result_source')) {
      _resultSource = _apiMapResponse['result_source']?.toString();
      _resultSourceSet = true;
    }
    return _resultSource;
  }

  set resultSource(String v) {
    _resultSource = v;
    _resultSourceSet = true;
  }

  /// Id of look associated with query.

  String get lookId {
    if (!_lookIdSet && _apiMapResponse.containsKey('look_id')) {
      _lookId = _apiMapResponse['look_id']?.toString();
      _lookIdSet = true;
    }
    return _lookId;
  }

  set lookId(String v) {
    _lookId = v;
    _lookIdSet = true;
  }

  /// Id of dashboard associated with query.

  String get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id']?.toString();
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(String v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// The data format of the query results. (read-only)

  String get resultFormat {
    if (!_resultFormatSet && _apiMapResponse.containsKey('result_format')) {
      _resultFormat = _apiMapResponse['result_format']?.toString();
      _resultFormatSet = true;
    }
    return _resultFormat;
  }

  set resultFormat(String v) {
    _resultFormat = v;
    _resultFormatSet = true;
  }

  QueryTask() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  QueryTask.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_queryIdSet || _apiMapResponse.containsKey('query_id')) {
      json['query_id'] = queryId;
    }
    if (_querySet || _apiMapResponse.containsKey('query')) {
      json['query'] = query?.toJson();
    }
    if (_generateLinksSet || _apiMapResponse.containsKey('generate_links')) {
      json['generate_links'] = generateLinks;
    }
    if (_forceProductionSet ||
        _apiMapResponse.containsKey('force_production')) {
      json['force_production'] = forceProduction;
    }
    if (_pathPrefixSet || _apiMapResponse.containsKey('path_prefix')) {
      json['path_prefix'] = pathPrefix;
    }
    if (_cacheSet || _apiMapResponse.containsKey('cache')) {
      json['cache'] = cache;
    }
    if (_serverTableCalcsSet ||
        _apiMapResponse.containsKey('server_table_calcs')) {
      json['server_table_calcs'] = serverTableCalcs;
    }
    if (_cacheOnlySet || _apiMapResponse.containsKey('cache_only')) {
      json['cache_only'] = cacheOnly;
    }
    if (_cacheKeySet || _apiMapResponse.containsKey('cache_key')) {
      json['cache_key'] = cacheKey;
    }
    if (_statusSet || _apiMapResponse.containsKey('status')) {
      json['status'] = status;
    }
    if (_sourceSet || _apiMapResponse.containsKey('source')) {
      json['source'] = source;
    }
    if (_runtimeSet || _apiMapResponse.containsKey('runtime')) {
      json['runtime'] = runtime;
    }
    if (_rebuildPdtsSet || _apiMapResponse.containsKey('rebuild_pdts')) {
      json['rebuild_pdts'] = rebuildPdts;
    }
    if (_resultSourceSet || _apiMapResponse.containsKey('result_source')) {
      json['result_source'] = resultSource;
    }
    if (_lookIdSet || _apiMapResponse.containsKey('look_id')) {
      json['look_id'] = lookId;
    }
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_resultFormatSet || _apiMapResponse.containsKey('result_format')) {
      json['result_format'] = resultFormat;
    }
    return json;
  }
}

class RenderTask {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _createdAt;
  bool _createdAtSet = false;

  String _dashboardFilters;
  bool _dashboardFiltersSet = false;

  int _dashboardId;
  bool _dashboardIdSet = false;

  String _dashboardStyle;
  bool _dashboardStyleSet = false;

  String _finalizedAt;
  bool _finalizedAtSet = false;

  int _height;
  bool _heightSet = false;

  String _id;
  bool _idSet = false;

  String _lookId;
  bool _lookIdSet = false;

  String _lookmlDashboardId;
  bool _lookmlDashboardIdSet = false;

  int _queryId;
  bool _queryIdSet = false;

  String _dashboardElementId;
  bool _dashboardElementIdSet = false;

  double _queryRuntime;
  bool _queryRuntimeSet = false;

  double _renderRuntime;
  bool _renderRuntimeSet = false;

  String _resultFormat;
  bool _resultFormatSet = false;

  double _runtime;
  bool _runtimeSet = false;

  String _status;
  bool _statusSet = false;

  String _statusDetail;
  bool _statusDetailSet = false;

  int _userId;
  bool _userIdSet = false;

  int _width;
  bool _widthSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Date/Time render task was created (read-only)

  String get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at']?.toString();
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(String v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// Filter values to apply to the dashboard queries, in URL query format (read-only)

  String get dashboardFilters {
    if (!_dashboardFiltersSet &&
        _apiMapResponse.containsKey('dashboard_filters')) {
      _dashboardFilters = _apiMapResponse['dashboard_filters']?.toString();
      _dashboardFiltersSet = true;
    }
    return _dashboardFilters;
  }

  set dashboardFilters(String v) {
    _dashboardFilters = v;
    _dashboardFiltersSet = true;
  }

  /// Id of dashboard to render (read-only)

  int get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id'];
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(int v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// Dashboard layout style: single_column or tiled (read-only)

  String get dashboardStyle {
    if (!_dashboardStyleSet && _apiMapResponse.containsKey('dashboard_style')) {
      _dashboardStyle = _apiMapResponse['dashboard_style']?.toString();
      _dashboardStyleSet = true;
    }
    return _dashboardStyle;
  }

  set dashboardStyle(String v) {
    _dashboardStyle = v;
    _dashboardStyleSet = true;
  }

  /// Date/Time render task was completed (read-only)

  String get finalizedAt {
    if (!_finalizedAtSet && _apiMapResponse.containsKey('finalized_at')) {
      _finalizedAt = _apiMapResponse['finalized_at']?.toString();
      _finalizedAtSet = true;
    }
    return _finalizedAt;
  }

  set finalizedAt(String v) {
    _finalizedAt = v;
    _finalizedAtSet = true;
  }

  /// Output height in pixels. Flowed layouts may ignore this value. (read-only)

  int get height {
    if (!_heightSet && _apiMapResponse.containsKey('height')) {
      _height = _apiMapResponse['height'];
      _heightSet = true;
    }
    return _height;
  }

  set height(int v) {
    _height = v;
    _heightSet = true;
  }

  /// Id of this render task (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Id of look to render (read-only)

  String get lookId {
    if (!_lookIdSet && _apiMapResponse.containsKey('look_id')) {
      _lookId = _apiMapResponse['look_id']?.toString();
      _lookIdSet = true;
    }
    return _lookId;
  }

  set lookId(String v) {
    _lookId = v;
    _lookIdSet = true;
  }

  /// Id of lookml dashboard to render (read-only)

  String get lookmlDashboardId {
    if (!_lookmlDashboardIdSet &&
        _apiMapResponse.containsKey('lookml_dashboard_id')) {
      _lookmlDashboardId = _apiMapResponse['lookml_dashboard_id']?.toString();
      _lookmlDashboardIdSet = true;
    }
    return _lookmlDashboardId;
  }

  set lookmlDashboardId(String v) {
    _lookmlDashboardId = v;
    _lookmlDashboardIdSet = true;
  }

  /// Id of query to render (read-only)

  int get queryId {
    if (!_queryIdSet && _apiMapResponse.containsKey('query_id')) {
      _queryId = _apiMapResponse['query_id'];
      _queryIdSet = true;
    }
    return _queryId;
  }

  set queryId(int v) {
    _queryId = v;
    _queryIdSet = true;
  }

  /// Id of dashboard element to render: UDD dashboard element would be numeric and LookML dashboard element would be model_name::dashboard_title::lookml_link_id (read-only)

  String get dashboardElementId {
    if (!_dashboardElementIdSet &&
        _apiMapResponse.containsKey('dashboard_element_id')) {
      _dashboardElementId = _apiMapResponse['dashboard_element_id']?.toString();
      _dashboardElementIdSet = true;
    }
    return _dashboardElementId;
  }

  set dashboardElementId(String v) {
    _dashboardElementId = v;
    _dashboardElementIdSet = true;
  }

  /// Number of seconds elapsed running queries (read-only)

  double get queryRuntime {
    if (!_queryRuntimeSet && _apiMapResponse.containsKey('query_runtime')) {
      _queryRuntime = _apiMapResponse['query_runtime'];
      _queryRuntimeSet = true;
    }
    return _queryRuntime;
  }

  set queryRuntime(double v) {
    _queryRuntime = v;
    _queryRuntimeSet = true;
  }

  /// Number of seconds elapsed rendering data (read-only)

  double get renderRuntime {
    if (!_renderRuntimeSet && _apiMapResponse.containsKey('render_runtime')) {
      _renderRuntime = _apiMapResponse['render_runtime'];
      _renderRuntimeSet = true;
    }
    return _renderRuntime;
  }

  set renderRuntime(double v) {
    _renderRuntime = v;
    _renderRuntimeSet = true;
  }

  /// Output format: pdf, png, or jpg (read-only)

  String get resultFormat {
    if (!_resultFormatSet && _apiMapResponse.containsKey('result_format')) {
      _resultFormat = _apiMapResponse['result_format']?.toString();
      _resultFormatSet = true;
    }
    return _resultFormat;
  }

  set resultFormat(String v) {
    _resultFormat = v;
    _resultFormatSet = true;
  }

  /// Total seconds elapsed for render task (read-only)

  double get runtime {
    if (!_runtimeSet && _apiMapResponse.containsKey('runtime')) {
      _runtime = _apiMapResponse['runtime'];
      _runtimeSet = true;
    }
    return _runtime;
  }

  set runtime(double v) {
    _runtime = v;
    _runtimeSet = true;
  }

  /// Render task status: enqueued_for_query, querying, enqueued_for_render, rendering, success, failure (read-only)

  String get status {
    if (!_statusSet && _apiMapResponse.containsKey('status')) {
      _status = _apiMapResponse['status']?.toString();
      _statusSet = true;
    }
    return _status;
  }

  set status(String v) {
    _status = v;
    _statusSet = true;
  }

  /// Additional information about the current status (read-only)

  String get statusDetail {
    if (!_statusDetailSet && _apiMapResponse.containsKey('status_detail')) {
      _statusDetail = _apiMapResponse['status_detail']?.toString();
      _statusDetailSet = true;
    }
    return _statusDetail;
  }

  set statusDetail(String v) {
    _statusDetail = v;
    _statusDetailSet = true;
  }

  /// The user account permissions in which the render task will execute (read-only)

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  /// Output width in pixels (read-only)

  int get width {
    if (!_widthSet && _apiMapResponse.containsKey('width')) {
      _width = _apiMapResponse['width'];
      _widthSet = true;
    }
    return _width;
  }

  set width(int v) {
    _width = v;
    _widthSet = true;
  }

  RenderTask() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  RenderTask.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt;
    }
    if (_dashboardFiltersSet ||
        _apiMapResponse.containsKey('dashboard_filters')) {
      json['dashboard_filters'] = dashboardFilters;
    }
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_dashboardStyleSet || _apiMapResponse.containsKey('dashboard_style')) {
      json['dashboard_style'] = dashboardStyle;
    }
    if (_finalizedAtSet || _apiMapResponse.containsKey('finalized_at')) {
      json['finalized_at'] = finalizedAt;
    }
    if (_heightSet || _apiMapResponse.containsKey('height')) {
      json['height'] = height;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_lookIdSet || _apiMapResponse.containsKey('look_id')) {
      json['look_id'] = lookId;
    }
    if (_lookmlDashboardIdSet ||
        _apiMapResponse.containsKey('lookml_dashboard_id')) {
      json['lookml_dashboard_id'] = lookmlDashboardId;
    }
    if (_queryIdSet || _apiMapResponse.containsKey('query_id')) {
      json['query_id'] = queryId;
    }
    if (_dashboardElementIdSet ||
        _apiMapResponse.containsKey('dashboard_element_id')) {
      json['dashboard_element_id'] = dashboardElementId;
    }
    if (_queryRuntimeSet || _apiMapResponse.containsKey('query_runtime')) {
      json['query_runtime'] = queryRuntime;
    }
    if (_renderRuntimeSet || _apiMapResponse.containsKey('render_runtime')) {
      json['render_runtime'] = renderRuntime;
    }
    if (_resultFormatSet || _apiMapResponse.containsKey('result_format')) {
      json['result_format'] = resultFormat;
    }
    if (_runtimeSet || _apiMapResponse.containsKey('runtime')) {
      json['runtime'] = runtime;
    }
    if (_statusSet || _apiMapResponse.containsKey('status')) {
      json['status'] = status;
    }
    if (_statusDetailSet || _apiMapResponse.containsKey('status_detail')) {
      json['status_detail'] = statusDetail;
    }
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    if (_widthSet || _apiMapResponse.containsKey('width')) {
      json['width'] = width;
    }
    return json;
  }
}

class RepositoryCredential {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _id;
  bool _idSet = false;

  String _rootProjectId;
  bool _rootProjectIdSet = false;

  String _remoteUrl;
  bool _remoteUrlSet = false;

  String _gitUsername;
  bool _gitUsernameSet = false;

  String _gitPassword;
  bool _gitPasswordSet = false;

  String _sshPublicKey;
  bool _sshPublicKeySet = false;

  bool _isConfigured;
  bool _isConfiguredSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Unique Id (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Root project Id (read-only)

  String get rootProjectId {
    if (!_rootProjectIdSet && _apiMapResponse.containsKey('root_project_id')) {
      _rootProjectId = _apiMapResponse['root_project_id']?.toString();
      _rootProjectIdSet = true;
    }
    return _rootProjectId;
  }

  set rootProjectId(String v) {
    _rootProjectId = v;
    _rootProjectIdSet = true;
  }

  /// Git remote repository url (read-only)

  String get remoteUrl {
    if (!_remoteUrlSet && _apiMapResponse.containsKey('remote_url')) {
      _remoteUrl = _apiMapResponse['remote_url']?.toString();
      _remoteUrlSet = true;
    }
    return _remoteUrl;
  }

  set remoteUrl(String v) {
    _remoteUrl = v;
    _remoteUrlSet = true;
  }

  /// Git username for HTTPS authentication.

  String get gitUsername {
    if (!_gitUsernameSet && _apiMapResponse.containsKey('git_username')) {
      _gitUsername = _apiMapResponse['git_username']?.toString();
      _gitUsernameSet = true;
    }
    return _gitUsername;
  }

  set gitUsername(String v) {
    _gitUsername = v;
    _gitUsernameSet = true;
  }

  /// (Write-Only) Git password for HTTPS authentication.

  String get gitPassword {
    if (!_gitPasswordSet && _apiMapResponse.containsKey('git_password')) {
      _gitPassword = _apiMapResponse['git_password']?.toString();
      _gitPasswordSet = true;
    }
    return _gitPassword;
  }

  set gitPassword(String v) {
    _gitPassword = v;
    _gitPasswordSet = true;
  }

  /// Public deploy key for SSH authentication.

  String get sshPublicKey {
    if (!_sshPublicKeySet && _apiMapResponse.containsKey('ssh_public_key')) {
      _sshPublicKey = _apiMapResponse['ssh_public_key']?.toString();
      _sshPublicKeySet = true;
    }
    return _sshPublicKey;
  }

  set sshPublicKey(String v) {
    _sshPublicKey = v;
    _sshPublicKeySet = true;
  }

  /// Whether the credentials have been configured for the Git Repository. (read-only)

  bool get isConfigured {
    if (!_isConfiguredSet && _apiMapResponse.containsKey('is_configured')) {
      _isConfigured = _apiMapResponse['is_configured'];
      _isConfiguredSet = true;
    }
    return _isConfigured;
  }

  set isConfigured(bool v) {
    _isConfigured = v;
    _isConfiguredSet = true;
  }

  RepositoryCredential() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  RepositoryCredential.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_rootProjectIdSet || _apiMapResponse.containsKey('root_project_id')) {
      json['root_project_id'] = rootProjectId;
    }
    if (_remoteUrlSet || _apiMapResponse.containsKey('remote_url')) {
      json['remote_url'] = remoteUrl;
    }
    if (_gitUsernameSet || _apiMapResponse.containsKey('git_username')) {
      json['git_username'] = gitUsername;
    }
    if (_gitPasswordSet || _apiMapResponse.containsKey('git_password')) {
      json['git_password'] = gitPassword;
    }
    if (_sshPublicKeySet || _apiMapResponse.containsKey('ssh_public_key')) {
      json['ssh_public_key'] = sshPublicKey;
    }
    if (_isConfiguredSet || _apiMapResponse.containsKey('is_configured')) {
      json['is_configured'] = isConfigured;
    }
    return json;
  }
}

/// Desired async query result format. Valid values are: "inline_json", "json", "json_detail", "json_fe", "csv", "html", "md", "txt", "xlsx", "gsxml". (Enum defined in CreateQueryTask)
enum ResultFormat {
  inlineJson,
  json,
  jsonDetail,
  jsonFe,
  csv,
  html,
  md,
  txt,
  xlsx,
  gsxml
}

class ResultFormatMapper {
  static String toStringValue(ResultFormat e) {
    switch (e) {
      case ResultFormat.inlineJson:
        return 'inline_json';
      case ResultFormat.json:
        return 'json';
      case ResultFormat.jsonDetail:
        return 'json_detail';
      case ResultFormat.jsonFe:
        return 'json_fe';
      case ResultFormat.csv:
        return 'csv';
      case ResultFormat.html:
        return 'html';
      case ResultFormat.md:
        return 'md';
      case ResultFormat.txt:
        return 'txt';
      case ResultFormat.xlsx:
        return 'xlsx';
      case ResultFormat.gsxml:
        return 'gsxml';

      default:
        return null;
    }
  }

  static ResultFormat fromStringValue(String s) {
    if (s == 'inline_json') {
      return ResultFormat.inlineJson;
    }
    if (s == 'json') {
      return ResultFormat.json;
    }
    if (s == 'json_detail') {
      return ResultFormat.jsonDetail;
    }
    if (s == 'json_fe') {
      return ResultFormat.jsonFe;
    }
    if (s == 'csv') {
      return ResultFormat.csv;
    }
    if (s == 'html') {
      return ResultFormat.html;
    }
    if (s == 'md') {
      return ResultFormat.md;
    }
    if (s == 'txt') {
      return ResultFormat.txt;
    }
    if (s == 'xlsx') {
      return ResultFormat.xlsx;
    }
    if (s == 'gsxml') {
      return ResultFormat.gsxml;
    }
    return null;
  }
}

class ResultMakerFilterables {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _model;
  bool _modelSet = false;

  String _view;
  bool _viewSet = false;

  String _name;
  bool _nameSet = false;

  List<ResultMakerFilterablesListen> _listen;
  bool _listenSet = false;

  /// The model this filterable comes from (used for field suggestions). (read-only)

  String get model {
    if (!_modelSet && _apiMapResponse.containsKey('model')) {
      _model = _apiMapResponse['model']?.toString();
      _modelSet = true;
    }
    return _model;
  }

  set model(String v) {
    _model = v;
    _modelSet = true;
  }

  /// The view this filterable comes from (used for field suggestions). (read-only)

  String get view {
    if (!_viewSet && _apiMapResponse.containsKey('view')) {
      _view = _apiMapResponse['view']?.toString();
      _viewSet = true;
    }
    return _view;
  }

  set view(String v) {
    _view = v;
    _viewSet = true;
  }

  /// The name of the filterable thing (Query or Merged Results). (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// array of dashboard_filter_name: and field: objects. (read-only)

  List<ResultMakerFilterablesListen> get listen {
    if (!_listenSet && _apiMapResponse.containsKey('listen')) {
      _listen = _apiMapResponse['listen'] == null
          ? null
          : (_apiMapResponse['listen'] as List)
              .map((i) => ResultMakerFilterablesListen.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _listenSet = true;
    }
    return _listen;
  }

  set listen(List<ResultMakerFilterablesListen> v) {
    _listen = v;
    _listenSet = true;
  }

  ResultMakerFilterables() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ResultMakerFilterables.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_modelSet || _apiMapResponse.containsKey('model')) {
      json['model'] = model;
    }
    if (_viewSet || _apiMapResponse.containsKey('view')) {
      json['view'] = view;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_listenSet || _apiMapResponse.containsKey('listen')) {
      json['listen'] = listen?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class ResultMakerFilterablesListen {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _dashboardFilterName;
  bool _dashboardFilterNameSet = false;

  String _field;
  bool _fieldSet = false;

  /// The name of a dashboard filter to listen to.

  String get dashboardFilterName {
    if (!_dashboardFilterNameSet &&
        _apiMapResponse.containsKey('dashboard_filter_name')) {
      _dashboardFilterName =
          _apiMapResponse['dashboard_filter_name']?.toString();
      _dashboardFilterNameSet = true;
    }
    return _dashboardFilterName;
  }

  set dashboardFilterName(String v) {
    _dashboardFilterName = v;
    _dashboardFilterNameSet = true;
  }

  /// The name of the field in the filterable to filter with the value of the dashboard filter.

  String get field {
    if (!_fieldSet && _apiMapResponse.containsKey('field')) {
      _field = _apiMapResponse['field']?.toString();
      _fieldSet = true;
    }
    return _field;
  }

  set field(String v) {
    _field = v;
    _fieldSet = true;
  }

  ResultMakerFilterablesListen() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ResultMakerFilterablesListen.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_dashboardFilterNameSet ||
        _apiMapResponse.containsKey('dashboard_filter_name')) {
      json['dashboard_filter_name'] = dashboardFilterName;
    }
    if (_fieldSet || _apiMapResponse.containsKey('field')) {
      json['field'] = field;
    }
    return json;
  }
}

class ResultMakerWithIdVisConfigAndDynamicFields {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _id;
  bool _idSet = false;

  String _dynamicFields;
  bool _dynamicFieldsSet = false;

  List<ResultMakerFilterables> _filterables;
  bool _filterablesSet = false;

  List<String> _sorts;
  bool _sortsSet = false;

  String _mergeResultId;
  bool _mergeResultIdSet = false;

  bool _total;
  bool _totalSet = false;

  int _queryId;
  bool _queryIdSet = false;

  String _sqlQueryId;
  bool _sqlQueryIdSet = false;

  Query _query;
  bool _querySet = false;

  Map<String, dynamic> _visConfig;
  bool _visConfigSet = false;

  /// Unique Id. (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// JSON string of dynamic field information. (read-only)

  String get dynamicFields {
    if (!_dynamicFieldsSet && _apiMapResponse.containsKey('dynamic_fields')) {
      _dynamicFields = _apiMapResponse['dynamic_fields']?.toString();
      _dynamicFieldsSet = true;
    }
    return _dynamicFields;
  }

  set dynamicFields(String v) {
    _dynamicFields = v;
    _dynamicFieldsSet = true;
  }

  /// array of items that can be filtered and information about them. (read-only)

  List<ResultMakerFilterables> get filterables {
    if (!_filterablesSet && _apiMapResponse.containsKey('filterables')) {
      _filterables = _apiMapResponse['filterables'] == null
          ? null
          : (_apiMapResponse['filterables'] as List)
              .map((i) => ResultMakerFilterables.fromResponse(
                  i, apiResponseContentType))
              .toList();
      _filterablesSet = true;
    }
    return _filterables;
  }

  set filterables(List<ResultMakerFilterables> v) {
    _filterables = v;
    _filterablesSet = true;
  }

  /// Sorts of the constituent Look, Query, or Merge Query (read-only)

  List<String> get sorts {
    if (!_sortsSet && _apiMapResponse.containsKey('sorts')) {
      _sorts =
          _apiMapResponse['sorts']?.map<String>((i) => i as String)?.toList();
      _sortsSet = true;
    }
    return _sorts;
  }

  set sorts(List<String> v) {
    _sorts = v;
    _sortsSet = true;
  }

  /// ID of merge result if this is a merge_result. (read-only)

  String get mergeResultId {
    if (!_mergeResultIdSet && _apiMapResponse.containsKey('merge_result_id')) {
      _mergeResultId = _apiMapResponse['merge_result_id']?.toString();
      _mergeResultIdSet = true;
    }
    return _mergeResultId;
  }

  set mergeResultId(String v) {
    _mergeResultId = v;
    _mergeResultIdSet = true;
  }

  /// Total of the constituent Look, Query, or Merge Query (read-only)

  bool get total {
    if (!_totalSet && _apiMapResponse.containsKey('total')) {
      _total = _apiMapResponse['total'];
      _totalSet = true;
    }
    return _total;
  }

  set total(bool v) {
    _total = v;
    _totalSet = true;
  }

  /// ID of query if this is a query. (read-only)

  int get queryId {
    if (!_queryIdSet && _apiMapResponse.containsKey('query_id')) {
      _queryId = _apiMapResponse['query_id'];
      _queryIdSet = true;
    }
    return _queryId;
  }

  set queryId(int v) {
    _queryId = v;
    _queryIdSet = true;
  }

  /// ID of SQL Query if this is a SQL Runner Query (read-only)

  String get sqlQueryId {
    if (!_sqlQueryIdSet && _apiMapResponse.containsKey('sql_query_id')) {
      _sqlQueryId = _apiMapResponse['sql_query_id']?.toString();
      _sqlQueryIdSet = true;
    }
    return _sqlQueryId;
  }

  set sqlQueryId(String v) {
    _sqlQueryId = v;
    _sqlQueryIdSet = true;
  }

  Query get query {
    if (!_querySet && _apiMapResponse.containsKey('query')) {
      _query = _apiMapResponse['query'] == null
          ? null
          : Query.fromResponse(
              _apiMapResponse['query'], apiResponseContentType);
      _querySet = true;
    }
    return _query;
  }

  set query(Query v) {
    _query = v;
    _querySet = true;
  }

  /// Vis config of the constituent Query, or Merge Query. (read-only)

  Map<String, dynamic> get visConfig {
    if (!_visConfigSet && _apiMapResponse.containsKey('vis_config')) {
      _visConfig = _apiMapResponse['vis_config'];
      _visConfigSet = true;
    }
    return _visConfig;
  }

  set visConfig(Map<String, dynamic> v) {
    _visConfig = v;
    _visConfigSet = true;
  }

  ResultMakerWithIdVisConfigAndDynamicFields() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ResultMakerWithIdVisConfigAndDynamicFields.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_dynamicFieldsSet || _apiMapResponse.containsKey('dynamic_fields')) {
      json['dynamic_fields'] = dynamicFields;
    }
    if (_filterablesSet || _apiMapResponse.containsKey('filterables')) {
      json['filterables'] = filterables?.map((i) => i.toJson())?.toList();
    }
    if (_sortsSet || _apiMapResponse.containsKey('sorts')) {
      json['sorts'] = sorts;
    }
    if (_mergeResultIdSet || _apiMapResponse.containsKey('merge_result_id')) {
      json['merge_result_id'] = mergeResultId;
    }
    if (_totalSet || _apiMapResponse.containsKey('total')) {
      json['total'] = total;
    }
    if (_queryIdSet || _apiMapResponse.containsKey('query_id')) {
      json['query_id'] = queryId;
    }
    if (_sqlQueryIdSet || _apiMapResponse.containsKey('sql_query_id')) {
      json['sql_query_id'] = sqlQueryId;
    }
    if (_querySet || _apiMapResponse.containsKey('query')) {
      json['query'] = query?.toJson();
    }
    if (_visConfigSet || _apiMapResponse.containsKey('vis_config')) {
      json['vis_config'] = visConfig;
    }
    return json;
  }
}

class Role {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _id;
  bool _idSet = false;

  String _name;
  bool _nameSet = false;

  PermissionSet _permissionSet;
  bool _permissionSetSet = false;

  int _permissionSetId;
  bool _permissionSetIdSet = false;

  ModelSet _modelSet;
  bool _modelSetSet = false;

  int _modelSetId;
  bool _modelSetIdSet = false;

  String _url;
  bool _urlSet = false;

  String _usersUrl;
  bool _usersUrlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Name of Role

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  PermissionSet get permissionSet {
    if (!_permissionSetSet && _apiMapResponse.containsKey('permission_set')) {
      _permissionSet = _apiMapResponse['permission_set'] == null
          ? null
          : PermissionSet.fromResponse(
              _apiMapResponse['permission_set'], apiResponseContentType);
      _permissionSetSet = true;
    }
    return _permissionSet;
  }

  set permissionSet(PermissionSet v) {
    _permissionSet = v;
    _permissionSetSet = true;
  }

  /// (Write-Only) Id of permission set

  int get permissionSetId {
    if (!_permissionSetIdSet &&
        _apiMapResponse.containsKey('permission_set_id')) {
      _permissionSetId = _apiMapResponse['permission_set_id'];
      _permissionSetIdSet = true;
    }
    return _permissionSetId;
  }

  set permissionSetId(int v) {
    _permissionSetId = v;
    _permissionSetIdSet = true;
  }

  ModelSet get modelSet {
    if (!_modelSetSet && _apiMapResponse.containsKey('model_set')) {
      _modelSet = _apiMapResponse['model_set'] == null
          ? null
          : ModelSet.fromResponse(
              _apiMapResponse['model_set'], apiResponseContentType);
      _modelSetSet = true;
    }
    return _modelSet;
  }

  set modelSet(ModelSet v) {
    _modelSet = v;
    _modelSetSet = true;
  }

  /// (Write-Only) Id of model set

  int get modelSetId {
    if (!_modelSetIdSet && _apiMapResponse.containsKey('model_set_id')) {
      _modelSetId = _apiMapResponse['model_set_id'];
      _modelSetIdSet = true;
    }
    return _modelSetId;
  }

  set modelSetId(int v) {
    _modelSetId = v;
    _modelSetIdSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  /// Link to get list of users with this role (read-only)

  String get usersUrl {
    if (!_usersUrlSet && _apiMapResponse.containsKey('users_url')) {
      _usersUrl = _apiMapResponse['users_url']?.toString();
      _usersUrlSet = true;
    }
    return _usersUrl;
  }

  set usersUrl(String v) {
    _usersUrl = v;
    _usersUrlSet = true;
  }

  Role() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Role.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_permissionSetSet || _apiMapResponse.containsKey('permission_set')) {
      json['permission_set'] = permissionSet?.toJson();
    }
    if (_permissionSetIdSet ||
        _apiMapResponse.containsKey('permission_set_id')) {
      json['permission_set_id'] = permissionSetId;
    }
    if (_modelSetSet || _apiMapResponse.containsKey('model_set')) {
      json['model_set'] = modelSet?.toJson();
    }
    if (_modelSetIdSet || _apiMapResponse.containsKey('model_set_id')) {
      json['model_set_id'] = modelSetId;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    if (_usersUrlSet || _apiMapResponse.containsKey('users_url')) {
      json['users_url'] = usersUrl;
    }
    return json;
  }
}

class RoleSearch {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _id;
  bool _idSet = false;

  String _name;
  bool _nameSet = false;

  PermissionSet _permissionSet;
  bool _permissionSetSet = false;

  int _permissionSetId;
  bool _permissionSetIdSet = false;

  ModelSet _modelSet;
  bool _modelSetSet = false;

  int _modelSetId;
  bool _modelSetIdSet = false;

  int _userCount;
  bool _userCountSet = false;

  String _url;
  bool _urlSet = false;

  String _usersUrl;
  bool _usersUrlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Name of Role

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  PermissionSet get permissionSet {
    if (!_permissionSetSet && _apiMapResponse.containsKey('permission_set')) {
      _permissionSet = _apiMapResponse['permission_set'] == null
          ? null
          : PermissionSet.fromResponse(
              _apiMapResponse['permission_set'], apiResponseContentType);
      _permissionSetSet = true;
    }
    return _permissionSet;
  }

  set permissionSet(PermissionSet v) {
    _permissionSet = v;
    _permissionSetSet = true;
  }

  /// (Write-Only) Id of permission set

  int get permissionSetId {
    if (!_permissionSetIdSet &&
        _apiMapResponse.containsKey('permission_set_id')) {
      _permissionSetId = _apiMapResponse['permission_set_id'];
      _permissionSetIdSet = true;
    }
    return _permissionSetId;
  }

  set permissionSetId(int v) {
    _permissionSetId = v;
    _permissionSetIdSet = true;
  }

  ModelSet get modelSet {
    if (!_modelSetSet && _apiMapResponse.containsKey('model_set')) {
      _modelSet = _apiMapResponse['model_set'] == null
          ? null
          : ModelSet.fromResponse(
              _apiMapResponse['model_set'], apiResponseContentType);
      _modelSetSet = true;
    }
    return _modelSet;
  }

  set modelSet(ModelSet v) {
    _modelSet = v;
    _modelSetSet = true;
  }

  /// (Write-Only) Id of model set

  int get modelSetId {
    if (!_modelSetIdSet && _apiMapResponse.containsKey('model_set_id')) {
      _modelSetId = _apiMapResponse['model_set_id'];
      _modelSetIdSet = true;
    }
    return _modelSetId;
  }

  set modelSetId(int v) {
    _modelSetId = v;
    _modelSetIdSet = true;
  }

  /// Count of users with this role (read-only)

  int get userCount {
    if (!_userCountSet && _apiMapResponse.containsKey('user_count')) {
      _userCount = _apiMapResponse['user_count'];
      _userCountSet = true;
    }
    return _userCount;
  }

  set userCount(int v) {
    _userCount = v;
    _userCountSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  /// Link to get list of users with this role (read-only)

  String get usersUrl {
    if (!_usersUrlSet && _apiMapResponse.containsKey('users_url')) {
      _usersUrl = _apiMapResponse['users_url']?.toString();
      _usersUrlSet = true;
    }
    return _usersUrl;
  }

  set usersUrl(String v) {
    _usersUrl = v;
    _usersUrlSet = true;
  }

  RoleSearch() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  RoleSearch.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_permissionSetSet || _apiMapResponse.containsKey('permission_set')) {
      json['permission_set'] = permissionSet?.toJson();
    }
    if (_permissionSetIdSet ||
        _apiMapResponse.containsKey('permission_set_id')) {
      json['permission_set_id'] = permissionSetId;
    }
    if (_modelSetSet || _apiMapResponse.containsKey('model_set')) {
      json['model_set'] = modelSet?.toJson();
    }
    if (_modelSetIdSet || _apiMapResponse.containsKey('model_set_id')) {
      json['model_set_id'] = modelSetId;
    }
    if (_userCountSet || _apiMapResponse.containsKey('user_count')) {
      json['user_count'] = userCount;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    if (_usersUrlSet || _apiMapResponse.containsKey('users_url')) {
      json['users_url'] = usersUrl;
    }
    return json;
  }
}

class RunningQueries {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _id;
  bool _idSet = false;

  UserPublic _user;
  bool _userSet = false;

  Query _query;
  bool _querySet = false;

  SqlQuery _sqlQuery;
  bool _sqlQuerySet = false;

  LookBasic _look;
  bool _lookSet = false;

  String _createdAt;
  bool _createdAtSet = false;

  String _completedAt;
  bool _completedAtSet = false;

  String _queryId;
  bool _queryIdSet = false;

  String _source;
  bool _sourceSet = false;

  String _nodeId;
  bool _nodeIdSet = false;

  String _slug;
  bool _slugSet = false;

  String _queryTaskId;
  bool _queryTaskIdSet = false;

  String _cacheKey;
  bool _cacheKeySet = false;

  String _connectionName;
  bool _connectionNameSet = false;

  String _dialect;
  bool _dialectSet = false;

  String _connectionId;
  bool _connectionIdSet = false;

  String _message;
  bool _messageSet = false;

  String _status;
  bool _statusSet = false;

  double _runtime;
  bool _runtimeSet = false;

  String _sql;
  bool _sqlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  UserPublic get user {
    if (!_userSet && _apiMapResponse.containsKey('user')) {
      _user = _apiMapResponse['user'] == null
          ? null
          : UserPublic.fromResponse(
              _apiMapResponse['user'], apiResponseContentType);
      _userSet = true;
    }
    return _user;
  }

  set user(UserPublic v) {
    _user = v;
    _userSet = true;
  }

  Query get query {
    if (!_querySet && _apiMapResponse.containsKey('query')) {
      _query = _apiMapResponse['query'] == null
          ? null
          : Query.fromResponse(
              _apiMapResponse['query'], apiResponseContentType);
      _querySet = true;
    }
    return _query;
  }

  set query(Query v) {
    _query = v;
    _querySet = true;
  }

  SqlQuery get sqlQuery {
    if (!_sqlQuerySet && _apiMapResponse.containsKey('sql_query')) {
      _sqlQuery = _apiMapResponse['sql_query'] == null
          ? null
          : SqlQuery.fromResponse(
              _apiMapResponse['sql_query'], apiResponseContentType);
      _sqlQuerySet = true;
    }
    return _sqlQuery;
  }

  set sqlQuery(SqlQuery v) {
    _sqlQuery = v;
    _sqlQuerySet = true;
  }

  LookBasic get look {
    if (!_lookSet && _apiMapResponse.containsKey('look')) {
      _look = _apiMapResponse['look'] == null
          ? null
          : LookBasic.fromResponse(
              _apiMapResponse['look'], apiResponseContentType);
      _lookSet = true;
    }
    return _look;
  }

  set look(LookBasic v) {
    _look = v;
    _lookSet = true;
  }

  /// Date/Time Query was initiated (read-only)

  String get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at']?.toString();
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(String v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// Date/Time Query was completed (read-only)

  String get completedAt {
    if (!_completedAtSet && _apiMapResponse.containsKey('completed_at')) {
      _completedAt = _apiMapResponse['completed_at']?.toString();
      _completedAtSet = true;
    }
    return _completedAt;
  }

  set completedAt(String v) {
    _completedAt = v;
    _completedAtSet = true;
  }

  /// Query Id (read-only)

  String get queryId {
    if (!_queryIdSet && _apiMapResponse.containsKey('query_id')) {
      _queryId = _apiMapResponse['query_id']?.toString();
      _queryIdSet = true;
    }
    return _queryId;
  }

  set queryId(String v) {
    _queryId = v;
    _queryIdSet = true;
  }

  /// Source (look, dashboard, queryrunner, explore, etc.) (read-only)

  String get source {
    if (!_sourceSet && _apiMapResponse.containsKey('source')) {
      _source = _apiMapResponse['source']?.toString();
      _sourceSet = true;
    }
    return _source;
  }

  set source(String v) {
    _source = v;
    _sourceSet = true;
  }

  /// Node Id (read-only)

  String get nodeId {
    if (!_nodeIdSet && _apiMapResponse.containsKey('node_id')) {
      _nodeId = _apiMapResponse['node_id']?.toString();
      _nodeIdSet = true;
    }
    return _nodeId;
  }

  set nodeId(String v) {
    _nodeId = v;
    _nodeIdSet = true;
  }

  /// Slug (read-only)

  String get slug {
    if (!_slugSet && _apiMapResponse.containsKey('slug')) {
      _slug = _apiMapResponse['slug']?.toString();
      _slugSet = true;
    }
    return _slug;
  }

  set slug(String v) {
    _slug = v;
    _slugSet = true;
  }

  /// ID of a Query Task (read-only)

  String get queryTaskId {
    if (!_queryTaskIdSet && _apiMapResponse.containsKey('query_task_id')) {
      _queryTaskId = _apiMapResponse['query_task_id']?.toString();
      _queryTaskIdSet = true;
    }
    return _queryTaskId;
  }

  set queryTaskId(String v) {
    _queryTaskId = v;
    _queryTaskIdSet = true;
  }

  /// Cache Key (read-only)

  String get cacheKey {
    if (!_cacheKeySet && _apiMapResponse.containsKey('cache_key')) {
      _cacheKey = _apiMapResponse['cache_key']?.toString();
      _cacheKeySet = true;
    }
    return _cacheKey;
  }

  set cacheKey(String v) {
    _cacheKey = v;
    _cacheKeySet = true;
  }

  /// Connection (read-only)

  String get connectionName {
    if (!_connectionNameSet && _apiMapResponse.containsKey('connection_name')) {
      _connectionName = _apiMapResponse['connection_name']?.toString();
      _connectionNameSet = true;
    }
    return _connectionName;
  }

  set connectionName(String v) {
    _connectionName = v;
    _connectionNameSet = true;
  }

  /// Dialect (read-only)

  String get dialect {
    if (!_dialectSet && _apiMapResponse.containsKey('dialect')) {
      _dialect = _apiMapResponse['dialect']?.toString();
      _dialectSet = true;
    }
    return _dialect;
  }

  set dialect(String v) {
    _dialect = v;
    _dialectSet = true;
  }

  /// Connection ID (read-only)

  String get connectionId {
    if (!_connectionIdSet && _apiMapResponse.containsKey('connection_id')) {
      _connectionId = _apiMapResponse['connection_id']?.toString();
      _connectionIdSet = true;
    }
    return _connectionId;
  }

  set connectionId(String v) {
    _connectionId = v;
    _connectionIdSet = true;
  }

  /// Additional Information(Error message or verbose status) (read-only)

  String get message {
    if (!_messageSet && _apiMapResponse.containsKey('message')) {
      _message = _apiMapResponse['message']?.toString();
      _messageSet = true;
    }
    return _message;
  }

  set message(String v) {
    _message = v;
    _messageSet = true;
  }

  /// Status description (read-only)

  String get status {
    if (!_statusSet && _apiMapResponse.containsKey('status')) {
      _status = _apiMapResponse['status']?.toString();
      _statusSet = true;
    }
    return _status;
  }

  set status(String v) {
    _status = v;
    _statusSet = true;
  }

  /// Number of seconds elapsed running the Query (read-only)

  double get runtime {
    if (!_runtimeSet && _apiMapResponse.containsKey('runtime')) {
      _runtime = _apiMapResponse['runtime'];
      _runtimeSet = true;
    }
    return _runtime;
  }

  set runtime(double v) {
    _runtime = v;
    _runtimeSet = true;
  }

  /// SQL text of the query as run (read-only)

  String get sql {
    if (!_sqlSet && _apiMapResponse.containsKey('sql')) {
      _sql = _apiMapResponse['sql']?.toString();
      _sqlSet = true;
    }
    return _sql;
  }

  set sql(String v) {
    _sql = v;
    _sqlSet = true;
  }

  RunningQueries() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  RunningQueries.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_userSet || _apiMapResponse.containsKey('user')) {
      json['user'] = user?.toJson();
    }
    if (_querySet || _apiMapResponse.containsKey('query')) {
      json['query'] = query?.toJson();
    }
    if (_sqlQuerySet || _apiMapResponse.containsKey('sql_query')) {
      json['sql_query'] = sqlQuery?.toJson();
    }
    if (_lookSet || _apiMapResponse.containsKey('look')) {
      json['look'] = look?.toJson();
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt;
    }
    if (_completedAtSet || _apiMapResponse.containsKey('completed_at')) {
      json['completed_at'] = completedAt;
    }
    if (_queryIdSet || _apiMapResponse.containsKey('query_id')) {
      json['query_id'] = queryId;
    }
    if (_sourceSet || _apiMapResponse.containsKey('source')) {
      json['source'] = source;
    }
    if (_nodeIdSet || _apiMapResponse.containsKey('node_id')) {
      json['node_id'] = nodeId;
    }
    if (_slugSet || _apiMapResponse.containsKey('slug')) {
      json['slug'] = slug;
    }
    if (_queryTaskIdSet || _apiMapResponse.containsKey('query_task_id')) {
      json['query_task_id'] = queryTaskId;
    }
    if (_cacheKeySet || _apiMapResponse.containsKey('cache_key')) {
      json['cache_key'] = cacheKey;
    }
    if (_connectionNameSet || _apiMapResponse.containsKey('connection_name')) {
      json['connection_name'] = connectionName;
    }
    if (_dialectSet || _apiMapResponse.containsKey('dialect')) {
      json['dialect'] = dialect;
    }
    if (_connectionIdSet || _apiMapResponse.containsKey('connection_id')) {
      json['connection_id'] = connectionId;
    }
    if (_messageSet || _apiMapResponse.containsKey('message')) {
      json['message'] = message;
    }
    if (_statusSet || _apiMapResponse.containsKey('status')) {
      json['status'] = status;
    }
    if (_runtimeSet || _apiMapResponse.containsKey('runtime')) {
      json['runtime'] = runtime;
    }
    if (_sqlSet || _apiMapResponse.containsKey('sql')) {
      json['sql'] = sql;
    }
    return json;
  }
}

class SamlConfig {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  bool _enabled;
  bool _enabledSet = false;

  String _idpCert;
  bool _idpCertSet = false;

  String _idpUrl;
  bool _idpUrlSet = false;

  String _idpIssuer;
  bool _idpIssuerSet = false;

  String _idpAudience;
  bool _idpAudienceSet = false;

  int _allowedClockDrift;
  bool _allowedClockDriftSet = false;

  String _userAttributeMapEmail;
  bool _userAttributeMapEmailSet = false;

  String _userAttributeMapFirstName;
  bool _userAttributeMapFirstNameSet = false;

  String _userAttributeMapLastName;
  bool _userAttributeMapLastNameSet = false;

  String _newUserMigrationTypes;
  bool _newUserMigrationTypesSet = false;

  bool _alternateEmailLoginAllowed;
  bool _alternateEmailLoginAllowedSet = false;

  String _testSlug;
  bool _testSlugSet = false;

  String _modifiedAt;
  bool _modifiedAtSet = false;

  String _modifiedBy;
  bool _modifiedBySet = false;

  List<Role> _defaultNewUserRoles;
  bool _defaultNewUserRolesSet = false;

  List<Group> _defaultNewUserGroups;
  bool _defaultNewUserGroupsSet = false;

  List<int> _defaultNewUserRoleIds;
  bool _defaultNewUserRoleIdsSet = false;

  List<int> _defaultNewUserGroupIds;
  bool _defaultNewUserGroupIdsSet = false;

  bool _setRolesFromGroups;
  bool _setRolesFromGroupsSet = false;

  String _groupsAttribute;
  bool _groupsAttributeSet = false;

  List<SamlGroupRead> _groups;
  bool _groupsSet = false;

  List<SamlGroupWrite> _groupsWithRoleIds;
  bool _groupsWithRoleIdsSet = false;

  bool _authRequiresRole;
  bool _authRequiresRoleSet = false;

  List<SamlUserAttributeRead> _userAttributes;
  bool _userAttributesSet = false;

  List<SamlUserAttributeWrite> _userAttributesWithIds;
  bool _userAttributesWithIdsSet = false;

  String _groupsFinderType;
  bool _groupsFinderTypeSet = false;

  String _groupsMemberValue;
  bool _groupsMemberValueSet = false;

  bool _bypassLoginPage;
  bool _bypassLoginPageSet = false;

  bool _allowNormalGroupMembership;
  bool _allowNormalGroupMembershipSet = false;

  bool _allowRolesFromNormalGroups;
  bool _allowRolesFromNormalGroupsSet = false;

  bool _allowDirectRoles;
  bool _allowDirectRolesSet = false;

  String _url;
  bool _urlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Enable/Disable Saml authentication for the server

  bool get enabled {
    if (!_enabledSet && _apiMapResponse.containsKey('enabled')) {
      _enabled = _apiMapResponse['enabled'];
      _enabledSet = true;
    }
    return _enabled;
  }

  set enabled(bool v) {
    _enabled = v;
    _enabledSet = true;
  }

  /// Identity Provider Certificate (provided by IdP)

  String get idpCert {
    if (!_idpCertSet && _apiMapResponse.containsKey('idp_cert')) {
      _idpCert = _apiMapResponse['idp_cert']?.toString();
      _idpCertSet = true;
    }
    return _idpCert;
  }

  set idpCert(String v) {
    _idpCert = v;
    _idpCertSet = true;
  }

  /// Identity Provider Url (provided by IdP)

  String get idpUrl {
    if (!_idpUrlSet && _apiMapResponse.containsKey('idp_url')) {
      _idpUrl = _apiMapResponse['idp_url']?.toString();
      _idpUrlSet = true;
    }
    return _idpUrl;
  }

  set idpUrl(String v) {
    _idpUrl = v;
    _idpUrlSet = true;
  }

  /// Identity Provider Issuer (provided by IdP)

  String get idpIssuer {
    if (!_idpIssuerSet && _apiMapResponse.containsKey('idp_issuer')) {
      _idpIssuer = _apiMapResponse['idp_issuer']?.toString();
      _idpIssuerSet = true;
    }
    return _idpIssuer;
  }

  set idpIssuer(String v) {
    _idpIssuer = v;
    _idpIssuerSet = true;
  }

  /// Identity Provider Audience (set in IdP config). Optional in Looker. Set this only if you want Looker to validate the audience value returned by the IdP.

  String get idpAudience {
    if (!_idpAudienceSet && _apiMapResponse.containsKey('idp_audience')) {
      _idpAudience = _apiMapResponse['idp_audience']?.toString();
      _idpAudienceSet = true;
    }
    return _idpAudience;
  }

  set idpAudience(String v) {
    _idpAudience = v;
    _idpAudienceSet = true;
  }

  /// Count of seconds of clock drift to allow when validating timestamps of assertions.

  int get allowedClockDrift {
    if (!_allowedClockDriftSet &&
        _apiMapResponse.containsKey('allowed_clock_drift')) {
      _allowedClockDrift = _apiMapResponse['allowed_clock_drift'];
      _allowedClockDriftSet = true;
    }
    return _allowedClockDrift;
  }

  set allowedClockDrift(int v) {
    _allowedClockDrift = v;
    _allowedClockDriftSet = true;
  }

  /// Name of user record attributes used to indicate email address field

  String get userAttributeMapEmail {
    if (!_userAttributeMapEmailSet &&
        _apiMapResponse.containsKey('user_attribute_map_email')) {
      _userAttributeMapEmail =
          _apiMapResponse['user_attribute_map_email']?.toString();
      _userAttributeMapEmailSet = true;
    }
    return _userAttributeMapEmail;
  }

  set userAttributeMapEmail(String v) {
    _userAttributeMapEmail = v;
    _userAttributeMapEmailSet = true;
  }

  /// Name of user record attributes used to indicate first name

  String get userAttributeMapFirstName {
    if (!_userAttributeMapFirstNameSet &&
        _apiMapResponse.containsKey('user_attribute_map_first_name')) {
      _userAttributeMapFirstName =
          _apiMapResponse['user_attribute_map_first_name']?.toString();
      _userAttributeMapFirstNameSet = true;
    }
    return _userAttributeMapFirstName;
  }

  set userAttributeMapFirstName(String v) {
    _userAttributeMapFirstName = v;
    _userAttributeMapFirstNameSet = true;
  }

  /// Name of user record attributes used to indicate last name

  String get userAttributeMapLastName {
    if (!_userAttributeMapLastNameSet &&
        _apiMapResponse.containsKey('user_attribute_map_last_name')) {
      _userAttributeMapLastName =
          _apiMapResponse['user_attribute_map_last_name']?.toString();
      _userAttributeMapLastNameSet = true;
    }
    return _userAttributeMapLastName;
  }

  set userAttributeMapLastName(String v) {
    _userAttributeMapLastName = v;
    _userAttributeMapLastNameSet = true;
  }

  /// Merge first-time saml login to existing user account by email addresses. When a user logs in for the first time via saml this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'

  String get newUserMigrationTypes {
    if (!_newUserMigrationTypesSet &&
        _apiMapResponse.containsKey('new_user_migration_types')) {
      _newUserMigrationTypes =
          _apiMapResponse['new_user_migration_types']?.toString();
      _newUserMigrationTypesSet = true;
    }
    return _newUserMigrationTypes;
  }

  set newUserMigrationTypes(String v) {
    _newUserMigrationTypes = v;
    _newUserMigrationTypesSet = true;
  }

  /// Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.

  bool get alternateEmailLoginAllowed {
    if (!_alternateEmailLoginAllowedSet &&
        _apiMapResponse.containsKey('alternate_email_login_allowed')) {
      _alternateEmailLoginAllowed =
          _apiMapResponse['alternate_email_login_allowed'];
      _alternateEmailLoginAllowedSet = true;
    }
    return _alternateEmailLoginAllowed;
  }

  set alternateEmailLoginAllowed(bool v) {
    _alternateEmailLoginAllowed = v;
    _alternateEmailLoginAllowedSet = true;
  }

  /// Slug to identify configurations that are created in order to run a Saml config test (read-only)

  String get testSlug {
    if (!_testSlugSet && _apiMapResponse.containsKey('test_slug')) {
      _testSlug = _apiMapResponse['test_slug']?.toString();
      _testSlugSet = true;
    }
    return _testSlug;
  }

  set testSlug(String v) {
    _testSlug = v;
    _testSlugSet = true;
  }

  /// When this config was last modified (read-only)

  String get modifiedAt {
    if (!_modifiedAtSet && _apiMapResponse.containsKey('modified_at')) {
      _modifiedAt = _apiMapResponse['modified_at']?.toString();
      _modifiedAtSet = true;
    }
    return _modifiedAt;
  }

  set modifiedAt(String v) {
    _modifiedAt = v;
    _modifiedAtSet = true;
  }

  /// User id of user who last modified this config (read-only)

  String get modifiedBy {
    if (!_modifiedBySet && _apiMapResponse.containsKey('modified_by')) {
      _modifiedBy = _apiMapResponse['modified_by']?.toString();
      _modifiedBySet = true;
    }
    return _modifiedBy;
  }

  set modifiedBy(String v) {
    _modifiedBy = v;
    _modifiedBySet = true;
  }

  /// (Read-only) Roles that will be applied to new users the first time they login via Saml (read-only)

  List<Role> get defaultNewUserRoles {
    if (!_defaultNewUserRolesSet &&
        _apiMapResponse.containsKey('default_new_user_roles')) {
      _defaultNewUserRoles = _apiMapResponse['default_new_user_roles'] == null
          ? null
          : (_apiMapResponse['default_new_user_roles'] as List)
              .map((i) => Role.fromResponse(i, apiResponseContentType))
              .toList();
      _defaultNewUserRolesSet = true;
    }
    return _defaultNewUserRoles;
  }

  set defaultNewUserRoles(List<Role> v) {
    _defaultNewUserRoles = v;
    _defaultNewUserRolesSet = true;
  }

  /// (Read-only) Groups that will be applied to new users the first time they login via Saml (read-only)

  List<Group> get defaultNewUserGroups {
    if (!_defaultNewUserGroupsSet &&
        _apiMapResponse.containsKey('default_new_user_groups')) {
      _defaultNewUserGroups = _apiMapResponse['default_new_user_groups'] == null
          ? null
          : (_apiMapResponse['default_new_user_groups'] as List)
              .map((i) => Group.fromResponse(i, apiResponseContentType))
              .toList();
      _defaultNewUserGroupsSet = true;
    }
    return _defaultNewUserGroups;
  }

  set defaultNewUserGroups(List<Group> v) {
    _defaultNewUserGroups = v;
    _defaultNewUserGroupsSet = true;
  }

  /// (Write-Only) Array of ids of roles that will be applied to new users the first time they login via Saml

  List<int> get defaultNewUserRoleIds {
    if (!_defaultNewUserRoleIdsSet &&
        _apiMapResponse.containsKey('default_new_user_role_ids')) {
      _defaultNewUserRoleIds = _apiMapResponse['default_new_user_role_ids']
          ?.map<int>((i) => i as int)
          ?.toList();
      _defaultNewUserRoleIdsSet = true;
    }
    return _defaultNewUserRoleIds;
  }

  set defaultNewUserRoleIds(List<int> v) {
    _defaultNewUserRoleIds = v;
    _defaultNewUserRoleIdsSet = true;
  }

  /// (Write-Only) Array of ids of groups that will be applied to new users the first time they login via Saml

  List<int> get defaultNewUserGroupIds {
    if (!_defaultNewUserGroupIdsSet &&
        _apiMapResponse.containsKey('default_new_user_group_ids')) {
      _defaultNewUserGroupIds = _apiMapResponse['default_new_user_group_ids']
          ?.map<int>((i) => i as int)
          ?.toList();
      _defaultNewUserGroupIdsSet = true;
    }
    return _defaultNewUserGroupIds;
  }

  set defaultNewUserGroupIds(List<int> v) {
    _defaultNewUserGroupIds = v;
    _defaultNewUserGroupIdsSet = true;
  }

  /// Set user roles in Looker based on groups from Saml

  bool get setRolesFromGroups {
    if (!_setRolesFromGroupsSet &&
        _apiMapResponse.containsKey('set_roles_from_groups')) {
      _setRolesFromGroups = _apiMapResponse['set_roles_from_groups'];
      _setRolesFromGroupsSet = true;
    }
    return _setRolesFromGroups;
  }

  set setRolesFromGroups(bool v) {
    _setRolesFromGroups = v;
    _setRolesFromGroupsSet = true;
  }

  /// Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'

  String get groupsAttribute {
    if (!_groupsAttributeSet &&
        _apiMapResponse.containsKey('groups_attribute')) {
      _groupsAttribute = _apiMapResponse['groups_attribute']?.toString();
      _groupsAttributeSet = true;
    }
    return _groupsAttribute;
  }

  set groupsAttribute(String v) {
    _groupsAttribute = v;
    _groupsAttributeSet = true;
  }

  /// (Read-only) Array of mappings between Saml Groups and Looker Roles (read-only)

  List<SamlGroupRead> get groups {
    if (!_groupsSet && _apiMapResponse.containsKey('groups')) {
      _groups = _apiMapResponse['groups'] == null
          ? null
          : (_apiMapResponse['groups'] as List)
              .map((i) => SamlGroupRead.fromResponse(i, apiResponseContentType))
              .toList();
      _groupsSet = true;
    }
    return _groups;
  }

  set groups(List<SamlGroupRead> v) {
    _groups = v;
    _groupsSet = true;
  }

  /// (Read/Write) Array of mappings between Saml Groups and arrays of Looker Role ids

  List<SamlGroupWrite> get groupsWithRoleIds {
    if (!_groupsWithRoleIdsSet &&
        _apiMapResponse.containsKey('groups_with_role_ids')) {
      _groupsWithRoleIds = _apiMapResponse['groups_with_role_ids'] == null
          ? null
          : (_apiMapResponse['groups_with_role_ids'] as List)
              .map(
                  (i) => SamlGroupWrite.fromResponse(i, apiResponseContentType))
              .toList();
      _groupsWithRoleIdsSet = true;
    }
    return _groupsWithRoleIds;
  }

  set groupsWithRoleIds(List<SamlGroupWrite> v) {
    _groupsWithRoleIds = v;
    _groupsWithRoleIdsSet = true;
  }

  /// Users will not be allowed to login at all unless a role for them is found in Saml if set to true

  bool get authRequiresRole {
    if (!_authRequiresRoleSet &&
        _apiMapResponse.containsKey('auth_requires_role')) {
      _authRequiresRole = _apiMapResponse['auth_requires_role'];
      _authRequiresRoleSet = true;
    }
    return _authRequiresRole;
  }

  set authRequiresRole(bool v) {
    _authRequiresRole = v;
    _authRequiresRoleSet = true;
  }

  /// (Read-only) Array of mappings between Saml User Attributes and Looker User Attributes (read-only)

  List<SamlUserAttributeRead> get userAttributes {
    if (!_userAttributesSet && _apiMapResponse.containsKey('user_attributes')) {
      _userAttributes = _apiMapResponse['user_attributes'] == null
          ? null
          : (_apiMapResponse['user_attributes'] as List)
              .map((i) =>
                  SamlUserAttributeRead.fromResponse(i, apiResponseContentType))
              .toList();
      _userAttributesSet = true;
    }
    return _userAttributes;
  }

  set userAttributes(List<SamlUserAttributeRead> v) {
    _userAttributes = v;
    _userAttributesSet = true;
  }

  /// (Read/Write) Array of mappings between Saml User Attributes and arrays of Looker User Attribute ids

  List<SamlUserAttributeWrite> get userAttributesWithIds {
    if (!_userAttributesWithIdsSet &&
        _apiMapResponse.containsKey('user_attributes_with_ids')) {
      _userAttributesWithIds =
          _apiMapResponse['user_attributes_with_ids'] == null
              ? null
              : (_apiMapResponse['user_attributes_with_ids'] as List)
                  .map((i) => SamlUserAttributeWrite.fromResponse(
                      i, apiResponseContentType))
                  .toList();
      _userAttributesWithIdsSet = true;
    }
    return _userAttributesWithIds;
  }

  set userAttributesWithIds(List<SamlUserAttributeWrite> v) {
    _userAttributesWithIds = v;
    _userAttributesWithIdsSet = true;
  }

  /// Identifier for a strategy for how Looker will find groups in the SAML response. One of ['grouped_attribute_values', 'individual_attributes']

  String get groupsFinderType {
    if (!_groupsFinderTypeSet &&
        _apiMapResponse.containsKey('groups_finder_type')) {
      _groupsFinderType = _apiMapResponse['groups_finder_type']?.toString();
      _groupsFinderTypeSet = true;
    }
    return _groupsFinderType;
  }

  set groupsFinderType(String v) {
    _groupsFinderType = v;
    _groupsFinderTypeSet = true;
  }

  /// Value for group attribute used to indicate membership. Used when 'groups_finder_type' is set to 'individual_attributes'

  String get groupsMemberValue {
    if (!_groupsMemberValueSet &&
        _apiMapResponse.containsKey('groups_member_value')) {
      _groupsMemberValue = _apiMapResponse['groups_member_value']?.toString();
      _groupsMemberValueSet = true;
    }
    return _groupsMemberValue;
  }

  set groupsMemberValue(String v) {
    _groupsMemberValue = v;
    _groupsMemberValueSet = true;
  }

  /// Bypass the login page when user authentication is required. Redirect to IdP immediately instead.

  bool get bypassLoginPage {
    if (!_bypassLoginPageSet &&
        _apiMapResponse.containsKey('bypass_login_page')) {
      _bypassLoginPage = _apiMapResponse['bypass_login_page'];
      _bypassLoginPageSet = true;
    }
    return _bypassLoginPage;
  }

  set bypassLoginPage(bool v) {
    _bypassLoginPage = v;
    _bypassLoginPageSet = true;
  }

  /// Allow SAML auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.

  bool get allowNormalGroupMembership {
    if (!_allowNormalGroupMembershipSet &&
        _apiMapResponse.containsKey('allow_normal_group_membership')) {
      _allowNormalGroupMembership =
          _apiMapResponse['allow_normal_group_membership'];
      _allowNormalGroupMembershipSet = true;
    }
    return _allowNormalGroupMembership;
  }

  set allowNormalGroupMembership(bool v) {
    _allowNormalGroupMembership = v;
    _allowNormalGroupMembershipSet = true;
  }

  /// SAML auth'd users will inherit roles from non-reflected Looker groups.

  bool get allowRolesFromNormalGroups {
    if (!_allowRolesFromNormalGroupsSet &&
        _apiMapResponse.containsKey('allow_roles_from_normal_groups')) {
      _allowRolesFromNormalGroups =
          _apiMapResponse['allow_roles_from_normal_groups'];
      _allowRolesFromNormalGroupsSet = true;
    }
    return _allowRolesFromNormalGroups;
  }

  set allowRolesFromNormalGroups(bool v) {
    _allowRolesFromNormalGroups = v;
    _allowRolesFromNormalGroupsSet = true;
  }

  /// Allows roles to be directly assigned to SAML auth'd users.

  bool get allowDirectRoles {
    if (!_allowDirectRolesSet &&
        _apiMapResponse.containsKey('allow_direct_roles')) {
      _allowDirectRoles = _apiMapResponse['allow_direct_roles'];
      _allowDirectRolesSet = true;
    }
    return _allowDirectRoles;
  }

  set allowDirectRoles(bool v) {
    _allowDirectRoles = v;
    _allowDirectRolesSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  SamlConfig() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SamlConfig.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_enabledSet || _apiMapResponse.containsKey('enabled')) {
      json['enabled'] = enabled;
    }
    if (_idpCertSet || _apiMapResponse.containsKey('idp_cert')) {
      json['idp_cert'] = idpCert;
    }
    if (_idpUrlSet || _apiMapResponse.containsKey('idp_url')) {
      json['idp_url'] = idpUrl;
    }
    if (_idpIssuerSet || _apiMapResponse.containsKey('idp_issuer')) {
      json['idp_issuer'] = idpIssuer;
    }
    if (_idpAudienceSet || _apiMapResponse.containsKey('idp_audience')) {
      json['idp_audience'] = idpAudience;
    }
    if (_allowedClockDriftSet ||
        _apiMapResponse.containsKey('allowed_clock_drift')) {
      json['allowed_clock_drift'] = allowedClockDrift;
    }
    if (_userAttributeMapEmailSet ||
        _apiMapResponse.containsKey('user_attribute_map_email')) {
      json['user_attribute_map_email'] = userAttributeMapEmail;
    }
    if (_userAttributeMapFirstNameSet ||
        _apiMapResponse.containsKey('user_attribute_map_first_name')) {
      json['user_attribute_map_first_name'] = userAttributeMapFirstName;
    }
    if (_userAttributeMapLastNameSet ||
        _apiMapResponse.containsKey('user_attribute_map_last_name')) {
      json['user_attribute_map_last_name'] = userAttributeMapLastName;
    }
    if (_newUserMigrationTypesSet ||
        _apiMapResponse.containsKey('new_user_migration_types')) {
      json['new_user_migration_types'] = newUserMigrationTypes;
    }
    if (_alternateEmailLoginAllowedSet ||
        _apiMapResponse.containsKey('alternate_email_login_allowed')) {
      json['alternate_email_login_allowed'] = alternateEmailLoginAllowed;
    }
    if (_testSlugSet || _apiMapResponse.containsKey('test_slug')) {
      json['test_slug'] = testSlug;
    }
    if (_modifiedAtSet || _apiMapResponse.containsKey('modified_at')) {
      json['modified_at'] = modifiedAt;
    }
    if (_modifiedBySet || _apiMapResponse.containsKey('modified_by')) {
      json['modified_by'] = modifiedBy;
    }
    if (_defaultNewUserRolesSet ||
        _apiMapResponse.containsKey('default_new_user_roles')) {
      json['default_new_user_roles'] =
          defaultNewUserRoles?.map((i) => i.toJson())?.toList();
    }
    if (_defaultNewUserGroupsSet ||
        _apiMapResponse.containsKey('default_new_user_groups')) {
      json['default_new_user_groups'] =
          defaultNewUserGroups?.map((i) => i.toJson())?.toList();
    }
    if (_defaultNewUserRoleIdsSet ||
        _apiMapResponse.containsKey('default_new_user_role_ids')) {
      json['default_new_user_role_ids'] = defaultNewUserRoleIds;
    }
    if (_defaultNewUserGroupIdsSet ||
        _apiMapResponse.containsKey('default_new_user_group_ids')) {
      json['default_new_user_group_ids'] = defaultNewUserGroupIds;
    }
    if (_setRolesFromGroupsSet ||
        _apiMapResponse.containsKey('set_roles_from_groups')) {
      json['set_roles_from_groups'] = setRolesFromGroups;
    }
    if (_groupsAttributeSet ||
        _apiMapResponse.containsKey('groups_attribute')) {
      json['groups_attribute'] = groupsAttribute;
    }
    if (_groupsSet || _apiMapResponse.containsKey('groups')) {
      json['groups'] = groups?.map((i) => i.toJson())?.toList();
    }
    if (_groupsWithRoleIdsSet ||
        _apiMapResponse.containsKey('groups_with_role_ids')) {
      json['groups_with_role_ids'] =
          groupsWithRoleIds?.map((i) => i.toJson())?.toList();
    }
    if (_authRequiresRoleSet ||
        _apiMapResponse.containsKey('auth_requires_role')) {
      json['auth_requires_role'] = authRequiresRole;
    }
    if (_userAttributesSet || _apiMapResponse.containsKey('user_attributes')) {
      json['user_attributes'] =
          userAttributes?.map((i) => i.toJson())?.toList();
    }
    if (_userAttributesWithIdsSet ||
        _apiMapResponse.containsKey('user_attributes_with_ids')) {
      json['user_attributes_with_ids'] =
          userAttributesWithIds?.map((i) => i.toJson())?.toList();
    }
    if (_groupsFinderTypeSet ||
        _apiMapResponse.containsKey('groups_finder_type')) {
      json['groups_finder_type'] = groupsFinderType;
    }
    if (_groupsMemberValueSet ||
        _apiMapResponse.containsKey('groups_member_value')) {
      json['groups_member_value'] = groupsMemberValue;
    }
    if (_bypassLoginPageSet ||
        _apiMapResponse.containsKey('bypass_login_page')) {
      json['bypass_login_page'] = bypassLoginPage;
    }
    if (_allowNormalGroupMembershipSet ||
        _apiMapResponse.containsKey('allow_normal_group_membership')) {
      json['allow_normal_group_membership'] = allowNormalGroupMembership;
    }
    if (_allowRolesFromNormalGroupsSet ||
        _apiMapResponse.containsKey('allow_roles_from_normal_groups')) {
      json['allow_roles_from_normal_groups'] = allowRolesFromNormalGroups;
    }
    if (_allowDirectRolesSet ||
        _apiMapResponse.containsKey('allow_direct_roles')) {
      json['allow_direct_roles'] = allowDirectRoles;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class SamlGroupRead {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _id;
  bool _idSet = false;

  int _lookerGroupId;
  bool _lookerGroupIdSet = false;

  String _lookerGroupName;
  bool _lookerGroupNameSet = false;

  String _name;
  bool _nameSet = false;

  List<Role> _roles;
  bool _rolesSet = false;

  String _url;
  bool _urlSet = false;

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Unique Id of group in Looker (read-only)

  int get lookerGroupId {
    if (!_lookerGroupIdSet && _apiMapResponse.containsKey('looker_group_id')) {
      _lookerGroupId = _apiMapResponse['looker_group_id'];
      _lookerGroupIdSet = true;
    }
    return _lookerGroupId;
  }

  set lookerGroupId(int v) {
    _lookerGroupId = v;
    _lookerGroupIdSet = true;
  }

  /// Name of group in Looker (read-only)

  String get lookerGroupName {
    if (!_lookerGroupNameSet &&
        _apiMapResponse.containsKey('looker_group_name')) {
      _lookerGroupName = _apiMapResponse['looker_group_name']?.toString();
      _lookerGroupNameSet = true;
    }
    return _lookerGroupName;
  }

  set lookerGroupName(String v) {
    _lookerGroupName = v;
    _lookerGroupNameSet = true;
  }

  /// Name of group in Saml (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Looker Roles (read-only)

  List<Role> get roles {
    if (!_rolesSet && _apiMapResponse.containsKey('roles')) {
      _roles = _apiMapResponse['roles'] == null
          ? null
          : (_apiMapResponse['roles'] as List)
              .map((i) => Role.fromResponse(i, apiResponseContentType))
              .toList();
      _rolesSet = true;
    }
    return _roles;
  }

  set roles(List<Role> v) {
    _roles = v;
    _rolesSet = true;
  }

  /// Link to saml config (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  SamlGroupRead() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SamlGroupRead.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_lookerGroupIdSet || _apiMapResponse.containsKey('looker_group_id')) {
      json['looker_group_id'] = lookerGroupId;
    }
    if (_lookerGroupNameSet ||
        _apiMapResponse.containsKey('looker_group_name')) {
      json['looker_group_name'] = lookerGroupName;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_rolesSet || _apiMapResponse.containsKey('roles')) {
      json['roles'] = roles?.map((i) => i.toJson())?.toList();
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class SamlGroupWrite {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _id;
  bool _idSet = false;

  int _lookerGroupId;
  bool _lookerGroupIdSet = false;

  String _lookerGroupName;
  bool _lookerGroupNameSet = false;

  String _name;
  bool _nameSet = false;

  List<int> _roleIds;
  bool _roleIdsSet = false;

  String _url;
  bool _urlSet = false;

  /// Unique Id

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Unique Id of group in Looker (read-only)

  int get lookerGroupId {
    if (!_lookerGroupIdSet && _apiMapResponse.containsKey('looker_group_id')) {
      _lookerGroupId = _apiMapResponse['looker_group_id'];
      _lookerGroupIdSet = true;
    }
    return _lookerGroupId;
  }

  set lookerGroupId(int v) {
    _lookerGroupId = v;
    _lookerGroupIdSet = true;
  }

  /// Name of group in Looker

  String get lookerGroupName {
    if (!_lookerGroupNameSet &&
        _apiMapResponse.containsKey('looker_group_name')) {
      _lookerGroupName = _apiMapResponse['looker_group_name']?.toString();
      _lookerGroupNameSet = true;
    }
    return _lookerGroupName;
  }

  set lookerGroupName(String v) {
    _lookerGroupName = v;
    _lookerGroupNameSet = true;
  }

  /// Name of group in Saml

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Looker Role Ids

  List<int> get roleIds {
    if (!_roleIdsSet && _apiMapResponse.containsKey('role_ids')) {
      _roleIds =
          _apiMapResponse['role_ids']?.map<int>((i) => i as int)?.toList();
      _roleIdsSet = true;
    }
    return _roleIds;
  }

  set roleIds(List<int> v) {
    _roleIds = v;
    _roleIdsSet = true;
  }

  /// Link to saml config (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  SamlGroupWrite() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SamlGroupWrite.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_lookerGroupIdSet || _apiMapResponse.containsKey('looker_group_id')) {
      json['looker_group_id'] = lookerGroupId;
    }
    if (_lookerGroupNameSet ||
        _apiMapResponse.containsKey('looker_group_name')) {
      json['looker_group_name'] = lookerGroupName;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_roleIdsSet || _apiMapResponse.containsKey('role_ids')) {
      json['role_ids'] = roleIds;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class SamlMetadataParseResult {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _idpIssuer;
  bool _idpIssuerSet = false;

  String _idpUrl;
  bool _idpUrlSet = false;

  String _idpCert;
  bool _idpCertSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Identify Provider Issuer (read-only)

  String get idpIssuer {
    if (!_idpIssuerSet && _apiMapResponse.containsKey('idp_issuer')) {
      _idpIssuer = _apiMapResponse['idp_issuer']?.toString();
      _idpIssuerSet = true;
    }
    return _idpIssuer;
  }

  set idpIssuer(String v) {
    _idpIssuer = v;
    _idpIssuerSet = true;
  }

  /// Identify Provider Url (read-only)

  String get idpUrl {
    if (!_idpUrlSet && _apiMapResponse.containsKey('idp_url')) {
      _idpUrl = _apiMapResponse['idp_url']?.toString();
      _idpUrlSet = true;
    }
    return _idpUrl;
  }

  set idpUrl(String v) {
    _idpUrl = v;
    _idpUrlSet = true;
  }

  /// Identify Provider Certificate (read-only)

  String get idpCert {
    if (!_idpCertSet && _apiMapResponse.containsKey('idp_cert')) {
      _idpCert = _apiMapResponse['idp_cert']?.toString();
      _idpCertSet = true;
    }
    return _idpCert;
  }

  set idpCert(String v) {
    _idpCert = v;
    _idpCertSet = true;
  }

  SamlMetadataParseResult() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SamlMetadataParseResult.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idpIssuerSet || _apiMapResponse.containsKey('idp_issuer')) {
      json['idp_issuer'] = idpIssuer;
    }
    if (_idpUrlSet || _apiMapResponse.containsKey('idp_url')) {
      json['idp_url'] = idpUrl;
    }
    if (_idpCertSet || _apiMapResponse.containsKey('idp_cert')) {
      json['idp_cert'] = idpCert;
    }
    return json;
  }
}

class SamlUserAttributeRead {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  bool _required;
  bool _requiredSet = false;

  List<UserAttribute> _userAttributes;
  bool _userAttributesSet = false;

  String _url;
  bool _urlSet = false;

  /// Name of User Attribute in Saml (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Required to be in Saml assertion for login to be allowed to succeed (read-only)

  bool get required {
    if (!_requiredSet && _apiMapResponse.containsKey('required')) {
      _required = _apiMapResponse['required'];
      _requiredSet = true;
    }
    return _required;
  }

  set required(bool v) {
    _required = v;
    _requiredSet = true;
  }

  /// Looker User Attributes (read-only)

  List<UserAttribute> get userAttributes {
    if (!_userAttributesSet && _apiMapResponse.containsKey('user_attributes')) {
      _userAttributes = _apiMapResponse['user_attributes'] == null
          ? null
          : (_apiMapResponse['user_attributes'] as List)
              .map((i) => UserAttribute.fromResponse(i, apiResponseContentType))
              .toList();
      _userAttributesSet = true;
    }
    return _userAttributes;
  }

  set userAttributes(List<UserAttribute> v) {
    _userAttributes = v;
    _userAttributesSet = true;
  }

  /// Link to saml config (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  SamlUserAttributeRead() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SamlUserAttributeRead.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_requiredSet || _apiMapResponse.containsKey('required')) {
      json['required'] = required;
    }
    if (_userAttributesSet || _apiMapResponse.containsKey('user_attributes')) {
      json['user_attributes'] =
          userAttributes?.map((i) => i.toJson())?.toList();
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class SamlUserAttributeWrite {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  bool _required;
  bool _requiredSet = false;

  List<int> _userAttributeIds;
  bool _userAttributeIdsSet = false;

  String _url;
  bool _urlSet = false;

  /// Name of User Attribute in Saml

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Required to be in Saml assertion for login to be allowed to succeed

  bool get required {
    if (!_requiredSet && _apiMapResponse.containsKey('required')) {
      _required = _apiMapResponse['required'];
      _requiredSet = true;
    }
    return _required;
  }

  set required(bool v) {
    _required = v;
    _requiredSet = true;
  }

  /// Looker User Attribute Ids

  List<int> get userAttributeIds {
    if (!_userAttributeIdsSet &&
        _apiMapResponse.containsKey('user_attribute_ids')) {
      _userAttributeIds = _apiMapResponse['user_attribute_ids']
          ?.map<int>((i) => i as int)
          ?.toList();
      _userAttributeIdsSet = true;
    }
    return _userAttributeIds;
  }

  set userAttributeIds(List<int> v) {
    _userAttributeIds = v;
    _userAttributeIdsSet = true;
  }

  /// Link to saml config (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  SamlUserAttributeWrite() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SamlUserAttributeWrite.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_requiredSet || _apiMapResponse.containsKey('required')) {
      json['required'] = required;
    }
    if (_userAttributeIdsSet ||
        _apiMapResponse.containsKey('user_attribute_ids')) {
      json['user_attribute_ids'] = userAttributeIds;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class ScheduledPlan {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  int _userId;
  bool _userIdSet = false;

  bool _runAsRecipient;
  bool _runAsRecipientSet = false;

  bool _enabled;
  bool _enabledSet = false;

  String _lookId;
  bool _lookIdSet = false;

  int _dashboardId;
  bool _dashboardIdSet = false;

  String _lookmlDashboardId;
  bool _lookmlDashboardIdSet = false;

  String _filtersString;
  bool _filtersStringSet = false;

  String _dashboardFilters;
  bool _dashboardFiltersSet = false;

  bool _requireResults;
  bool _requireResultsSet = false;

  bool _requireNoResults;
  bool _requireNoResultsSet = false;

  bool _requireChange;
  bool _requireChangeSet = false;

  bool _sendAllResults;
  bool _sendAllResultsSet = false;

  String _crontab;
  bool _crontabSet = false;

  String _datagroup;
  bool _datagroupSet = false;

  String _timezone;
  bool _timezoneSet = false;

  String _queryId;
  bool _queryIdSet = false;

  List<ScheduledPlanDestination> _scheduledPlanDestination;
  bool _scheduledPlanDestinationSet = false;

  bool _runOnce;
  bool _runOnceSet = false;

  bool _includeLinks;
  bool _includeLinksSet = false;

  String _pdfPaperSize;
  bool _pdfPaperSizeSet = false;

  bool _pdfLandscape;
  bool _pdfLandscapeSet = false;

  bool _embed;
  bool _embedSet = false;

  String _colorTheme;
  bool _colorThemeSet = false;

  bool _longTables;
  bool _longTablesSet = false;

  int _inlineTableWidth;
  bool _inlineTableWidthSet = false;

  int _id;
  bool _idSet = false;

  DateTime _createdAt;
  bool _createdAtSet = false;

  DateTime _updatedAt;
  bool _updatedAtSet = false;

  String _title;
  bool _titleSet = false;

  UserPublic _user;
  bool _userSet = false;

  DateTime _nextRunAt;
  bool _nextRunAtSet = false;

  DateTime _lastRunAt;
  bool _lastRunAtSet = false;

  Map<String, dynamic> _can;
  bool _canSet = false;

  /// Name of this scheduled plan

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// User Id which owns this scheduled plan

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  /// Whether schedule is run as recipient (only applicable for email recipients)

  bool get runAsRecipient {
    if (!_runAsRecipientSet &&
        _apiMapResponse.containsKey('run_as_recipient')) {
      _runAsRecipient = _apiMapResponse['run_as_recipient'];
      _runAsRecipientSet = true;
    }
    return _runAsRecipient;
  }

  set runAsRecipient(bool v) {
    _runAsRecipient = v;
    _runAsRecipientSet = true;
  }

  /// Whether the ScheduledPlan is enabled

  bool get enabled {
    if (!_enabledSet && _apiMapResponse.containsKey('enabled')) {
      _enabled = _apiMapResponse['enabled'];
      _enabledSet = true;
    }
    return _enabled;
  }

  set enabled(bool v) {
    _enabled = v;
    _enabledSet = true;
  }

  /// Id of a look

  String get lookId {
    if (!_lookIdSet && _apiMapResponse.containsKey('look_id')) {
      _lookId = _apiMapResponse['look_id']?.toString();
      _lookIdSet = true;
    }
    return _lookId;
  }

  set lookId(String v) {
    _lookId = v;
    _lookIdSet = true;
  }

  /// Id of a dashboard

  int get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id'];
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(int v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// Id of a LookML dashboard

  String get lookmlDashboardId {
    if (!_lookmlDashboardIdSet &&
        _apiMapResponse.containsKey('lookml_dashboard_id')) {
      _lookmlDashboardId = _apiMapResponse['lookml_dashboard_id']?.toString();
      _lookmlDashboardIdSet = true;
    }
    return _lookmlDashboardId;
  }

  set lookmlDashboardId(String v) {
    _lookmlDashboardId = v;
    _lookmlDashboardIdSet = true;
  }

  /// Query string to run look or dashboard with

  String get filtersString {
    if (!_filtersStringSet && _apiMapResponse.containsKey('filters_string')) {
      _filtersString = _apiMapResponse['filters_string']?.toString();
      _filtersStringSet = true;
    }
    return _filtersString;
  }

  set filtersString(String v) {
    _filtersString = v;
    _filtersStringSet = true;
  }

  /// (DEPRECATED) Alias for filters_string field

  String get dashboardFilters {
    if (!_dashboardFiltersSet &&
        _apiMapResponse.containsKey('dashboard_filters')) {
      _dashboardFilters = _apiMapResponse['dashboard_filters']?.toString();
      _dashboardFiltersSet = true;
    }
    return _dashboardFilters;
  }

  set dashboardFilters(String v) {
    _dashboardFilters = v;
    _dashboardFiltersSet = true;
  }

  /// Delivery should occur if running the dashboard or look returns results

  bool get requireResults {
    if (!_requireResultsSet && _apiMapResponse.containsKey('require_results')) {
      _requireResults = _apiMapResponse['require_results'];
      _requireResultsSet = true;
    }
    return _requireResults;
  }

  set requireResults(bool v) {
    _requireResults = v;
    _requireResultsSet = true;
  }

  /// Delivery should occur if the dashboard look does not return results

  bool get requireNoResults {
    if (!_requireNoResultsSet &&
        _apiMapResponse.containsKey('require_no_results')) {
      _requireNoResults = _apiMapResponse['require_no_results'];
      _requireNoResultsSet = true;
    }
    return _requireNoResults;
  }

  set requireNoResults(bool v) {
    _requireNoResults = v;
    _requireNoResultsSet = true;
  }

  /// Delivery should occur if data have changed since the last run

  bool get requireChange {
    if (!_requireChangeSet && _apiMapResponse.containsKey('require_change')) {
      _requireChange = _apiMapResponse['require_change'];
      _requireChangeSet = true;
    }
    return _requireChange;
  }

  set requireChange(bool v) {
    _requireChange = v;
    _requireChangeSet = true;
  }

  /// Will run an unlimited query and send all results.

  bool get sendAllResults {
    if (!_sendAllResultsSet &&
        _apiMapResponse.containsKey('send_all_results')) {
      _sendAllResults = _apiMapResponse['send_all_results'];
      _sendAllResultsSet = true;
    }
    return _sendAllResults;
  }

  set sendAllResults(bool v) {
    _sendAllResults = v;
    _sendAllResultsSet = true;
  }

  /// Vixie-Style crontab specification when to run

  String get crontab {
    if (!_crontabSet && _apiMapResponse.containsKey('crontab')) {
      _crontab = _apiMapResponse['crontab']?.toString();
      _crontabSet = true;
    }
    return _crontab;
  }

  set crontab(String v) {
    _crontab = v;
    _crontabSet = true;
  }

  /// Name of a datagroup; if specified will run when datagroup triggered (can't be used with cron string)

  String get datagroup {
    if (!_datagroupSet && _apiMapResponse.containsKey('datagroup')) {
      _datagroup = _apiMapResponse['datagroup']?.toString();
      _datagroupSet = true;
    }
    return _datagroup;
  }

  set datagroup(String v) {
    _datagroup = v;
    _datagroupSet = true;
  }

  /// Timezone for interpreting the specified crontab (default is Looker instance timezone)

  String get timezone {
    if (!_timezoneSet && _apiMapResponse.containsKey('timezone')) {
      _timezone = _apiMapResponse['timezone']?.toString();
      _timezoneSet = true;
    }
    return _timezone;
  }

  set timezone(String v) {
    _timezone = v;
    _timezoneSet = true;
  }

  /// Query id

  String get queryId {
    if (!_queryIdSet && _apiMapResponse.containsKey('query_id')) {
      _queryId = _apiMapResponse['query_id']?.toString();
      _queryIdSet = true;
    }
    return _queryId;
  }

  set queryId(String v) {
    _queryId = v;
    _queryIdSet = true;
  }

  /// Scheduled plan destinations

  List<ScheduledPlanDestination> get scheduledPlanDestination {
    if (!_scheduledPlanDestinationSet &&
        _apiMapResponse.containsKey('scheduled_plan_destination')) {
      _scheduledPlanDestination =
          _apiMapResponse['scheduled_plan_destination'] == null
              ? null
              : (_apiMapResponse['scheduled_plan_destination'] as List)
                  .map((i) => ScheduledPlanDestination.fromResponse(
                      i, apiResponseContentType))
                  .toList();
      _scheduledPlanDestinationSet = true;
    }
    return _scheduledPlanDestination;
  }

  set scheduledPlanDestination(List<ScheduledPlanDestination> v) {
    _scheduledPlanDestination = v;
    _scheduledPlanDestinationSet = true;
  }

  /// Whether the plan in question should only be run once (usually for testing)

  bool get runOnce {
    if (!_runOnceSet && _apiMapResponse.containsKey('run_once')) {
      _runOnce = _apiMapResponse['run_once'];
      _runOnceSet = true;
    }
    return _runOnce;
  }

  set runOnce(bool v) {
    _runOnce = v;
    _runOnceSet = true;
  }

  /// Whether links back to Looker should be included in this ScheduledPlan

  bool get includeLinks {
    if (!_includeLinksSet && _apiMapResponse.containsKey('include_links')) {
      _includeLinks = _apiMapResponse['include_links'];
      _includeLinksSet = true;
    }
    return _includeLinks;
  }

  set includeLinks(bool v) {
    _includeLinks = v;
    _includeLinksSet = true;
  }

  /// The size of paper the PDF should be formatted to fit. Valid values are: "letter", "legal", "tabloid", "a0", "a1", "a2", "a3", "a4", "a5".

  String get pdfPaperSize {
    if (!_pdfPaperSizeSet && _apiMapResponse.containsKey('pdf_paper_size')) {
      _pdfPaperSize = _apiMapResponse['pdf_paper_size']?.toString();
      _pdfPaperSizeSet = true;
    }
    return _pdfPaperSize;
  }

  set pdfPaperSize(String v) {
    _pdfPaperSize = v;
    _pdfPaperSizeSet = true;
  }

  /// Whether the PDF should be formatted for landscape orientation

  bool get pdfLandscape {
    if (!_pdfLandscapeSet && _apiMapResponse.containsKey('pdf_landscape')) {
      _pdfLandscape = _apiMapResponse['pdf_landscape'];
      _pdfLandscapeSet = true;
    }
    return _pdfLandscape;
  }

  set pdfLandscape(bool v) {
    _pdfLandscape = v;
    _pdfLandscapeSet = true;
  }

  /// Whether this schedule is in an embed context or not

  bool get embed {
    if (!_embedSet && _apiMapResponse.containsKey('embed')) {
      _embed = _apiMapResponse['embed'];
      _embedSet = true;
    }
    return _embed;
  }

  set embed(bool v) {
    _embed = v;
    _embedSet = true;
  }

  /// Color scheme of the dashboard if applicable

  String get colorTheme {
    if (!_colorThemeSet && _apiMapResponse.containsKey('color_theme')) {
      _colorTheme = _apiMapResponse['color_theme']?.toString();
      _colorThemeSet = true;
    }
    return _colorTheme;
  }

  set colorTheme(String v) {
    _colorTheme = v;
    _colorThemeSet = true;
  }

  /// Whether or not to expand table vis to full length

  bool get longTables {
    if (!_longTablesSet && _apiMapResponse.containsKey('long_tables')) {
      _longTables = _apiMapResponse['long_tables'];
      _longTablesSet = true;
    }
    return _longTables;
  }

  set longTables(bool v) {
    _longTables = v;
    _longTablesSet = true;
  }

  /// The pixel width at which we render the inline table visualizations

  int get inlineTableWidth {
    if (!_inlineTableWidthSet &&
        _apiMapResponse.containsKey('inline_table_width')) {
      _inlineTableWidth = _apiMapResponse['inline_table_width'];
      _inlineTableWidthSet = true;
    }
    return _inlineTableWidth;
  }

  set inlineTableWidth(int v) {
    _inlineTableWidth = v;
    _inlineTableWidthSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Date and time when ScheduledPlan was created (read-only)

  DateTime get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['created_at']);
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(DateTime v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// Date and time when ScheduledPlan was last updated (read-only)

  DateTime get updatedAt {
    if (!_updatedAtSet && _apiMapResponse.containsKey('updated_at')) {
      _updatedAt = _apiMapResponse['updated_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['updated_at']);
      _updatedAtSet = true;
    }
    return _updatedAt;
  }

  set updatedAt(DateTime v) {
    _updatedAt = v;
    _updatedAtSet = true;
  }

  /// Title (read-only)

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  UserPublic get user {
    if (!_userSet && _apiMapResponse.containsKey('user')) {
      _user = _apiMapResponse['user'] == null
          ? null
          : UserPublic.fromResponse(
              _apiMapResponse['user'], apiResponseContentType);
      _userSet = true;
    }
    return _user;
  }

  set user(UserPublic v) {
    _user = v;
    _userSet = true;
  }

  /// When the ScheduledPlan will next run (null if running once) (read-only)

  DateTime get nextRunAt {
    if (!_nextRunAtSet && _apiMapResponse.containsKey('next_run_at')) {
      _nextRunAt = _apiMapResponse['next_run_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['next_run_at']);
      _nextRunAtSet = true;
    }
    return _nextRunAt;
  }

  set nextRunAt(DateTime v) {
    _nextRunAt = v;
    _nextRunAtSet = true;
  }

  /// When the ScheduledPlan was last run (read-only)

  DateTime get lastRunAt {
    if (!_lastRunAtSet && _apiMapResponse.containsKey('last_run_at')) {
      _lastRunAt = _apiMapResponse['last_run_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['last_run_at']);
      _lastRunAtSet = true;
    }
    return _lastRunAt;
  }

  set lastRunAt(DateTime v) {
    _lastRunAt = v;
    _lastRunAtSet = true;
  }

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  ScheduledPlan() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ScheduledPlan.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    if (_runAsRecipientSet || _apiMapResponse.containsKey('run_as_recipient')) {
      json['run_as_recipient'] = runAsRecipient;
    }
    if (_enabledSet || _apiMapResponse.containsKey('enabled')) {
      json['enabled'] = enabled;
    }
    if (_lookIdSet || _apiMapResponse.containsKey('look_id')) {
      json['look_id'] = lookId;
    }
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_lookmlDashboardIdSet ||
        _apiMapResponse.containsKey('lookml_dashboard_id')) {
      json['lookml_dashboard_id'] = lookmlDashboardId;
    }
    if (_filtersStringSet || _apiMapResponse.containsKey('filters_string')) {
      json['filters_string'] = filtersString;
    }
    if (_dashboardFiltersSet ||
        _apiMapResponse.containsKey('dashboard_filters')) {
      json['dashboard_filters'] = dashboardFilters;
    }
    if (_requireResultsSet || _apiMapResponse.containsKey('require_results')) {
      json['require_results'] = requireResults;
    }
    if (_requireNoResultsSet ||
        _apiMapResponse.containsKey('require_no_results')) {
      json['require_no_results'] = requireNoResults;
    }
    if (_requireChangeSet || _apiMapResponse.containsKey('require_change')) {
      json['require_change'] = requireChange;
    }
    if (_sendAllResultsSet || _apiMapResponse.containsKey('send_all_results')) {
      json['send_all_results'] = sendAllResults;
    }
    if (_crontabSet || _apiMapResponse.containsKey('crontab')) {
      json['crontab'] = crontab;
    }
    if (_datagroupSet || _apiMapResponse.containsKey('datagroup')) {
      json['datagroup'] = datagroup;
    }
    if (_timezoneSet || _apiMapResponse.containsKey('timezone')) {
      json['timezone'] = timezone;
    }
    if (_queryIdSet || _apiMapResponse.containsKey('query_id')) {
      json['query_id'] = queryId;
    }
    if (_scheduledPlanDestinationSet ||
        _apiMapResponse.containsKey('scheduled_plan_destination')) {
      json['scheduled_plan_destination'] =
          scheduledPlanDestination?.map((i) => i.toJson())?.toList();
    }
    if (_runOnceSet || _apiMapResponse.containsKey('run_once')) {
      json['run_once'] = runOnce;
    }
    if (_includeLinksSet || _apiMapResponse.containsKey('include_links')) {
      json['include_links'] = includeLinks;
    }
    if (_pdfPaperSizeSet || _apiMapResponse.containsKey('pdf_paper_size')) {
      json['pdf_paper_size'] = pdfPaperSize;
    }
    if (_pdfLandscapeSet || _apiMapResponse.containsKey('pdf_landscape')) {
      json['pdf_landscape'] = pdfLandscape;
    }
    if (_embedSet || _apiMapResponse.containsKey('embed')) {
      json['embed'] = embed;
    }
    if (_colorThemeSet || _apiMapResponse.containsKey('color_theme')) {
      json['color_theme'] = colorTheme;
    }
    if (_longTablesSet || _apiMapResponse.containsKey('long_tables')) {
      json['long_tables'] = longTables;
    }
    if (_inlineTableWidthSet ||
        _apiMapResponse.containsKey('inline_table_width')) {
      json['inline_table_width'] = inlineTableWidth;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt?.toIso8601String();
    }
    if (_updatedAtSet || _apiMapResponse.containsKey('updated_at')) {
      json['updated_at'] = updatedAt?.toIso8601String();
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_userSet || _apiMapResponse.containsKey('user')) {
      json['user'] = user?.toJson();
    }
    if (_nextRunAtSet || _apiMapResponse.containsKey('next_run_at')) {
      json['next_run_at'] = nextRunAt?.toIso8601String();
    }
    if (_lastRunAtSet || _apiMapResponse.containsKey('last_run_at')) {
      json['last_run_at'] = lastRunAt?.toIso8601String();
    }
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    return json;
  }
}

class ScheduledPlanDestination {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _id;
  bool _idSet = false;

  int _scheduledPlanId;
  bool _scheduledPlanIdSet = false;

  String _format;
  bool _formatSet = false;

  bool _applyFormatting;
  bool _applyFormattingSet = false;

  bool _applyVis;
  bool _applyVisSet = false;

  String _address;
  bool _addressSet = false;

  bool _lookerRecipient;
  bool _lookerRecipientSet = false;

  String _type;
  bool _typeSet = false;

  String _parameters;
  bool _parametersSet = false;

  String _secretParameters;
  bool _secretParametersSet = false;

  String _message;
  bool _messageSet = false;

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Id of a scheduled plan you own

  int get scheduledPlanId {
    if (!_scheduledPlanIdSet &&
        _apiMapResponse.containsKey('scheduled_plan_id')) {
      _scheduledPlanId = _apiMapResponse['scheduled_plan_id'];
      _scheduledPlanIdSet = true;
    }
    return _scheduledPlanId;
  }

  set scheduledPlanId(int v) {
    _scheduledPlanId = v;
    _scheduledPlanIdSet = true;
  }

  /// The data format to send to the given destination. Supported formats vary by destination, but include: "txt", "csv", "inline_json", "json", "json_detail", "xlsx", "html", "wysiwyg_pdf", "assembled_pdf", "wysiwyg_png"

  String get format {
    if (!_formatSet && _apiMapResponse.containsKey('format')) {
      _format = _apiMapResponse['format']?.toString();
      _formatSet = true;
    }
    return _format;
  }

  set format(String v) {
    _format = v;
    _formatSet = true;
  }

  /// Are values formatted? (containing currency symbols, digit separators, etc.

  bool get applyFormatting {
    if (!_applyFormattingSet &&
        _apiMapResponse.containsKey('apply_formatting')) {
      _applyFormatting = _apiMapResponse['apply_formatting'];
      _applyFormattingSet = true;
    }
    return _applyFormatting;
  }

  set applyFormatting(bool v) {
    _applyFormatting = v;
    _applyFormattingSet = true;
  }

  /// Whether visualization options are applied to the results.

  bool get applyVis {
    if (!_applyVisSet && _apiMapResponse.containsKey('apply_vis')) {
      _applyVis = _apiMapResponse['apply_vis'];
      _applyVisSet = true;
    }
    return _applyVis;
  }

  set applyVis(bool v) {
    _applyVis = v;
    _applyVisSet = true;
  }

  /// Address for recipient. For email e.g. 'user@example.com'. For webhooks e.g. 'https://domain/path'. For Amazon S3 e.g. 's3://bucket-name/path/'. For SFTP e.g. 'sftp://host-name/path/'.

  String get address {
    if (!_addressSet && _apiMapResponse.containsKey('address')) {
      _address = _apiMapResponse['address']?.toString();
      _addressSet = true;
    }
    return _address;
  }

  set address(String v) {
    _address = v;
    _addressSet = true;
  }

  /// Whether the recipient is a Looker user on the current instance (only applicable for email recipients) (read-only)

  bool get lookerRecipient {
    if (!_lookerRecipientSet &&
        _apiMapResponse.containsKey('looker_recipient')) {
      _lookerRecipient = _apiMapResponse['looker_recipient'];
      _lookerRecipientSet = true;
    }
    return _lookerRecipient;
  }

  set lookerRecipient(bool v) {
    _lookerRecipient = v;
    _lookerRecipientSet = true;
  }

  /// Type of the address ('email', 'webhook', 's3', or 'sftp')

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// JSON object containing parameters for external scheduling. For Amazon S3, this requires keys and values for access_key_id and region. For SFTP, this requires a key and value for username.

  String get parameters {
    if (!_parametersSet && _apiMapResponse.containsKey('parameters')) {
      _parameters = _apiMapResponse['parameters']?.toString();
      _parametersSet = true;
    }
    return _parameters;
  }

  set parameters(String v) {
    _parameters = v;
    _parametersSet = true;
  }

  /// (Write-Only) JSON object containing secret parameters for external scheduling. For Amazon S3, this requires a key and value for secret_access_key. For SFTP, this requires a key and value for password.

  String get secretParameters {
    if (!_secretParametersSet &&
        _apiMapResponse.containsKey('secret_parameters')) {
      _secretParameters = _apiMapResponse['secret_parameters']?.toString();
      _secretParametersSet = true;
    }
    return _secretParameters;
  }

  set secretParameters(String v) {
    _secretParameters = v;
    _secretParametersSet = true;
  }

  /// Optional message to be included in scheduled emails

  String get message {
    if (!_messageSet && _apiMapResponse.containsKey('message')) {
      _message = _apiMapResponse['message']?.toString();
      _messageSet = true;
    }
    return _message;
  }

  set message(String v) {
    _message = v;
    _messageSet = true;
  }

  ScheduledPlanDestination() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ScheduledPlanDestination.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_scheduledPlanIdSet ||
        _apiMapResponse.containsKey('scheduled_plan_id')) {
      json['scheduled_plan_id'] = scheduledPlanId;
    }
    if (_formatSet || _apiMapResponse.containsKey('format')) {
      json['format'] = format;
    }
    if (_applyFormattingSet ||
        _apiMapResponse.containsKey('apply_formatting')) {
      json['apply_formatting'] = applyFormatting;
    }
    if (_applyVisSet || _apiMapResponse.containsKey('apply_vis')) {
      json['apply_vis'] = applyVis;
    }
    if (_addressSet || _apiMapResponse.containsKey('address')) {
      json['address'] = address;
    }
    if (_lookerRecipientSet ||
        _apiMapResponse.containsKey('looker_recipient')) {
      json['looker_recipient'] = lookerRecipient;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_parametersSet || _apiMapResponse.containsKey('parameters')) {
      json['parameters'] = parameters;
    }
    if (_secretParametersSet ||
        _apiMapResponse.containsKey('secret_parameters')) {
      json['secret_parameters'] = secretParameters;
    }
    if (_messageSet || _apiMapResponse.containsKey('message')) {
      json['message'] = message;
    }
    return json;
  }
}

class Schema {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  bool _isDefault;
  bool _isDefaultSet = false;

  /// Schema name (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// True if this is the default schema (read-only)

  bool get isDefault {
    if (!_isDefaultSet && _apiMapResponse.containsKey('is_default')) {
      _isDefault = _apiMapResponse['is_default'];
      _isDefaultSet = true;
    }
    return _isDefault;
  }

  set isDefault(bool v) {
    _isDefault = v;
    _isDefaultSet = true;
  }

  Schema() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Schema.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_isDefaultSet || _apiMapResponse.containsKey('is_default')) {
      json['is_default'] = isDefault;
    }
    return json;
  }
}

class SchemaColumn {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _sqlEscapedName;
  bool _sqlEscapedNameSet = false;

  String _schemaName;
  bool _schemaNameSet = false;

  String _dataTypeDatabase;
  bool _dataTypeDatabaseSet = false;

  String _dataType;
  bool _dataTypeSet = false;

  String _dataTypeLooker;
  bool _dataTypeLookerSet = false;

  String _description;
  bool _descriptionSet = false;

  int _columnSize;
  bool _columnSizeSet = false;

  List<Snippet> _snippets;
  bool _snippetsSet = false;

  /// Schema item name (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Full name of item (read-only)

  String get sqlEscapedName {
    if (!_sqlEscapedNameSet &&
        _apiMapResponse.containsKey('sql_escaped_name')) {
      _sqlEscapedName = _apiMapResponse['sql_escaped_name']?.toString();
      _sqlEscapedNameSet = true;
    }
    return _sqlEscapedName;
  }

  set sqlEscapedName(String v) {
    _sqlEscapedName = v;
    _sqlEscapedNameSet = true;
  }

  /// Name of schema (read-only)

  String get schemaName {
    if (!_schemaNameSet && _apiMapResponse.containsKey('schema_name')) {
      _schemaName = _apiMapResponse['schema_name']?.toString();
      _schemaNameSet = true;
    }
    return _schemaName;
  }

  set schemaName(String v) {
    _schemaName = v;
    _schemaNameSet = true;
  }

  /// SQL dialect data type (read-only)

  String get dataTypeDatabase {
    if (!_dataTypeDatabaseSet &&
        _apiMapResponse.containsKey('data_type_database')) {
      _dataTypeDatabase = _apiMapResponse['data_type_database']?.toString();
      _dataTypeDatabaseSet = true;
    }
    return _dataTypeDatabase;
  }

  set dataTypeDatabase(String v) {
    _dataTypeDatabase = v;
    _dataTypeDatabaseSet = true;
  }

  /// Data type (read-only)

  String get dataType {
    if (!_dataTypeSet && _apiMapResponse.containsKey('data_type')) {
      _dataType = _apiMapResponse['data_type']?.toString();
      _dataTypeSet = true;
    }
    return _dataType;
  }

  set dataType(String v) {
    _dataType = v;
    _dataTypeSet = true;
  }

  /// Looker data type (read-only)

  String get dataTypeLooker {
    if (!_dataTypeLookerSet &&
        _apiMapResponse.containsKey('data_type_looker')) {
      _dataTypeLooker = _apiMapResponse['data_type_looker']?.toString();
      _dataTypeLookerSet = true;
    }
    return _dataTypeLooker;
  }

  set dataTypeLooker(String v) {
    _dataTypeLooker = v;
    _dataTypeLookerSet = true;
  }

  /// SQL data type (read-only)

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Column data size (read-only)

  int get columnSize {
    if (!_columnSizeSet && _apiMapResponse.containsKey('column_size')) {
      _columnSize = _apiMapResponse['column_size'];
      _columnSizeSet = true;
    }
    return _columnSize;
  }

  set columnSize(int v) {
    _columnSize = v;
    _columnSizeSet = true;
  }

  /// SQL Runner snippets for this connection (read-only)

  List<Snippet> get snippets {
    if (!_snippetsSet && _apiMapResponse.containsKey('snippets')) {
      _snippets = _apiMapResponse['snippets'] == null
          ? null
          : (_apiMapResponse['snippets'] as List)
              .map((i) => Snippet.fromResponse(i, apiResponseContentType))
              .toList();
      _snippetsSet = true;
    }
    return _snippets;
  }

  set snippets(List<Snippet> v) {
    _snippets = v;
    _snippetsSet = true;
  }

  SchemaColumn() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SchemaColumn.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_sqlEscapedNameSet || _apiMapResponse.containsKey('sql_escaped_name')) {
      json['sql_escaped_name'] = sqlEscapedName;
    }
    if (_schemaNameSet || _apiMapResponse.containsKey('schema_name')) {
      json['schema_name'] = schemaName;
    }
    if (_dataTypeDatabaseSet ||
        _apiMapResponse.containsKey('data_type_database')) {
      json['data_type_database'] = dataTypeDatabase;
    }
    if (_dataTypeSet || _apiMapResponse.containsKey('data_type')) {
      json['data_type'] = dataType;
    }
    if (_dataTypeLookerSet || _apiMapResponse.containsKey('data_type_looker')) {
      json['data_type_looker'] = dataTypeLooker;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_columnSizeSet || _apiMapResponse.containsKey('column_size')) {
      json['column_size'] = columnSize;
    }
    if (_snippetsSet || _apiMapResponse.containsKey('snippets')) {
      json['snippets'] = snippets?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class SchemaColumns {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _sqlEscapedName;
  bool _sqlEscapedNameSet = false;

  String _schemaName;
  bool _schemaNameSet = false;

  List<SchemaColumn> _columns;
  bool _columnsSet = false;

  /// Schema item name (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Full name of item (read-only)

  String get sqlEscapedName {
    if (!_sqlEscapedNameSet &&
        _apiMapResponse.containsKey('sql_escaped_name')) {
      _sqlEscapedName = _apiMapResponse['sql_escaped_name']?.toString();
      _sqlEscapedNameSet = true;
    }
    return _sqlEscapedName;
  }

  set sqlEscapedName(String v) {
    _sqlEscapedName = v;
    _sqlEscapedNameSet = true;
  }

  /// Name of schema (read-only)

  String get schemaName {
    if (!_schemaNameSet && _apiMapResponse.containsKey('schema_name')) {
      _schemaName = _apiMapResponse['schema_name']?.toString();
      _schemaNameSet = true;
    }
    return _schemaName;
  }

  set schemaName(String v) {
    _schemaName = v;
    _schemaNameSet = true;
  }

  /// Columns for this schema (read-only)

  List<SchemaColumn> get columns {
    if (!_columnsSet && _apiMapResponse.containsKey('columns')) {
      _columns = _apiMapResponse['columns'] == null
          ? null
          : (_apiMapResponse['columns'] as List)
              .map((i) => SchemaColumn.fromResponse(i, apiResponseContentType))
              .toList();
      _columnsSet = true;
    }
    return _columns;
  }

  set columns(List<SchemaColumn> v) {
    _columns = v;
    _columnsSet = true;
  }

  SchemaColumns() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SchemaColumns.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_sqlEscapedNameSet || _apiMapResponse.containsKey('sql_escaped_name')) {
      json['sql_escaped_name'] = sqlEscapedName;
    }
    if (_schemaNameSet || _apiMapResponse.containsKey('schema_name')) {
      json['schema_name'] = schemaName;
    }
    if (_columnsSet || _apiMapResponse.containsKey('columns')) {
      json['columns'] = columns?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class SchemaTable {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _sqlEscapedName;
  bool _sqlEscapedNameSet = false;

  String _schemaName;
  bool _schemaNameSet = false;

  int _rows;
  bool _rowsSet = false;

  String _external;
  bool _externalSet = false;

  List<Snippet> _snippets;
  bool _snippetsSet = false;

  /// Schema item name (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Full name of item (read-only)

  String get sqlEscapedName {
    if (!_sqlEscapedNameSet &&
        _apiMapResponse.containsKey('sql_escaped_name')) {
      _sqlEscapedName = _apiMapResponse['sql_escaped_name']?.toString();
      _sqlEscapedNameSet = true;
    }
    return _sqlEscapedName;
  }

  set sqlEscapedName(String v) {
    _sqlEscapedName = v;
    _sqlEscapedNameSet = true;
  }

  /// Name of schema (read-only)

  String get schemaName {
    if (!_schemaNameSet && _apiMapResponse.containsKey('schema_name')) {
      _schemaName = _apiMapResponse['schema_name']?.toString();
      _schemaNameSet = true;
    }
    return _schemaName;
  }

  set schemaName(String v) {
    _schemaName = v;
    _schemaNameSet = true;
  }

  /// Number of data rows (read-only)

  int get rows {
    if (!_rowsSet && _apiMapResponse.containsKey('rows')) {
      _rows = _apiMapResponse['rows'];
      _rowsSet = true;
    }
    return _rows;
  }

  set rows(int v) {
    _rows = v;
    _rowsSet = true;
  }

  /// External reference??? (read-only)

  String get external {
    if (!_externalSet && _apiMapResponse.containsKey('external')) {
      _external = _apiMapResponse['external']?.toString();
      _externalSet = true;
    }
    return _external;
  }

  set external(String v) {
    _external = v;
    _externalSet = true;
  }

  /// SQL Runner snippets for connection (read-only)

  List<Snippet> get snippets {
    if (!_snippetsSet && _apiMapResponse.containsKey('snippets')) {
      _snippets = _apiMapResponse['snippets'] == null
          ? null
          : (_apiMapResponse['snippets'] as List)
              .map((i) => Snippet.fromResponse(i, apiResponseContentType))
              .toList();
      _snippetsSet = true;
    }
    return _snippets;
  }

  set snippets(List<Snippet> v) {
    _snippets = v;
    _snippetsSet = true;
  }

  SchemaTable() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SchemaTable.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_sqlEscapedNameSet || _apiMapResponse.containsKey('sql_escaped_name')) {
      json['sql_escaped_name'] = sqlEscapedName;
    }
    if (_schemaNameSet || _apiMapResponse.containsKey('schema_name')) {
      json['schema_name'] = schemaName;
    }
    if (_rowsSet || _apiMapResponse.containsKey('rows')) {
      json['rows'] = rows;
    }
    if (_externalSet || _apiMapResponse.containsKey('external')) {
      json['external'] = external;
    }
    if (_snippetsSet || _apiMapResponse.containsKey('snippets')) {
      json['snippets'] = snippets?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class SchemaTables {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  bool _isDefault;
  bool _isDefaultSet = false;

  List<SchemaTable> _tables;
  bool _tablesSet = false;

  bool _tableLimitHit;
  bool _tableLimitHitSet = false;

  /// Schema name (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// True if this is the default schema (read-only)

  bool get isDefault {
    if (!_isDefaultSet && _apiMapResponse.containsKey('is_default')) {
      _isDefault = _apiMapResponse['is_default'];
      _isDefaultSet = true;
    }
    return _isDefault;
  }

  set isDefault(bool v) {
    _isDefault = v;
    _isDefaultSet = true;
  }

  /// Tables for this schema (read-only)

  List<SchemaTable> get tables {
    if (!_tablesSet && _apiMapResponse.containsKey('tables')) {
      _tables = _apiMapResponse['tables'] == null
          ? null
          : (_apiMapResponse['tables'] as List)
              .map((i) => SchemaTable.fromResponse(i, apiResponseContentType))
              .toList();
      _tablesSet = true;
    }
    return _tables;
  }

  set tables(List<SchemaTable> v) {
    _tables = v;
    _tablesSet = true;
  }

  /// True if the table limit was hit while retrieving tables in this schema (read-only)

  bool get tableLimitHit {
    if (!_tableLimitHitSet && _apiMapResponse.containsKey('table_limit_hit')) {
      _tableLimitHit = _apiMapResponse['table_limit_hit'];
      _tableLimitHitSet = true;
    }
    return _tableLimitHit;
  }

  set tableLimitHit(bool v) {
    _tableLimitHit = v;
    _tableLimitHitSet = true;
  }

  SchemaTables() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SchemaTables.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_isDefaultSet || _apiMapResponse.containsKey('is_default')) {
      json['is_default'] = isDefault;
    }
    if (_tablesSet || _apiMapResponse.containsKey('tables')) {
      json['tables'] = tables?.map((i) => i.toJson())?.toList();
    }
    if (_tableLimitHitSet || _apiMapResponse.containsKey('table_limit_hit')) {
      json['table_limit_hit'] = tableLimitHit;
    }
    return json;
  }
}

class Session {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _id;
  bool _idSet = false;

  String _ipAddress;
  bool _ipAddressSet = false;

  String _browser;
  bool _browserSet = false;

  String _operatingSystem;
  bool _operatingSystemSet = false;

  String _city;
  bool _citySet = false;

  String _state;
  bool _stateSet = false;

  String _country;
  bool _countrySet = false;

  String _credentialsType;
  bool _credentialsTypeSet = false;

  String _extendedAt;
  bool _extendedAtSet = false;

  int _extendedCount;
  bool _extendedCountSet = false;

  int _sudoUserId;
  bool _sudoUserIdSet = false;

  String _createdAt;
  bool _createdAtSet = false;

  String _expiresAt;
  bool _expiresAtSet = false;

  String _url;
  bool _urlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// IP address of user when this session was initiated (read-only)

  String get ipAddress {
    if (!_ipAddressSet && _apiMapResponse.containsKey('ip_address')) {
      _ipAddress = _apiMapResponse['ip_address']?.toString();
      _ipAddressSet = true;
    }
    return _ipAddress;
  }

  set ipAddress(String v) {
    _ipAddress = v;
    _ipAddressSet = true;
  }

  /// User's browser type (read-only)

  String get browser {
    if (!_browserSet && _apiMapResponse.containsKey('browser')) {
      _browser = _apiMapResponse['browser']?.toString();
      _browserSet = true;
    }
    return _browser;
  }

  set browser(String v) {
    _browser = v;
    _browserSet = true;
  }

  /// User's Operating System (read-only)

  String get operatingSystem {
    if (!_operatingSystemSet &&
        _apiMapResponse.containsKey('operating_system')) {
      _operatingSystem = _apiMapResponse['operating_system']?.toString();
      _operatingSystemSet = true;
    }
    return _operatingSystem;
  }

  set operatingSystem(String v) {
    _operatingSystem = v;
    _operatingSystemSet = true;
  }

  /// City component of user location (derived from IP address) (read-only)

  String get city {
    if (!_citySet && _apiMapResponse.containsKey('city')) {
      _city = _apiMapResponse['city']?.toString();
      _citySet = true;
    }
    return _city;
  }

  set city(String v) {
    _city = v;
    _citySet = true;
  }

  /// State component of user location (derived from IP address) (read-only)

  String get state {
    if (!_stateSet && _apiMapResponse.containsKey('state')) {
      _state = _apiMapResponse['state']?.toString();
      _stateSet = true;
    }
    return _state;
  }

  set state(String v) {
    _state = v;
    _stateSet = true;
  }

  /// Country component of user location (derived from IP address) (read-only)

  String get country {
    if (!_countrySet && _apiMapResponse.containsKey('country')) {
      _country = _apiMapResponse['country']?.toString();
      _countrySet = true;
    }
    return _country;
  }

  set country(String v) {
    _country = v;
    _countrySet = true;
  }

  /// Type of credentials used for logging in this session (read-only)

  String get credentialsType {
    if (!_credentialsTypeSet &&
        _apiMapResponse.containsKey('credentials_type')) {
      _credentialsType = _apiMapResponse['credentials_type']?.toString();
      _credentialsTypeSet = true;
    }
    return _credentialsType;
  }

  set credentialsType(String v) {
    _credentialsType = v;
    _credentialsTypeSet = true;
  }

  /// Time when this session was last extended by the user (read-only)

  String get extendedAt {
    if (!_extendedAtSet && _apiMapResponse.containsKey('extended_at')) {
      _extendedAt = _apiMapResponse['extended_at']?.toString();
      _extendedAtSet = true;
    }
    return _extendedAt;
  }

  set extendedAt(String v) {
    _extendedAt = v;
    _extendedAtSet = true;
  }

  /// Number of times this session was extended (read-only)

  int get extendedCount {
    if (!_extendedCountSet && _apiMapResponse.containsKey('extended_count')) {
      _extendedCount = _apiMapResponse['extended_count'];
      _extendedCountSet = true;
    }
    return _extendedCount;
  }

  set extendedCount(int v) {
    _extendedCount = v;
    _extendedCountSet = true;
  }

  /// Actual user in the case when this session represents one user sudo'ing as another (read-only)

  int get sudoUserId {
    if (!_sudoUserIdSet && _apiMapResponse.containsKey('sudo_user_id')) {
      _sudoUserId = _apiMapResponse['sudo_user_id'];
      _sudoUserIdSet = true;
    }
    return _sudoUserId;
  }

  set sudoUserId(int v) {
    _sudoUserId = v;
    _sudoUserIdSet = true;
  }

  /// Time when this session was initiated (read-only)

  String get createdAt {
    if (!_createdAtSet && _apiMapResponse.containsKey('created_at')) {
      _createdAt = _apiMapResponse['created_at']?.toString();
      _createdAtSet = true;
    }
    return _createdAt;
  }

  set createdAt(String v) {
    _createdAt = v;
    _createdAtSet = true;
  }

  /// Time when this session will expire (read-only)

  String get expiresAt {
    if (!_expiresAtSet && _apiMapResponse.containsKey('expires_at')) {
      _expiresAt = _apiMapResponse['expires_at']?.toString();
      _expiresAtSet = true;
    }
    return _expiresAt;
  }

  set expiresAt(String v) {
    _expiresAt = v;
    _expiresAtSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  Session() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Session.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_ipAddressSet || _apiMapResponse.containsKey('ip_address')) {
      json['ip_address'] = ipAddress;
    }
    if (_browserSet || _apiMapResponse.containsKey('browser')) {
      json['browser'] = browser;
    }
    if (_operatingSystemSet ||
        _apiMapResponse.containsKey('operating_system')) {
      json['operating_system'] = operatingSystem;
    }
    if (_citySet || _apiMapResponse.containsKey('city')) {
      json['city'] = city;
    }
    if (_stateSet || _apiMapResponse.containsKey('state')) {
      json['state'] = state;
    }
    if (_countrySet || _apiMapResponse.containsKey('country')) {
      json['country'] = country;
    }
    if (_credentialsTypeSet ||
        _apiMapResponse.containsKey('credentials_type')) {
      json['credentials_type'] = credentialsType;
    }
    if (_extendedAtSet || _apiMapResponse.containsKey('extended_at')) {
      json['extended_at'] = extendedAt;
    }
    if (_extendedCountSet || _apiMapResponse.containsKey('extended_count')) {
      json['extended_count'] = extendedCount;
    }
    if (_sudoUserIdSet || _apiMapResponse.containsKey('sudo_user_id')) {
      json['sudo_user_id'] = sudoUserId;
    }
    if (_createdAtSet || _apiMapResponse.containsKey('created_at')) {
      json['created_at'] = createdAt;
    }
    if (_expiresAtSet || _apiMapResponse.containsKey('expires_at')) {
      json['expires_at'] = expiresAt;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class SessionConfig {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  bool _allowPersistentSessions;
  bool _allowPersistentSessionsSet = false;

  int _sessionMinutes;
  bool _sessionMinutesSet = false;

  bool _unlimitedSessionsPerUser;
  bool _unlimitedSessionsPerUserSet = false;

  bool _useInactivityBasedLogout;
  bool _useInactivityBasedLogoutSet = false;

  bool _trackSessionLocation;
  bool _trackSessionLocationSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Allow users to have persistent sessions when they login

  bool get allowPersistentSessions {
    if (!_allowPersistentSessionsSet &&
        _apiMapResponse.containsKey('allow_persistent_sessions')) {
      _allowPersistentSessions = _apiMapResponse['allow_persistent_sessions'];
      _allowPersistentSessionsSet = true;
    }
    return _allowPersistentSessions;
  }

  set allowPersistentSessions(bool v) {
    _allowPersistentSessions = v;
    _allowPersistentSessionsSet = true;
  }

  /// Number of minutes for user sessions.  Must be between 5 and 43200

  int get sessionMinutes {
    if (!_sessionMinutesSet && _apiMapResponse.containsKey('session_minutes')) {
      _sessionMinutes = _apiMapResponse['session_minutes'];
      _sessionMinutesSet = true;
    }
    return _sessionMinutes;
  }

  set sessionMinutes(int v) {
    _sessionMinutes = v;
    _sessionMinutesSet = true;
  }

  /// Allow users to have an unbounded number of concurrent sessions (otherwise, users will be limited to only one session at a time).

  bool get unlimitedSessionsPerUser {
    if (!_unlimitedSessionsPerUserSet &&
        _apiMapResponse.containsKey('unlimited_sessions_per_user')) {
      _unlimitedSessionsPerUser =
          _apiMapResponse['unlimited_sessions_per_user'];
      _unlimitedSessionsPerUserSet = true;
    }
    return _unlimitedSessionsPerUser;
  }

  set unlimitedSessionsPerUser(bool v) {
    _unlimitedSessionsPerUser = v;
    _unlimitedSessionsPerUserSet = true;
  }

  /// Enforce session logout for sessions that are inactive for 15 minutes.

  bool get useInactivityBasedLogout {
    if (!_useInactivityBasedLogoutSet &&
        _apiMapResponse.containsKey('use_inactivity_based_logout')) {
      _useInactivityBasedLogout =
          _apiMapResponse['use_inactivity_based_logout'];
      _useInactivityBasedLogoutSet = true;
    }
    return _useInactivityBasedLogout;
  }

  set useInactivityBasedLogout(bool v) {
    _useInactivityBasedLogout = v;
    _useInactivityBasedLogoutSet = true;
  }

  /// Track location of session when user logs in.

  bool get trackSessionLocation {
    if (!_trackSessionLocationSet &&
        _apiMapResponse.containsKey('track_session_location')) {
      _trackSessionLocation = _apiMapResponse['track_session_location'];
      _trackSessionLocationSet = true;
    }
    return _trackSessionLocation;
  }

  set trackSessionLocation(bool v) {
    _trackSessionLocation = v;
    _trackSessionLocationSet = true;
  }

  SessionConfig() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SessionConfig.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_allowPersistentSessionsSet ||
        _apiMapResponse.containsKey('allow_persistent_sessions')) {
      json['allow_persistent_sessions'] = allowPersistentSessions;
    }
    if (_sessionMinutesSet || _apiMapResponse.containsKey('session_minutes')) {
      json['session_minutes'] = sessionMinutes;
    }
    if (_unlimitedSessionsPerUserSet ||
        _apiMapResponse.containsKey('unlimited_sessions_per_user')) {
      json['unlimited_sessions_per_user'] = unlimitedSessionsPerUser;
    }
    if (_useInactivityBasedLogoutSet ||
        _apiMapResponse.containsKey('use_inactivity_based_logout')) {
      json['use_inactivity_based_logout'] = useInactivityBasedLogout;
    }
    if (_trackSessionLocationSet ||
        _apiMapResponse.containsKey('track_session_location')) {
      json['track_session_location'] = trackSessionLocation;
    }
    return json;
  }
}

class Setting {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _extensionFrameworkEnabled;
  bool _extensionFrameworkEnabledSet = false;

  bool _marketplaceAutoInstallEnabled;
  bool _marketplaceAutoInstallEnabledSet = false;

  bool _marketplaceEnabled;
  bool _marketplaceEnabledSet = false;

  WhitelabelConfiguration _whitelabelConfiguration;
  bool _whitelabelConfigurationSet = false;

  CustomWelcomeEmail _customWelcomeEmail;
  bool _customWelcomeEmailSet = false;

  /// Toggle extension framework on or off

  bool get extensionFrameworkEnabled {
    if (!_extensionFrameworkEnabledSet &&
        _apiMapResponse.containsKey('extension_framework_enabled')) {
      _extensionFrameworkEnabled =
          _apiMapResponse['extension_framework_enabled'];
      _extensionFrameworkEnabledSet = true;
    }
    return _extensionFrameworkEnabled;
  }

  set extensionFrameworkEnabled(bool v) {
    _extensionFrameworkEnabled = v;
    _extensionFrameworkEnabledSet = true;
  }

  /// Toggle marketplace auto install on or off. Note that auto install only runs if marketplace is enabled.

  bool get marketplaceAutoInstallEnabled {
    if (!_marketplaceAutoInstallEnabledSet &&
        _apiMapResponse.containsKey('marketplace_auto_install_enabled')) {
      _marketplaceAutoInstallEnabled =
          _apiMapResponse['marketplace_auto_install_enabled'];
      _marketplaceAutoInstallEnabledSet = true;
    }
    return _marketplaceAutoInstallEnabled;
  }

  set marketplaceAutoInstallEnabled(bool v) {
    _marketplaceAutoInstallEnabled = v;
    _marketplaceAutoInstallEnabledSet = true;
  }

  /// Toggle marketplace on or off

  bool get marketplaceEnabled {
    if (!_marketplaceEnabledSet &&
        _apiMapResponse.containsKey('marketplace_enabled')) {
      _marketplaceEnabled = _apiMapResponse['marketplace_enabled'];
      _marketplaceEnabledSet = true;
    }
    return _marketplaceEnabled;
  }

  set marketplaceEnabled(bool v) {
    _marketplaceEnabled = v;
    _marketplaceEnabledSet = true;
  }

  WhitelabelConfiguration get whitelabelConfiguration {
    if (!_whitelabelConfigurationSet &&
        _apiMapResponse.containsKey('whitelabel_configuration')) {
      _whitelabelConfiguration =
          _apiMapResponse['whitelabel_configuration'] == null
              ? null
              : WhitelabelConfiguration.fromResponse(
                  _apiMapResponse['whitelabel_configuration'],
                  apiResponseContentType);
      _whitelabelConfigurationSet = true;
    }
    return _whitelabelConfiguration;
  }

  set whitelabelConfiguration(WhitelabelConfiguration v) {
    _whitelabelConfiguration = v;
    _whitelabelConfigurationSet = true;
  }

  CustomWelcomeEmail get customWelcomeEmail {
    if (!_customWelcomeEmailSet &&
        _apiMapResponse.containsKey('custom_welcome_email')) {
      _customWelcomeEmail = _apiMapResponse['custom_welcome_email'] == null
          ? null
          : CustomWelcomeEmail.fromResponse(
              _apiMapResponse['custom_welcome_email'], apiResponseContentType);
      _customWelcomeEmailSet = true;
    }
    return _customWelcomeEmail;
  }

  set customWelcomeEmail(CustomWelcomeEmail v) {
    _customWelcomeEmail = v;
    _customWelcomeEmailSet = true;
  }

  Setting() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Setting.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_extensionFrameworkEnabledSet ||
        _apiMapResponse.containsKey('extension_framework_enabled')) {
      json['extension_framework_enabled'] = extensionFrameworkEnabled;
    }
    if (_marketplaceAutoInstallEnabledSet ||
        _apiMapResponse.containsKey('marketplace_auto_install_enabled')) {
      json['marketplace_auto_install_enabled'] = marketplaceAutoInstallEnabled;
    }
    if (_marketplaceEnabledSet ||
        _apiMapResponse.containsKey('marketplace_enabled')) {
      json['marketplace_enabled'] = marketplaceEnabled;
    }
    if (_whitelabelConfigurationSet ||
        _apiMapResponse.containsKey('whitelabel_configuration')) {
      json['whitelabel_configuration'] = whitelabelConfiguration?.toJson();
    }
    if (_customWelcomeEmailSet ||
        _apiMapResponse.containsKey('custom_welcome_email')) {
      json['custom_welcome_email'] = customWelcomeEmail?.toJson();
    }
    return json;
  }
}

class SmtpNodeStatus {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _isValid;
  bool _isValidSet = false;

  String _message;
  bool _messageSet = false;

  String _hostname;
  bool _hostnameSet = false;

  /// SMTP status of node (read-only)

  bool get isValid {
    if (!_isValidSet && _apiMapResponse.containsKey('is_valid')) {
      _isValid = _apiMapResponse['is_valid'];
      _isValidSet = true;
    }
    return _isValid;
  }

  set isValid(bool v) {
    _isValid = v;
    _isValidSet = true;
  }

  /// Error message for node (read-only)

  String get message {
    if (!_messageSet && _apiMapResponse.containsKey('message')) {
      _message = _apiMapResponse['message']?.toString();
      _messageSet = true;
    }
    return _message;
  }

  set message(String v) {
    _message = v;
    _messageSet = true;
  }

  /// Host name of node (read-only)

  String get hostname {
    if (!_hostnameSet && _apiMapResponse.containsKey('hostname')) {
      _hostname = _apiMapResponse['hostname']?.toString();
      _hostnameSet = true;
    }
    return _hostname;
  }

  set hostname(String v) {
    _hostname = v;
    _hostnameSet = true;
  }

  SmtpNodeStatus() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SmtpNodeStatus.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_isValidSet || _apiMapResponse.containsKey('is_valid')) {
      json['is_valid'] = isValid;
    }
    if (_messageSet || _apiMapResponse.containsKey('message')) {
      json['message'] = message;
    }
    if (_hostnameSet || _apiMapResponse.containsKey('hostname')) {
      json['hostname'] = hostname;
    }
    return json;
  }
}

class SmtpStatus {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _isValid;
  bool _isValidSet = false;

  int _nodeCount;
  bool _nodeCountSet = false;

  List<SmtpNodeStatus> _nodeStatus;
  bool _nodeStatusSet = false;

  /// Overall SMTP status of cluster (read-only)

  bool get isValid {
    if (!_isValidSet && _apiMapResponse.containsKey('is_valid')) {
      _isValid = _apiMapResponse['is_valid'];
      _isValidSet = true;
    }
    return _isValid;
  }

  set isValid(bool v) {
    _isValid = v;
    _isValidSet = true;
  }

  /// Total number of nodes in cluster (read-only)

  int get nodeCount {
    if (!_nodeCountSet && _apiMapResponse.containsKey('node_count')) {
      _nodeCount = _apiMapResponse['node_count'];
      _nodeCountSet = true;
    }
    return _nodeCount;
  }

  set nodeCount(int v) {
    _nodeCount = v;
    _nodeCountSet = true;
  }

  /// array of each node's status containing is_valid, message, hostname (read-only)

  List<SmtpNodeStatus> get nodeStatus {
    if (!_nodeStatusSet && _apiMapResponse.containsKey('node_status')) {
      _nodeStatus = _apiMapResponse['node_status'] == null
          ? null
          : (_apiMapResponse['node_status'] as List)
              .map(
                  (i) => SmtpNodeStatus.fromResponse(i, apiResponseContentType))
              .toList();
      _nodeStatusSet = true;
    }
    return _nodeStatus;
  }

  set nodeStatus(List<SmtpNodeStatus> v) {
    _nodeStatus = v;
    _nodeStatusSet = true;
  }

  SmtpStatus() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SmtpStatus.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_isValidSet || _apiMapResponse.containsKey('is_valid')) {
      json['is_valid'] = isValid;
    }
    if (_nodeCountSet || _apiMapResponse.containsKey('node_count')) {
      json['node_count'] = nodeCount;
    }
    if (_nodeStatusSet || _apiMapResponse.containsKey('node_status')) {
      json['node_status'] = nodeStatus?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

class Snippet {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _label;
  bool _labelSet = false;

  String _sql;
  bool _sqlSet = false;

  /// Name of the snippet (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Label of the snippet (read-only)

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// SQL text of the snippet (read-only)

  String get sql {
    if (!_sqlSet && _apiMapResponse.containsKey('sql')) {
      _sql = _apiMapResponse['sql']?.toString();
      _sqlSet = true;
    }
    return _sql;
  }

  set sql(String v) {
    _sql = v;
    _sqlSet = true;
  }

  Snippet() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Snippet.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_sqlSet || _apiMapResponse.containsKey('sql')) {
      json['sql'] = sql;
    }
    return json;
  }
}

class SqlQuery {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _slug;
  bool _slugSet = false;

  double _lastRuntime;
  bool _lastRuntimeSet = false;

  int _runCount;
  bool _runCountSet = false;

  int _browserLimit;
  bool _browserLimitSet = false;

  String _sql;
  bool _sqlSet = false;

  String _lastRunAt;
  bool _lastRunAtSet = false;

  DBConnectionBase _connection;
  bool _connectionSet = false;

  String _modelName;
  bool _modelNameSet = false;

  UserPublic _creator;
  bool _creatorSet = false;

  String _exploreUrl;
  bool _exploreUrlSet = false;

  bool _plaintext;
  bool _plaintextSet = false;

  Map<String, dynamic> _visConfig;
  bool _visConfigSet = false;

  int _resultMakerId;
  bool _resultMakerIdSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// The identifier of the SQL query (read-only)

  String get slug {
    if (!_slugSet && _apiMapResponse.containsKey('slug')) {
      _slug = _apiMapResponse['slug']?.toString();
      _slugSet = true;
    }
    return _slug;
  }

  set slug(String v) {
    _slug = v;
    _slugSet = true;
  }

  /// Number of seconds this query took to run the most recent time it was run (read-only)

  double get lastRuntime {
    if (!_lastRuntimeSet && _apiMapResponse.containsKey('last_runtime')) {
      _lastRuntime = _apiMapResponse['last_runtime'];
      _lastRuntimeSet = true;
    }
    return _lastRuntime;
  }

  set lastRuntime(double v) {
    _lastRuntime = v;
    _lastRuntimeSet = true;
  }

  /// Number of times this query has been run (read-only)

  int get runCount {
    if (!_runCountSet && _apiMapResponse.containsKey('run_count')) {
      _runCount = _apiMapResponse['run_count'];
      _runCountSet = true;
    }
    return _runCount;
  }

  set runCount(int v) {
    _runCount = v;
    _runCountSet = true;
  }

  /// Maximum number of rows this query will display on the SQL Runner page (read-only)

  int get browserLimit {
    if (!_browserLimitSet && _apiMapResponse.containsKey('browser_limit')) {
      _browserLimit = _apiMapResponse['browser_limit'];
      _browserLimitSet = true;
    }
    return _browserLimit;
  }

  set browserLimit(int v) {
    _browserLimit = v;
    _browserLimitSet = true;
  }

  /// SQL query text (read-only)

  String get sql {
    if (!_sqlSet && _apiMapResponse.containsKey('sql')) {
      _sql = _apiMapResponse['sql']?.toString();
      _sqlSet = true;
    }
    return _sql;
  }

  set sql(String v) {
    _sql = v;
    _sqlSet = true;
  }

  /// The most recent time this query was run (read-only)

  String get lastRunAt {
    if (!_lastRunAtSet && _apiMapResponse.containsKey('last_run_at')) {
      _lastRunAt = _apiMapResponse['last_run_at']?.toString();
      _lastRunAtSet = true;
    }
    return _lastRunAt;
  }

  set lastRunAt(String v) {
    _lastRunAt = v;
    _lastRunAtSet = true;
  }

  DBConnectionBase get connection {
    if (!_connectionSet && _apiMapResponse.containsKey('connection')) {
      _connection = _apiMapResponse['connection'] == null
          ? null
          : DBConnectionBase.fromResponse(
              _apiMapResponse['connection'], apiResponseContentType);
      _connectionSet = true;
    }
    return _connection;
  }

  set connection(DBConnectionBase v) {
    _connection = v;
    _connectionSet = true;
  }

  /// Model name this query uses (read-only)

  String get modelName {
    if (!_modelNameSet && _apiMapResponse.containsKey('model_name')) {
      _modelName = _apiMapResponse['model_name']?.toString();
      _modelNameSet = true;
    }
    return _modelName;
  }

  set modelName(String v) {
    _modelName = v;
    _modelNameSet = true;
  }

  UserPublic get creator {
    if (!_creatorSet && _apiMapResponse.containsKey('creator')) {
      _creator = _apiMapResponse['creator'] == null
          ? null
          : UserPublic.fromResponse(
              _apiMapResponse['creator'], apiResponseContentType);
      _creatorSet = true;
    }
    return _creator;
  }

  set creator(UserPublic v) {
    _creator = v;
    _creatorSet = true;
  }

  /// Explore page URL for this SQL query (read-only)

  String get exploreUrl {
    if (!_exploreUrlSet && _apiMapResponse.containsKey('explore_url')) {
      _exploreUrl = _apiMapResponse['explore_url']?.toString();
      _exploreUrlSet = true;
    }
    return _exploreUrl;
  }

  set exploreUrl(String v) {
    _exploreUrl = v;
    _exploreUrlSet = true;
  }

  /// Should this query be rendered as plain text (read-only)

  bool get plaintext {
    if (!_plaintextSet && _apiMapResponse.containsKey('plaintext')) {
      _plaintext = _apiMapResponse['plaintext'];
      _plaintextSet = true;
    }
    return _plaintext;
  }

  set plaintext(bool v) {
    _plaintext = v;
    _plaintextSet = true;
  }

  /// Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.

  Map<String, dynamic> get visConfig {
    if (!_visConfigSet && _apiMapResponse.containsKey('vis_config')) {
      _visConfig = _apiMapResponse['vis_config'];
      _visConfigSet = true;
    }
    return _visConfig;
  }

  set visConfig(Map<String, dynamic> v) {
    _visConfig = v;
    _visConfigSet = true;
  }

  /// ID of the ResultMakerLookup entry.

  int get resultMakerId {
    if (!_resultMakerIdSet && _apiMapResponse.containsKey('result_maker_id')) {
      _resultMakerId = _apiMapResponse['result_maker_id'];
      _resultMakerIdSet = true;
    }
    return _resultMakerId;
  }

  set resultMakerId(int v) {
    _resultMakerId = v;
    _resultMakerIdSet = true;
  }

  SqlQuery() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SqlQuery.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_slugSet || _apiMapResponse.containsKey('slug')) {
      json['slug'] = slug;
    }
    if (_lastRuntimeSet || _apiMapResponse.containsKey('last_runtime')) {
      json['last_runtime'] = lastRuntime;
    }
    if (_runCountSet || _apiMapResponse.containsKey('run_count')) {
      json['run_count'] = runCount;
    }
    if (_browserLimitSet || _apiMapResponse.containsKey('browser_limit')) {
      json['browser_limit'] = browserLimit;
    }
    if (_sqlSet || _apiMapResponse.containsKey('sql')) {
      json['sql'] = sql;
    }
    if (_lastRunAtSet || _apiMapResponse.containsKey('last_run_at')) {
      json['last_run_at'] = lastRunAt;
    }
    if (_connectionSet || _apiMapResponse.containsKey('connection')) {
      json['connection'] = connection?.toJson();
    }
    if (_modelNameSet || _apiMapResponse.containsKey('model_name')) {
      json['model_name'] = modelName;
    }
    if (_creatorSet || _apiMapResponse.containsKey('creator')) {
      json['creator'] = creator?.toJson();
    }
    if (_exploreUrlSet || _apiMapResponse.containsKey('explore_url')) {
      json['explore_url'] = exploreUrl;
    }
    if (_plaintextSet || _apiMapResponse.containsKey('plaintext')) {
      json['plaintext'] = plaintext;
    }
    if (_visConfigSet || _apiMapResponse.containsKey('vis_config')) {
      json['vis_config'] = visConfig;
    }
    if (_resultMakerIdSet || _apiMapResponse.containsKey('result_maker_id')) {
      json['result_maker_id'] = resultMakerId;
    }
    return json;
  }
}

class SqlQueryCreate {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _connectionName;
  bool _connectionNameSet = false;

  String _connectionId;
  bool _connectionIdSet = false;

  String _modelName;
  bool _modelNameSet = false;

  String _sql;
  bool _sqlSet = false;

  Map<String, dynamic> _visConfig;
  bool _visConfigSet = false;

  /// Name of the db connection on which to run this query

  String get connectionName {
    if (!_connectionNameSet && _apiMapResponse.containsKey('connection_name')) {
      _connectionName = _apiMapResponse['connection_name']?.toString();
      _connectionNameSet = true;
    }
    return _connectionName;
  }

  set connectionName(String v) {
    _connectionName = v;
    _connectionNameSet = true;
  }

  /// (DEPRECATED) Use `connection_name` instead

  String get connectionId {
    if (!_connectionIdSet && _apiMapResponse.containsKey('connection_id')) {
      _connectionId = _apiMapResponse['connection_id']?.toString();
      _connectionIdSet = true;
    }
    return _connectionId;
  }

  set connectionId(String v) {
    _connectionId = v;
    _connectionIdSet = true;
  }

  /// Name of LookML Model (this or `connection_id` required)

  String get modelName {
    if (!_modelNameSet && _apiMapResponse.containsKey('model_name')) {
      _modelName = _apiMapResponse['model_name']?.toString();
      _modelNameSet = true;
    }
    return _modelName;
  }

  set modelName(String v) {
    _modelName = v;
    _modelNameSet = true;
  }

  /// SQL query

  String get sql {
    if (!_sqlSet && _apiMapResponse.containsKey('sql')) {
      _sql = _apiMapResponse['sql']?.toString();
      _sqlSet = true;
    }
    return _sql;
  }

  set sql(String v) {
    _sql = v;
    _sqlSet = true;
  }

  /// Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.

  Map<String, dynamic> get visConfig {
    if (!_visConfigSet && _apiMapResponse.containsKey('vis_config')) {
      _visConfig = _apiMapResponse['vis_config'];
      _visConfigSet = true;
    }
    return _visConfig;
  }

  set visConfig(Map<String, dynamic> v) {
    _visConfig = v;
    _visConfigSet = true;
  }

  SqlQueryCreate() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SqlQueryCreate.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_connectionNameSet || _apiMapResponse.containsKey('connection_name')) {
      json['connection_name'] = connectionName;
    }
    if (_connectionIdSet || _apiMapResponse.containsKey('connection_id')) {
      json['connection_id'] = connectionId;
    }
    if (_modelNameSet || _apiMapResponse.containsKey('model_name')) {
      json['model_name'] = modelName;
    }
    if (_sqlSet || _apiMapResponse.containsKey('sql')) {
      json['sql'] = sql;
    }
    if (_visConfigSet || _apiMapResponse.containsKey('vis_config')) {
      json['vis_config'] = visConfig;
    }
    return json;
  }
}

class SshPublicKey {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _publicKey;
  bool _publicKeySet = false;

  /// The SSH public key created for this instance (read-only)

  String get publicKey {
    if (!_publicKeySet && _apiMapResponse.containsKey('public_key')) {
      _publicKey = _apiMapResponse['public_key']?.toString();
      _publicKeySet = true;
    }
    return _publicKey;
  }

  set publicKey(String v) {
    _publicKey = v;
    _publicKeySet = true;
  }

  SshPublicKey() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SshPublicKey.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_publicKeySet || _apiMapResponse.containsKey('public_key')) {
      json['public_key'] = publicKey;
    }
    return json;
  }
}

class SshServer {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _sshServerId;
  bool _sshServerIdSet = false;

  String _sshServerName;
  bool _sshServerNameSet = false;

  String _sshServerHost;
  bool _sshServerHostSet = false;

  int _sshServerPort;
  bool _sshServerPortSet = false;

  String _sshServerUser;
  bool _sshServerUserSet = false;

  String _fingerPrint;
  bool _fingerPrintSet = false;

  String _shaFingerPrint;
  bool _shaFingerPrintSet = false;

  String _publicKey;
  bool _publicKeySet = false;

  String _status;
  bool _statusSet = false;

  /// A unique id used to identify this SSH Server (read-only)

  String get sshServerId {
    if (!_sshServerIdSet && _apiMapResponse.containsKey('ssh_server_id')) {
      _sshServerId = _apiMapResponse['ssh_server_id']?.toString();
      _sshServerIdSet = true;
    }
    return _sshServerId;
  }

  set sshServerId(String v) {
    _sshServerId = v;
    _sshServerIdSet = true;
  }

  /// The name to identify this SSH Server

  String get sshServerName {
    if (!_sshServerNameSet && _apiMapResponse.containsKey('ssh_server_name')) {
      _sshServerName = _apiMapResponse['ssh_server_name']?.toString();
      _sshServerNameSet = true;
    }
    return _sshServerName;
  }

  set sshServerName(String v) {
    _sshServerName = v;
    _sshServerNameSet = true;
  }

  /// The hostname or ip address of the SSH Server

  String get sshServerHost {
    if (!_sshServerHostSet && _apiMapResponse.containsKey('ssh_server_host')) {
      _sshServerHost = _apiMapResponse['ssh_server_host']?.toString();
      _sshServerHostSet = true;
    }
    return _sshServerHost;
  }

  set sshServerHost(String v) {
    _sshServerHost = v;
    _sshServerHostSet = true;
  }

  /// The port to connect to on the SSH Server

  int get sshServerPort {
    if (!_sshServerPortSet && _apiMapResponse.containsKey('ssh_server_port')) {
      _sshServerPort = _apiMapResponse['ssh_server_port'];
      _sshServerPortSet = true;
    }
    return _sshServerPort;
  }

  set sshServerPort(int v) {
    _sshServerPort = v;
    _sshServerPortSet = true;
  }

  /// The username used to connect to the SSH Server

  String get sshServerUser {
    if (!_sshServerUserSet && _apiMapResponse.containsKey('ssh_server_user')) {
      _sshServerUser = _apiMapResponse['ssh_server_user']?.toString();
      _sshServerUserSet = true;
    }
    return _sshServerUser;
  }

  set sshServerUser(String v) {
    _sshServerUser = v;
    _sshServerUserSet = true;
  }

  /// The md5 fingerprint used to identify the SSH Server (read-only)

  String get fingerPrint {
    if (!_fingerPrintSet && _apiMapResponse.containsKey('finger_print')) {
      _fingerPrint = _apiMapResponse['finger_print']?.toString();
      _fingerPrintSet = true;
    }
    return _fingerPrint;
  }

  set fingerPrint(String v) {
    _fingerPrint = v;
    _fingerPrintSet = true;
  }

  /// The SHA fingerprint used to identify the SSH Server (read-only)

  String get shaFingerPrint {
    if (!_shaFingerPrintSet &&
        _apiMapResponse.containsKey('sha_finger_print')) {
      _shaFingerPrint = _apiMapResponse['sha_finger_print']?.toString();
      _shaFingerPrintSet = true;
    }
    return _shaFingerPrint;
  }

  set shaFingerPrint(String v) {
    _shaFingerPrint = v;
    _shaFingerPrintSet = true;
  }

  /// The SSH public key created for this instance (read-only)

  String get publicKey {
    if (!_publicKeySet && _apiMapResponse.containsKey('public_key')) {
      _publicKey = _apiMapResponse['public_key']?.toString();
      _publicKeySet = true;
    }
    return _publicKey;
  }

  set publicKey(String v) {
    _publicKey = v;
    _publicKeySet = true;
  }

  /// The current connection status to this SSH Server (read-only)

  String get status {
    if (!_statusSet && _apiMapResponse.containsKey('status')) {
      _status = _apiMapResponse['status']?.toString();
      _statusSet = true;
    }
    return _status;
  }

  set status(String v) {
    _status = v;
    _statusSet = true;
  }

  SshServer() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SshServer.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_sshServerIdSet || _apiMapResponse.containsKey('ssh_server_id')) {
      json['ssh_server_id'] = sshServerId;
    }
    if (_sshServerNameSet || _apiMapResponse.containsKey('ssh_server_name')) {
      json['ssh_server_name'] = sshServerName;
    }
    if (_sshServerHostSet || _apiMapResponse.containsKey('ssh_server_host')) {
      json['ssh_server_host'] = sshServerHost;
    }
    if (_sshServerPortSet || _apiMapResponse.containsKey('ssh_server_port')) {
      json['ssh_server_port'] = sshServerPort;
    }
    if (_sshServerUserSet || _apiMapResponse.containsKey('ssh_server_user')) {
      json['ssh_server_user'] = sshServerUser;
    }
    if (_fingerPrintSet || _apiMapResponse.containsKey('finger_print')) {
      json['finger_print'] = fingerPrint;
    }
    if (_shaFingerPrintSet || _apiMapResponse.containsKey('sha_finger_print')) {
      json['sha_finger_print'] = shaFingerPrint;
    }
    if (_publicKeySet || _apiMapResponse.containsKey('public_key')) {
      json['public_key'] = publicKey;
    }
    if (_statusSet || _apiMapResponse.containsKey('status')) {
      json['status'] = status;
    }
    return json;
  }
}

class SshTunnel {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _tunnelId;
  bool _tunnelIdSet = false;

  String _sshServerId;
  bool _sshServerIdSet = false;

  String _sshServerName;
  bool _sshServerNameSet = false;

  String _sshServerHost;
  bool _sshServerHostSet = false;

  int _sshServerPort;
  bool _sshServerPortSet = false;

  String _sshServerUser;
  bool _sshServerUserSet = false;

  String _lastAttempt;
  bool _lastAttemptSet = false;

  int _localHostPort;
  bool _localHostPortSet = false;

  String _databaseHost;
  bool _databaseHostSet = false;

  int _databasePort;
  bool _databasePortSet = false;

  String _status;
  bool _statusSet = false;

  /// Unique ID for the tunnel (read-only)

  String get tunnelId {
    if (!_tunnelIdSet && _apiMapResponse.containsKey('tunnel_id')) {
      _tunnelId = _apiMapResponse['tunnel_id']?.toString();
      _tunnelIdSet = true;
    }
    return _tunnelId;
  }

  set tunnelId(String v) {
    _tunnelId = v;
    _tunnelIdSet = true;
  }

  /// SSH Server ID

  String get sshServerId {
    if (!_sshServerIdSet && _apiMapResponse.containsKey('ssh_server_id')) {
      _sshServerId = _apiMapResponse['ssh_server_id']?.toString();
      _sshServerIdSet = true;
    }
    return _sshServerId;
  }

  set sshServerId(String v) {
    _sshServerId = v;
    _sshServerIdSet = true;
  }

  /// SSH Server name (read-only)

  String get sshServerName {
    if (!_sshServerNameSet && _apiMapResponse.containsKey('ssh_server_name')) {
      _sshServerName = _apiMapResponse['ssh_server_name']?.toString();
      _sshServerNameSet = true;
    }
    return _sshServerName;
  }

  set sshServerName(String v) {
    _sshServerName = v;
    _sshServerNameSet = true;
  }

  /// SSH Server Hostname or IP Address (read-only)

  String get sshServerHost {
    if (!_sshServerHostSet && _apiMapResponse.containsKey('ssh_server_host')) {
      _sshServerHost = _apiMapResponse['ssh_server_host']?.toString();
      _sshServerHostSet = true;
    }
    return _sshServerHost;
  }

  set sshServerHost(String v) {
    _sshServerHost = v;
    _sshServerHostSet = true;
  }

  /// SSH Server port (read-only)

  int get sshServerPort {
    if (!_sshServerPortSet && _apiMapResponse.containsKey('ssh_server_port')) {
      _sshServerPort = _apiMapResponse['ssh_server_port'];
      _sshServerPortSet = true;
    }
    return _sshServerPort;
  }

  set sshServerPort(int v) {
    _sshServerPort = v;
    _sshServerPortSet = true;
  }

  /// Username used to connect to the SSH Server (read-only)

  String get sshServerUser {
    if (!_sshServerUserSet && _apiMapResponse.containsKey('ssh_server_user')) {
      _sshServerUser = _apiMapResponse['ssh_server_user']?.toString();
      _sshServerUserSet = true;
    }
    return _sshServerUser;
  }

  set sshServerUser(String v) {
    _sshServerUser = v;
    _sshServerUserSet = true;
  }

  /// Time of last connect attempt (read-only)

  String get lastAttempt {
    if (!_lastAttemptSet && _apiMapResponse.containsKey('last_attempt')) {
      _lastAttempt = _apiMapResponse['last_attempt']?.toString();
      _lastAttemptSet = true;
    }
    return _lastAttempt;
  }

  set lastAttempt(String v) {
    _lastAttempt = v;
    _lastAttemptSet = true;
  }

  /// Localhost Port used by the Looker instance to connect to the remote DB (read-only)

  int get localHostPort {
    if (!_localHostPortSet && _apiMapResponse.containsKey('local_host_port')) {
      _localHostPort = _apiMapResponse['local_host_port'];
      _localHostPortSet = true;
    }
    return _localHostPort;
  }

  set localHostPort(int v) {
    _localHostPort = v;
    _localHostPortSet = true;
  }

  /// Hostname or IP Address of the Database Server

  String get databaseHost {
    if (!_databaseHostSet && _apiMapResponse.containsKey('database_host')) {
      _databaseHost = _apiMapResponse['database_host']?.toString();
      _databaseHostSet = true;
    }
    return _databaseHost;
  }

  set databaseHost(String v) {
    _databaseHost = v;
    _databaseHostSet = true;
  }

  /// Port that the Database Server is listening on

  int get databasePort {
    if (!_databasePortSet && _apiMapResponse.containsKey('database_port')) {
      _databasePort = _apiMapResponse['database_port'];
      _databasePortSet = true;
    }
    return _databasePort;
  }

  set databasePort(int v) {
    _databasePort = v;
    _databasePortSet = true;
  }

  /// Current connection status for this Tunnel (read-only)

  String get status {
    if (!_statusSet && _apiMapResponse.containsKey('status')) {
      _status = _apiMapResponse['status']?.toString();
      _statusSet = true;
    }
    return _status;
  }

  set status(String v) {
    _status = v;
    _statusSet = true;
  }

  SshTunnel() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SshTunnel.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_tunnelIdSet || _apiMapResponse.containsKey('tunnel_id')) {
      json['tunnel_id'] = tunnelId;
    }
    if (_sshServerIdSet || _apiMapResponse.containsKey('ssh_server_id')) {
      json['ssh_server_id'] = sshServerId;
    }
    if (_sshServerNameSet || _apiMapResponse.containsKey('ssh_server_name')) {
      json['ssh_server_name'] = sshServerName;
    }
    if (_sshServerHostSet || _apiMapResponse.containsKey('ssh_server_host')) {
      json['ssh_server_host'] = sshServerHost;
    }
    if (_sshServerPortSet || _apiMapResponse.containsKey('ssh_server_port')) {
      json['ssh_server_port'] = sshServerPort;
    }
    if (_sshServerUserSet || _apiMapResponse.containsKey('ssh_server_user')) {
      json['ssh_server_user'] = sshServerUser;
    }
    if (_lastAttemptSet || _apiMapResponse.containsKey('last_attempt')) {
      json['last_attempt'] = lastAttempt;
    }
    if (_localHostPortSet || _apiMapResponse.containsKey('local_host_port')) {
      json['local_host_port'] = localHostPort;
    }
    if (_databaseHostSet || _apiMapResponse.containsKey('database_host')) {
      json['database_host'] = databaseHost;
    }
    if (_databasePortSet || _apiMapResponse.containsKey('database_port')) {
      json['database_port'] = databasePort;
    }
    if (_statusSet || _apiMapResponse.containsKey('status')) {
      json['status'] = status;
    }
    return json;
  }
}

class SupportAccessAddEntries {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  List<String> _emails;
  bool _emailsSet = false;

  String _reason;
  bool _reasonSet = false;

  /// An array of emails to add to the Allowlist

  List<String> get emails {
    if (!_emailsSet && _apiMapResponse.containsKey('emails')) {
      _emails =
          _apiMapResponse['emails']?.map<String>((i) => i as String)?.toList();
      _emailsSet = true;
    }
    return _emails;
  }

  set emails(List<String> v) {
    _emails = v;
    _emailsSet = true;
  }

  /// Reason for adding emails to the Allowlist

  String get reason {
    if (!_reasonSet && _apiMapResponse.containsKey('reason')) {
      _reason = _apiMapResponse['reason']?.toString();
      _reasonSet = true;
    }
    return _reason;
  }

  set reason(String v) {
    _reason = v;
    _reasonSet = true;
  }

  SupportAccessAddEntries() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SupportAccessAddEntries.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_emailsSet || _apiMapResponse.containsKey('emails')) {
      json['emails'] = emails;
    }
    if (_reasonSet || _apiMapResponse.containsKey('reason')) {
      json['reason'] = reason;
    }
    return json;
  }
}

class SupportAccessAllowlistEntry {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _id;
  bool _idSet = false;

  String _email;
  bool _emailSet = false;

  String _fullName;
  bool _fullNameSet = false;

  String _reason;
  bool _reasonSet = false;

  DateTime _createdDate;
  bool _createdDateSet = false;

  /// Unique ID (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// Email address

  String get email {
    if (!_emailSet && _apiMapResponse.containsKey('email')) {
      _email = _apiMapResponse['email']?.toString();
      _emailSet = true;
    }
    return _email;
  }

  set email(String v) {
    _email = v;
    _emailSet = true;
  }

  /// Full name of allowlisted user (read-only)

  String get fullName {
    if (!_fullNameSet && _apiMapResponse.containsKey('full_name')) {
      _fullName = _apiMapResponse['full_name']?.toString();
      _fullNameSet = true;
    }
    return _fullName;
  }

  set fullName(String v) {
    _fullName = v;
    _fullNameSet = true;
  }

  /// Reason the Email is included in the Allowlist

  String get reason {
    if (!_reasonSet && _apiMapResponse.containsKey('reason')) {
      _reason = _apiMapResponse['reason']?.toString();
      _reasonSet = true;
    }
    return _reason;
  }

  set reason(String v) {
    _reason = v;
    _reasonSet = true;
  }

  /// Date the Email was added to the Allowlist (read-only)

  DateTime get createdDate {
    if (!_createdDateSet && _apiMapResponse.containsKey('created_date')) {
      _createdDate = _apiMapResponse['created_date'] == null
          ? null
          : DateTime.parse(_apiMapResponse['created_date']);
      _createdDateSet = true;
    }
    return _createdDate;
  }

  set createdDate(DateTime v) {
    _createdDate = v;
    _createdDateSet = true;
  }

  SupportAccessAllowlistEntry() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SupportAccessAllowlistEntry.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_emailSet || _apiMapResponse.containsKey('email')) {
      json['email'] = email;
    }
    if (_fullNameSet || _apiMapResponse.containsKey('full_name')) {
      json['full_name'] = fullName;
    }
    if (_reasonSet || _apiMapResponse.containsKey('reason')) {
      json['reason'] = reason;
    }
    if (_createdDateSet || _apiMapResponse.containsKey('created_date')) {
      json['created_date'] = createdDate?.toIso8601String();
    }
    return json;
  }
}

class SupportAccessEnable {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _durationInSeconds;
  bool _durationInSecondsSet = false;

  /// Duration Support Access will remain enabled

  int get durationInSeconds {
    if (!_durationInSecondsSet &&
        _apiMapResponse.containsKey('duration_in_seconds')) {
      _durationInSeconds = _apiMapResponse['duration_in_seconds'];
      _durationInSecondsSet = true;
    }
    return _durationInSeconds;
  }

  set durationInSeconds(int v) {
    _durationInSeconds = v;
    _durationInSecondsSet = true;
  }

  SupportAccessEnable() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SupportAccessEnable.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_durationInSecondsSet ||
        _apiMapResponse.containsKey('duration_in_seconds')) {
      json['duration_in_seconds'] = durationInSeconds;
    }
    return json;
  }
}

class SupportAccessStatus {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _open;
  bool _openSet = false;

  DateTime _openUntil;
  bool _openUntilSet = false;

  /// Whether or not Support Access is open (read-only)

  bool get open {
    if (!_openSet && _apiMapResponse.containsKey('open')) {
      _open = _apiMapResponse['open'];
      _openSet = true;
    }
    return _open;
  }

  set open(bool v) {
    _open = v;
    _openSet = true;
  }

  /// Time that Support Access will expire (read-only)

  DateTime get openUntil {
    if (!_openUntilSet && _apiMapResponse.containsKey('open_until')) {
      _openUntil = _apiMapResponse['open_until'] == null
          ? null
          : DateTime.parse(_apiMapResponse['open_until']);
      _openUntilSet = true;
    }
    return _openUntil;
  }

  set openUntil(DateTime v) {
    _openUntil = v;
    _openUntilSet = true;
  }

  SupportAccessStatus() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  SupportAccessStatus.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_openSet || _apiMapResponse.containsKey('open')) {
      json['open'] = open;
    }
    if (_openUntilSet || _apiMapResponse.containsKey('open_until')) {
      json['open_until'] = openUntil?.toIso8601String();
    }
    return json;
  }
}

/// A list of action types the integration supports. Valid values are: "cell", "query", "dashboard". (Enum defined in Integration)
enum SupportedActionTypes { cell, query, dashboard }

class SupportedActionTypesMapper {
  static String toStringValue(SupportedActionTypes e) {
    switch (e) {
      case SupportedActionTypes.cell:
        return 'cell';
      case SupportedActionTypes.query:
        return 'query';
      case SupportedActionTypes.dashboard:
        return 'dashboard';

      default:
        return null;
    }
  }

  static SupportedActionTypes fromStringValue(String s) {
    if (s == 'cell') {
      return SupportedActionTypes.cell;
    }
    if (s == 'query') {
      return SupportedActionTypes.query;
    }
    if (s == 'dashboard') {
      return SupportedActionTypes.dashboard;
    }
    return null;
  }
}

/// A list of all the download mechanisms the integration supports. The order of values is not significant: Looker will select the most appropriate supported download mechanism for a given query. The integration must ensure it can handle any of the mechanisms it claims to support. If unspecified, this defaults to all download setting values. Valid values are: "push", "url". (Enum defined in Integration)
enum SupportedDownloadSettings { push, url }

class SupportedDownloadSettingsMapper {
  static String toStringValue(SupportedDownloadSettings e) {
    switch (e) {
      case SupportedDownloadSettings.push:
        return 'push';
      case SupportedDownloadSettings.url:
        return 'url';

      default:
        return null;
    }
  }

  static SupportedDownloadSettings fromStringValue(String s) {
    if (s == 'push') {
      return SupportedDownloadSettings.push;
    }
    if (s == 'url') {
      return SupportedDownloadSettings.url;
    }
    return null;
  }
}

/// A list of data formats the integration supports. If unspecified, the default is all data formats. Valid values are: "txt", "csv", "inline_json", "json", "json_label", "json_detail", "json_detail_lite_stream", "xlsx", "html", "wysiwyg_pdf", "assembled_pdf", "wysiwyg_png", "csv_zip". (Enum defined in Integration)
enum SupportedFormats {
  txt,
  csv,
  inlineJson,
  json,
  jsonLabel,
  jsonDetail,
  jsonDetailLiteStream,
  xlsx,
  html,
  wysiwygPdf,
  assembledPdf,
  wysiwygPng,
  csvZip
}

class SupportedFormatsMapper {
  static String toStringValue(SupportedFormats e) {
    switch (e) {
      case SupportedFormats.txt:
        return 'txt';
      case SupportedFormats.csv:
        return 'csv';
      case SupportedFormats.inlineJson:
        return 'inline_json';
      case SupportedFormats.json:
        return 'json';
      case SupportedFormats.jsonLabel:
        return 'json_label';
      case SupportedFormats.jsonDetail:
        return 'json_detail';
      case SupportedFormats.jsonDetailLiteStream:
        return 'json_detail_lite_stream';
      case SupportedFormats.xlsx:
        return 'xlsx';
      case SupportedFormats.html:
        return 'html';
      case SupportedFormats.wysiwygPdf:
        return 'wysiwyg_pdf';
      case SupportedFormats.assembledPdf:
        return 'assembled_pdf';
      case SupportedFormats.wysiwygPng:
        return 'wysiwyg_png';
      case SupportedFormats.csvZip:
        return 'csv_zip';

      default:
        return null;
    }
  }

  static SupportedFormats fromStringValue(String s) {
    if (s == 'txt') {
      return SupportedFormats.txt;
    }
    if (s == 'csv') {
      return SupportedFormats.csv;
    }
    if (s == 'inline_json') {
      return SupportedFormats.inlineJson;
    }
    if (s == 'json') {
      return SupportedFormats.json;
    }
    if (s == 'json_label') {
      return SupportedFormats.jsonLabel;
    }
    if (s == 'json_detail') {
      return SupportedFormats.jsonDetail;
    }
    if (s == 'json_detail_lite_stream') {
      return SupportedFormats.jsonDetailLiteStream;
    }
    if (s == 'xlsx') {
      return SupportedFormats.xlsx;
    }
    if (s == 'html') {
      return SupportedFormats.html;
    }
    if (s == 'wysiwyg_pdf') {
      return SupportedFormats.wysiwygPdf;
    }
    if (s == 'assembled_pdf') {
      return SupportedFormats.assembledPdf;
    }
    if (s == 'wysiwyg_png') {
      return SupportedFormats.wysiwygPng;
    }
    if (s == 'csv_zip') {
      return SupportedFormats.csvZip;
    }
    return null;
  }
}

/// A list of formatting options the integration supports. If unspecified, defaults to all formats. Valid values are: "formatted", "unformatted". (Enum defined in Integration)
enum SupportedFormattings { formatted, unformatted }

class SupportedFormattingsMapper {
  static String toStringValue(SupportedFormattings e) {
    switch (e) {
      case SupportedFormattings.formatted:
        return 'formatted';
      case SupportedFormattings.unformatted:
        return 'unformatted';

      default:
        return null;
    }
  }

  static SupportedFormattings fromStringValue(String s) {
    if (s == 'formatted') {
      return SupportedFormattings.formatted;
    }
    if (s == 'unformatted') {
      return SupportedFormattings.unformatted;
    }
    return null;
  }
}

/// A list of visualization formatting options the integration supports. If unspecified, defaults to all formats. Valid values are: "apply", "noapply". (Enum defined in Integration)
enum SupportedVisualizationFormattings { apply, noapply }

class SupportedVisualizationFormattingsMapper {
  static String toStringValue(SupportedVisualizationFormattings e) {
    switch (e) {
      case SupportedVisualizationFormattings.apply:
        return 'apply';
      case SupportedVisualizationFormattings.noapply:
        return 'noapply';

      default:
        return null;
    }
  }

  static SupportedVisualizationFormattings fromStringValue(String s) {
    if (s == 'apply') {
      return SupportedVisualizationFormattings.apply;
    }
    if (s == 'noapply') {
      return SupportedVisualizationFormattings.noapply;
    }
    return null;
  }
}

class Theme {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  DateTime _beginAt;
  bool _beginAtSet = false;

  DateTime _endAt;
  bool _endAtSet = false;

  int _id;
  bool _idSet = false;

  String _name;
  bool _nameSet = false;

  ThemeSettings _settings;
  bool _settingsSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Timestamp for when this theme becomes active. Null=always

  DateTime get beginAt {
    if (!_beginAtSet && _apiMapResponse.containsKey('begin_at')) {
      _beginAt = _apiMapResponse['begin_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['begin_at']);
      _beginAtSet = true;
    }
    return _beginAt;
  }

  set beginAt(DateTime v) {
    _beginAt = v;
    _beginAtSet = true;
  }

  /// Timestamp for when this theme expires. Null=never

  DateTime get endAt {
    if (!_endAtSet && _apiMapResponse.containsKey('end_at')) {
      _endAt = _apiMapResponse['end_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['end_at']);
      _endAtSet = true;
    }
    return _endAt;
  }

  set endAt(DateTime v) {
    _endAt = v;
    _endAtSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Name of theme. Can only be alphanumeric and underscores.

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  ThemeSettings get settings {
    if (!_settingsSet && _apiMapResponse.containsKey('settings')) {
      _settings = _apiMapResponse['settings'] == null
          ? null
          : ThemeSettings.fromResponse(
              _apiMapResponse['settings'], apiResponseContentType);
      _settingsSet = true;
    }
    return _settings;
  }

  set settings(ThemeSettings v) {
    _settings = v;
    _settingsSet = true;
  }

  Theme() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Theme.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_beginAtSet || _apiMapResponse.containsKey('begin_at')) {
      json['begin_at'] = beginAt?.toIso8601String();
    }
    if (_endAtSet || _apiMapResponse.containsKey('end_at')) {
      json['end_at'] = endAt?.toIso8601String();
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_settingsSet || _apiMapResponse.containsKey('settings')) {
      json['settings'] = settings?.toJson();
    }
    return json;
  }
}

class ThemeSettings {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _backgroundColor;
  bool _backgroundColorSet = false;

  String _baseFontSize;
  bool _baseFontSizeSet = false;

  String _colorCollectionId;
  bool _colorCollectionIdSet = false;

  String _fontColor;
  bool _fontColorSet = false;

  String _fontFamily;
  bool _fontFamilySet = false;

  String _fontSource;
  bool _fontSourceSet = false;

  String _infoButtonColor;
  bool _infoButtonColorSet = false;

  String _primaryButtonColor;
  bool _primaryButtonColorSet = false;

  bool _showFiltersBar;
  bool _showFiltersBarSet = false;

  bool _showTitle;
  bool _showTitleSet = false;

  String _textTileTextColor;
  bool _textTileTextColorSet = false;

  String _tileBackgroundColor;
  bool _tileBackgroundColorSet = false;

  String _tileTextColor;
  bool _tileTextColorSet = false;

  String _titleColor;
  bool _titleColorSet = false;

  String _warnButtonColor;
  bool _warnButtonColorSet = false;

  String _tileTitleAlignment;
  bool _tileTitleAlignmentSet = false;

  bool _tileShadow;
  bool _tileShadowSet = false;

  /// Default background color

  String get backgroundColor {
    if (!_backgroundColorSet &&
        _apiMapResponse.containsKey('background_color')) {
      _backgroundColor = _apiMapResponse['background_color']?.toString();
      _backgroundColorSet = true;
    }
    return _backgroundColor;
  }

  set backgroundColor(String v) {
    _backgroundColor = v;
    _backgroundColorSet = true;
  }

  /// Base font size for scaling fonts

  String get baseFontSize {
    if (!_baseFontSizeSet && _apiMapResponse.containsKey('base_font_size')) {
      _baseFontSize = _apiMapResponse['base_font_size']?.toString();
      _baseFontSizeSet = true;
    }
    return _baseFontSize;
  }

  set baseFontSize(String v) {
    _baseFontSize = v;
    _baseFontSizeSet = true;
  }

  /// Optional. ID of color collection to use with the theme. Use an empty string for none.

  String get colorCollectionId {
    if (!_colorCollectionIdSet &&
        _apiMapResponse.containsKey('color_collection_id')) {
      _colorCollectionId = _apiMapResponse['color_collection_id']?.toString();
      _colorCollectionIdSet = true;
    }
    return _colorCollectionId;
  }

  set colorCollectionId(String v) {
    _colorCollectionId = v;
    _colorCollectionIdSet = true;
  }

  /// Default font color

  String get fontColor {
    if (!_fontColorSet && _apiMapResponse.containsKey('font_color')) {
      _fontColor = _apiMapResponse['font_color']?.toString();
      _fontColorSet = true;
    }
    return _fontColor;
  }

  set fontColor(String v) {
    _fontColor = v;
    _fontColorSet = true;
  }

  /// Primary font family

  String get fontFamily {
    if (!_fontFamilySet && _apiMapResponse.containsKey('font_family')) {
      _fontFamily = _apiMapResponse['font_family']?.toString();
      _fontFamilySet = true;
    }
    return _fontFamily;
  }

  set fontFamily(String v) {
    _fontFamily = v;
    _fontFamilySet = true;
  }

  /// Source specification for font

  String get fontSource {
    if (!_fontSourceSet && _apiMapResponse.containsKey('font_source')) {
      _fontSource = _apiMapResponse['font_source']?.toString();
      _fontSourceSet = true;
    }
    return _fontSource;
  }

  set fontSource(String v) {
    _fontSource = v;
    _fontSourceSet = true;
  }

  /// Info button color

  String get infoButtonColor {
    if (!_infoButtonColorSet &&
        _apiMapResponse.containsKey('info_button_color')) {
      _infoButtonColor = _apiMapResponse['info_button_color']?.toString();
      _infoButtonColorSet = true;
    }
    return _infoButtonColor;
  }

  set infoButtonColor(String v) {
    _infoButtonColor = v;
    _infoButtonColorSet = true;
  }

  /// Primary button color

  String get primaryButtonColor {
    if (!_primaryButtonColorSet &&
        _apiMapResponse.containsKey('primary_button_color')) {
      _primaryButtonColor = _apiMapResponse['primary_button_color']?.toString();
      _primaryButtonColorSet = true;
    }
    return _primaryButtonColor;
  }

  set primaryButtonColor(String v) {
    _primaryButtonColor = v;
    _primaryButtonColorSet = true;
  }

  /// Toggle to show filters. Defaults to true.

  bool get showFiltersBar {
    if (!_showFiltersBarSet &&
        _apiMapResponse.containsKey('show_filters_bar')) {
      _showFiltersBar = _apiMapResponse['show_filters_bar'];
      _showFiltersBarSet = true;
    }
    return _showFiltersBar;
  }

  set showFiltersBar(bool v) {
    _showFiltersBar = v;
    _showFiltersBarSet = true;
  }

  /// Toggle to show the title. Defaults to true.

  bool get showTitle {
    if (!_showTitleSet && _apiMapResponse.containsKey('show_title')) {
      _showTitle = _apiMapResponse['show_title'];
      _showTitleSet = true;
    }
    return _showTitle;
  }

  set showTitle(bool v) {
    _showTitle = v;
    _showTitleSet = true;
  }

  /// Text color for text tiles

  String get textTileTextColor {
    if (!_textTileTextColorSet &&
        _apiMapResponse.containsKey('text_tile_text_color')) {
      _textTileTextColor = _apiMapResponse['text_tile_text_color']?.toString();
      _textTileTextColorSet = true;
    }
    return _textTileTextColor;
  }

  set textTileTextColor(String v) {
    _textTileTextColor = v;
    _textTileTextColorSet = true;
  }

  /// Background color for tiles

  String get tileBackgroundColor {
    if (!_tileBackgroundColorSet &&
        _apiMapResponse.containsKey('tile_background_color')) {
      _tileBackgroundColor =
          _apiMapResponse['tile_background_color']?.toString();
      _tileBackgroundColorSet = true;
    }
    return _tileBackgroundColor;
  }

  set tileBackgroundColor(String v) {
    _tileBackgroundColor = v;
    _tileBackgroundColorSet = true;
  }

  /// Text color for tiles

  String get tileTextColor {
    if (!_tileTextColorSet && _apiMapResponse.containsKey('tile_text_color')) {
      _tileTextColor = _apiMapResponse['tile_text_color']?.toString();
      _tileTextColorSet = true;
    }
    return _tileTextColor;
  }

  set tileTextColor(String v) {
    _tileTextColor = v;
    _tileTextColorSet = true;
  }

  /// Color for titles

  String get titleColor {
    if (!_titleColorSet && _apiMapResponse.containsKey('title_color')) {
      _titleColor = _apiMapResponse['title_color']?.toString();
      _titleColorSet = true;
    }
    return _titleColor;
  }

  set titleColor(String v) {
    _titleColor = v;
    _titleColorSet = true;
  }

  /// Warning button color

  String get warnButtonColor {
    if (!_warnButtonColorSet &&
        _apiMapResponse.containsKey('warn_button_color')) {
      _warnButtonColor = _apiMapResponse['warn_button_color']?.toString();
      _warnButtonColorSet = true;
    }
    return _warnButtonColor;
  }

  set warnButtonColor(String v) {
    _warnButtonColor = v;
    _warnButtonColorSet = true;
  }

  /// The text alignment of tile titles (New Dashboards)

  String get tileTitleAlignment {
    if (!_tileTitleAlignmentSet &&
        _apiMapResponse.containsKey('tile_title_alignment')) {
      _tileTitleAlignment = _apiMapResponse['tile_title_alignment']?.toString();
      _tileTitleAlignmentSet = true;
    }
    return _tileTitleAlignment;
  }

  set tileTitleAlignment(String v) {
    _tileTitleAlignment = v;
    _tileTitleAlignmentSet = true;
  }

  /// Toggles the tile shadow (New Dashboards)

  bool get tileShadow {
    if (!_tileShadowSet && _apiMapResponse.containsKey('tile_shadow')) {
      _tileShadow = _apiMapResponse['tile_shadow'];
      _tileShadowSet = true;
    }
    return _tileShadow;
  }

  set tileShadow(bool v) {
    _tileShadow = v;
    _tileShadowSet = true;
  }

  ThemeSettings() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ThemeSettings.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_backgroundColorSet ||
        _apiMapResponse.containsKey('background_color')) {
      json['background_color'] = backgroundColor;
    }
    if (_baseFontSizeSet || _apiMapResponse.containsKey('base_font_size')) {
      json['base_font_size'] = baseFontSize;
    }
    if (_colorCollectionIdSet ||
        _apiMapResponse.containsKey('color_collection_id')) {
      json['color_collection_id'] = colorCollectionId;
    }
    if (_fontColorSet || _apiMapResponse.containsKey('font_color')) {
      json['font_color'] = fontColor;
    }
    if (_fontFamilySet || _apiMapResponse.containsKey('font_family')) {
      json['font_family'] = fontFamily;
    }
    if (_fontSourceSet || _apiMapResponse.containsKey('font_source')) {
      json['font_source'] = fontSource;
    }
    if (_infoButtonColorSet ||
        _apiMapResponse.containsKey('info_button_color')) {
      json['info_button_color'] = infoButtonColor;
    }
    if (_primaryButtonColorSet ||
        _apiMapResponse.containsKey('primary_button_color')) {
      json['primary_button_color'] = primaryButtonColor;
    }
    if (_showFiltersBarSet || _apiMapResponse.containsKey('show_filters_bar')) {
      json['show_filters_bar'] = showFiltersBar;
    }
    if (_showTitleSet || _apiMapResponse.containsKey('show_title')) {
      json['show_title'] = showTitle;
    }
    if (_textTileTextColorSet ||
        _apiMapResponse.containsKey('text_tile_text_color')) {
      json['text_tile_text_color'] = textTileTextColor;
    }
    if (_tileBackgroundColorSet ||
        _apiMapResponse.containsKey('tile_background_color')) {
      json['tile_background_color'] = tileBackgroundColor;
    }
    if (_tileTextColorSet || _apiMapResponse.containsKey('tile_text_color')) {
      json['tile_text_color'] = tileTextColor;
    }
    if (_titleColorSet || _apiMapResponse.containsKey('title_color')) {
      json['title_color'] = titleColor;
    }
    if (_warnButtonColorSet ||
        _apiMapResponse.containsKey('warn_button_color')) {
      json['warn_button_color'] = warnButtonColor;
    }
    if (_tileTitleAlignmentSet ||
        _apiMapResponse.containsKey('tile_title_alignment')) {
      json['tile_title_alignment'] = tileTitleAlignment;
    }
    if (_tileShadowSet || _apiMapResponse.containsKey('tile_shadow')) {
      json['tile_shadow'] = tileShadow;
    }
    return json;
  }
}

class Timezone {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _value;
  bool _valueSet = false;

  String _label;
  bool _labelSet = false;

  String _group;
  bool _groupSet = false;

  /// Timezone (read-only)

  String get value {
    if (!_valueSet && _apiMapResponse.containsKey('value')) {
      _value = _apiMapResponse['value']?.toString();
      _valueSet = true;
    }
    return _value;
  }

  set value(String v) {
    _value = v;
    _valueSet = true;
  }

  /// Description of timezone (read-only)

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// Timezone group (e.g Common, Other, etc.) (read-only)

  String get group {
    if (!_groupSet && _apiMapResponse.containsKey('group')) {
      _group = _apiMapResponse['group']?.toString();
      _groupSet = true;
    }
    return _group;
  }

  set group(String v) {
    _group = v;
    _groupSet = true;
  }

  Timezone() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Timezone.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_valueSet || _apiMapResponse.containsKey('value')) {
      json['value'] = value;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_groupSet || _apiMapResponse.containsKey('group')) {
      json['group'] = group;
    }
    return json;
  }
}

class UpdateCommand {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _description;
  bool _descriptionSet = false;

  /// Name of the command

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Description of the command

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  UpdateCommand() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  UpdateCommand.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    return json;
  }
}

class UpdateFolder {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _parentId;
  bool _parentIdSet = false;

  /// Unique Name

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Id of Parent. If the parent id is null, this is a root-level entry

  String get parentId {
    if (!_parentIdSet && _apiMapResponse.containsKey('parent_id')) {
      _parentId = _apiMapResponse['parent_id']?.toString();
      _parentIdSet = true;
    }
    return _parentId;
  }

  set parentId(String v) {
    _parentId = v;
    _parentIdSet = true;
  }

  UpdateFolder() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  UpdateFolder.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_parentIdSet || _apiMapResponse.containsKey('parent_id')) {
      json['parent_id'] = parentId;
    }
    return json;
  }
}

class User {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _avatarUrl;
  bool _avatarUrlSet = false;

  String _avatarUrlWithoutSizing;
  bool _avatarUrlWithoutSizingSet = false;

  List<CredentialsApi3> _credentialsApi3;
  bool _credentialsApi3Set = false;

  CredentialsEmail _credentialsEmail;
  bool _credentialsEmailSet = false;

  List<CredentialsEmbed> _credentialsEmbed;
  bool _credentialsEmbedSet = false;

  CredentialsGoogle _credentialsGoogle;
  bool _credentialsGoogleSet = false;

  CredentialsLDAP _credentialsLdap;
  bool _credentialsLdapSet = false;

  CredentialsLookerOpenid _credentialsLookerOpenid;
  bool _credentialsLookerOpenidSet = false;

  CredentialsOIDC _credentialsOidc;
  bool _credentialsOidcSet = false;

  CredentialsSaml _credentialsSaml;
  bool _credentialsSamlSet = false;

  CredentialsTotp _credentialsTotp;
  bool _credentialsTotpSet = false;

  String _displayName;
  bool _displayNameSet = false;

  String _email;
  bool _emailSet = false;

  int _embedGroupSpaceId;
  bool _embedGroupSpaceIdSet = false;

  String _firstName;
  bool _firstNameSet = false;

  List<int> _groupIds;
  bool _groupIdsSet = false;

  String _homeFolderId;
  bool _homeFolderIdSet = false;

  int _id;
  bool _idSet = false;

  bool _isDisabled;
  bool _isDisabledSet = false;

  String _lastName;
  bool _lastNameSet = false;

  String _locale;
  bool _localeSet = false;

  List<String> _lookerVersions;
  bool _lookerVersionsSet = false;

  bool _modelsDirValidated;
  bool _modelsDirValidatedSet = false;

  int _personalFolderId;
  bool _personalFolderIdSet = false;

  bool _presumedLookerEmployee;
  bool _presumedLookerEmployeeSet = false;

  List<int> _roleIds;
  bool _roleIdsSet = false;

  List<Session> _sessions;
  bool _sessionsSet = false;

  Map<String, dynamic> _uiState;
  bool _uiStateSet = false;

  bool _verifiedLookerEmployee;
  bool _verifiedLookerEmployeeSet = false;

  bool _rolesExternallyManaged;
  bool _rolesExternallyManagedSet = false;

  bool _allowDirectRoles;
  bool _allowDirectRolesSet = false;

  bool _allowNormalGroupMembership;
  bool _allowNormalGroupMembershipSet = false;

  bool _allowRolesFromNormalGroups;
  bool _allowRolesFromNormalGroupsSet = false;

  String _url;
  bool _urlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// URL for the avatar image (may be generic) (read-only)

  String get avatarUrl {
    if (!_avatarUrlSet && _apiMapResponse.containsKey('avatar_url')) {
      _avatarUrl = _apiMapResponse['avatar_url']?.toString();
      _avatarUrlSet = true;
    }
    return _avatarUrl;
  }

  set avatarUrl(String v) {
    _avatarUrl = v;
    _avatarUrlSet = true;
  }

  /// URL for the avatar image (may be generic), does not specify size (read-only)

  String get avatarUrlWithoutSizing {
    if (!_avatarUrlWithoutSizingSet &&
        _apiMapResponse.containsKey('avatar_url_without_sizing')) {
      _avatarUrlWithoutSizing =
          _apiMapResponse['avatar_url_without_sizing']?.toString();
      _avatarUrlWithoutSizingSet = true;
    }
    return _avatarUrlWithoutSizing;
  }

  set avatarUrlWithoutSizing(String v) {
    _avatarUrlWithoutSizing = v;
    _avatarUrlWithoutSizingSet = true;
  }

  /// API 3 credentials (read-only)

  List<CredentialsApi3> get credentialsApi3 {
    if (!_credentialsApi3Set &&
        _apiMapResponse.containsKey('credentials_api3')) {
      _credentialsApi3 = _apiMapResponse['credentials_api3'] == null
          ? null
          : (_apiMapResponse['credentials_api3'] as List)
              .map((i) =>
                  CredentialsApi3.fromResponse(i, apiResponseContentType))
              .toList();
      _credentialsApi3Set = true;
    }
    return _credentialsApi3;
  }

  set credentialsApi3(List<CredentialsApi3> v) {
    _credentialsApi3 = v;
    _credentialsApi3Set = true;
  }

  CredentialsEmail get credentialsEmail {
    if (!_credentialsEmailSet &&
        _apiMapResponse.containsKey('credentials_email')) {
      _credentialsEmail = _apiMapResponse['credentials_email'] == null
          ? null
          : CredentialsEmail.fromResponse(
              _apiMapResponse['credentials_email'], apiResponseContentType);
      _credentialsEmailSet = true;
    }
    return _credentialsEmail;
  }

  set credentialsEmail(CredentialsEmail v) {
    _credentialsEmail = v;
    _credentialsEmailSet = true;
  }

  /// Embed credentials (read-only)

  List<CredentialsEmbed> get credentialsEmbed {
    if (!_credentialsEmbedSet &&
        _apiMapResponse.containsKey('credentials_embed')) {
      _credentialsEmbed = _apiMapResponse['credentials_embed'] == null
          ? null
          : (_apiMapResponse['credentials_embed'] as List)
              .map((i) =>
                  CredentialsEmbed.fromResponse(i, apiResponseContentType))
              .toList();
      _credentialsEmbedSet = true;
    }
    return _credentialsEmbed;
  }

  set credentialsEmbed(List<CredentialsEmbed> v) {
    _credentialsEmbed = v;
    _credentialsEmbedSet = true;
  }

  CredentialsGoogle get credentialsGoogle {
    if (!_credentialsGoogleSet &&
        _apiMapResponse.containsKey('credentials_google')) {
      _credentialsGoogle = _apiMapResponse['credentials_google'] == null
          ? null
          : CredentialsGoogle.fromResponse(
              _apiMapResponse['credentials_google'], apiResponseContentType);
      _credentialsGoogleSet = true;
    }
    return _credentialsGoogle;
  }

  set credentialsGoogle(CredentialsGoogle v) {
    _credentialsGoogle = v;
    _credentialsGoogleSet = true;
  }

  CredentialsLDAP get credentialsLdap {
    if (!_credentialsLdapSet &&
        _apiMapResponse.containsKey('credentials_ldap')) {
      _credentialsLdap = _apiMapResponse['credentials_ldap'] == null
          ? null
          : CredentialsLDAP.fromResponse(
              _apiMapResponse['credentials_ldap'], apiResponseContentType);
      _credentialsLdapSet = true;
    }
    return _credentialsLdap;
  }

  set credentialsLdap(CredentialsLDAP v) {
    _credentialsLdap = v;
    _credentialsLdapSet = true;
  }

  CredentialsLookerOpenid get credentialsLookerOpenid {
    if (!_credentialsLookerOpenidSet &&
        _apiMapResponse.containsKey('credentials_looker_openid')) {
      _credentialsLookerOpenid =
          _apiMapResponse['credentials_looker_openid'] == null
              ? null
              : CredentialsLookerOpenid.fromResponse(
                  _apiMapResponse['credentials_looker_openid'],
                  apiResponseContentType);
      _credentialsLookerOpenidSet = true;
    }
    return _credentialsLookerOpenid;
  }

  set credentialsLookerOpenid(CredentialsLookerOpenid v) {
    _credentialsLookerOpenid = v;
    _credentialsLookerOpenidSet = true;
  }

  CredentialsOIDC get credentialsOidc {
    if (!_credentialsOidcSet &&
        _apiMapResponse.containsKey('credentials_oidc')) {
      _credentialsOidc = _apiMapResponse['credentials_oidc'] == null
          ? null
          : CredentialsOIDC.fromResponse(
              _apiMapResponse['credentials_oidc'], apiResponseContentType);
      _credentialsOidcSet = true;
    }
    return _credentialsOidc;
  }

  set credentialsOidc(CredentialsOIDC v) {
    _credentialsOidc = v;
    _credentialsOidcSet = true;
  }

  CredentialsSaml get credentialsSaml {
    if (!_credentialsSamlSet &&
        _apiMapResponse.containsKey('credentials_saml')) {
      _credentialsSaml = _apiMapResponse['credentials_saml'] == null
          ? null
          : CredentialsSaml.fromResponse(
              _apiMapResponse['credentials_saml'], apiResponseContentType);
      _credentialsSamlSet = true;
    }
    return _credentialsSaml;
  }

  set credentialsSaml(CredentialsSaml v) {
    _credentialsSaml = v;
    _credentialsSamlSet = true;
  }

  CredentialsTotp get credentialsTotp {
    if (!_credentialsTotpSet &&
        _apiMapResponse.containsKey('credentials_totp')) {
      _credentialsTotp = _apiMapResponse['credentials_totp'] == null
          ? null
          : CredentialsTotp.fromResponse(
              _apiMapResponse['credentials_totp'], apiResponseContentType);
      _credentialsTotpSet = true;
    }
    return _credentialsTotp;
  }

  set credentialsTotp(CredentialsTotp v) {
    _credentialsTotp = v;
    _credentialsTotpSet = true;
  }

  /// Full name for display (available only if both first_name and last_name are set) (read-only)

  String get displayName {
    if (!_displayNameSet && _apiMapResponse.containsKey('display_name')) {
      _displayName = _apiMapResponse['display_name']?.toString();
      _displayNameSet = true;
    }
    return _displayName;
  }

  set displayName(String v) {
    _displayName = v;
    _displayNameSet = true;
  }

  /// EMail address (read-only)

  String get email {
    if (!_emailSet && _apiMapResponse.containsKey('email')) {
      _email = _apiMapResponse['email']?.toString();
      _emailSet = true;
    }
    return _email;
  }

  set email(String v) {
    _email = v;
    _emailSet = true;
  }

  /// (Embed only) ID of user's group space based on the external_group_id optionally specified during embed user login (read-only)

  int get embedGroupSpaceId {
    if (!_embedGroupSpaceIdSet &&
        _apiMapResponse.containsKey('embed_group_space_id')) {
      _embedGroupSpaceId = _apiMapResponse['embed_group_space_id'];
      _embedGroupSpaceIdSet = true;
    }
    return _embedGroupSpaceId;
  }

  set embedGroupSpaceId(int v) {
    _embedGroupSpaceId = v;
    _embedGroupSpaceIdSet = true;
  }

  /// First name

  String get firstName {
    if (!_firstNameSet && _apiMapResponse.containsKey('first_name')) {
      _firstName = _apiMapResponse['first_name']?.toString();
      _firstNameSet = true;
    }
    return _firstName;
  }

  set firstName(String v) {
    _firstName = v;
    _firstNameSet = true;
  }

  /// Array of ids of the groups for this user (read-only)

  List<int> get groupIds {
    if (!_groupIdsSet && _apiMapResponse.containsKey('group_ids')) {
      _groupIds =
          _apiMapResponse['group_ids']?.map<int>((i) => i as int)?.toList();
      _groupIdsSet = true;
    }
    return _groupIds;
  }

  set groupIds(List<int> v) {
    _groupIds = v;
    _groupIdsSet = true;
  }

  /// ID string for user's home folder

  String get homeFolderId {
    if (!_homeFolderIdSet && _apiMapResponse.containsKey('home_folder_id')) {
      _homeFolderId = _apiMapResponse['home_folder_id']?.toString();
      _homeFolderIdSet = true;
    }
    return _homeFolderId;
  }

  set homeFolderId(String v) {
    _homeFolderId = v;
    _homeFolderIdSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Account has been disabled

  bool get isDisabled {
    if (!_isDisabledSet && _apiMapResponse.containsKey('is_disabled')) {
      _isDisabled = _apiMapResponse['is_disabled'];
      _isDisabledSet = true;
    }
    return _isDisabled;
  }

  set isDisabled(bool v) {
    _isDisabled = v;
    _isDisabledSet = true;
  }

  /// Last name

  String get lastName {
    if (!_lastNameSet && _apiMapResponse.containsKey('last_name')) {
      _lastName = _apiMapResponse['last_name']?.toString();
      _lastNameSet = true;
    }
    return _lastName;
  }

  set lastName(String v) {
    _lastName = v;
    _lastNameSet = true;
  }

  /// User's preferred locale. User locale takes precedence over Looker's system-wide default locale. Locale determines language of display strings and date and numeric formatting in API responses. Locale string must be a 2 letter language code or a combination of language code and region code: 'en' or 'en-US', for example.

  String get locale {
    if (!_localeSet && _apiMapResponse.containsKey('locale')) {
      _locale = _apiMapResponse['locale']?.toString();
      _localeSet = true;
    }
    return _locale;
  }

  set locale(String v) {
    _locale = v;
    _localeSet = true;
  }

  /// Array of strings representing the Looker versions that this user has used (this only goes back as far as '3.54.0') (read-only)

  List<String> get lookerVersions {
    if (!_lookerVersionsSet && _apiMapResponse.containsKey('looker_versions')) {
      _lookerVersions = _apiMapResponse['looker_versions']
          ?.map<String>((i) => i as String)
          ?.toList();
      _lookerVersionsSet = true;
    }
    return _lookerVersions;
  }

  set lookerVersions(List<String> v) {
    _lookerVersions = v;
    _lookerVersionsSet = true;
  }

  /// User's dev workspace has been checked for presence of applicable production projects

  bool get modelsDirValidated {
    if (!_modelsDirValidatedSet &&
        _apiMapResponse.containsKey('models_dir_validated')) {
      _modelsDirValidated = _apiMapResponse['models_dir_validated'];
      _modelsDirValidatedSet = true;
    }
    return _modelsDirValidated;
  }

  set modelsDirValidated(bool v) {
    _modelsDirValidated = v;
    _modelsDirValidatedSet = true;
  }

  /// ID of user's personal folder (read-only)

  int get personalFolderId {
    if (!_personalFolderIdSet &&
        _apiMapResponse.containsKey('personal_folder_id')) {
      _personalFolderId = _apiMapResponse['personal_folder_id'];
      _personalFolderIdSet = true;
    }
    return _personalFolderId;
  }

  set personalFolderId(int v) {
    _personalFolderId = v;
    _personalFolderIdSet = true;
  }

  /// User is identified as an employee of Looker (read-only)

  bool get presumedLookerEmployee {
    if (!_presumedLookerEmployeeSet &&
        _apiMapResponse.containsKey('presumed_looker_employee')) {
      _presumedLookerEmployee = _apiMapResponse['presumed_looker_employee'];
      _presumedLookerEmployeeSet = true;
    }
    return _presumedLookerEmployee;
  }

  set presumedLookerEmployee(bool v) {
    _presumedLookerEmployee = v;
    _presumedLookerEmployeeSet = true;
  }

  /// Array of ids of the roles for this user (read-only)

  List<int> get roleIds {
    if (!_roleIdsSet && _apiMapResponse.containsKey('role_ids')) {
      _roleIds =
          _apiMapResponse['role_ids']?.map<int>((i) => i as int)?.toList();
      _roleIdsSet = true;
    }
    return _roleIds;
  }

  set roleIds(List<int> v) {
    _roleIds = v;
    _roleIdsSet = true;
  }

  /// Active sessions (read-only)

  List<Session> get sessions {
    if (!_sessionsSet && _apiMapResponse.containsKey('sessions')) {
      _sessions = _apiMapResponse['sessions'] == null
          ? null
          : (_apiMapResponse['sessions'] as List)
              .map((i) => Session.fromResponse(i, apiResponseContentType))
              .toList();
      _sessionsSet = true;
    }
    return _sessions;
  }

  set sessions(List<Session> v) {
    _sessions = v;
    _sessionsSet = true;
  }

  /// Per user dictionary of undocumented state information owned by the Looker UI.

  Map<String, dynamic> get uiState {
    if (!_uiStateSet && _apiMapResponse.containsKey('ui_state')) {
      _uiState = _apiMapResponse['ui_state'];
      _uiStateSet = true;
    }
    return _uiState;
  }

  set uiState(Map<String, dynamic> v) {
    _uiState = v;
    _uiStateSet = true;
  }

  /// User is identified as an employee of Looker who has been verified via Looker corporate authentication (read-only)

  bool get verifiedLookerEmployee {
    if (!_verifiedLookerEmployeeSet &&
        _apiMapResponse.containsKey('verified_looker_employee')) {
      _verifiedLookerEmployee = _apiMapResponse['verified_looker_employee'];
      _verifiedLookerEmployeeSet = true;
    }
    return _verifiedLookerEmployee;
  }

  set verifiedLookerEmployee(bool v) {
    _verifiedLookerEmployee = v;
    _verifiedLookerEmployeeSet = true;
  }

  /// User's roles are managed by an external directory like SAML or LDAP and can not be changed directly. (read-only)

  bool get rolesExternallyManaged {
    if (!_rolesExternallyManagedSet &&
        _apiMapResponse.containsKey('roles_externally_managed')) {
      _rolesExternallyManaged = _apiMapResponse['roles_externally_managed'];
      _rolesExternallyManagedSet = true;
    }
    return _rolesExternallyManaged;
  }

  set rolesExternallyManaged(bool v) {
    _rolesExternallyManaged = v;
    _rolesExternallyManagedSet = true;
  }

  /// User can be directly assigned a role. (read-only)

  bool get allowDirectRoles {
    if (!_allowDirectRolesSet &&
        _apiMapResponse.containsKey('allow_direct_roles')) {
      _allowDirectRoles = _apiMapResponse['allow_direct_roles'];
      _allowDirectRolesSet = true;
    }
    return _allowDirectRoles;
  }

  set allowDirectRoles(bool v) {
    _allowDirectRoles = v;
    _allowDirectRolesSet = true;
  }

  /// User can be a direct member of a normal Looker group. (read-only)

  bool get allowNormalGroupMembership {
    if (!_allowNormalGroupMembershipSet &&
        _apiMapResponse.containsKey('allow_normal_group_membership')) {
      _allowNormalGroupMembership =
          _apiMapResponse['allow_normal_group_membership'];
      _allowNormalGroupMembershipSet = true;
    }
    return _allowNormalGroupMembership;
  }

  set allowNormalGroupMembership(bool v) {
    _allowNormalGroupMembership = v;
    _allowNormalGroupMembershipSet = true;
  }

  /// User can inherit roles from a normal Looker group. (read-only)

  bool get allowRolesFromNormalGroups {
    if (!_allowRolesFromNormalGroupsSet &&
        _apiMapResponse.containsKey('allow_roles_from_normal_groups')) {
      _allowRolesFromNormalGroups =
          _apiMapResponse['allow_roles_from_normal_groups'];
      _allowRolesFromNormalGroupsSet = true;
    }
    return _allowRolesFromNormalGroups;
  }

  set allowRolesFromNormalGroups(bool v) {
    _allowRolesFromNormalGroups = v;
    _allowRolesFromNormalGroupsSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  User() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  User.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_avatarUrlSet || _apiMapResponse.containsKey('avatar_url')) {
      json['avatar_url'] = avatarUrl;
    }
    if (_avatarUrlWithoutSizingSet ||
        _apiMapResponse.containsKey('avatar_url_without_sizing')) {
      json['avatar_url_without_sizing'] = avatarUrlWithoutSizing;
    }
    if (_credentialsApi3Set ||
        _apiMapResponse.containsKey('credentials_api3')) {
      json['credentials_api3'] =
          credentialsApi3?.map((i) => i.toJson())?.toList();
    }
    if (_credentialsEmailSet ||
        _apiMapResponse.containsKey('credentials_email')) {
      json['credentials_email'] = credentialsEmail?.toJson();
    }
    if (_credentialsEmbedSet ||
        _apiMapResponse.containsKey('credentials_embed')) {
      json['credentials_embed'] =
          credentialsEmbed?.map((i) => i.toJson())?.toList();
    }
    if (_credentialsGoogleSet ||
        _apiMapResponse.containsKey('credentials_google')) {
      json['credentials_google'] = credentialsGoogle?.toJson();
    }
    if (_credentialsLdapSet ||
        _apiMapResponse.containsKey('credentials_ldap')) {
      json['credentials_ldap'] = credentialsLdap?.toJson();
    }
    if (_credentialsLookerOpenidSet ||
        _apiMapResponse.containsKey('credentials_looker_openid')) {
      json['credentials_looker_openid'] = credentialsLookerOpenid?.toJson();
    }
    if (_credentialsOidcSet ||
        _apiMapResponse.containsKey('credentials_oidc')) {
      json['credentials_oidc'] = credentialsOidc?.toJson();
    }
    if (_credentialsSamlSet ||
        _apiMapResponse.containsKey('credentials_saml')) {
      json['credentials_saml'] = credentialsSaml?.toJson();
    }
    if (_credentialsTotpSet ||
        _apiMapResponse.containsKey('credentials_totp')) {
      json['credentials_totp'] = credentialsTotp?.toJson();
    }
    if (_displayNameSet || _apiMapResponse.containsKey('display_name')) {
      json['display_name'] = displayName;
    }
    if (_emailSet || _apiMapResponse.containsKey('email')) {
      json['email'] = email;
    }
    if (_embedGroupSpaceIdSet ||
        _apiMapResponse.containsKey('embed_group_space_id')) {
      json['embed_group_space_id'] = embedGroupSpaceId;
    }
    if (_firstNameSet || _apiMapResponse.containsKey('first_name')) {
      json['first_name'] = firstName;
    }
    if (_groupIdsSet || _apiMapResponse.containsKey('group_ids')) {
      json['group_ids'] = groupIds;
    }
    if (_homeFolderIdSet || _apiMapResponse.containsKey('home_folder_id')) {
      json['home_folder_id'] = homeFolderId;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_isDisabledSet || _apiMapResponse.containsKey('is_disabled')) {
      json['is_disabled'] = isDisabled;
    }
    if (_lastNameSet || _apiMapResponse.containsKey('last_name')) {
      json['last_name'] = lastName;
    }
    if (_localeSet || _apiMapResponse.containsKey('locale')) {
      json['locale'] = locale;
    }
    if (_lookerVersionsSet || _apiMapResponse.containsKey('looker_versions')) {
      json['looker_versions'] = lookerVersions;
    }
    if (_modelsDirValidatedSet ||
        _apiMapResponse.containsKey('models_dir_validated')) {
      json['models_dir_validated'] = modelsDirValidated;
    }
    if (_personalFolderIdSet ||
        _apiMapResponse.containsKey('personal_folder_id')) {
      json['personal_folder_id'] = personalFolderId;
    }
    if (_presumedLookerEmployeeSet ||
        _apiMapResponse.containsKey('presumed_looker_employee')) {
      json['presumed_looker_employee'] = presumedLookerEmployee;
    }
    if (_roleIdsSet || _apiMapResponse.containsKey('role_ids')) {
      json['role_ids'] = roleIds;
    }
    if (_sessionsSet || _apiMapResponse.containsKey('sessions')) {
      json['sessions'] = sessions?.map((i) => i.toJson())?.toList();
    }
    if (_uiStateSet || _apiMapResponse.containsKey('ui_state')) {
      json['ui_state'] = uiState;
    }
    if (_verifiedLookerEmployeeSet ||
        _apiMapResponse.containsKey('verified_looker_employee')) {
      json['verified_looker_employee'] = verifiedLookerEmployee;
    }
    if (_rolesExternallyManagedSet ||
        _apiMapResponse.containsKey('roles_externally_managed')) {
      json['roles_externally_managed'] = rolesExternallyManaged;
    }
    if (_allowDirectRolesSet ||
        _apiMapResponse.containsKey('allow_direct_roles')) {
      json['allow_direct_roles'] = allowDirectRoles;
    }
    if (_allowNormalGroupMembershipSet ||
        _apiMapResponse.containsKey('allow_normal_group_membership')) {
      json['allow_normal_group_membership'] = allowNormalGroupMembership;
    }
    if (_allowRolesFromNormalGroupsSet ||
        _apiMapResponse.containsKey('allow_roles_from_normal_groups')) {
      json['allow_roles_from_normal_groups'] = allowRolesFromNormalGroups;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class UserAttribute {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _id;
  bool _idSet = false;

  String _name;
  bool _nameSet = false;

  String _label;
  bool _labelSet = false;

  String _type;
  bool _typeSet = false;

  String _defaultValue;
  bool _defaultValueSet = false;

  bool _isSystem;
  bool _isSystemSet = false;

  bool _isPermanent;
  bool _isPermanentSet = false;

  bool _valueIsHidden;
  bool _valueIsHiddenSet = false;

  bool _userCanView;
  bool _userCanViewSet = false;

  bool _userCanEdit;
  bool _userCanEditSet = false;

  String _hiddenValueDomainWhitelist;
  bool _hiddenValueDomainWhitelistSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Name of user attribute

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Human-friendly label for user attribute

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// Type of user attribute ("string", "number", "datetime", "yesno", "zipcode")

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Default value for when no value is set on the user

  String get defaultValue {
    if (!_defaultValueSet && _apiMapResponse.containsKey('default_value')) {
      _defaultValue = _apiMapResponse['default_value']?.toString();
      _defaultValueSet = true;
    }
    return _defaultValue;
  }

  set defaultValue(String v) {
    _defaultValue = v;
    _defaultValueSet = true;
  }

  /// Attribute is a system default (read-only)

  bool get isSystem {
    if (!_isSystemSet && _apiMapResponse.containsKey('is_system')) {
      _isSystem = _apiMapResponse['is_system'];
      _isSystemSet = true;
    }
    return _isSystem;
  }

  set isSystem(bool v) {
    _isSystem = v;
    _isSystemSet = true;
  }

  /// Attribute is permanent and cannot be deleted (read-only)

  bool get isPermanent {
    if (!_isPermanentSet && _apiMapResponse.containsKey('is_permanent')) {
      _isPermanent = _apiMapResponse['is_permanent'];
      _isPermanentSet = true;
    }
    return _isPermanent;
  }

  set isPermanent(bool v) {
    _isPermanent = v;
    _isPermanentSet = true;
  }

  /// If true, users will not be able to view values of this attribute

  bool get valueIsHidden {
    if (!_valueIsHiddenSet && _apiMapResponse.containsKey('value_is_hidden')) {
      _valueIsHidden = _apiMapResponse['value_is_hidden'];
      _valueIsHiddenSet = true;
    }
    return _valueIsHidden;
  }

  set valueIsHidden(bool v) {
    _valueIsHidden = v;
    _valueIsHiddenSet = true;
  }

  /// Non-admin users can see the values of their attributes and use them in filters

  bool get userCanView {
    if (!_userCanViewSet && _apiMapResponse.containsKey('user_can_view')) {
      _userCanView = _apiMapResponse['user_can_view'];
      _userCanViewSet = true;
    }
    return _userCanView;
  }

  set userCanView(bool v) {
    _userCanView = v;
    _userCanViewSet = true;
  }

  /// Users can change the value of this attribute for themselves

  bool get userCanEdit {
    if (!_userCanEditSet && _apiMapResponse.containsKey('user_can_edit')) {
      _userCanEdit = _apiMapResponse['user_can_edit'];
      _userCanEditSet = true;
    }
    return _userCanEdit;
  }

  set userCanEdit(bool v) {
    _userCanEdit = v;
    _userCanEditSet = true;
  }

  /// Destinations to which a hidden attribute may be sent. Once set, cannot be edited.

  String get hiddenValueDomainWhitelist {
    if (!_hiddenValueDomainWhitelistSet &&
        _apiMapResponse.containsKey('hidden_value_domain_whitelist')) {
      _hiddenValueDomainWhitelist =
          _apiMapResponse['hidden_value_domain_whitelist']?.toString();
      _hiddenValueDomainWhitelistSet = true;
    }
    return _hiddenValueDomainWhitelist;
  }

  set hiddenValueDomainWhitelist(String v) {
    _hiddenValueDomainWhitelist = v;
    _hiddenValueDomainWhitelistSet = true;
  }

  UserAttribute() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  UserAttribute.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_defaultValueSet || _apiMapResponse.containsKey('default_value')) {
      json['default_value'] = defaultValue;
    }
    if (_isSystemSet || _apiMapResponse.containsKey('is_system')) {
      json['is_system'] = isSystem;
    }
    if (_isPermanentSet || _apiMapResponse.containsKey('is_permanent')) {
      json['is_permanent'] = isPermanent;
    }
    if (_valueIsHiddenSet || _apiMapResponse.containsKey('value_is_hidden')) {
      json['value_is_hidden'] = valueIsHidden;
    }
    if (_userCanViewSet || _apiMapResponse.containsKey('user_can_view')) {
      json['user_can_view'] = userCanView;
    }
    if (_userCanEditSet || _apiMapResponse.containsKey('user_can_edit')) {
      json['user_can_edit'] = userCanEdit;
    }
    if (_hiddenValueDomainWhitelistSet ||
        _apiMapResponse.containsKey('hidden_value_domain_whitelist')) {
      json['hidden_value_domain_whitelist'] = hiddenValueDomainWhitelist;
    }
    return json;
  }
}

/// An array of user attribute types that are allowed to be used in filters on this field. Valid values are: "advanced_filter_string", "advanced_filter_number", "advanced_filter_datetime", "string", "number", "datetime", "relative_url", "yesno", "zipcode". (Enum defined in LookmlModelExploreField)
enum UserAttributeFilterTypes {
  advancedFilterString,
  advancedFilterNumber,
  advancedFilterDatetime,
  string,
  number,
  datetime,
  relativeUrl,
  yesno,
  zipcode
}

class UserAttributeFilterTypesMapper {
  static String toStringValue(UserAttributeFilterTypes e) {
    switch (e) {
      case UserAttributeFilterTypes.advancedFilterString:
        return 'advanced_filter_string';
      case UserAttributeFilterTypes.advancedFilterNumber:
        return 'advanced_filter_number';
      case UserAttributeFilterTypes.advancedFilterDatetime:
        return 'advanced_filter_datetime';
      case UserAttributeFilterTypes.string:
        return 'string';
      case UserAttributeFilterTypes.number:
        return 'number';
      case UserAttributeFilterTypes.datetime:
        return 'datetime';
      case UserAttributeFilterTypes.relativeUrl:
        return 'relative_url';
      case UserAttributeFilterTypes.yesno:
        return 'yesno';
      case UserAttributeFilterTypes.zipcode:
        return 'zipcode';

      default:
        return null;
    }
  }

  static UserAttributeFilterTypes fromStringValue(String s) {
    if (s == 'advanced_filter_string') {
      return UserAttributeFilterTypes.advancedFilterString;
    }
    if (s == 'advanced_filter_number') {
      return UserAttributeFilterTypes.advancedFilterNumber;
    }
    if (s == 'advanced_filter_datetime') {
      return UserAttributeFilterTypes.advancedFilterDatetime;
    }
    if (s == 'string') {
      return UserAttributeFilterTypes.string;
    }
    if (s == 'number') {
      return UserAttributeFilterTypes.number;
    }
    if (s == 'datetime') {
      return UserAttributeFilterTypes.datetime;
    }
    if (s == 'relative_url') {
      return UserAttributeFilterTypes.relativeUrl;
    }
    if (s == 'yesno') {
      return UserAttributeFilterTypes.yesno;
    }
    if (s == 'zipcode') {
      return UserAttributeFilterTypes.zipcode;
    }
    return null;
  }
}

/// WARNING: no writeable properties found for POST, PUT, or PATCH
class UserAttributeGroupValue {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _id;
  bool _idSet = false;

  int _groupId;
  bool _groupIdSet = false;

  int _userAttributeId;
  bool _userAttributeIdSet = false;

  bool _valueIsHidden;
  bool _valueIsHiddenSet = false;

  int _rank;
  bool _rankSet = false;

  String _value;
  bool _valueSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Unique Id of this group-attribute relation (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Id of group (read-only)

  int get groupId {
    if (!_groupIdSet && _apiMapResponse.containsKey('group_id')) {
      _groupId = _apiMapResponse['group_id'];
      _groupIdSet = true;
    }
    return _groupId;
  }

  set groupId(int v) {
    _groupId = v;
    _groupIdSet = true;
  }

  /// Id of user attribute (read-only)

  int get userAttributeId {
    if (!_userAttributeIdSet &&
        _apiMapResponse.containsKey('user_attribute_id')) {
      _userAttributeId = _apiMapResponse['user_attribute_id'];
      _userAttributeIdSet = true;
    }
    return _userAttributeId;
  }

  set userAttributeId(int v) {
    _userAttributeId = v;
    _userAttributeIdSet = true;
  }

  /// If true, the "value" field will be null, because the attribute settings block access to this value (read-only)

  bool get valueIsHidden {
    if (!_valueIsHiddenSet && _apiMapResponse.containsKey('value_is_hidden')) {
      _valueIsHidden = _apiMapResponse['value_is_hidden'];
      _valueIsHiddenSet = true;
    }
    return _valueIsHidden;
  }

  set valueIsHidden(bool v) {
    _valueIsHidden = v;
    _valueIsHiddenSet = true;
  }

  /// Precedence for resolving value for user (read-only)

  int get rank {
    if (!_rankSet && _apiMapResponse.containsKey('rank')) {
      _rank = _apiMapResponse['rank'];
      _rankSet = true;
    }
    return _rank;
  }

  set rank(int v) {
    _rank = v;
    _rankSet = true;
  }

  /// Value of user attribute for group (read-only)

  String get value {
    if (!_valueSet && _apiMapResponse.containsKey('value')) {
      _value = _apiMapResponse['value']?.toString();
      _valueSet = true;
    }
    return _value;
  }

  set value(String v) {
    _value = v;
    _valueSet = true;
  }

  UserAttributeGroupValue() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  UserAttributeGroupValue.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_groupIdSet || _apiMapResponse.containsKey('group_id')) {
      json['group_id'] = groupId;
    }
    if (_userAttributeIdSet ||
        _apiMapResponse.containsKey('user_attribute_id')) {
      json['user_attribute_id'] = userAttributeId;
    }
    if (_valueIsHiddenSet || _apiMapResponse.containsKey('value_is_hidden')) {
      json['value_is_hidden'] = valueIsHidden;
    }
    if (_rankSet || _apiMapResponse.containsKey('rank')) {
      json['rank'] = rank;
    }
    if (_valueSet || _apiMapResponse.containsKey('value')) {
      json['value'] = value;
    }
    return json;
  }
}

class UserAttributeWithValue {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _name;
  bool _nameSet = false;

  String _label;
  bool _labelSet = false;

  int _rank;
  bool _rankSet = false;

  String _value;
  bool _valueSet = false;

  int _userId;
  bool _userIdSet = false;

  bool _userCanEdit;
  bool _userCanEditSet = false;

  bool _valueIsHidden;
  bool _valueIsHiddenSet = false;

  int _userAttributeId;
  bool _userAttributeIdSet = false;

  String _source;
  bool _sourceSet = false;

  String _hiddenValueDomainWhitelist;
  bool _hiddenValueDomainWhitelistSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Name of user attribute (read-only)

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Human-friendly label for user attribute (read-only)

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// Precedence for setting value on user (lowest wins) (read-only)

  int get rank {
    if (!_rankSet && _apiMapResponse.containsKey('rank')) {
      _rank = _apiMapResponse['rank'];
      _rankSet = true;
    }
    return _rank;
  }

  set rank(int v) {
    _rank = v;
    _rankSet = true;
  }

  /// Value of attribute for user

  String get value {
    if (!_valueSet && _apiMapResponse.containsKey('value')) {
      _value = _apiMapResponse['value']?.toString();
      _valueSet = true;
    }
    return _value;
  }

  set value(String v) {
    _value = v;
    _valueSet = true;
  }

  /// Id of User (read-only)

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  /// Can the user set this value (read-only)

  bool get userCanEdit {
    if (!_userCanEditSet && _apiMapResponse.containsKey('user_can_edit')) {
      _userCanEdit = _apiMapResponse['user_can_edit'];
      _userCanEditSet = true;
    }
    return _userCanEdit;
  }

  set userCanEdit(bool v) {
    _userCanEdit = v;
    _userCanEditSet = true;
  }

  /// If true, the "value" field will be null, because the attribute settings block access to this value (read-only)

  bool get valueIsHidden {
    if (!_valueIsHiddenSet && _apiMapResponse.containsKey('value_is_hidden')) {
      _valueIsHidden = _apiMapResponse['value_is_hidden'];
      _valueIsHiddenSet = true;
    }
    return _valueIsHidden;
  }

  set valueIsHidden(bool v) {
    _valueIsHidden = v;
    _valueIsHiddenSet = true;
  }

  /// Id of User Attribute (read-only)

  int get userAttributeId {
    if (!_userAttributeIdSet &&
        _apiMapResponse.containsKey('user_attribute_id')) {
      _userAttributeId = _apiMapResponse['user_attribute_id'];
      _userAttributeIdSet = true;
    }
    return _userAttributeId;
  }

  set userAttributeId(int v) {
    _userAttributeId = v;
    _userAttributeIdSet = true;
  }

  /// How user got this value for this attribute (read-only)

  String get source {
    if (!_sourceSet && _apiMapResponse.containsKey('source')) {
      _source = _apiMapResponse['source']?.toString();
      _sourceSet = true;
    }
    return _source;
  }

  set source(String v) {
    _source = v;
    _sourceSet = true;
  }

  /// If this user attribute is hidden, whitelist of destinations to which it may be sent. (read-only)

  String get hiddenValueDomainWhitelist {
    if (!_hiddenValueDomainWhitelistSet &&
        _apiMapResponse.containsKey('hidden_value_domain_whitelist')) {
      _hiddenValueDomainWhitelist =
          _apiMapResponse['hidden_value_domain_whitelist']?.toString();
      _hiddenValueDomainWhitelistSet = true;
    }
    return _hiddenValueDomainWhitelist;
  }

  set hiddenValueDomainWhitelist(String v) {
    _hiddenValueDomainWhitelist = v;
    _hiddenValueDomainWhitelistSet = true;
  }

  UserAttributeWithValue() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  UserAttributeWithValue.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_rankSet || _apiMapResponse.containsKey('rank')) {
      json['rank'] = rank;
    }
    if (_valueSet || _apiMapResponse.containsKey('value')) {
      json['value'] = value;
    }
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    if (_userCanEditSet || _apiMapResponse.containsKey('user_can_edit')) {
      json['user_can_edit'] = userCanEdit;
    }
    if (_valueIsHiddenSet || _apiMapResponse.containsKey('value_is_hidden')) {
      json['value_is_hidden'] = valueIsHidden;
    }
    if (_userAttributeIdSet ||
        _apiMapResponse.containsKey('user_attribute_id')) {
      json['user_attribute_id'] = userAttributeId;
    }
    if (_sourceSet || _apiMapResponse.containsKey('source')) {
      json['source'] = source;
    }
    if (_hiddenValueDomainWhitelistSet ||
        _apiMapResponse.containsKey('hidden_value_domain_whitelist')) {
      json['hidden_value_domain_whitelist'] = hiddenValueDomainWhitelist;
    }
    return json;
  }
}

class UserEmailOnly {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _email;
  bool _emailSet = false;

  /// Email Address

  String get email {
    if (!_emailSet && _apiMapResponse.containsKey('email')) {
      _email = _apiMapResponse['email']?.toString();
      _emailSet = true;
    }
    return _email;
  }

  set email(String v) {
    _email = v;
    _emailSet = true;
  }

  UserEmailOnly() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  UserEmailOnly.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_emailSet || _apiMapResponse.containsKey('email')) {
      json['email'] = email;
    }
    return json;
  }
}

class UserLoginLockout {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _key;
  bool _keySet = false;

  String _authType;
  bool _authTypeSet = false;

  String _ip;
  bool _ipSet = false;

  int _userId;
  bool _userIdSet = false;

  String _remoteId;
  bool _remoteIdSet = false;

  String _fullName;
  bool _fullNameSet = false;

  String _email;
  bool _emailSet = false;

  int _failCount;
  bool _failCountSet = false;

  DateTime _lockoutAt;
  bool _lockoutAtSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Hash of user's client id (read-only)

  String get key {
    if (!_keySet && _apiMapResponse.containsKey('key')) {
      _key = _apiMapResponse['key']?.toString();
      _keySet = true;
    }
    return _key;
  }

  set key(String v) {
    _key = v;
    _keySet = true;
  }

  /// Authentication method for login failures (read-only)

  String get authType {
    if (!_authTypeSet && _apiMapResponse.containsKey('auth_type')) {
      _authType = _apiMapResponse['auth_type']?.toString();
      _authTypeSet = true;
    }
    return _authType;
  }

  set authType(String v) {
    _authType = v;
    _authTypeSet = true;
  }

  /// IP address of most recent failed attempt (read-only)

  String get ip {
    if (!_ipSet && _apiMapResponse.containsKey('ip')) {
      _ip = _apiMapResponse['ip']?.toString();
      _ipSet = true;
    }
    return _ip;
  }

  set ip(String v) {
    _ip = v;
    _ipSet = true;
  }

  /// User ID (read-only)

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  /// Remote ID of user if using LDAP (read-only)

  String get remoteId {
    if (!_remoteIdSet && _apiMapResponse.containsKey('remote_id')) {
      _remoteId = _apiMapResponse['remote_id']?.toString();
      _remoteIdSet = true;
    }
    return _remoteId;
  }

  set remoteId(String v) {
    _remoteId = v;
    _remoteIdSet = true;
  }

  /// User's name (read-only)

  String get fullName {
    if (!_fullNameSet && _apiMapResponse.containsKey('full_name')) {
      _fullName = _apiMapResponse['full_name']?.toString();
      _fullNameSet = true;
    }
    return _fullName;
  }

  set fullName(String v) {
    _fullName = v;
    _fullNameSet = true;
  }

  /// Email address associated with the user's account (read-only)

  String get email {
    if (!_emailSet && _apiMapResponse.containsKey('email')) {
      _email = _apiMapResponse['email']?.toString();
      _emailSet = true;
    }
    return _email;
  }

  set email(String v) {
    _email = v;
    _emailSet = true;
  }

  /// Number of failures that triggered the lockout (read-only)

  int get failCount {
    if (!_failCountSet && _apiMapResponse.containsKey('fail_count')) {
      _failCount = _apiMapResponse['fail_count'];
      _failCountSet = true;
    }
    return _failCount;
  }

  set failCount(int v) {
    _failCount = v;
    _failCountSet = true;
  }

  /// Time when lockout was triggered (read-only)

  DateTime get lockoutAt {
    if (!_lockoutAtSet && _apiMapResponse.containsKey('lockout_at')) {
      _lockoutAt = _apiMapResponse['lockout_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['lockout_at']);
      _lockoutAtSet = true;
    }
    return _lockoutAt;
  }

  set lockoutAt(DateTime v) {
    _lockoutAt = v;
    _lockoutAtSet = true;
  }

  UserLoginLockout() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  UserLoginLockout.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_keySet || _apiMapResponse.containsKey('key')) {
      json['key'] = key;
    }
    if (_authTypeSet || _apiMapResponse.containsKey('auth_type')) {
      json['auth_type'] = authType;
    }
    if (_ipSet || _apiMapResponse.containsKey('ip')) {
      json['ip'] = ip;
    }
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    if (_remoteIdSet || _apiMapResponse.containsKey('remote_id')) {
      json['remote_id'] = remoteId;
    }
    if (_fullNameSet || _apiMapResponse.containsKey('full_name')) {
      json['full_name'] = fullName;
    }
    if (_emailSet || _apiMapResponse.containsKey('email')) {
      json['email'] = email;
    }
    if (_failCountSet || _apiMapResponse.containsKey('fail_count')) {
      json['fail_count'] = failCount;
    }
    if (_lockoutAtSet || _apiMapResponse.containsKey('lockout_at')) {
      json['lockout_at'] = lockoutAt?.toIso8601String();
    }
    return json;
  }
}

class UserPublic {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  int _id;
  bool _idSet = false;

  String _firstName;
  bool _firstNameSet = false;

  String _lastName;
  bool _lastNameSet = false;

  String _displayName;
  bool _displayNameSet = false;

  String _avatarUrl;
  bool _avatarUrlSet = false;

  String _url;
  bool _urlSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// First Name (read-only)

  String get firstName {
    if (!_firstNameSet && _apiMapResponse.containsKey('first_name')) {
      _firstName = _apiMapResponse['first_name']?.toString();
      _firstNameSet = true;
    }
    return _firstName;
  }

  set firstName(String v) {
    _firstName = v;
    _firstNameSet = true;
  }

  /// Last Name (read-only)

  String get lastName {
    if (!_lastNameSet && _apiMapResponse.containsKey('last_name')) {
      _lastName = _apiMapResponse['last_name']?.toString();
      _lastNameSet = true;
    }
    return _lastName;
  }

  set lastName(String v) {
    _lastName = v;
    _lastNameSet = true;
  }

  /// Full name for display (available only if both first_name and last_name are set) (read-only)

  String get displayName {
    if (!_displayNameSet && _apiMapResponse.containsKey('display_name')) {
      _displayName = _apiMapResponse['display_name']?.toString();
      _displayNameSet = true;
    }
    return _displayName;
  }

  set displayName(String v) {
    _displayName = v;
    _displayNameSet = true;
  }

  /// URL for the avatar image (may be generic) (read-only)

  String get avatarUrl {
    if (!_avatarUrlSet && _apiMapResponse.containsKey('avatar_url')) {
      _avatarUrl = _apiMapResponse['avatar_url']?.toString();
      _avatarUrlSet = true;
    }
    return _avatarUrl;
  }

  set avatarUrl(String v) {
    _avatarUrl = v;
    _avatarUrlSet = true;
  }

  /// Link to get this item (read-only)

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  UserPublic() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  UserPublic.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_firstNameSet || _apiMapResponse.containsKey('first_name')) {
      json['first_name'] = firstName;
    }
    if (_lastNameSet || _apiMapResponse.containsKey('last_name')) {
      json['last_name'] = lastName;
    }
    if (_displayNameSet || _apiMapResponse.containsKey('display_name')) {
      json['display_name'] = displayName;
    }
    if (_avatarUrlSet || _apiMapResponse.containsKey('avatar_url')) {
      json['avatar_url'] = avatarUrl;
    }
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    return json;
  }
}

class ValidationError {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _message;
  bool _messageSet = false;

  List<ValidationErrorDetail> _errors;
  bool _errorsSet = false;

  String _documentationUrl;
  bool _documentationUrlSet = false;

  /// Error details (read-only)

  String get message {
    if (!_messageSet && _apiMapResponse.containsKey('message')) {
      _message = _apiMapResponse['message']?.toString();
      _messageSet = true;
    }
    return _message;
  }

  set message(String v) {
    _message = v;
    _messageSet = true;
  }

  /// Error detail array (read-only)

  List<ValidationErrorDetail> get errors {
    if (!_errorsSet && _apiMapResponse.containsKey('errors')) {
      _errors = _apiMapResponse['errors'] == null
          ? null
          : (_apiMapResponse['errors'] as List)
              .map((i) =>
                  ValidationErrorDetail.fromResponse(i, apiResponseContentType))
              .toList();
      _errorsSet = true;
    }
    return _errors;
  }

  set errors(List<ValidationErrorDetail> v) {
    _errors = v;
    _errorsSet = true;
  }

  /// Documentation link (read-only)

  String get documentationUrl {
    if (!_documentationUrlSet &&
        _apiMapResponse.containsKey('documentation_url')) {
      _documentationUrl = _apiMapResponse['documentation_url']?.toString();
      _documentationUrlSet = true;
    }
    return _documentationUrl;
  }

  set documentationUrl(String v) {
    _documentationUrl = v;
    _documentationUrlSet = true;
  }

  ValidationError() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ValidationError.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_messageSet || _apiMapResponse.containsKey('message')) {
      json['message'] = message;
    }
    if (_errorsSet || _apiMapResponse.containsKey('errors')) {
      json['errors'] = errors?.map((i) => i.toJson())?.toList();
    }
    if (_documentationUrlSet ||
        _apiMapResponse.containsKey('documentation_url')) {
      json['documentation_url'] = documentationUrl;
    }
    return json;
  }
}

class ValidationErrorDetail {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _field;
  bool _fieldSet = false;

  String _code;
  bool _codeSet = false;

  String _message;
  bool _messageSet = false;

  String _documentationUrl;
  bool _documentationUrlSet = false;

  /// Field with error (read-only)

  String get field {
    if (!_fieldSet && _apiMapResponse.containsKey('field')) {
      _field = _apiMapResponse['field']?.toString();
      _fieldSet = true;
    }
    return _field;
  }

  set field(String v) {
    _field = v;
    _fieldSet = true;
  }

  /// Error code (read-only)

  String get code {
    if (!_codeSet && _apiMapResponse.containsKey('code')) {
      _code = _apiMapResponse['code']?.toString();
      _codeSet = true;
    }
    return _code;
  }

  set code(String v) {
    _code = v;
    _codeSet = true;
  }

  /// Error info message (read-only)

  String get message {
    if (!_messageSet && _apiMapResponse.containsKey('message')) {
      _message = _apiMapResponse['message']?.toString();
      _messageSet = true;
    }
    return _message;
  }

  set message(String v) {
    _message = v;
    _messageSet = true;
  }

  /// Documentation link (read-only)

  String get documentationUrl {
    if (!_documentationUrlSet &&
        _apiMapResponse.containsKey('documentation_url')) {
      _documentationUrl = _apiMapResponse['documentation_url']?.toString();
      _documentationUrlSet = true;
    }
    return _documentationUrl;
  }

  set documentationUrl(String v) {
    _documentationUrl = v;
    _documentationUrlSet = true;
  }

  ValidationErrorDetail() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  ValidationErrorDetail.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_fieldSet || _apiMapResponse.containsKey('field')) {
      json['field'] = field;
    }
    if (_codeSet || _apiMapResponse.containsKey('code')) {
      json['code'] = code;
    }
    if (_messageSet || _apiMapResponse.containsKey('message')) {
      json['message'] = message;
    }
    if (_documentationUrlSet ||
        _apiMapResponse.containsKey('documentation_url')) {
      json['documentation_url'] = documentationUrl;
    }
    return json;
  }
}

/// The name of the starting day of the week. Valid values are: "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday". (Enum defined in LookmlModelExploreField)
enum WeekStartDay {
  monday,
  tuesday,
  wednesday,
  thursday,
  friday,
  saturday,
  sunday
}

class WeekStartDayMapper {
  static String toStringValue(WeekStartDay e) {
    switch (e) {
      case WeekStartDay.monday:
        return 'monday';
      case WeekStartDay.tuesday:
        return 'tuesday';
      case WeekStartDay.wednesday:
        return 'wednesday';
      case WeekStartDay.thursday:
        return 'thursday';
      case WeekStartDay.friday:
        return 'friday';
      case WeekStartDay.saturday:
        return 'saturday';
      case WeekStartDay.sunday:
        return 'sunday';

      default:
        return null;
    }
  }

  static WeekStartDay fromStringValue(String s) {
    if (s == 'monday') {
      return WeekStartDay.monday;
    }
    if (s == 'tuesday') {
      return WeekStartDay.tuesday;
    }
    if (s == 'wednesday') {
      return WeekStartDay.wednesday;
    }
    if (s == 'thursday') {
      return WeekStartDay.thursday;
    }
    if (s == 'friday') {
      return WeekStartDay.friday;
    }
    if (s == 'saturday') {
      return WeekStartDay.saturday;
    }
    if (s == 'sunday') {
      return WeekStartDay.sunday;
    }
    return null;
  }
}

class WelcomeEmailTest {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _content;
  bool _contentSet = false;

  String _subject;
  bool _subjectSet = false;

  String _header;
  bool _headerSet = false;

  /// The content that would be sent in the body of a custom welcome email

  String get content {
    if (!_contentSet && _apiMapResponse.containsKey('content')) {
      _content = _apiMapResponse['content']?.toString();
      _contentSet = true;
    }
    return _content;
  }

  set content(String v) {
    _content = v;
    _contentSet = true;
  }

  /// The subject that would be sent for the custom welcome email

  String get subject {
    if (!_subjectSet && _apiMapResponse.containsKey('subject')) {
      _subject = _apiMapResponse['subject']?.toString();
      _subjectSet = true;
    }
    return _subject;
  }

  set subject(String v) {
    _subject = v;
    _subjectSet = true;
  }

  /// The header that would be sent in the body of a custom welcome email

  String get header {
    if (!_headerSet && _apiMapResponse.containsKey('header')) {
      _header = _apiMapResponse['header']?.toString();
      _headerSet = true;
    }
    return _header;
  }

  set header(String v) {
    _header = v;
    _headerSet = true;
  }

  WelcomeEmailTest() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WelcomeEmailTest.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_contentSet || _apiMapResponse.containsKey('content')) {
      json['content'] = content;
    }
    if (_subjectSet || _apiMapResponse.containsKey('subject')) {
      json['subject'] = subject;
    }
    if (_headerSet || _apiMapResponse.containsKey('header')) {
      json['header'] = header;
    }
    return json;
  }
}

class WhitelabelConfiguration {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _id;
  bool _idSet = false;

  String _logoFile;
  bool _logoFileSet = false;

  String _logoUrl;
  bool _logoUrlSet = false;

  String _faviconFile;
  bool _faviconFileSet = false;

  String _faviconUrl;
  bool _faviconUrlSet = false;

  String _defaultTitle;
  bool _defaultTitleSet = false;

  bool _showHelpMenu;
  bool _showHelpMenuSet = false;

  bool _showDocs;
  bool _showDocsSet = false;

  bool _showEmailSubOptions;
  bool _showEmailSubOptionsSet = false;

  bool _allowLookerMentions;
  bool _allowLookerMentionsSet = false;

  bool _allowLookerLinks;
  bool _allowLookerLinksSet = false;

  bool _customWelcomeEmailAdvanced;
  bool _customWelcomeEmailAdvancedSet = false;

  bool _setupMentions;
  bool _setupMentionsSet = false;

  bool _alertsLogo;
  bool _alertsLogoSet = false;

  bool _alertsLinks;
  bool _alertsLinksSet = false;

  bool _foldersMentions;
  bool _foldersMentionsSet = false;

  /// Unique Id (read-only)

  int get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id'];
      _idSet = true;
    }
    return _id;
  }

  set id(int v) {
    _id = v;
    _idSet = true;
  }

  /// Customer logo image. Expected base64 encoded data (write-only)

  String get logoFile {
    if (!_logoFileSet && _apiMapResponse.containsKey('logo_file')) {
      _logoFile = _apiMapResponse['logo_file']?.toString();
      _logoFileSet = true;
    }
    return _logoFile;
  }

  set logoFile(String v) {
    _logoFile = v;
    _logoFileSet = true;
  }

  /// Logo image url (read-only) (read-only)

  String get logoUrl {
    if (!_logoUrlSet && _apiMapResponse.containsKey('logo_url')) {
      _logoUrl = _apiMapResponse['logo_url']?.toString();
      _logoUrlSet = true;
    }
    return _logoUrl;
  }

  set logoUrl(String v) {
    _logoUrl = v;
    _logoUrlSet = true;
  }

  /// Custom favicon image. Expected base64 encoded data (write-only)

  String get faviconFile {
    if (!_faviconFileSet && _apiMapResponse.containsKey('favicon_file')) {
      _faviconFile = _apiMapResponse['favicon_file']?.toString();
      _faviconFileSet = true;
    }
    return _faviconFile;
  }

  set faviconFile(String v) {
    _faviconFile = v;
    _faviconFileSet = true;
  }

  /// Favicon image url (read-only) (read-only)

  String get faviconUrl {
    if (!_faviconUrlSet && _apiMapResponse.containsKey('favicon_url')) {
      _faviconUrl = _apiMapResponse['favicon_url']?.toString();
      _faviconUrlSet = true;
    }
    return _faviconUrl;
  }

  set faviconUrl(String v) {
    _faviconUrl = v;
    _faviconUrlSet = true;
  }

  /// Default page title

  String get defaultTitle {
    if (!_defaultTitleSet && _apiMapResponse.containsKey('default_title')) {
      _defaultTitle = _apiMapResponse['default_title']?.toString();
      _defaultTitleSet = true;
    }
    return _defaultTitle;
  }

  set defaultTitle(String v) {
    _defaultTitle = v;
    _defaultTitleSet = true;
  }

  /// Boolean to toggle showing help menus

  bool get showHelpMenu {
    if (!_showHelpMenuSet && _apiMapResponse.containsKey('show_help_menu')) {
      _showHelpMenu = _apiMapResponse['show_help_menu'];
      _showHelpMenuSet = true;
    }
    return _showHelpMenu;
  }

  set showHelpMenu(bool v) {
    _showHelpMenu = v;
    _showHelpMenuSet = true;
  }

  /// Boolean to toggle showing docs

  bool get showDocs {
    if (!_showDocsSet && _apiMapResponse.containsKey('show_docs')) {
      _showDocs = _apiMapResponse['show_docs'];
      _showDocsSet = true;
    }
    return _showDocs;
  }

  set showDocs(bool v) {
    _showDocs = v;
    _showDocsSet = true;
  }

  /// Boolean to toggle showing email subscription options.

  bool get showEmailSubOptions {
    if (!_showEmailSubOptionsSet &&
        _apiMapResponse.containsKey('show_email_sub_options')) {
      _showEmailSubOptions = _apiMapResponse['show_email_sub_options'];
      _showEmailSubOptionsSet = true;
    }
    return _showEmailSubOptions;
  }

  set showEmailSubOptions(bool v) {
    _showEmailSubOptions = v;
    _showEmailSubOptionsSet = true;
  }

  /// Boolean to toggle mentions of Looker in emails

  bool get allowLookerMentions {
    if (!_allowLookerMentionsSet &&
        _apiMapResponse.containsKey('allow_looker_mentions')) {
      _allowLookerMentions = _apiMapResponse['allow_looker_mentions'];
      _allowLookerMentionsSet = true;
    }
    return _allowLookerMentions;
  }

  set allowLookerMentions(bool v) {
    _allowLookerMentions = v;
    _allowLookerMentionsSet = true;
  }

  /// Boolean to toggle links to Looker in emails

  bool get allowLookerLinks {
    if (!_allowLookerLinksSet &&
        _apiMapResponse.containsKey('allow_looker_links')) {
      _allowLookerLinks = _apiMapResponse['allow_looker_links'];
      _allowLookerLinksSet = true;
    }
    return _allowLookerLinks;
  }

  set allowLookerLinks(bool v) {
    _allowLookerLinks = v;
    _allowLookerLinksSet = true;
  }

  /// Allow subject line and email heading customization in customized emails”

  bool get customWelcomeEmailAdvanced {
    if (!_customWelcomeEmailAdvancedSet &&
        _apiMapResponse.containsKey('custom_welcome_email_advanced')) {
      _customWelcomeEmailAdvanced =
          _apiMapResponse['custom_welcome_email_advanced'];
      _customWelcomeEmailAdvancedSet = true;
    }
    return _customWelcomeEmailAdvanced;
  }

  set customWelcomeEmailAdvanced(bool v) {
    _customWelcomeEmailAdvanced = v;
    _customWelcomeEmailAdvancedSet = true;
  }

  /// Remove the word Looker from appearing in the account setup page

  bool get setupMentions {
    if (!_setupMentionsSet && _apiMapResponse.containsKey('setup_mentions')) {
      _setupMentions = _apiMapResponse['setup_mentions'];
      _setupMentionsSet = true;
    }
    return _setupMentions;
  }

  set setupMentions(bool v) {
    _setupMentions = v;
    _setupMentionsSet = true;
  }

  /// Remove Looker logo from Alerts

  bool get alertsLogo {
    if (!_alertsLogoSet && _apiMapResponse.containsKey('alerts_logo')) {
      _alertsLogo = _apiMapResponse['alerts_logo'];
      _alertsLogoSet = true;
    }
    return _alertsLogo;
  }

  set alertsLogo(bool v) {
    _alertsLogo = v;
    _alertsLogoSet = true;
  }

  /// Remove Looker links from Alerts

  bool get alertsLinks {
    if (!_alertsLinksSet && _apiMapResponse.containsKey('alerts_links')) {
      _alertsLinks = _apiMapResponse['alerts_links'];
      _alertsLinksSet = true;
    }
    return _alertsLinks;
  }

  set alertsLinks(bool v) {
    _alertsLinks = v;
    _alertsLinksSet = true;
  }

  /// Remove Looker mentions in home folder page when you don’t have any items saved

  bool get foldersMentions {
    if (!_foldersMentionsSet &&
        _apiMapResponse.containsKey('folders_mentions')) {
      _foldersMentions = _apiMapResponse['folders_mentions'];
      _foldersMentionsSet = true;
    }
    return _foldersMentions;
  }

  set foldersMentions(bool v) {
    _foldersMentions = v;
    _foldersMentionsSet = true;
  }

  WhitelabelConfiguration() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WhitelabelConfiguration.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_logoFileSet || _apiMapResponse.containsKey('logo_file')) {
      json['logo_file'] = logoFile;
    }
    if (_logoUrlSet || _apiMapResponse.containsKey('logo_url')) {
      json['logo_url'] = logoUrl;
    }
    if (_faviconFileSet || _apiMapResponse.containsKey('favicon_file')) {
      json['favicon_file'] = faviconFile;
    }
    if (_faviconUrlSet || _apiMapResponse.containsKey('favicon_url')) {
      json['favicon_url'] = faviconUrl;
    }
    if (_defaultTitleSet || _apiMapResponse.containsKey('default_title')) {
      json['default_title'] = defaultTitle;
    }
    if (_showHelpMenuSet || _apiMapResponse.containsKey('show_help_menu')) {
      json['show_help_menu'] = showHelpMenu;
    }
    if (_showDocsSet || _apiMapResponse.containsKey('show_docs')) {
      json['show_docs'] = showDocs;
    }
    if (_showEmailSubOptionsSet ||
        _apiMapResponse.containsKey('show_email_sub_options')) {
      json['show_email_sub_options'] = showEmailSubOptions;
    }
    if (_allowLookerMentionsSet ||
        _apiMapResponse.containsKey('allow_looker_mentions')) {
      json['allow_looker_mentions'] = allowLookerMentions;
    }
    if (_allowLookerLinksSet ||
        _apiMapResponse.containsKey('allow_looker_links')) {
      json['allow_looker_links'] = allowLookerLinks;
    }
    if (_customWelcomeEmailAdvancedSet ||
        _apiMapResponse.containsKey('custom_welcome_email_advanced')) {
      json['custom_welcome_email_advanced'] = customWelcomeEmailAdvanced;
    }
    if (_setupMentionsSet || _apiMapResponse.containsKey('setup_mentions')) {
      json['setup_mentions'] = setupMentions;
    }
    if (_alertsLogoSet || _apiMapResponse.containsKey('alerts_logo')) {
      json['alerts_logo'] = alertsLogo;
    }
    if (_alertsLinksSet || _apiMapResponse.containsKey('alerts_links')) {
      json['alerts_links'] = alertsLinks;
    }
    if (_foldersMentionsSet ||
        _apiMapResponse.containsKey('folders_mentions')) {
      json['folders_mentions'] = foldersMentions;
    }
    return json;
  }
}

class Workspace {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  Map<String, dynamic> _can;
  bool _canSet = false;

  String _id;
  bool _idSet = false;

  List<Project> _projects;
  bool _projectsSet = false;

  /// Operations the current user is able to perform on this object (read-only)

  Map<String, dynamic> get can {
    if (!_canSet && _apiMapResponse.containsKey('can')) {
      _can = _apiMapResponse['can'];
      _canSet = true;
    }
    return _can;
  }

  set can(Map<String, dynamic> v) {
    _can = v;
    _canSet = true;
  }

  /// The unique id of this user workspace. Predefined workspace ids include "production" and "dev" (read-only)

  String get id {
    if (!_idSet && _apiMapResponse.containsKey('id')) {
      _id = _apiMapResponse['id']?.toString();
      _idSet = true;
    }
    return _id;
  }

  set id(String v) {
    _id = v;
    _idSet = true;
  }

  /// The local state of each project in the workspace (read-only)

  List<Project> get projects {
    if (!_projectsSet && _apiMapResponse.containsKey('projects')) {
      _projects = _apiMapResponse['projects'] == null
          ? null
          : (_apiMapResponse['projects'] as List)
              .map((i) => Project.fromResponse(i, apiResponseContentType))
              .toList();
      _projectsSet = true;
    }
    return _projects;
  }

  set projects(List<Project> v) {
    _projects = v;
    _projectsSet = true;
  }

  Workspace() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  Workspace.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canSet || _apiMapResponse.containsKey('can')) {
      json['can'] = can;
    }
    if (_idSet || _apiMapResponse.containsKey('id')) {
      json['id'] = id;
    }
    if (_projectsSet || _apiMapResponse.containsKey('projects')) {
      json['projects'] = projects?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

/// Dynamic writeable type for Alert removes:
/// followed, followable, id, investigative_content_title, owner_display_name
class WriteAlert {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  List<AlertAppliedDashboardFilter> _appliedDashboardFilters;
  bool _appliedDashboardFiltersSet = false;

  ComparisonType _comparisonType;
  bool _comparisonTypeSet = false;

  String _cron;
  bool _cronSet = false;

  String _customTitle;
  bool _customTitleSet = false;

  int _dashboardElementId;
  bool _dashboardElementIdSet = false;

  String _description;
  bool _descriptionSet = false;

  List<AlertDestination> _destinations;
  bool _destinationsSet = false;

  AlertField _field;
  bool _fieldSet = false;

  bool _isDisabled;
  bool _isDisabledSet = false;

  String _disabledReason;
  bool _disabledReasonSet = false;

  bool _isPublic;
  bool _isPublicSet = false;

  InvestigativeContentType _investigativeContentType;
  bool _investigativeContentTypeSet = false;

  String _investigativeContentId;
  bool _investigativeContentIdSet = false;

  String _lookmlDashboardId;
  bool _lookmlDashboardIdSet = false;

  String _lookmlLinkId;
  bool _lookmlLinkIdSet = false;

  int _ownerId;
  bool _ownerIdSet = false;

  double _threshold;
  bool _thresholdSet = false;

  AlertConditionState _timeSeriesConditionState;
  bool _timeSeriesConditionStateSet = false;

  /// Filters coming from the dashboard that are applied. Example `[{ "filter_title": "Name", "field_name": "distribution_centers.name", "filter_value": "Los Angeles CA" }]`

  List<AlertAppliedDashboardFilter> get appliedDashboardFilters {
    if (!_appliedDashboardFiltersSet &&
        _apiMapResponse.containsKey('applied_dashboard_filters')) {
      _appliedDashboardFilters =
          _apiMapResponse['applied_dashboard_filters'] == null
              ? null
              : (_apiMapResponse['applied_dashboard_filters'] as List)
                  .map((i) => AlertAppliedDashboardFilter.fromResponse(
                      i, apiResponseContentType))
                  .toList();
      _appliedDashboardFiltersSet = true;
    }
    return _appliedDashboardFilters;
  }

  set appliedDashboardFilters(List<AlertAppliedDashboardFilter> v) {
    _appliedDashboardFilters = v;
    _appliedDashboardFiltersSet = true;
  }

  /// This property informs the check what kind of comparison we are performing. Only certain condition types are valid for time series alerts. For details, refer to [Setting Alert Conditions](https://docs.looker.com/sharing-and-publishing/creating-alerts#setting_alert_conditions) Valid values are: "EQUAL_TO", "GREATER_THAN", "GREATER_THAN_OR_EQUAL_TO", "LESS_THAN", "LESS_THAN_OR_EQUAL_TO", "INCREASES_BY", "DECREASES_BY", "CHANGES_BY".

  ComparisonType get comparisonType {
    if (!_comparisonTypeSet && _apiMapResponse.containsKey('comparison_type')) {
      _comparisonType = ComparisonTypeMapper.fromStringValue(
          _apiMapResponse['comparison_type']);
      _comparisonTypeSet = true;
    }
    return _comparisonType;
  }

  set comparisonType(ComparisonType v) {
    _comparisonType = v;
    _comparisonTypeSet = true;
  }

  /// Vixie-Style crontab specification when to run. At minumum, it has to be longer than 15 minute intervals

  String get cron {
    if (!_cronSet && _apiMapResponse.containsKey('cron')) {
      _cron = _apiMapResponse['cron']?.toString();
      _cronSet = true;
    }
    return _cron;
  }

  set cron(String v) {
    _cron = v;
    _cronSet = true;
  }

  /// An optional, user-defined title for the alert

  String get customTitle {
    if (!_customTitleSet && _apiMapResponse.containsKey('custom_title')) {
      _customTitle = _apiMapResponse['custom_title']?.toString();
      _customTitleSet = true;
    }
    return _customTitle;
  }

  set customTitle(String v) {
    _customTitle = v;
    _customTitleSet = true;
  }

  /// ID of the dashboard element associated with the alert. Refer to [dashboard_element()](#!/Dashboard/DashboardElement)

  int get dashboardElementId {
    if (!_dashboardElementIdSet &&
        _apiMapResponse.containsKey('dashboard_element_id')) {
      _dashboardElementId = _apiMapResponse['dashboard_element_id'];
      _dashboardElementIdSet = true;
    }
    return _dashboardElementId;
  }

  set dashboardElementId(int v) {
    _dashboardElementId = v;
    _dashboardElementIdSet = true;
  }

  /// An optional description for the alert. This supplements the title

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Array of destinations to send alerts to. Must be the same type of destination. Example `[{ "destination_type": "EMAIL", "email_address": "test@test.com" }]`

  List<AlertDestination> get destinations {
    if (!_destinationsSet && _apiMapResponse.containsKey('destinations')) {
      _destinations = _apiMapResponse['destinations'] == null
          ? null
          : (_apiMapResponse['destinations'] as List)
              .map((i) =>
                  AlertDestination.fromResponse(i, apiResponseContentType))
              .toList();
      _destinationsSet = true;
    }
    return _destinations;
  }

  set destinations(List<AlertDestination> v) {
    _destinations = v;
    _destinationsSet = true;
  }

  AlertField get field {
    if (!_fieldSet && _apiMapResponse.containsKey('field')) {
      _field = _apiMapResponse['field'] == null
          ? null
          : AlertField.fromResponse(
              _apiMapResponse['field'], apiResponseContentType);
      _fieldSet = true;
    }
    return _field;
  }

  set field(AlertField v) {
    _field = v;
    _fieldSet = true;
  }

  /// Whether or not the alert is disabled

  bool get isDisabled {
    if (!_isDisabledSet && _apiMapResponse.containsKey('is_disabled')) {
      _isDisabled = _apiMapResponse['is_disabled'];
      _isDisabledSet = true;
    }
    return _isDisabled;
  }

  set isDisabled(bool v) {
    _isDisabled = v;
    _isDisabledSet = true;
  }

  /// Reason for disabling alert

  String get disabledReason {
    if (!_disabledReasonSet && _apiMapResponse.containsKey('disabled_reason')) {
      _disabledReason = _apiMapResponse['disabled_reason']?.toString();
      _disabledReasonSet = true;
    }
    return _disabledReason;
  }

  set disabledReason(String v) {
    _disabledReason = v;
    _disabledReasonSet = true;
  }

  /// Whether or not the alert is public

  bool get isPublic {
    if (!_isPublicSet && _apiMapResponse.containsKey('is_public')) {
      _isPublic = _apiMapResponse['is_public'];
      _isPublicSet = true;
    }
    return _isPublic;
  }

  set isPublic(bool v) {
    _isPublic = v;
    _isPublicSet = true;
  }

  /// The type of the investigative content Valid values are: "dashboard".

  InvestigativeContentType get investigativeContentType {
    if (!_investigativeContentTypeSet &&
        _apiMapResponse.containsKey('investigative_content_type')) {
      _investigativeContentType =
          InvestigativeContentTypeMapper.fromStringValue(
              _apiMapResponse['investigative_content_type']);
      _investigativeContentTypeSet = true;
    }
    return _investigativeContentType;
  }

  set investigativeContentType(InvestigativeContentType v) {
    _investigativeContentType = v;
    _investigativeContentTypeSet = true;
  }

  /// The ID of the investigative content. For dashboards, this will be the dashboard ID

  String get investigativeContentId {
    if (!_investigativeContentIdSet &&
        _apiMapResponse.containsKey('investigative_content_id')) {
      _investigativeContentId =
          _apiMapResponse['investigative_content_id']?.toString();
      _investigativeContentIdSet = true;
    }
    return _investigativeContentId;
  }

  set investigativeContentId(String v) {
    _investigativeContentId = v;
    _investigativeContentIdSet = true;
  }

  /// ID of the LookML dashboard associated with the alert

  String get lookmlDashboardId {
    if (!_lookmlDashboardIdSet &&
        _apiMapResponse.containsKey('lookml_dashboard_id')) {
      _lookmlDashboardId = _apiMapResponse['lookml_dashboard_id']?.toString();
      _lookmlDashboardIdSet = true;
    }
    return _lookmlDashboardId;
  }

  set lookmlDashboardId(String v) {
    _lookmlDashboardId = v;
    _lookmlDashboardIdSet = true;
  }

  /// ID of the LookML dashboard element associated with the alert

  String get lookmlLinkId {
    if (!_lookmlLinkIdSet && _apiMapResponse.containsKey('lookml_link_id')) {
      _lookmlLinkId = _apiMapResponse['lookml_link_id']?.toString();
      _lookmlLinkIdSet = true;
    }
    return _lookmlLinkId;
  }

  set lookmlLinkId(String v) {
    _lookmlLinkId = v;
    _lookmlLinkIdSet = true;
  }

  /// User id of alert owner

  int get ownerId {
    if (!_ownerIdSet && _apiMapResponse.containsKey('owner_id')) {
      _ownerId = _apiMapResponse['owner_id'];
      _ownerIdSet = true;
    }
    return _ownerId;
  }

  set ownerId(int v) {
    _ownerId = v;
    _ownerIdSet = true;
  }

  /// Value of the alert threshold

  double get threshold {
    if (!_thresholdSet && _apiMapResponse.containsKey('threshold')) {
      _threshold = _apiMapResponse['threshold'];
      _thresholdSet = true;
    }
    return _threshold;
  }

  set threshold(double v) {
    _threshold = v;
    _thresholdSet = true;
  }

  AlertConditionState get timeSeriesConditionState {
    if (!_timeSeriesConditionStateSet &&
        _apiMapResponse.containsKey('time_series_condition_state')) {
      _timeSeriesConditionState =
          _apiMapResponse['time_series_condition_state'] == null
              ? null
              : AlertConditionState.fromResponse(
                  _apiMapResponse['time_series_condition_state'],
                  apiResponseContentType);
      _timeSeriesConditionStateSet = true;
    }
    return _timeSeriesConditionState;
  }

  set timeSeriesConditionState(AlertConditionState v) {
    _timeSeriesConditionState = v;
    _timeSeriesConditionStateSet = true;
  }

  WriteAlert() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteAlert.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_appliedDashboardFiltersSet ||
        _apiMapResponse.containsKey('applied_dashboard_filters')) {
      json['applied_dashboard_filters'] =
          appliedDashboardFilters?.map((i) => i.toJson())?.toList();
    }
    if (_comparisonTypeSet || _apiMapResponse.containsKey('comparison_type')) {
      json['comparison_type'] =
          ComparisonTypeMapper.toStringValue(comparisonType);
    }
    if (_cronSet || _apiMapResponse.containsKey('cron')) {
      json['cron'] = cron;
    }
    if (_customTitleSet || _apiMapResponse.containsKey('custom_title')) {
      json['custom_title'] = customTitle;
    }
    if (_dashboardElementIdSet ||
        _apiMapResponse.containsKey('dashboard_element_id')) {
      json['dashboard_element_id'] = dashboardElementId;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_destinationsSet || _apiMapResponse.containsKey('destinations')) {
      json['destinations'] = destinations?.map((i) => i.toJson())?.toList();
    }
    if (_fieldSet || _apiMapResponse.containsKey('field')) {
      json['field'] = field?.toJson();
    }
    if (_isDisabledSet || _apiMapResponse.containsKey('is_disabled')) {
      json['is_disabled'] = isDisabled;
    }
    if (_disabledReasonSet || _apiMapResponse.containsKey('disabled_reason')) {
      json['disabled_reason'] = disabledReason;
    }
    if (_isPublicSet || _apiMapResponse.containsKey('is_public')) {
      json['is_public'] = isPublic;
    }
    if (_investigativeContentTypeSet ||
        _apiMapResponse.containsKey('investigative_content_type')) {
      json['investigative_content_type'] =
          InvestigativeContentTypeMapper.toStringValue(
              investigativeContentType);
    }
    if (_investigativeContentIdSet ||
        _apiMapResponse.containsKey('investigative_content_id')) {
      json['investigative_content_id'] = investigativeContentId;
    }
    if (_lookmlDashboardIdSet ||
        _apiMapResponse.containsKey('lookml_dashboard_id')) {
      json['lookml_dashboard_id'] = lookmlDashboardId;
    }
    if (_lookmlLinkIdSet || _apiMapResponse.containsKey('lookml_link_id')) {
      json['lookml_link_id'] = lookmlLinkId;
    }
    if (_ownerIdSet || _apiMapResponse.containsKey('owner_id')) {
      json['owner_id'] = ownerId;
    }
    if (_thresholdSet || _apiMapResponse.containsKey('threshold')) {
      json['threshold'] = threshold;
    }
    if (_timeSeriesConditionStateSet ||
        _apiMapResponse.containsKey('time_series_condition_state')) {
      json['time_series_condition_state'] = timeSeriesConditionState?.toJson();
    }
    return json;
  }
}

/// Dynamic writeable type for ApiSession removes:
/// can, sudo_user_id
class WriteApiSession {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _workspaceId;
  bool _workspaceIdSet = false;

  /// The id of active workspace for this session

  String get workspaceId {
    if (!_workspaceIdSet && _apiMapResponse.containsKey('workspace_id')) {
      _workspaceId = _apiMapResponse['workspace_id']?.toString();
      _workspaceIdSet = true;
    }
    return _workspaceId;
  }

  set workspaceId(String v) {
    _workspaceId = v;
    _workspaceIdSet = true;
  }

  WriteApiSession() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteApiSession.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_workspaceIdSet || _apiMapResponse.containsKey('workspace_id')) {
      json['workspace_id'] = workspaceId;
    }
    return json;
  }
}

/// Dynamic writeable type for BackupConfiguration removes:
/// can, url
class WriteBackupConfiguration {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _type;
  bool _typeSet = false;

  String _customS3Bucket;
  bool _customS3BucketSet = false;

  String _customS3BucketRegion;
  bool _customS3BucketRegionSet = false;

  String _customS3Key;
  bool _customS3KeySet = false;

  String _customS3Secret;
  bool _customS3SecretSet = false;

  /// Type of backup: looker-s3 or custom-s3

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Name of bucket for custom-s3 backups

  String get customS3Bucket {
    if (!_customS3BucketSet &&
        _apiMapResponse.containsKey('custom_s3_bucket')) {
      _customS3Bucket = _apiMapResponse['custom_s3_bucket']?.toString();
      _customS3BucketSet = true;
    }
    return _customS3Bucket;
  }

  set customS3Bucket(String v) {
    _customS3Bucket = v;
    _customS3BucketSet = true;
  }

  /// Name of region where the bucket is located

  String get customS3BucketRegion {
    if (!_customS3BucketRegionSet &&
        _apiMapResponse.containsKey('custom_s3_bucket_region')) {
      _customS3BucketRegion =
          _apiMapResponse['custom_s3_bucket_region']?.toString();
      _customS3BucketRegionSet = true;
    }
    return _customS3BucketRegion;
  }

  set customS3BucketRegion(String v) {
    _customS3BucketRegion = v;
    _customS3BucketRegionSet = true;
  }

  /// (Write-Only) AWS S3 key used for custom-s3 backups

  String get customS3Key {
    if (!_customS3KeySet && _apiMapResponse.containsKey('custom_s3_key')) {
      _customS3Key = _apiMapResponse['custom_s3_key']?.toString();
      _customS3KeySet = true;
    }
    return _customS3Key;
  }

  set customS3Key(String v) {
    _customS3Key = v;
    _customS3KeySet = true;
  }

  /// (Write-Only) AWS S3 secret used for custom-s3 backups

  String get customS3Secret {
    if (!_customS3SecretSet &&
        _apiMapResponse.containsKey('custom_s3_secret')) {
      _customS3Secret = _apiMapResponse['custom_s3_secret']?.toString();
      _customS3SecretSet = true;
    }
    return _customS3Secret;
  }

  set customS3Secret(String v) {
    _customS3Secret = v;
    _customS3SecretSet = true;
  }

  WriteBackupConfiguration() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteBackupConfiguration.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_customS3BucketSet || _apiMapResponse.containsKey('custom_s3_bucket')) {
      json['custom_s3_bucket'] = customS3Bucket;
    }
    if (_customS3BucketRegionSet ||
        _apiMapResponse.containsKey('custom_s3_bucket_region')) {
      json['custom_s3_bucket_region'] = customS3BucketRegion;
    }
    if (_customS3KeySet || _apiMapResponse.containsKey('custom_s3_key')) {
      json['custom_s3_key'] = customS3Key;
    }
    if (_customS3SecretSet || _apiMapResponse.containsKey('custom_s3_secret')) {
      json['custom_s3_secret'] = customS3Secret;
    }
    return json;
  }
}

/// Dynamic writeable type for Board removes:
/// can, content_metadata_id, created_at, board_sections, id, updated_at, user_id, primary_homepage
class WriteBoard {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  DateTime _deletedAt;
  bool _deletedAtSet = false;

  String _description;
  bool _descriptionSet = false;

  List<int> _sectionOrder;
  bool _sectionOrderSet = false;

  String _title;
  bool _titleSet = false;

  /// Date of board deletion

  DateTime get deletedAt {
    if (!_deletedAtSet && _apiMapResponse.containsKey('deleted_at')) {
      _deletedAt = _apiMapResponse['deleted_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['deleted_at']);
      _deletedAtSet = true;
    }
    return _deletedAt;
  }

  set deletedAt(DateTime v) {
    _deletedAt = v;
    _deletedAtSet = true;
  }

  /// Description of the board

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// ids of the board sections in the order they should be displayed

  List<int> get sectionOrder {
    if (!_sectionOrderSet && _apiMapResponse.containsKey('section_order')) {
      _sectionOrder =
          _apiMapResponse['section_order']?.map<int>((i) => i as int)?.toList();
      _sectionOrderSet = true;
    }
    return _sectionOrder;
  }

  set sectionOrder(List<int> v) {
    _sectionOrder = v;
    _sectionOrderSet = true;
  }

  /// Title of the board

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  WriteBoard() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteBoard.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_deletedAtSet || _apiMapResponse.containsKey('deleted_at')) {
      json['deleted_at'] = deletedAt?.toIso8601String();
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_sectionOrderSet || _apiMapResponse.containsKey('section_order')) {
      json['section_order'] = sectionOrder;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    return json;
  }
}

/// Dynamic writeable type for BoardItem removes:
/// can, content_created_by, content_favorite_id, content_metadata_id, content_updated_at, description, favorite_count, id, image_url, location, title, url, view_count
class WriteBoardItem {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _customDescription;
  bool _customDescriptionSet = false;

  String _customTitle;
  bool _customTitleSet = false;

  String _customUrl;
  bool _customUrlSet = false;

  int _dashboardId;
  bool _dashboardIdSet = false;

  int _boardSectionId;
  bool _boardSectionIdSet = false;

  String _lookId;
  bool _lookIdSet = false;

  String _lookmlDashboardId;
  bool _lookmlDashboardIdSet = false;

  int _order;
  bool _orderSet = false;

  /// Custom description entered by the user, if present

  String get customDescription {
    if (!_customDescriptionSet &&
        _apiMapResponse.containsKey('custom_description')) {
      _customDescription = _apiMapResponse['custom_description']?.toString();
      _customDescriptionSet = true;
    }
    return _customDescription;
  }

  set customDescription(String v) {
    _customDescription = v;
    _customDescriptionSet = true;
  }

  /// Custom title entered by the user, if present

  String get customTitle {
    if (!_customTitleSet && _apiMapResponse.containsKey('custom_title')) {
      _customTitle = _apiMapResponse['custom_title']?.toString();
      _customTitleSet = true;
    }
    return _customTitle;
  }

  set customTitle(String v) {
    _customTitle = v;
    _customTitleSet = true;
  }

  /// Custom url entered by the user, if present

  String get customUrl {
    if (!_customUrlSet && _apiMapResponse.containsKey('custom_url')) {
      _customUrl = _apiMapResponse['custom_url']?.toString();
      _customUrlSet = true;
    }
    return _customUrl;
  }

  set customUrl(String v) {
    _customUrl = v;
    _customUrlSet = true;
  }

  /// Dashboard to base this item on

  int get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id'];
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(int v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// Associated Board Section

  int get boardSectionId {
    if (!_boardSectionIdSet &&
        _apiMapResponse.containsKey('board_section_id')) {
      _boardSectionId = _apiMapResponse['board_section_id'];
      _boardSectionIdSet = true;
    }
    return _boardSectionId;
  }

  set boardSectionId(int v) {
    _boardSectionId = v;
    _boardSectionIdSet = true;
  }

  /// Look to base this item on

  String get lookId {
    if (!_lookIdSet && _apiMapResponse.containsKey('look_id')) {
      _lookId = _apiMapResponse['look_id']?.toString();
      _lookIdSet = true;
    }
    return _lookId;
  }

  set lookId(String v) {
    _lookId = v;
    _lookIdSet = true;
  }

  /// LookML Dashboard to base this item on

  String get lookmlDashboardId {
    if (!_lookmlDashboardIdSet &&
        _apiMapResponse.containsKey('lookml_dashboard_id')) {
      _lookmlDashboardId = _apiMapResponse['lookml_dashboard_id']?.toString();
      _lookmlDashboardIdSet = true;
    }
    return _lookmlDashboardId;
  }

  set lookmlDashboardId(String v) {
    _lookmlDashboardId = v;
    _lookmlDashboardIdSet = true;
  }

  /// An arbitrary integer representing the sort order within the section

  int get order {
    if (!_orderSet && _apiMapResponse.containsKey('order')) {
      _order = _apiMapResponse['order'];
      _orderSet = true;
    }
    return _order;
  }

  set order(int v) {
    _order = v;
    _orderSet = true;
  }

  WriteBoardItem() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteBoardItem.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_customDescriptionSet ||
        _apiMapResponse.containsKey('custom_description')) {
      json['custom_description'] = customDescription;
    }
    if (_customTitleSet || _apiMapResponse.containsKey('custom_title')) {
      json['custom_title'] = customTitle;
    }
    if (_customUrlSet || _apiMapResponse.containsKey('custom_url')) {
      json['custom_url'] = customUrl;
    }
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_boardSectionIdSet || _apiMapResponse.containsKey('board_section_id')) {
      json['board_section_id'] = boardSectionId;
    }
    if (_lookIdSet || _apiMapResponse.containsKey('look_id')) {
      json['look_id'] = lookId;
    }
    if (_lookmlDashboardIdSet ||
        _apiMapResponse.containsKey('lookml_dashboard_id')) {
      json['lookml_dashboard_id'] = lookmlDashboardId;
    }
    if (_orderSet || _apiMapResponse.containsKey('order')) {
      json['order'] = order;
    }
    return json;
  }
}

/// Dynamic writeable type for BoardSection removes:
/// can, created_at, board_items, id, visible_item_order, updated_at
class WriteBoardSection {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  DateTime _deletedAt;
  bool _deletedAtSet = false;

  String _description;
  bool _descriptionSet = false;

  int _boardId;
  bool _boardIdSet = false;

  List<int> _itemOrder;
  bool _itemOrderSet = false;

  String _title;
  bool _titleSet = false;

  /// Time at which this section was deleted.

  DateTime get deletedAt {
    if (!_deletedAtSet && _apiMapResponse.containsKey('deleted_at')) {
      _deletedAt = _apiMapResponse['deleted_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['deleted_at']);
      _deletedAtSet = true;
    }
    return _deletedAt;
  }

  set deletedAt(DateTime v) {
    _deletedAt = v;
    _deletedAtSet = true;
  }

  /// Description of the content found in this section.

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Id reference to parent board

  int get boardId {
    if (!_boardIdSet && _apiMapResponse.containsKey('board_id')) {
      _boardId = _apiMapResponse['board_id'];
      _boardIdSet = true;
    }
    return _boardId;
  }

  set boardId(int v) {
    _boardId = v;
    _boardIdSet = true;
  }

  /// ids of the board items in the order they should be displayed

  List<int> get itemOrder {
    if (!_itemOrderSet && _apiMapResponse.containsKey('item_order')) {
      _itemOrder =
          _apiMapResponse['item_order']?.map<int>((i) => i as int)?.toList();
      _itemOrderSet = true;
    }
    return _itemOrder;
  }

  set itemOrder(List<int> v) {
    _itemOrder = v;
    _itemOrderSet = true;
  }

  /// Name of row

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  WriteBoardSection() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteBoardSection.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_deletedAtSet || _apiMapResponse.containsKey('deleted_at')) {
      json['deleted_at'] = deletedAt?.toIso8601String();
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_boardIdSet || _apiMapResponse.containsKey('board_id')) {
      json['board_id'] = boardId;
    }
    if (_itemOrderSet || _apiMapResponse.containsKey('item_order')) {
      json['item_order'] = itemOrder;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    return json;
  }
}

/// Dynamic writeable type for ColorCollection removes:
/// id
class WriteColorCollection {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _label;
  bool _labelSet = false;

  List<DiscretePalette> _categoricalPalettes;
  bool _categoricalPalettesSet = false;

  List<ContinuousPalette> _sequentialPalettes;
  bool _sequentialPalettesSet = false;

  List<ContinuousPalette> _divergingPalettes;
  bool _divergingPalettesSet = false;

  /// Label of color collection

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// Array of categorical palette definitions

  List<DiscretePalette> get categoricalPalettes {
    if (!_categoricalPalettesSet &&
        _apiMapResponse.containsKey('categoricalPalettes')) {
      _categoricalPalettes = _apiMapResponse['categoricalPalettes'] == null
          ? null
          : (_apiMapResponse['categoricalPalettes'] as List)
              .map((i) =>
                  DiscretePalette.fromResponse(i, apiResponseContentType))
              .toList();
      _categoricalPalettesSet = true;
    }
    return _categoricalPalettes;
  }

  set categoricalPalettes(List<DiscretePalette> v) {
    _categoricalPalettes = v;
    _categoricalPalettesSet = true;
  }

  /// Array of discrete palette definitions

  List<ContinuousPalette> get sequentialPalettes {
    if (!_sequentialPalettesSet &&
        _apiMapResponse.containsKey('sequentialPalettes')) {
      _sequentialPalettes = _apiMapResponse['sequentialPalettes'] == null
          ? null
          : (_apiMapResponse['sequentialPalettes'] as List)
              .map((i) =>
                  ContinuousPalette.fromResponse(i, apiResponseContentType))
              .toList();
      _sequentialPalettesSet = true;
    }
    return _sequentialPalettes;
  }

  set sequentialPalettes(List<ContinuousPalette> v) {
    _sequentialPalettes = v;
    _sequentialPalettesSet = true;
  }

  /// Array of diverging palette definitions

  List<ContinuousPalette> get divergingPalettes {
    if (!_divergingPalettesSet &&
        _apiMapResponse.containsKey('divergingPalettes')) {
      _divergingPalettes = _apiMapResponse['divergingPalettes'] == null
          ? null
          : (_apiMapResponse['divergingPalettes'] as List)
              .map((i) =>
                  ContinuousPalette.fromResponse(i, apiResponseContentType))
              .toList();
      _divergingPalettesSet = true;
    }
    return _divergingPalettes;
  }

  set divergingPalettes(List<ContinuousPalette> v) {
    _divergingPalettes = v;
    _divergingPalettesSet = true;
  }

  WriteColorCollection() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteColorCollection.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_categoricalPalettesSet ||
        _apiMapResponse.containsKey('categoricalPalettes')) {
      json['categoricalPalettes'] =
          categoricalPalettes?.map((i) => i.toJson())?.toList();
    }
    if (_sequentialPalettesSet ||
        _apiMapResponse.containsKey('sequentialPalettes')) {
      json['sequentialPalettes'] =
          sequentialPalettes?.map((i) => i.toJson())?.toList();
    }
    if (_divergingPalettesSet ||
        _apiMapResponse.containsKey('divergingPalettes')) {
      json['divergingPalettes'] =
          divergingPalettes?.map((i) => i.toJson())?.toList();
    }
    return json;
  }
}

/// Dynamic writeable type for Command removes:
/// id, author_id
class WriteCommand {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _description;
  bool _descriptionSet = false;

  String _linkedContentId;
  bool _linkedContentIdSet = false;

  LinkedContentType _linkedContentType;
  bool _linkedContentTypeSet = false;

  /// Name of the command

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Description of the command

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Id of the content associated with the command

  String get linkedContentId {
    if (!_linkedContentIdSet &&
        _apiMapResponse.containsKey('linked_content_id')) {
      _linkedContentId = _apiMapResponse['linked_content_id']?.toString();
      _linkedContentIdSet = true;
    }
    return _linkedContentId;
  }

  set linkedContentId(String v) {
    _linkedContentId = v;
    _linkedContentIdSet = true;
  }

  /// Name of the command Valid values are: "dashboard", "lookml_dashboard".

  LinkedContentType get linkedContentType {
    if (!_linkedContentTypeSet &&
        _apiMapResponse.containsKey('linked_content_type')) {
      _linkedContentType = LinkedContentTypeMapper.fromStringValue(
          _apiMapResponse['linked_content_type']);
      _linkedContentTypeSet = true;
    }
    return _linkedContentType;
  }

  set linkedContentType(LinkedContentType v) {
    _linkedContentType = v;
    _linkedContentTypeSet = true;
  }

  WriteCommand() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteCommand.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_linkedContentIdSet ||
        _apiMapResponse.containsKey('linked_content_id')) {
      json['linked_content_id'] = linkedContentId;
    }
    if (_linkedContentTypeSet ||
        _apiMapResponse.containsKey('linked_content_type')) {
      json['linked_content_type'] =
          LinkedContentTypeMapper.toStringValue(linkedContentType);
    }
    return json;
  }
}

/// Dynamic writeable type for ContentFavorite removes:
/// id, look_id, dashboard_id, board_id
class WriteContentFavorite {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _userId;
  bool _userIdSet = false;

  int _contentMetadataId;
  bool _contentMetadataIdSet = false;

  WriteLookBasic _look;
  bool _lookSet = false;

  WriteDashboardBase _dashboard;
  bool _dashboardSet = false;

  /// User Id which owns this ContentFavorite

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  /// Content Metadata Id associated with this ContentFavorite

  int get contentMetadataId {
    if (!_contentMetadataIdSet &&
        _apiMapResponse.containsKey('content_metadata_id')) {
      _contentMetadataId = _apiMapResponse['content_metadata_id'];
      _contentMetadataIdSet = true;
    }
    return _contentMetadataId;
  }

  set contentMetadataId(int v) {
    _contentMetadataId = v;
    _contentMetadataIdSet = true;
  }

  /// Dynamic writeable type for LookBasic removes:
  /// can, content_metadata_id, id, title

  WriteLookBasic get look {
    if (!_lookSet && _apiMapResponse.containsKey('look')) {
      _look = _apiMapResponse['look'] == null
          ? null
          : WriteLookBasic.fromResponse(
              _apiMapResponse['look'], apiResponseContentType);
      _lookSet = true;
    }
    return _look;
  }

  set look(WriteLookBasic v) {
    _look = v;
    _lookSet = true;
  }

  /// Dynamic writeable type for DashboardBase removes:
  /// can, content_favorite_id, content_metadata_id, description, hidden, id, model, query_timezone, readonly, refresh_interval, refresh_interval_to_i, title, user_id, slug, preferred_viewer

  WriteDashboardBase get dashboard {
    if (!_dashboardSet && _apiMapResponse.containsKey('dashboard')) {
      _dashboard = _apiMapResponse['dashboard'] == null
          ? null
          : WriteDashboardBase.fromResponse(
              _apiMapResponse['dashboard'], apiResponseContentType);
      _dashboardSet = true;
    }
    return _dashboard;
  }

  set dashboard(WriteDashboardBase v) {
    _dashboard = v;
    _dashboardSet = true;
  }

  WriteContentFavorite() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteContentFavorite.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    if (_contentMetadataIdSet ||
        _apiMapResponse.containsKey('content_metadata_id')) {
      json['content_metadata_id'] = contentMetadataId;
    }
    if (_lookSet || _apiMapResponse.containsKey('look')) {
      json['look'] = look?.toJson();
    }
    if (_dashboardSet || _apiMapResponse.containsKey('dashboard')) {
      json['dashboard'] = dashboard?.toJson();
    }
    return json;
  }
}

/// Dynamic writeable type for ContentMeta removes:
/// can, id, name, parent_id, dashboard_id, look_id, folder_id, content_type, inheriting_id, slug
class WriteContentMeta {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _inherits;
  bool _inheritsSet = false;

  /// Whether content inherits its access levels from parent

  bool get inherits {
    if (!_inheritsSet && _apiMapResponse.containsKey('inherits')) {
      _inherits = _apiMapResponse['inherits'];
      _inheritsSet = true;
    }
    return _inherits;
  }

  set inherits(bool v) {
    _inherits = v;
    _inheritsSet = true;
  }

  WriteContentMeta() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteContentMeta.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_inheritsSet || _apiMapResponse.containsKey('inherits')) {
      json['inherits'] = inherits;
    }
    return json;
  }
}

/// Dynamic writeable type for CreateDashboardFilter removes:
/// id, field
class WriteCreateDashboardFilter {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _dashboardId;
  bool _dashboardIdSet = false;

  String _name;
  bool _nameSet = false;

  String _title;
  bool _titleSet = false;

  String _type;
  bool _typeSet = false;

  String _defaultValue;
  bool _defaultValueSet = false;

  String _model;
  bool _modelSet = false;

  String _explore;
  bool _exploreSet = false;

  String _dimension;
  bool _dimensionSet = false;

  int _row;
  bool _rowSet = false;

  List<String> _listensToFilters;
  bool _listensToFiltersSet = false;

  bool _allowMultipleValues;
  bool _allowMultipleValuesSet = false;

  bool _required;
  bool _requiredSet = false;

  Map<String, dynamic> _uiConfig;
  bool _uiConfigSet = false;

  /// Id of Dashboard

  String get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id']?.toString();
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(String v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// Name of filter

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Title of filter

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Type of filter: one of date, number, string, or field

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Default value of filter

  String get defaultValue {
    if (!_defaultValueSet && _apiMapResponse.containsKey('default_value')) {
      _defaultValue = _apiMapResponse['default_value']?.toString();
      _defaultValueSet = true;
    }
    return _defaultValue;
  }

  set defaultValue(String v) {
    _defaultValue = v;
    _defaultValueSet = true;
  }

  /// Model of filter (required if type = field)

  String get model {
    if (!_modelSet && _apiMapResponse.containsKey('model')) {
      _model = _apiMapResponse['model']?.toString();
      _modelSet = true;
    }
    return _model;
  }

  set model(String v) {
    _model = v;
    _modelSet = true;
  }

  /// Explore of filter (required if type = field)

  String get explore {
    if (!_exploreSet && _apiMapResponse.containsKey('explore')) {
      _explore = _apiMapResponse['explore']?.toString();
      _exploreSet = true;
    }
    return _explore;
  }

  set explore(String v) {
    _explore = v;
    _exploreSet = true;
  }

  /// Dimension of filter (required if type = field)

  String get dimension {
    if (!_dimensionSet && _apiMapResponse.containsKey('dimension')) {
      _dimension = _apiMapResponse['dimension']?.toString();
      _dimensionSet = true;
    }
    return _dimension;
  }

  set dimension(String v) {
    _dimension = v;
    _dimensionSet = true;
  }

  /// Display order of this filter relative to other filters

  int get row {
    if (!_rowSet && _apiMapResponse.containsKey('row')) {
      _row = _apiMapResponse['row'];
      _rowSet = true;
    }
    return _row;
  }

  set row(int v) {
    _row = v;
    _rowSet = true;
  }

  /// Array of listeners for faceted filters

  List<String> get listensToFilters {
    if (!_listensToFiltersSet &&
        _apiMapResponse.containsKey('listens_to_filters')) {
      _listensToFilters = _apiMapResponse['listens_to_filters']
          ?.map<String>((i) => i as String)
          ?.toList();
      _listensToFiltersSet = true;
    }
    return _listensToFilters;
  }

  set listensToFilters(List<String> v) {
    _listensToFilters = v;
    _listensToFiltersSet = true;
  }

  /// Whether the filter allows multiple filter values (deprecated in the latest version of dashboards)

  bool get allowMultipleValues {
    if (!_allowMultipleValuesSet &&
        _apiMapResponse.containsKey('allow_multiple_values')) {
      _allowMultipleValues = _apiMapResponse['allow_multiple_values'];
      _allowMultipleValuesSet = true;
    }
    return _allowMultipleValues;
  }

  set allowMultipleValues(bool v) {
    _allowMultipleValues = v;
    _allowMultipleValuesSet = true;
  }

  /// Whether the filter requires a value to run the dashboard

  bool get required {
    if (!_requiredSet && _apiMapResponse.containsKey('required')) {
      _required = _apiMapResponse['required'];
      _requiredSet = true;
    }
    return _required;
  }

  set required(bool v) {
    _required = v;
    _requiredSet = true;
  }

  /// The visual configuration for this filter. Used to set up how the UI for this filter should appear.

  Map<String, dynamic> get uiConfig {
    if (!_uiConfigSet && _apiMapResponse.containsKey('ui_config')) {
      _uiConfig = _apiMapResponse['ui_config'];
      _uiConfigSet = true;
    }
    return _uiConfig;
  }

  set uiConfig(Map<String, dynamic> v) {
    _uiConfig = v;
    _uiConfigSet = true;
  }

  WriteCreateDashboardFilter() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteCreateDashboardFilter.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_defaultValueSet || _apiMapResponse.containsKey('default_value')) {
      json['default_value'] = defaultValue;
    }
    if (_modelSet || _apiMapResponse.containsKey('model')) {
      json['model'] = model;
    }
    if (_exploreSet || _apiMapResponse.containsKey('explore')) {
      json['explore'] = explore;
    }
    if (_dimensionSet || _apiMapResponse.containsKey('dimension')) {
      json['dimension'] = dimension;
    }
    if (_rowSet || _apiMapResponse.containsKey('row')) {
      json['row'] = row;
    }
    if (_listensToFiltersSet ||
        _apiMapResponse.containsKey('listens_to_filters')) {
      json['listens_to_filters'] = listensToFilters;
    }
    if (_allowMultipleValuesSet ||
        _apiMapResponse.containsKey('allow_multiple_values')) {
      json['allow_multiple_values'] = allowMultipleValues;
    }
    if (_requiredSet || _apiMapResponse.containsKey('required')) {
      json['required'] = required;
    }
    if (_uiConfigSet || _apiMapResponse.containsKey('ui_config')) {
      json['ui_config'] = uiConfig;
    }
    return json;
  }
}

/// Dynamic writeable type for CreateQueryTask removes:
/// can
class WriteCreateQueryTask {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _queryId;
  bool _queryIdSet = false;

  ResultFormat _resultFormat;
  bool _resultFormatSet = false;

  String _source;
  bool _sourceSet = false;

  bool _deferred;
  bool _deferredSet = false;

  String _lookId;
  bool _lookIdSet = false;

  String _dashboardId;
  bool _dashboardIdSet = false;

  /// Id of query to run

  int get queryId {
    if (!_queryIdSet && _apiMapResponse.containsKey('query_id')) {
      _queryId = _apiMapResponse['query_id'];
      _queryIdSet = true;
    }
    return _queryId;
  }

  set queryId(int v) {
    _queryId = v;
    _queryIdSet = true;
  }

  /// Desired async query result format. Valid values are: "inline_json", "json", "json_detail", "json_fe", "csv", "html", "md", "txt", "xlsx", "gsxml".

  ResultFormat get resultFormat {
    if (!_resultFormatSet && _apiMapResponse.containsKey('result_format')) {
      _resultFormat =
          ResultFormatMapper.fromStringValue(_apiMapResponse['result_format']);
      _resultFormatSet = true;
    }
    return _resultFormat;
  }

  set resultFormat(ResultFormat v) {
    _resultFormat = v;
    _resultFormatSet = true;
  }

  /// Source of query task

  String get source {
    if (!_sourceSet && _apiMapResponse.containsKey('source')) {
      _source = _apiMapResponse['source']?.toString();
      _sourceSet = true;
    }
    return _source;
  }

  set source(String v) {
    _source = v;
    _sourceSet = true;
  }

  /// Create the task but defer execution

  bool get deferred {
    if (!_deferredSet && _apiMapResponse.containsKey('deferred')) {
      _deferred = _apiMapResponse['deferred'];
      _deferredSet = true;
    }
    return _deferred;
  }

  set deferred(bool v) {
    _deferred = v;
    _deferredSet = true;
  }

  /// Id of look associated with query.

  String get lookId {
    if (!_lookIdSet && _apiMapResponse.containsKey('look_id')) {
      _lookId = _apiMapResponse['look_id']?.toString();
      _lookIdSet = true;
    }
    return _lookId;
  }

  set lookId(String v) {
    _lookId = v;
    _lookIdSet = true;
  }

  /// Id of dashboard associated with query.

  String get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id']?.toString();
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(String v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  WriteCreateQueryTask() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteCreateQueryTask.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_queryIdSet || _apiMapResponse.containsKey('query_id')) {
      json['query_id'] = queryId;
    }
    if (_resultFormatSet || _apiMapResponse.containsKey('result_format')) {
      json['result_format'] = ResultFormatMapper.toStringValue(resultFormat);
    }
    if (_sourceSet || _apiMapResponse.containsKey('source')) {
      json['source'] = source;
    }
    if (_deferredSet || _apiMapResponse.containsKey('deferred')) {
      json['deferred'] = deferred;
    }
    if (_lookIdSet || _apiMapResponse.containsKey('look_id')) {
      json['look_id'] = lookId;
    }
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    return json;
  }
}

/// Dynamic writeable type for CredentialsEmail removes:
/// can, created_at, is_disabled, logged_in_at, password_reset_url, type, url, user_url
class WriteCredentialsEmail {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _email;
  bool _emailSet = false;

  bool _forcedPasswordResetAtNextLogin;
  bool _forcedPasswordResetAtNextLoginSet = false;

  /// EMail address used for user login

  String get email {
    if (!_emailSet && _apiMapResponse.containsKey('email')) {
      _email = _apiMapResponse['email']?.toString();
      _emailSet = true;
    }
    return _email;
  }

  set email(String v) {
    _email = v;
    _emailSet = true;
  }

  /// Force the user to change their password upon their next login

  bool get forcedPasswordResetAtNextLogin {
    if (!_forcedPasswordResetAtNextLoginSet &&
        _apiMapResponse.containsKey('forced_password_reset_at_next_login')) {
      _forcedPasswordResetAtNextLogin =
          _apiMapResponse['forced_password_reset_at_next_login'];
      _forcedPasswordResetAtNextLoginSet = true;
    }
    return _forcedPasswordResetAtNextLogin;
  }

  set forcedPasswordResetAtNextLogin(bool v) {
    _forcedPasswordResetAtNextLogin = v;
    _forcedPasswordResetAtNextLoginSet = true;
  }

  WriteCredentialsEmail() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteCredentialsEmail.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_emailSet || _apiMapResponse.containsKey('email')) {
      json['email'] = email;
    }
    if (_forcedPasswordResetAtNextLoginSet ||
        _apiMapResponse.containsKey('forced_password_reset_at_next_login')) {
      json['forced_password_reset_at_next_login'] =
          forcedPasswordResetAtNextLogin;
    }
    return json;
  }
}

/// Dynamic writeable type for Dashboard removes:
/// can, content_favorite_id, content_metadata_id, id, model, readonly, refresh_interval_to_i, user_id, created_at, dashboard_elements, dashboard_filters, dashboard_layouts, deleted_at, deleter_id, edit_uri, favorite_count, last_accessed_at, last_viewed_at, updated_at, last_updater_id, last_updater_name, user_name, view_count, url
class WriteDashboard {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _description;
  bool _descriptionSet = false;

  bool _hidden;
  bool _hiddenSet = false;

  String _queryTimezone;
  bool _queryTimezoneSet = false;

  String _refreshInterval;
  bool _refreshIntervalSet = false;

  WriteFolderBase _folder;
  bool _folderSet = false;

  String _title;
  bool _titleSet = false;

  String _slug;
  bool _slugSet = false;

  String _preferredViewer;
  bool _preferredViewerSet = false;

  bool _alertSyncWithDashboardFilterEnabled;
  bool _alertSyncWithDashboardFilterEnabledSet = false;

  String _backgroundColor;
  bool _backgroundColorSet = false;

  bool _crossfilterEnabled;
  bool _crossfilterEnabledSet = false;

  bool _deleted;
  bool _deletedSet = false;

  bool _filtersBarCollapsed;
  bool _filtersBarCollapsedSet = false;

  String _loadConfiguration;
  bool _loadConfigurationSet = false;

  String _lookmlLinkId;
  bool _lookmlLinkIdSet = false;

  bool _showFiltersBar;
  bool _showFiltersBarSet = false;

  bool _showTitle;
  bool _showTitleSet = false;

  String _folderId;
  bool _folderIdSet = false;

  String _textTileTextColor;
  bool _textTileTextColorSet = false;

  String _tileBackgroundColor;
  bool _tileBackgroundColorSet = false;

  String _tileTextColor;
  bool _tileTextColorSet = false;

  String _titleColor;
  bool _titleColorSet = false;

  DashboardAppearance _appearance;
  bool _appearanceSet = false;

  /// Description

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// Is Hidden

  bool get hidden {
    if (!_hiddenSet && _apiMapResponse.containsKey('hidden')) {
      _hidden = _apiMapResponse['hidden'];
      _hiddenSet = true;
    }
    return _hidden;
  }

  set hidden(bool v) {
    _hidden = v;
    _hiddenSet = true;
  }

  /// Timezone in which the Dashboard will run by default.

  String get queryTimezone {
    if (!_queryTimezoneSet && _apiMapResponse.containsKey('query_timezone')) {
      _queryTimezone = _apiMapResponse['query_timezone']?.toString();
      _queryTimezoneSet = true;
    }
    return _queryTimezone;
  }

  set queryTimezone(String v) {
    _queryTimezone = v;
    _queryTimezoneSet = true;
  }

  /// Refresh Interval, as a time duration phrase like "2 hours 30 minutes". A number with no time units will be interpreted as whole seconds.

  String get refreshInterval {
    if (!_refreshIntervalSet &&
        _apiMapResponse.containsKey('refresh_interval')) {
      _refreshInterval = _apiMapResponse['refresh_interval']?.toString();
      _refreshIntervalSet = true;
    }
    return _refreshInterval;
  }

  set refreshInterval(String v) {
    _refreshInterval = v;
    _refreshIntervalSet = true;
  }

  /// Dynamic writeable type for FolderBase removes:
  /// id, content_metadata_id, created_at, creator_id, child_count, external_id, is_embed, is_embed_shared_root, is_embed_users_root, is_personal, is_personal_descendant, is_shared_root, is_users_root, can

  WriteFolderBase get folder {
    if (!_folderSet && _apiMapResponse.containsKey('folder')) {
      _folder = _apiMapResponse['folder'] == null
          ? null
          : WriteFolderBase.fromResponse(
              _apiMapResponse['folder'], apiResponseContentType);
      _folderSet = true;
    }
    return _folder;
  }

  set folder(WriteFolderBase v) {
    _folder = v;
    _folderSet = true;
  }

  /// Dashboard Title

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Content Metadata Slug

  String get slug {
    if (!_slugSet && _apiMapResponse.containsKey('slug')) {
      _slug = _apiMapResponse['slug']?.toString();
      _slugSet = true;
    }
    return _slug;
  }

  set slug(String v) {
    _slug = v;
    _slugSet = true;
  }

  /// The preferred route for viewing this dashboard (ie: dashboards or dashboards-next)

  String get preferredViewer {
    if (!_preferredViewerSet &&
        _apiMapResponse.containsKey('preferred_viewer')) {
      _preferredViewer = _apiMapResponse['preferred_viewer']?.toString();
      _preferredViewerSet = true;
    }
    return _preferredViewer;
  }

  set preferredViewer(String v) {
    _preferredViewer = v;
    _preferredViewerSet = true;
  }

  /// Enables alerts to keep in sync with dashboard filter changes

  bool get alertSyncWithDashboardFilterEnabled {
    if (!_alertSyncWithDashboardFilterEnabledSet &&
        _apiMapResponse
            .containsKey('alert_sync_with_dashboard_filter_enabled')) {
      _alertSyncWithDashboardFilterEnabled =
          _apiMapResponse['alert_sync_with_dashboard_filter_enabled'];
      _alertSyncWithDashboardFilterEnabledSet = true;
    }
    return _alertSyncWithDashboardFilterEnabled;
  }

  set alertSyncWithDashboardFilterEnabled(bool v) {
    _alertSyncWithDashboardFilterEnabled = v;
    _alertSyncWithDashboardFilterEnabledSet = true;
  }

  /// Background color

  String get backgroundColor {
    if (!_backgroundColorSet &&
        _apiMapResponse.containsKey('background_color')) {
      _backgroundColor = _apiMapResponse['background_color']?.toString();
      _backgroundColorSet = true;
    }
    return _backgroundColor;
  }

  set backgroundColor(String v) {
    _backgroundColor = v;
    _backgroundColorSet = true;
  }

  /// Enables crossfiltering in dashboards - only available in dashboards-next (beta)

  bool get crossfilterEnabled {
    if (!_crossfilterEnabledSet &&
        _apiMapResponse.containsKey('crossfilter_enabled')) {
      _crossfilterEnabled = _apiMapResponse['crossfilter_enabled'];
      _crossfilterEnabledSet = true;
    }
    return _crossfilterEnabled;
  }

  set crossfilterEnabled(bool v) {
    _crossfilterEnabled = v;
    _crossfilterEnabledSet = true;
  }

  /// Whether or not a dashboard is 'soft' deleted.

  bool get deleted {
    if (!_deletedSet && _apiMapResponse.containsKey('deleted')) {
      _deleted = _apiMapResponse['deleted'];
      _deletedSet = true;
    }
    return _deleted;
  }

  set deleted(bool v) {
    _deleted = v;
    _deletedSet = true;
  }

  /// Sets the default state of the filters bar to collapsed or open

  bool get filtersBarCollapsed {
    if (!_filtersBarCollapsedSet &&
        _apiMapResponse.containsKey('filters_bar_collapsed')) {
      _filtersBarCollapsed = _apiMapResponse['filters_bar_collapsed'];
      _filtersBarCollapsedSet = true;
    }
    return _filtersBarCollapsed;
  }

  set filtersBarCollapsed(bool v) {
    _filtersBarCollapsed = v;
    _filtersBarCollapsedSet = true;
  }

  /// configuration option that governs how dashboard loading will happen.

  String get loadConfiguration {
    if (!_loadConfigurationSet &&
        _apiMapResponse.containsKey('load_configuration')) {
      _loadConfiguration = _apiMapResponse['load_configuration']?.toString();
      _loadConfigurationSet = true;
    }
    return _loadConfiguration;
  }

  set loadConfiguration(String v) {
    _loadConfiguration = v;
    _loadConfigurationSet = true;
  }

  /// Links this dashboard to a particular LookML dashboard such that calling a **sync** operation on that LookML dashboard will update this dashboard to match.

  String get lookmlLinkId {
    if (!_lookmlLinkIdSet && _apiMapResponse.containsKey('lookml_link_id')) {
      _lookmlLinkId = _apiMapResponse['lookml_link_id']?.toString();
      _lookmlLinkIdSet = true;
    }
    return _lookmlLinkId;
  }

  set lookmlLinkId(String v) {
    _lookmlLinkId = v;
    _lookmlLinkIdSet = true;
  }

  /// Show filters bar.  **Security Note:** This property only affects the *cosmetic* appearance of the dashboard, not a user's ability to access data. Hiding the filters bar does **NOT** prevent users from changing filters by other means. For information on how to set up secure data access control policies, see [Control User Access to Data](https://looker.com/docs/r/api/control-access)

  bool get showFiltersBar {
    if (!_showFiltersBarSet &&
        _apiMapResponse.containsKey('show_filters_bar')) {
      _showFiltersBar = _apiMapResponse['show_filters_bar'];
      _showFiltersBarSet = true;
    }
    return _showFiltersBar;
  }

  set showFiltersBar(bool v) {
    _showFiltersBar = v;
    _showFiltersBarSet = true;
  }

  /// Show title

  bool get showTitle {
    if (!_showTitleSet && _apiMapResponse.containsKey('show_title')) {
      _showTitle = _apiMapResponse['show_title'];
      _showTitleSet = true;
    }
    return _showTitle;
  }

  set showTitle(bool v) {
    _showTitle = v;
    _showTitleSet = true;
  }

  /// Id of folder

  String get folderId {
    if (!_folderIdSet && _apiMapResponse.containsKey('folder_id')) {
      _folderId = _apiMapResponse['folder_id']?.toString();
      _folderIdSet = true;
    }
    return _folderId;
  }

  set folderId(String v) {
    _folderId = v;
    _folderIdSet = true;
  }

  /// Color of text on text tiles

  String get textTileTextColor {
    if (!_textTileTextColorSet &&
        _apiMapResponse.containsKey('text_tile_text_color')) {
      _textTileTextColor = _apiMapResponse['text_tile_text_color']?.toString();
      _textTileTextColorSet = true;
    }
    return _textTileTextColor;
  }

  set textTileTextColor(String v) {
    _textTileTextColor = v;
    _textTileTextColorSet = true;
  }

  /// Tile background color

  String get tileBackgroundColor {
    if (!_tileBackgroundColorSet &&
        _apiMapResponse.containsKey('tile_background_color')) {
      _tileBackgroundColor =
          _apiMapResponse['tile_background_color']?.toString();
      _tileBackgroundColorSet = true;
    }
    return _tileBackgroundColor;
  }

  set tileBackgroundColor(String v) {
    _tileBackgroundColor = v;
    _tileBackgroundColorSet = true;
  }

  /// Tile text color

  String get tileTextColor {
    if (!_tileTextColorSet && _apiMapResponse.containsKey('tile_text_color')) {
      _tileTextColor = _apiMapResponse['tile_text_color']?.toString();
      _tileTextColorSet = true;
    }
    return _tileTextColor;
  }

  set tileTextColor(String v) {
    _tileTextColor = v;
    _tileTextColorSet = true;
  }

  /// Title color

  String get titleColor {
    if (!_titleColorSet && _apiMapResponse.containsKey('title_color')) {
      _titleColor = _apiMapResponse['title_color']?.toString();
      _titleColorSet = true;
    }
    return _titleColor;
  }

  set titleColor(String v) {
    _titleColor = v;
    _titleColorSet = true;
  }

  DashboardAppearance get appearance {
    if (!_appearanceSet && _apiMapResponse.containsKey('appearance')) {
      _appearance = _apiMapResponse['appearance'] == null
          ? null
          : DashboardAppearance.fromResponse(
              _apiMapResponse['appearance'], apiResponseContentType);
      _appearanceSet = true;
    }
    return _appearance;
  }

  set appearance(DashboardAppearance v) {
    _appearance = v;
    _appearanceSet = true;
  }

  WriteDashboard() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteDashboard.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_hiddenSet || _apiMapResponse.containsKey('hidden')) {
      json['hidden'] = hidden;
    }
    if (_queryTimezoneSet || _apiMapResponse.containsKey('query_timezone')) {
      json['query_timezone'] = queryTimezone;
    }
    if (_refreshIntervalSet ||
        _apiMapResponse.containsKey('refresh_interval')) {
      json['refresh_interval'] = refreshInterval;
    }
    if (_folderSet || _apiMapResponse.containsKey('folder')) {
      json['folder'] = folder?.toJson();
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_slugSet || _apiMapResponse.containsKey('slug')) {
      json['slug'] = slug;
    }
    if (_preferredViewerSet ||
        _apiMapResponse.containsKey('preferred_viewer')) {
      json['preferred_viewer'] = preferredViewer;
    }
    if (_alertSyncWithDashboardFilterEnabledSet ||
        _apiMapResponse
            .containsKey('alert_sync_with_dashboard_filter_enabled')) {
      json['alert_sync_with_dashboard_filter_enabled'] =
          alertSyncWithDashboardFilterEnabled;
    }
    if (_backgroundColorSet ||
        _apiMapResponse.containsKey('background_color')) {
      json['background_color'] = backgroundColor;
    }
    if (_crossfilterEnabledSet ||
        _apiMapResponse.containsKey('crossfilter_enabled')) {
      json['crossfilter_enabled'] = crossfilterEnabled;
    }
    if (_deletedSet || _apiMapResponse.containsKey('deleted')) {
      json['deleted'] = deleted;
    }
    if (_filtersBarCollapsedSet ||
        _apiMapResponse.containsKey('filters_bar_collapsed')) {
      json['filters_bar_collapsed'] = filtersBarCollapsed;
    }
    if (_loadConfigurationSet ||
        _apiMapResponse.containsKey('load_configuration')) {
      json['load_configuration'] = loadConfiguration;
    }
    if (_lookmlLinkIdSet || _apiMapResponse.containsKey('lookml_link_id')) {
      json['lookml_link_id'] = lookmlLinkId;
    }
    if (_showFiltersBarSet || _apiMapResponse.containsKey('show_filters_bar')) {
      json['show_filters_bar'] = showFiltersBar;
    }
    if (_showTitleSet || _apiMapResponse.containsKey('show_title')) {
      json['show_title'] = showTitle;
    }
    if (_folderIdSet || _apiMapResponse.containsKey('folder_id')) {
      json['folder_id'] = folderId;
    }
    if (_textTileTextColorSet ||
        _apiMapResponse.containsKey('text_tile_text_color')) {
      json['text_tile_text_color'] = textTileTextColor;
    }
    if (_tileBackgroundColorSet ||
        _apiMapResponse.containsKey('tile_background_color')) {
      json['tile_background_color'] = tileBackgroundColor;
    }
    if (_tileTextColorSet || _apiMapResponse.containsKey('tile_text_color')) {
      json['tile_text_color'] = tileTextColor;
    }
    if (_titleColorSet || _apiMapResponse.containsKey('title_color')) {
      json['title_color'] = titleColor;
    }
    if (_appearanceSet || _apiMapResponse.containsKey('appearance')) {
      json['appearance'] = appearance?.toJson();
    }
    return json;
  }
}

/// Dynamic writeable type for DashboardBase removes:
/// can, content_favorite_id, content_metadata_id, description, hidden, id, model, query_timezone, readonly, refresh_interval, refresh_interval_to_i, title, user_id, slug, preferred_viewer
class WriteDashboardBase {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  WriteFolderBase _folder;
  bool _folderSet = false;

  /// Dynamic writeable type for FolderBase removes:
  /// id, content_metadata_id, created_at, creator_id, child_count, external_id, is_embed, is_embed_shared_root, is_embed_users_root, is_personal, is_personal_descendant, is_shared_root, is_users_root, can

  WriteFolderBase get folder {
    if (!_folderSet && _apiMapResponse.containsKey('folder')) {
      _folder = _apiMapResponse['folder'] == null
          ? null
          : WriteFolderBase.fromResponse(
              _apiMapResponse['folder'], apiResponseContentType);
      _folderSet = true;
    }
    return _folder;
  }

  set folder(WriteFolderBase v) {
    _folder = v;
    _folderSet = true;
  }

  WriteDashboardBase() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteDashboardBase.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_folderSet || _apiMapResponse.containsKey('folder')) {
      json['folder'] = folder?.toJson();
    }
    return json;
  }
}

/// Dynamic writeable type for DashboardElement removes:
/// can, body_text_as_html, edit_uri, id, lookml_link_id, note_text_as_html, refresh_interval_to_i, alert_count, title_text_as_html, subtitle_text_as_html
class WriteDashboardElement {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _bodyText;
  bool _bodyTextSet = false;

  String _dashboardId;
  bool _dashboardIdSet = false;

  WriteLookWithQuery _look;
  bool _lookSet = false;

  String _lookId;
  bool _lookIdSet = false;

  String _mergeResultId;
  bool _mergeResultIdSet = false;

  String _noteDisplay;
  bool _noteDisplaySet = false;

  String _noteState;
  bool _noteStateSet = false;

  String _noteText;
  bool _noteTextSet = false;

  WriteQuery _query;
  bool _querySet = false;

  int _queryId;
  bool _queryIdSet = false;

  String _refreshInterval;
  bool _refreshIntervalSet = false;

  WriteResultMakerWithIdVisConfigAndDynamicFields _resultMaker;
  bool _resultMakerSet = false;

  int _resultMakerId;
  bool _resultMakerIdSet = false;

  String _subtitleText;
  bool _subtitleTextSet = false;

  String _title;
  bool _titleSet = false;

  bool _titleHidden;
  bool _titleHiddenSet = false;

  String _titleText;
  bool _titleTextSet = false;

  String _type;
  bool _typeSet = false;

  /// Text tile body text

  String get bodyText {
    if (!_bodyTextSet && _apiMapResponse.containsKey('body_text')) {
      _bodyText = _apiMapResponse['body_text']?.toString();
      _bodyTextSet = true;
    }
    return _bodyText;
  }

  set bodyText(String v) {
    _bodyText = v;
    _bodyTextSet = true;
  }

  /// Id of Dashboard

  String get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id']?.toString();
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(String v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// Dynamic writeable type for LookWithQuery removes:
  /// can, content_metadata_id, id, content_favorite_id, created_at, deleted_at, deleter_id, embed_url, excel_file_url, favorite_count, google_spreadsheet_formula, image_embed_url, last_accessed_at, last_updater_id, last_viewed_at, model, public_slug, public_url, short_url, updated_at, view_count, url

  WriteLookWithQuery get look {
    if (!_lookSet && _apiMapResponse.containsKey('look')) {
      _look = _apiMapResponse['look'] == null
          ? null
          : WriteLookWithQuery.fromResponse(
              _apiMapResponse['look'], apiResponseContentType);
      _lookSet = true;
    }
    return _look;
  }

  set look(WriteLookWithQuery v) {
    _look = v;
    _lookSet = true;
  }

  /// Id Of Look

  String get lookId {
    if (!_lookIdSet && _apiMapResponse.containsKey('look_id')) {
      _lookId = _apiMapResponse['look_id']?.toString();
      _lookIdSet = true;
    }
    return _lookId;
  }

  set lookId(String v) {
    _lookId = v;
    _lookIdSet = true;
  }

  /// ID of merge result

  String get mergeResultId {
    if (!_mergeResultIdSet && _apiMapResponse.containsKey('merge_result_id')) {
      _mergeResultId = _apiMapResponse['merge_result_id']?.toString();
      _mergeResultIdSet = true;
    }
    return _mergeResultId;
  }

  set mergeResultId(String v) {
    _mergeResultId = v;
    _mergeResultIdSet = true;
  }

  /// Note Display

  String get noteDisplay {
    if (!_noteDisplaySet && _apiMapResponse.containsKey('note_display')) {
      _noteDisplay = _apiMapResponse['note_display']?.toString();
      _noteDisplaySet = true;
    }
    return _noteDisplay;
  }

  set noteDisplay(String v) {
    _noteDisplay = v;
    _noteDisplaySet = true;
  }

  /// Note State

  String get noteState {
    if (!_noteStateSet && _apiMapResponse.containsKey('note_state')) {
      _noteState = _apiMapResponse['note_state']?.toString();
      _noteStateSet = true;
    }
    return _noteState;
  }

  set noteState(String v) {
    _noteState = v;
    _noteStateSet = true;
  }

  /// Note Text

  String get noteText {
    if (!_noteTextSet && _apiMapResponse.containsKey('note_text')) {
      _noteText = _apiMapResponse['note_text']?.toString();
      _noteTextSet = true;
    }
    return _noteText;
  }

  set noteText(String v) {
    _noteText = v;
    _noteTextSet = true;
  }

  /// Dynamic writeable type for Query removes:
  /// can, id, slug, share_url, expanded_share_url, url, has_table_calculations

  WriteQuery get query {
    if (!_querySet && _apiMapResponse.containsKey('query')) {
      _query = _apiMapResponse['query'] == null
          ? null
          : WriteQuery.fromResponse(
              _apiMapResponse['query'], apiResponseContentType);
      _querySet = true;
    }
    return _query;
  }

  set query(WriteQuery v) {
    _query = v;
    _querySet = true;
  }

  /// Id Of Query

  int get queryId {
    if (!_queryIdSet && _apiMapResponse.containsKey('query_id')) {
      _queryId = _apiMapResponse['query_id'];
      _queryIdSet = true;
    }
    return _queryId;
  }

  set queryId(int v) {
    _queryId = v;
    _queryIdSet = true;
  }

  /// Refresh Interval

  String get refreshInterval {
    if (!_refreshIntervalSet &&
        _apiMapResponse.containsKey('refresh_interval')) {
      _refreshInterval = _apiMapResponse['refresh_interval']?.toString();
      _refreshIntervalSet = true;
    }
    return _refreshInterval;
  }

  set refreshInterval(String v) {
    _refreshInterval = v;
    _refreshIntervalSet = true;
  }

  /// Dynamic writeable type for ResultMakerWithIdVisConfigAndDynamicFields removes:
  /// id, dynamic_fields, filterables, sorts, merge_result_id, total, query_id, sql_query_id, vis_config

  WriteResultMakerWithIdVisConfigAndDynamicFields get resultMaker {
    if (!_resultMakerSet && _apiMapResponse.containsKey('result_maker')) {
      _resultMaker = _apiMapResponse['result_maker'] == null
          ? null
          : WriteResultMakerWithIdVisConfigAndDynamicFields.fromResponse(
              _apiMapResponse['result_maker'], apiResponseContentType);
      _resultMakerSet = true;
    }
    return _resultMaker;
  }

  set resultMaker(WriteResultMakerWithIdVisConfigAndDynamicFields v) {
    _resultMaker = v;
    _resultMakerSet = true;
  }

  /// ID of the ResultMakerLookup entry.

  int get resultMakerId {
    if (!_resultMakerIdSet && _apiMapResponse.containsKey('result_maker_id')) {
      _resultMakerId = _apiMapResponse['result_maker_id'];
      _resultMakerIdSet = true;
    }
    return _resultMakerId;
  }

  set resultMakerId(int v) {
    _resultMakerId = v;
    _resultMakerIdSet = true;
  }

  /// Text tile subtitle text

  String get subtitleText {
    if (!_subtitleTextSet && _apiMapResponse.containsKey('subtitle_text')) {
      _subtitleText = _apiMapResponse['subtitle_text']?.toString();
      _subtitleTextSet = true;
    }
    return _subtitleText;
  }

  set subtitleText(String v) {
    _subtitleText = v;
    _subtitleTextSet = true;
  }

  /// Title of dashboard element

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Whether title is hidden

  bool get titleHidden {
    if (!_titleHiddenSet && _apiMapResponse.containsKey('title_hidden')) {
      _titleHidden = _apiMapResponse['title_hidden'];
      _titleHiddenSet = true;
    }
    return _titleHidden;
  }

  set titleHidden(bool v) {
    _titleHidden = v;
    _titleHiddenSet = true;
  }

  /// Text tile title

  String get titleText {
    if (!_titleTextSet && _apiMapResponse.containsKey('title_text')) {
      _titleText = _apiMapResponse['title_text']?.toString();
      _titleTextSet = true;
    }
    return _titleText;
  }

  set titleText(String v) {
    _titleText = v;
    _titleTextSet = true;
  }

  /// Type

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  WriteDashboardElement() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteDashboardElement.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_bodyTextSet || _apiMapResponse.containsKey('body_text')) {
      json['body_text'] = bodyText;
    }
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_lookSet || _apiMapResponse.containsKey('look')) {
      json['look'] = look?.toJson();
    }
    if (_lookIdSet || _apiMapResponse.containsKey('look_id')) {
      json['look_id'] = lookId;
    }
    if (_mergeResultIdSet || _apiMapResponse.containsKey('merge_result_id')) {
      json['merge_result_id'] = mergeResultId;
    }
    if (_noteDisplaySet || _apiMapResponse.containsKey('note_display')) {
      json['note_display'] = noteDisplay;
    }
    if (_noteStateSet || _apiMapResponse.containsKey('note_state')) {
      json['note_state'] = noteState;
    }
    if (_noteTextSet || _apiMapResponse.containsKey('note_text')) {
      json['note_text'] = noteText;
    }
    if (_querySet || _apiMapResponse.containsKey('query')) {
      json['query'] = query?.toJson();
    }
    if (_queryIdSet || _apiMapResponse.containsKey('query_id')) {
      json['query_id'] = queryId;
    }
    if (_refreshIntervalSet ||
        _apiMapResponse.containsKey('refresh_interval')) {
      json['refresh_interval'] = refreshInterval;
    }
    if (_resultMakerSet || _apiMapResponse.containsKey('result_maker')) {
      json['result_maker'] = resultMaker?.toJson();
    }
    if (_resultMakerIdSet || _apiMapResponse.containsKey('result_maker_id')) {
      json['result_maker_id'] = resultMakerId;
    }
    if (_subtitleTextSet || _apiMapResponse.containsKey('subtitle_text')) {
      json['subtitle_text'] = subtitleText;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_titleHiddenSet || _apiMapResponse.containsKey('title_hidden')) {
      json['title_hidden'] = titleHidden;
    }
    if (_titleTextSet || _apiMapResponse.containsKey('title_text')) {
      json['title_text'] = titleText;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    return json;
  }
}

/// Dynamic writeable type for DashboardFilter removes:
/// can, id, dashboard_id, field
class WriteDashboardFilter {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _title;
  bool _titleSet = false;

  String _type;
  bool _typeSet = false;

  String _defaultValue;
  bool _defaultValueSet = false;

  String _model;
  bool _modelSet = false;

  String _explore;
  bool _exploreSet = false;

  String _dimension;
  bool _dimensionSet = false;

  int _row;
  bool _rowSet = false;

  List<String> _listensToFilters;
  bool _listensToFiltersSet = false;

  bool _allowMultipleValues;
  bool _allowMultipleValuesSet = false;

  bool _required;
  bool _requiredSet = false;

  Map<String, dynamic> _uiConfig;
  bool _uiConfigSet = false;

  /// Name of filter

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Title of filter

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// Type of filter: one of date, number, string, or field

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Default value of filter

  String get defaultValue {
    if (!_defaultValueSet && _apiMapResponse.containsKey('default_value')) {
      _defaultValue = _apiMapResponse['default_value']?.toString();
      _defaultValueSet = true;
    }
    return _defaultValue;
  }

  set defaultValue(String v) {
    _defaultValue = v;
    _defaultValueSet = true;
  }

  /// Model of filter (required if type = field)

  String get model {
    if (!_modelSet && _apiMapResponse.containsKey('model')) {
      _model = _apiMapResponse['model']?.toString();
      _modelSet = true;
    }
    return _model;
  }

  set model(String v) {
    _model = v;
    _modelSet = true;
  }

  /// Explore of filter (required if type = field)

  String get explore {
    if (!_exploreSet && _apiMapResponse.containsKey('explore')) {
      _explore = _apiMapResponse['explore']?.toString();
      _exploreSet = true;
    }
    return _explore;
  }

  set explore(String v) {
    _explore = v;
    _exploreSet = true;
  }

  /// Dimension of filter (required if type = field)

  String get dimension {
    if (!_dimensionSet && _apiMapResponse.containsKey('dimension')) {
      _dimension = _apiMapResponse['dimension']?.toString();
      _dimensionSet = true;
    }
    return _dimension;
  }

  set dimension(String v) {
    _dimension = v;
    _dimensionSet = true;
  }

  /// Display order of this filter relative to other filters

  int get row {
    if (!_rowSet && _apiMapResponse.containsKey('row')) {
      _row = _apiMapResponse['row'];
      _rowSet = true;
    }
    return _row;
  }

  set row(int v) {
    _row = v;
    _rowSet = true;
  }

  /// Array of listeners for faceted filters

  List<String> get listensToFilters {
    if (!_listensToFiltersSet &&
        _apiMapResponse.containsKey('listens_to_filters')) {
      _listensToFilters = _apiMapResponse['listens_to_filters']
          ?.map<String>((i) => i as String)
          ?.toList();
      _listensToFiltersSet = true;
    }
    return _listensToFilters;
  }

  set listensToFilters(List<String> v) {
    _listensToFilters = v;
    _listensToFiltersSet = true;
  }

  /// Whether the filter allows multiple filter values (deprecated in the latest version of dashboards)

  bool get allowMultipleValues {
    if (!_allowMultipleValuesSet &&
        _apiMapResponse.containsKey('allow_multiple_values')) {
      _allowMultipleValues = _apiMapResponse['allow_multiple_values'];
      _allowMultipleValuesSet = true;
    }
    return _allowMultipleValues;
  }

  set allowMultipleValues(bool v) {
    _allowMultipleValues = v;
    _allowMultipleValuesSet = true;
  }

  /// Whether the filter requires a value to run the dashboard

  bool get required {
    if (!_requiredSet && _apiMapResponse.containsKey('required')) {
      _required = _apiMapResponse['required'];
      _requiredSet = true;
    }
    return _required;
  }

  set required(bool v) {
    _required = v;
    _requiredSet = true;
  }

  /// The visual configuration for this filter. Used to set up how the UI for this filter should appear.

  Map<String, dynamic> get uiConfig {
    if (!_uiConfigSet && _apiMapResponse.containsKey('ui_config')) {
      _uiConfig = _apiMapResponse['ui_config'];
      _uiConfigSet = true;
    }
    return _uiConfig;
  }

  set uiConfig(Map<String, dynamic> v) {
    _uiConfig = v;
    _uiConfigSet = true;
  }

  WriteDashboardFilter() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteDashboardFilter.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_defaultValueSet || _apiMapResponse.containsKey('default_value')) {
      json['default_value'] = defaultValue;
    }
    if (_modelSet || _apiMapResponse.containsKey('model')) {
      json['model'] = model;
    }
    if (_exploreSet || _apiMapResponse.containsKey('explore')) {
      json['explore'] = explore;
    }
    if (_dimensionSet || _apiMapResponse.containsKey('dimension')) {
      json['dimension'] = dimension;
    }
    if (_rowSet || _apiMapResponse.containsKey('row')) {
      json['row'] = row;
    }
    if (_listensToFiltersSet ||
        _apiMapResponse.containsKey('listens_to_filters')) {
      json['listens_to_filters'] = listensToFilters;
    }
    if (_allowMultipleValuesSet ||
        _apiMapResponse.containsKey('allow_multiple_values')) {
      json['allow_multiple_values'] = allowMultipleValues;
    }
    if (_requiredSet || _apiMapResponse.containsKey('required')) {
      json['required'] = required;
    }
    if (_uiConfigSet || _apiMapResponse.containsKey('ui_config')) {
      json['ui_config'] = uiConfig;
    }
    return json;
  }
}

/// Dynamic writeable type for DashboardLayout removes:
/// can, id, deleted, dashboard_title, dashboard_layout_components
class WriteDashboardLayout {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _dashboardId;
  bool _dashboardIdSet = false;

  String _type;
  bool _typeSet = false;

  bool _active;
  bool _activeSet = false;

  int _columnWidth;
  bool _columnWidthSet = false;

  int _width;
  bool _widthSet = false;

  /// Id of Dashboard

  String get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id']?.toString();
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(String v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// Type

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Is Active

  bool get active {
    if (!_activeSet && _apiMapResponse.containsKey('active')) {
      _active = _apiMapResponse['active'];
      _activeSet = true;
    }
    return _active;
  }

  set active(bool v) {
    _active = v;
    _activeSet = true;
  }

  /// Column Width

  int get columnWidth {
    if (!_columnWidthSet && _apiMapResponse.containsKey('column_width')) {
      _columnWidth = _apiMapResponse['column_width'];
      _columnWidthSet = true;
    }
    return _columnWidth;
  }

  set columnWidth(int v) {
    _columnWidth = v;
    _columnWidthSet = true;
  }

  /// Width

  int get width {
    if (!_widthSet && _apiMapResponse.containsKey('width')) {
      _width = _apiMapResponse['width'];
      _widthSet = true;
    }
    return _width;
  }

  set width(int v) {
    _width = v;
    _widthSet = true;
  }

  WriteDashboardLayout() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteDashboardLayout.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_activeSet || _apiMapResponse.containsKey('active')) {
      json['active'] = active;
    }
    if (_columnWidthSet || _apiMapResponse.containsKey('column_width')) {
      json['column_width'] = columnWidth;
    }
    if (_widthSet || _apiMapResponse.containsKey('width')) {
      json['width'] = width;
    }
    return json;
  }
}

/// Dynamic writeable type for DashboardLayoutComponent removes:
/// can, id, deleted, element_title, element_title_hidden, vis_type
class WriteDashboardLayoutComponent {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _dashboardLayoutId;
  bool _dashboardLayoutIdSet = false;

  String _dashboardElementId;
  bool _dashboardElementIdSet = false;

  int _row;
  bool _rowSet = false;

  int _column;
  bool _columnSet = false;

  int _width;
  bool _widthSet = false;

  int _height;
  bool _heightSet = false;

  /// Id of Dashboard Layout

  String get dashboardLayoutId {
    if (!_dashboardLayoutIdSet &&
        _apiMapResponse.containsKey('dashboard_layout_id')) {
      _dashboardLayoutId = _apiMapResponse['dashboard_layout_id']?.toString();
      _dashboardLayoutIdSet = true;
    }
    return _dashboardLayoutId;
  }

  set dashboardLayoutId(String v) {
    _dashboardLayoutId = v;
    _dashboardLayoutIdSet = true;
  }

  /// Id Of Dashboard Element

  String get dashboardElementId {
    if (!_dashboardElementIdSet &&
        _apiMapResponse.containsKey('dashboard_element_id')) {
      _dashboardElementId = _apiMapResponse['dashboard_element_id']?.toString();
      _dashboardElementIdSet = true;
    }
    return _dashboardElementId;
  }

  set dashboardElementId(String v) {
    _dashboardElementId = v;
    _dashboardElementIdSet = true;
  }

  /// Row

  int get row {
    if (!_rowSet && _apiMapResponse.containsKey('row')) {
      _row = _apiMapResponse['row'];
      _rowSet = true;
    }
    return _row;
  }

  set row(int v) {
    _row = v;
    _rowSet = true;
  }

  /// Column

  int get column {
    if (!_columnSet && _apiMapResponse.containsKey('column')) {
      _column = _apiMapResponse['column'];
      _columnSet = true;
    }
    return _column;
  }

  set column(int v) {
    _column = v;
    _columnSet = true;
  }

  /// Width

  int get width {
    if (!_widthSet && _apiMapResponse.containsKey('width')) {
      _width = _apiMapResponse['width'];
      _widthSet = true;
    }
    return _width;
  }

  set width(int v) {
    _width = v;
    _widthSet = true;
  }

  /// Height

  int get height {
    if (!_heightSet && _apiMapResponse.containsKey('height')) {
      _height = _apiMapResponse['height'];
      _heightSet = true;
    }
    return _height;
  }

  set height(int v) {
    _height = v;
    _heightSet = true;
  }

  WriteDashboardLayoutComponent() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteDashboardLayoutComponent.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_dashboardLayoutIdSet ||
        _apiMapResponse.containsKey('dashboard_layout_id')) {
      json['dashboard_layout_id'] = dashboardLayoutId;
    }
    if (_dashboardElementIdSet ||
        _apiMapResponse.containsKey('dashboard_element_id')) {
      json['dashboard_element_id'] = dashboardElementId;
    }
    if (_rowSet || _apiMapResponse.containsKey('row')) {
      json['row'] = row;
    }
    if (_columnSet || _apiMapResponse.containsKey('column')) {
      json['column'] = column;
    }
    if (_widthSet || _apiMapResponse.containsKey('width')) {
      json['width'] = width;
    }
    if (_heightSet || _apiMapResponse.containsKey('height')) {
      json['height'] = height;
    }
    return json;
  }
}

/// Dynamic writeable type for Datagroup removes:
/// can, created_at, id, model_name, name, trigger_check_at, trigger_error, trigger_value
class WriteDatagroup {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _staleBefore;
  bool _staleBeforeSet = false;

  int _triggeredAt;
  bool _triggeredAtSet = false;

  /// UNIX timestamp before which cache entries are considered stale. Cannot be in the future.

  int get staleBefore {
    if (!_staleBeforeSet && _apiMapResponse.containsKey('stale_before')) {
      _staleBefore = _apiMapResponse['stale_before'];
      _staleBeforeSet = true;
    }
    return _staleBefore;
  }

  set staleBefore(int v) {
    _staleBefore = v;
    _staleBeforeSet = true;
  }

  /// UNIX timestamp at which this entry became triggered. Cannot be in the future.

  int get triggeredAt {
    if (!_triggeredAtSet && _apiMapResponse.containsKey('triggered_at')) {
      _triggeredAt = _apiMapResponse['triggered_at'];
      _triggeredAtSet = true;
    }
    return _triggeredAt;
  }

  set triggeredAt(int v) {
    _triggeredAt = v;
    _triggeredAtSet = true;
  }

  WriteDatagroup() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteDatagroup.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_staleBeforeSet || _apiMapResponse.containsKey('stale_before')) {
      json['stale_before'] = staleBefore;
    }
    if (_triggeredAtSet || _apiMapResponse.containsKey('triggered_at')) {
      json['triggered_at'] = triggeredAt;
    }
    return json;
  }
}

/// Dynamic writeable type for DBConnection removes:
/// can, dialect, snippets, pdts_enabled, uses_oauth, created_at, user_id, example, last_regen_at, last_reap_at, managed
class WriteDBConnection {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _host;
  bool _hostSet = false;

  String _port;
  bool _portSet = false;

  String _username;
  bool _usernameSet = false;

  String _password;
  bool _passwordSet = false;

  String _certificate;
  bool _certificateSet = false;

  String _fileType;
  bool _fileTypeSet = false;

  String _database;
  bool _databaseSet = false;

  String _dbTimezone;
  bool _dbTimezoneSet = false;

  String _queryTimezone;
  bool _queryTimezoneSet = false;

  String _schema;
  bool _schemaSet = false;

  int _maxConnections;
  bool _maxConnectionsSet = false;

  String _maxBillingGigabytes;
  bool _maxBillingGigabytesSet = false;

  bool _ssl;
  bool _sslSet = false;

  bool _verifySsl;
  bool _verifySslSet = false;

  String _tmpDbName;
  bool _tmpDbNameSet = false;

  String _jdbcAdditionalParams;
  bool _jdbcAdditionalParamsSet = false;

  int _poolTimeout;
  bool _poolTimeoutSet = false;

  String _dialectName;
  bool _dialectNameSet = false;

  bool _userDbCredentials;
  bool _userDbCredentialsSet = false;

  List<String> _userAttributeFields;
  bool _userAttributeFieldsSet = false;

  String _maintenanceCron;
  bool _maintenanceCronSet = false;

  bool _sqlRunnerPrecacheTables;
  bool _sqlRunnerPrecacheTablesSet = false;

  bool _sqlWritingWithInfoSchema;
  bool _sqlWritingWithInfoSchemaSet = false;

  String _afterConnectStatements;
  bool _afterConnectStatementsSet = false;

  WriteDBConnectionOverride _pdtContextOverride;
  bool _pdtContextOverrideSet = false;

  String _tunnelId;
  bool _tunnelIdSet = false;

  int _pdtConcurrency;
  bool _pdtConcurrencySet = false;

  bool _disableContextComment;
  bool _disableContextCommentSet = false;

  int _oauthApplicationId;
  bool _oauthApplicationIdSet = false;

  bool _alwaysRetryFailedBuilds;
  bool _alwaysRetryFailedBuildsSet = false;

  /// Name of the connection. Also used as the unique identifier

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Host name/address of server

  String get host {
    if (!_hostSet && _apiMapResponse.containsKey('host')) {
      _host = _apiMapResponse['host']?.toString();
      _hostSet = true;
    }
    return _host;
  }

  set host(String v) {
    _host = v;
    _hostSet = true;
  }

  /// Port number on server

  String get port {
    if (!_portSet && _apiMapResponse.containsKey('port')) {
      _port = _apiMapResponse['port']?.toString();
      _portSet = true;
    }
    return _port;
  }

  set port(String v) {
    _port = v;
    _portSet = true;
  }

  /// Username for server authentication

  String get username {
    if (!_usernameSet && _apiMapResponse.containsKey('username')) {
      _username = _apiMapResponse['username']?.toString();
      _usernameSet = true;
    }
    return _username;
  }

  set username(String v) {
    _username = v;
    _usernameSet = true;
  }

  /// (Write-Only) Password for server authentication

  String get password {
    if (!_passwordSet && _apiMapResponse.containsKey('password')) {
      _password = _apiMapResponse['password']?.toString();
      _passwordSet = true;
    }
    return _password;
  }

  set password(String v) {
    _password = v;
    _passwordSet = true;
  }

  /// (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).

  String get certificate {
    if (!_certificateSet && _apiMapResponse.containsKey('certificate')) {
      _certificate = _apiMapResponse['certificate']?.toString();
      _certificateSet = true;
    }
    return _certificate;
  }

  set certificate(String v) {
    _certificate = v;
    _certificateSet = true;
  }

  /// (Write-Only) Certificate keyfile type - .json or .p12

  String get fileType {
    if (!_fileTypeSet && _apiMapResponse.containsKey('file_type')) {
      _fileType = _apiMapResponse['file_type']?.toString();
      _fileTypeSet = true;
    }
    return _fileType;
  }

  set fileType(String v) {
    _fileType = v;
    _fileTypeSet = true;
  }

  /// Database name

  String get database {
    if (!_databaseSet && _apiMapResponse.containsKey('database')) {
      _database = _apiMapResponse['database']?.toString();
      _databaseSet = true;
    }
    return _database;
  }

  set database(String v) {
    _database = v;
    _databaseSet = true;
  }

  /// Time zone of database

  String get dbTimezone {
    if (!_dbTimezoneSet && _apiMapResponse.containsKey('db_timezone')) {
      _dbTimezone = _apiMapResponse['db_timezone']?.toString();
      _dbTimezoneSet = true;
    }
    return _dbTimezone;
  }

  set dbTimezone(String v) {
    _dbTimezone = v;
    _dbTimezoneSet = true;
  }

  /// Timezone to use in queries

  String get queryTimezone {
    if (!_queryTimezoneSet && _apiMapResponse.containsKey('query_timezone')) {
      _queryTimezone = _apiMapResponse['query_timezone']?.toString();
      _queryTimezoneSet = true;
    }
    return _queryTimezone;
  }

  set queryTimezone(String v) {
    _queryTimezone = v;
    _queryTimezoneSet = true;
  }

  /// Scheme name

  String get schema {
    if (!_schemaSet && _apiMapResponse.containsKey('schema')) {
      _schema = _apiMapResponse['schema']?.toString();
      _schemaSet = true;
    }
    return _schema;
  }

  set schema(String v) {
    _schema = v;
    _schemaSet = true;
  }

  /// Maximum number of concurrent connection to use

  int get maxConnections {
    if (!_maxConnectionsSet && _apiMapResponse.containsKey('max_connections')) {
      _maxConnections = _apiMapResponse['max_connections'];
      _maxConnectionsSet = true;
    }
    return _maxConnections;
  }

  set maxConnections(int v) {
    _maxConnections = v;
    _maxConnectionsSet = true;
  }

  /// Maximum size of query in GBs (BigQuery only, can be a user_attribute name)

  String get maxBillingGigabytes {
    if (!_maxBillingGigabytesSet &&
        _apiMapResponse.containsKey('max_billing_gigabytes')) {
      _maxBillingGigabytes =
          _apiMapResponse['max_billing_gigabytes']?.toString();
      _maxBillingGigabytesSet = true;
    }
    return _maxBillingGigabytes;
  }

  set maxBillingGigabytes(String v) {
    _maxBillingGigabytes = v;
    _maxBillingGigabytesSet = true;
  }

  /// Use SSL/TLS when connecting to server

  bool get ssl {
    if (!_sslSet && _apiMapResponse.containsKey('ssl')) {
      _ssl = _apiMapResponse['ssl'];
      _sslSet = true;
    }
    return _ssl;
  }

  set ssl(bool v) {
    _ssl = v;
    _sslSet = true;
  }

  /// Verify the SSL

  bool get verifySsl {
    if (!_verifySslSet && _apiMapResponse.containsKey('verify_ssl')) {
      _verifySsl = _apiMapResponse['verify_ssl'];
      _verifySslSet = true;
    }
    return _verifySsl;
  }

  set verifySsl(bool v) {
    _verifySsl = v;
    _verifySslSet = true;
  }

  /// Name of temporary database (if used)

  String get tmpDbName {
    if (!_tmpDbNameSet && _apiMapResponse.containsKey('tmp_db_name')) {
      _tmpDbName = _apiMapResponse['tmp_db_name']?.toString();
      _tmpDbNameSet = true;
    }
    return _tmpDbName;
  }

  set tmpDbName(String v) {
    _tmpDbName = v;
    _tmpDbNameSet = true;
  }

  /// Additional params to add to JDBC connection string

  String get jdbcAdditionalParams {
    if (!_jdbcAdditionalParamsSet &&
        _apiMapResponse.containsKey('jdbc_additional_params')) {
      _jdbcAdditionalParams =
          _apiMapResponse['jdbc_additional_params']?.toString();
      _jdbcAdditionalParamsSet = true;
    }
    return _jdbcAdditionalParams;
  }

  set jdbcAdditionalParams(String v) {
    _jdbcAdditionalParams = v;
    _jdbcAdditionalParamsSet = true;
  }

  /// Connection Pool Timeout, in seconds

  int get poolTimeout {
    if (!_poolTimeoutSet && _apiMapResponse.containsKey('pool_timeout')) {
      _poolTimeout = _apiMapResponse['pool_timeout'];
      _poolTimeoutSet = true;
    }
    return _poolTimeout;
  }

  set poolTimeout(int v) {
    _poolTimeout = v;
    _poolTimeoutSet = true;
  }

  /// (Read/Write) SQL Dialect name

  String get dialectName {
    if (!_dialectNameSet && _apiMapResponse.containsKey('dialect_name')) {
      _dialectName = _apiMapResponse['dialect_name']?.toString();
      _dialectNameSet = true;
    }
    return _dialectName;
  }

  set dialectName(String v) {
    _dialectName = v;
    _dialectNameSet = true;
  }

  /// (Limited access feature) Are per user db credentials enabled. Enabling will remove previously set username and password

  bool get userDbCredentials {
    if (!_userDbCredentialsSet &&
        _apiMapResponse.containsKey('user_db_credentials')) {
      _userDbCredentials = _apiMapResponse['user_db_credentials'];
      _userDbCredentialsSet = true;
    }
    return _userDbCredentials;
  }

  set userDbCredentials(bool v) {
    _userDbCredentials = v;
    _userDbCredentialsSet = true;
  }

  /// Fields whose values map to user attribute names

  List<String> get userAttributeFields {
    if (!_userAttributeFieldsSet &&
        _apiMapResponse.containsKey('user_attribute_fields')) {
      _userAttributeFields = _apiMapResponse['user_attribute_fields']
          ?.map<String>((i) => i as String)
          ?.toList();
      _userAttributeFieldsSet = true;
    }
    return _userAttributeFields;
  }

  set userAttributeFields(List<String> v) {
    _userAttributeFields = v;
    _userAttributeFieldsSet = true;
  }

  /// Cron string specifying when maintenance such as PDT trigger checks and drops should be performed

  String get maintenanceCron {
    if (!_maintenanceCronSet &&
        _apiMapResponse.containsKey('maintenance_cron')) {
      _maintenanceCron = _apiMapResponse['maintenance_cron']?.toString();
      _maintenanceCronSet = true;
    }
    return _maintenanceCron;
  }

  set maintenanceCron(String v) {
    _maintenanceCron = v;
    _maintenanceCronSet = true;
  }

  /// Precache tables in the SQL Runner

  bool get sqlRunnerPrecacheTables {
    if (!_sqlRunnerPrecacheTablesSet &&
        _apiMapResponse.containsKey('sql_runner_precache_tables')) {
      _sqlRunnerPrecacheTables = _apiMapResponse['sql_runner_precache_tables'];
      _sqlRunnerPrecacheTablesSet = true;
    }
    return _sqlRunnerPrecacheTables;
  }

  set sqlRunnerPrecacheTables(bool v) {
    _sqlRunnerPrecacheTables = v;
    _sqlRunnerPrecacheTablesSet = true;
  }

  /// Fetch Information Schema For SQL Writing

  bool get sqlWritingWithInfoSchema {
    if (!_sqlWritingWithInfoSchemaSet &&
        _apiMapResponse.containsKey('sql_writing_with_info_schema')) {
      _sqlWritingWithInfoSchema =
          _apiMapResponse['sql_writing_with_info_schema'];
      _sqlWritingWithInfoSchemaSet = true;
    }
    return _sqlWritingWithInfoSchema;
  }

  set sqlWritingWithInfoSchema(bool v) {
    _sqlWritingWithInfoSchema = v;
    _sqlWritingWithInfoSchemaSet = true;
  }

  /// SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature

  String get afterConnectStatements {
    if (!_afterConnectStatementsSet &&
        _apiMapResponse.containsKey('after_connect_statements')) {
      _afterConnectStatements =
          _apiMapResponse['after_connect_statements']?.toString();
      _afterConnectStatementsSet = true;
    }
    return _afterConnectStatements;
  }

  set afterConnectStatements(String v) {
    _afterConnectStatements = v;
    _afterConnectStatementsSet = true;
  }

  /// Dynamic writeable type for DBConnectionOverride removes:
  /// has_password

  WriteDBConnectionOverride get pdtContextOverride {
    if (!_pdtContextOverrideSet &&
        _apiMapResponse.containsKey('pdt_context_override')) {
      _pdtContextOverride = _apiMapResponse['pdt_context_override'] == null
          ? null
          : WriteDBConnectionOverride.fromResponse(
              _apiMapResponse['pdt_context_override'], apiResponseContentType);
      _pdtContextOverrideSet = true;
    }
    return _pdtContextOverride;
  }

  set pdtContextOverride(WriteDBConnectionOverride v) {
    _pdtContextOverride = v;
    _pdtContextOverrideSet = true;
  }

  /// The Id of the ssh tunnel this connection uses

  String get tunnelId {
    if (!_tunnelIdSet && _apiMapResponse.containsKey('tunnel_id')) {
      _tunnelId = _apiMapResponse['tunnel_id']?.toString();
      _tunnelIdSet = true;
    }
    return _tunnelId;
  }

  set tunnelId(String v) {
    _tunnelId = v;
    _tunnelIdSet = true;
  }

  /// Maximum number of threads to use to build PDTs in parallel

  int get pdtConcurrency {
    if (!_pdtConcurrencySet && _apiMapResponse.containsKey('pdt_concurrency')) {
      _pdtConcurrency = _apiMapResponse['pdt_concurrency'];
      _pdtConcurrencySet = true;
    }
    return _pdtConcurrency;
  }

  set pdtConcurrency(int v) {
    _pdtConcurrency = v;
    _pdtConcurrencySet = true;
  }

  /// When disable_context_comment is true comment will not be added to SQL

  bool get disableContextComment {
    if (!_disableContextCommentSet &&
        _apiMapResponse.containsKey('disable_context_comment')) {
      _disableContextComment = _apiMapResponse['disable_context_comment'];
      _disableContextCommentSet = true;
    }
    return _disableContextComment;
  }

  set disableContextComment(bool v) {
    _disableContextComment = v;
    _disableContextCommentSet = true;
  }

  /// An External OAuth Application to use for authenticating to the database

  int get oauthApplicationId {
    if (!_oauthApplicationIdSet &&
        _apiMapResponse.containsKey('oauth_application_id')) {
      _oauthApplicationId = _apiMapResponse['oauth_application_id'];
      _oauthApplicationIdSet = true;
    }
    return _oauthApplicationId;
  }

  set oauthApplicationId(int v) {
    _oauthApplicationId = v;
    _oauthApplicationIdSet = true;
  }

  /// When true, error PDTs will be retried every regenerator cycle

  bool get alwaysRetryFailedBuilds {
    if (!_alwaysRetryFailedBuildsSet &&
        _apiMapResponse.containsKey('always_retry_failed_builds')) {
      _alwaysRetryFailedBuilds = _apiMapResponse['always_retry_failed_builds'];
      _alwaysRetryFailedBuildsSet = true;
    }
    return _alwaysRetryFailedBuilds;
  }

  set alwaysRetryFailedBuilds(bool v) {
    _alwaysRetryFailedBuilds = v;
    _alwaysRetryFailedBuildsSet = true;
  }

  WriteDBConnection() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteDBConnection.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_hostSet || _apiMapResponse.containsKey('host')) {
      json['host'] = host;
    }
    if (_portSet || _apiMapResponse.containsKey('port')) {
      json['port'] = port;
    }
    if (_usernameSet || _apiMapResponse.containsKey('username')) {
      json['username'] = username;
    }
    if (_passwordSet || _apiMapResponse.containsKey('password')) {
      json['password'] = password;
    }
    if (_certificateSet || _apiMapResponse.containsKey('certificate')) {
      json['certificate'] = certificate;
    }
    if (_fileTypeSet || _apiMapResponse.containsKey('file_type')) {
      json['file_type'] = fileType;
    }
    if (_databaseSet || _apiMapResponse.containsKey('database')) {
      json['database'] = database;
    }
    if (_dbTimezoneSet || _apiMapResponse.containsKey('db_timezone')) {
      json['db_timezone'] = dbTimezone;
    }
    if (_queryTimezoneSet || _apiMapResponse.containsKey('query_timezone')) {
      json['query_timezone'] = queryTimezone;
    }
    if (_schemaSet || _apiMapResponse.containsKey('schema')) {
      json['schema'] = schema;
    }
    if (_maxConnectionsSet || _apiMapResponse.containsKey('max_connections')) {
      json['max_connections'] = maxConnections;
    }
    if (_maxBillingGigabytesSet ||
        _apiMapResponse.containsKey('max_billing_gigabytes')) {
      json['max_billing_gigabytes'] = maxBillingGigabytes;
    }
    if (_sslSet || _apiMapResponse.containsKey('ssl')) {
      json['ssl'] = ssl;
    }
    if (_verifySslSet || _apiMapResponse.containsKey('verify_ssl')) {
      json['verify_ssl'] = verifySsl;
    }
    if (_tmpDbNameSet || _apiMapResponse.containsKey('tmp_db_name')) {
      json['tmp_db_name'] = tmpDbName;
    }
    if (_jdbcAdditionalParamsSet ||
        _apiMapResponse.containsKey('jdbc_additional_params')) {
      json['jdbc_additional_params'] = jdbcAdditionalParams;
    }
    if (_poolTimeoutSet || _apiMapResponse.containsKey('pool_timeout')) {
      json['pool_timeout'] = poolTimeout;
    }
    if (_dialectNameSet || _apiMapResponse.containsKey('dialect_name')) {
      json['dialect_name'] = dialectName;
    }
    if (_userDbCredentialsSet ||
        _apiMapResponse.containsKey('user_db_credentials')) {
      json['user_db_credentials'] = userDbCredentials;
    }
    if (_userAttributeFieldsSet ||
        _apiMapResponse.containsKey('user_attribute_fields')) {
      json['user_attribute_fields'] = userAttributeFields;
    }
    if (_maintenanceCronSet ||
        _apiMapResponse.containsKey('maintenance_cron')) {
      json['maintenance_cron'] = maintenanceCron;
    }
    if (_sqlRunnerPrecacheTablesSet ||
        _apiMapResponse.containsKey('sql_runner_precache_tables')) {
      json['sql_runner_precache_tables'] = sqlRunnerPrecacheTables;
    }
    if (_sqlWritingWithInfoSchemaSet ||
        _apiMapResponse.containsKey('sql_writing_with_info_schema')) {
      json['sql_writing_with_info_schema'] = sqlWritingWithInfoSchema;
    }
    if (_afterConnectStatementsSet ||
        _apiMapResponse.containsKey('after_connect_statements')) {
      json['after_connect_statements'] = afterConnectStatements;
    }
    if (_pdtContextOverrideSet ||
        _apiMapResponse.containsKey('pdt_context_override')) {
      json['pdt_context_override'] = pdtContextOverride?.toJson();
    }
    if (_tunnelIdSet || _apiMapResponse.containsKey('tunnel_id')) {
      json['tunnel_id'] = tunnelId;
    }
    if (_pdtConcurrencySet || _apiMapResponse.containsKey('pdt_concurrency')) {
      json['pdt_concurrency'] = pdtConcurrency;
    }
    if (_disableContextCommentSet ||
        _apiMapResponse.containsKey('disable_context_comment')) {
      json['disable_context_comment'] = disableContextComment;
    }
    if (_oauthApplicationIdSet ||
        _apiMapResponse.containsKey('oauth_application_id')) {
      json['oauth_application_id'] = oauthApplicationId;
    }
    if (_alwaysRetryFailedBuildsSet ||
        _apiMapResponse.containsKey('always_retry_failed_builds')) {
      json['always_retry_failed_builds'] = alwaysRetryFailedBuilds;
    }
    return json;
  }
}

/// Dynamic writeable type for DBConnectionOverride removes:
/// has_password
class WriteDBConnectionOverride {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _context;
  bool _contextSet = false;

  String _host;
  bool _hostSet = false;

  String _port;
  bool _portSet = false;

  String _username;
  bool _usernameSet = false;

  String _password;
  bool _passwordSet = false;

  String _certificate;
  bool _certificateSet = false;

  String _fileType;
  bool _fileTypeSet = false;

  String _database;
  bool _databaseSet = false;

  String _schema;
  bool _schemaSet = false;

  String _jdbcAdditionalParams;
  bool _jdbcAdditionalParamsSet = false;

  String _afterConnectStatements;
  bool _afterConnectStatementsSet = false;

  /// Context in which to override (`pdt` is the only allowed value)

  String get context {
    if (!_contextSet && _apiMapResponse.containsKey('context')) {
      _context = _apiMapResponse['context']?.toString();
      _contextSet = true;
    }
    return _context;
  }

  set context(String v) {
    _context = v;
    _contextSet = true;
  }

  /// Host name/address of server

  String get host {
    if (!_hostSet && _apiMapResponse.containsKey('host')) {
      _host = _apiMapResponse['host']?.toString();
      _hostSet = true;
    }
    return _host;
  }

  set host(String v) {
    _host = v;
    _hostSet = true;
  }

  /// Port number on server

  String get port {
    if (!_portSet && _apiMapResponse.containsKey('port')) {
      _port = _apiMapResponse['port']?.toString();
      _portSet = true;
    }
    return _port;
  }

  set port(String v) {
    _port = v;
    _portSet = true;
  }

  /// Username for server authentication

  String get username {
    if (!_usernameSet && _apiMapResponse.containsKey('username')) {
      _username = _apiMapResponse['username']?.toString();
      _usernameSet = true;
    }
    return _username;
  }

  set username(String v) {
    _username = v;
    _usernameSet = true;
  }

  /// (Write-Only) Password for server authentication

  String get password {
    if (!_passwordSet && _apiMapResponse.containsKey('password')) {
      _password = _apiMapResponse['password']?.toString();
      _passwordSet = true;
    }
    return _password;
  }

  set password(String v) {
    _password = v;
    _passwordSet = true;
  }

  /// (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).

  String get certificate {
    if (!_certificateSet && _apiMapResponse.containsKey('certificate')) {
      _certificate = _apiMapResponse['certificate']?.toString();
      _certificateSet = true;
    }
    return _certificate;
  }

  set certificate(String v) {
    _certificate = v;
    _certificateSet = true;
  }

  /// (Write-Only) Certificate keyfile type - .json or .p12

  String get fileType {
    if (!_fileTypeSet && _apiMapResponse.containsKey('file_type')) {
      _fileType = _apiMapResponse['file_type']?.toString();
      _fileTypeSet = true;
    }
    return _fileType;
  }

  set fileType(String v) {
    _fileType = v;
    _fileTypeSet = true;
  }

  /// Database name

  String get database {
    if (!_databaseSet && _apiMapResponse.containsKey('database')) {
      _database = _apiMapResponse['database']?.toString();
      _databaseSet = true;
    }
    return _database;
  }

  set database(String v) {
    _database = v;
    _databaseSet = true;
  }

  /// Scheme name

  String get schema {
    if (!_schemaSet && _apiMapResponse.containsKey('schema')) {
      _schema = _apiMapResponse['schema']?.toString();
      _schemaSet = true;
    }
    return _schema;
  }

  set schema(String v) {
    _schema = v;
    _schemaSet = true;
  }

  /// Additional params to add to JDBC connection string

  String get jdbcAdditionalParams {
    if (!_jdbcAdditionalParamsSet &&
        _apiMapResponse.containsKey('jdbc_additional_params')) {
      _jdbcAdditionalParams =
          _apiMapResponse['jdbc_additional_params']?.toString();
      _jdbcAdditionalParamsSet = true;
    }
    return _jdbcAdditionalParams;
  }

  set jdbcAdditionalParams(String v) {
    _jdbcAdditionalParams = v;
    _jdbcAdditionalParamsSet = true;
  }

  /// SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature

  String get afterConnectStatements {
    if (!_afterConnectStatementsSet &&
        _apiMapResponse.containsKey('after_connect_statements')) {
      _afterConnectStatements =
          _apiMapResponse['after_connect_statements']?.toString();
      _afterConnectStatementsSet = true;
    }
    return _afterConnectStatements;
  }

  set afterConnectStatements(String v) {
    _afterConnectStatements = v;
    _afterConnectStatementsSet = true;
  }

  WriteDBConnectionOverride() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteDBConnectionOverride.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_contextSet || _apiMapResponse.containsKey('context')) {
      json['context'] = context;
    }
    if (_hostSet || _apiMapResponse.containsKey('host')) {
      json['host'] = host;
    }
    if (_portSet || _apiMapResponse.containsKey('port')) {
      json['port'] = port;
    }
    if (_usernameSet || _apiMapResponse.containsKey('username')) {
      json['username'] = username;
    }
    if (_passwordSet || _apiMapResponse.containsKey('password')) {
      json['password'] = password;
    }
    if (_certificateSet || _apiMapResponse.containsKey('certificate')) {
      json['certificate'] = certificate;
    }
    if (_fileTypeSet || _apiMapResponse.containsKey('file_type')) {
      json['file_type'] = fileType;
    }
    if (_databaseSet || _apiMapResponse.containsKey('database')) {
      json['database'] = database;
    }
    if (_schemaSet || _apiMapResponse.containsKey('schema')) {
      json['schema'] = schema;
    }
    if (_jdbcAdditionalParamsSet ||
        _apiMapResponse.containsKey('jdbc_additional_params')) {
      json['jdbc_additional_params'] = jdbcAdditionalParams;
    }
    if (_afterConnectStatementsSet ||
        _apiMapResponse.containsKey('after_connect_statements')) {
      json['after_connect_statements'] = afterConnectStatements;
    }
    return json;
  }
}

/// Dynamic writeable type for EmbedSecret removes:
/// created_at, id, secret, user_id
class WriteEmbedSecret {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _algorithm;
  bool _algorithmSet = false;

  bool _enabled;
  bool _enabledSet = false;

  /// Signing algorithm to use with this secret. Either `hmac/sha-256`(default) or `hmac/sha-1`

  String get algorithm {
    if (!_algorithmSet && _apiMapResponse.containsKey('algorithm')) {
      _algorithm = _apiMapResponse['algorithm']?.toString();
      _algorithmSet = true;
    }
    return _algorithm;
  }

  set algorithm(String v) {
    _algorithm = v;
    _algorithmSet = true;
  }

  /// Is this secret currently enabled

  bool get enabled {
    if (!_enabledSet && _apiMapResponse.containsKey('enabled')) {
      _enabled = _apiMapResponse['enabled'];
      _enabledSet = true;
    }
    return _enabled;
  }

  set enabled(bool v) {
    _enabled = v;
    _enabledSet = true;
  }

  WriteEmbedSecret() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteEmbedSecret.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_algorithmSet || _apiMapResponse.containsKey('algorithm')) {
      json['algorithm'] = algorithm;
    }
    if (_enabledSet || _apiMapResponse.containsKey('enabled')) {
      json['enabled'] = enabled;
    }
    return json;
  }
}

/// Dynamic writeable type for ExternalOauthApplication removes:
/// can, id, created_at
class WriteExternalOauthApplication {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _clientId;
  bool _clientIdSet = false;

  String _clientSecret;
  bool _clientSecretSet = false;

  String _dialectName;
  bool _dialectNameSet = false;

  /// The name of this application.  For Snowflake connections, this should be the name of the host database.

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// The OAuth Client ID for this application

  String get clientId {
    if (!_clientIdSet && _apiMapResponse.containsKey('client_id')) {
      _clientId = _apiMapResponse['client_id']?.toString();
      _clientIdSet = true;
    }
    return _clientId;
  }

  set clientId(String v) {
    _clientId = v;
    _clientIdSet = true;
  }

  /// (Write-Only) The OAuth Client Secret for this application

  String get clientSecret {
    if (!_clientSecretSet && _apiMapResponse.containsKey('client_secret')) {
      _clientSecret = _apiMapResponse['client_secret']?.toString();
      _clientSecretSet = true;
    }
    return _clientSecret;
  }

  set clientSecret(String v) {
    _clientSecret = v;
    _clientSecretSet = true;
  }

  /// The database dialect for this application.

  String get dialectName {
    if (!_dialectNameSet && _apiMapResponse.containsKey('dialect_name')) {
      _dialectName = _apiMapResponse['dialect_name']?.toString();
      _dialectNameSet = true;
    }
    return _dialectName;
  }

  set dialectName(String v) {
    _dialectName = v;
    _dialectNameSet = true;
  }

  WriteExternalOauthApplication() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteExternalOauthApplication.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_clientIdSet || _apiMapResponse.containsKey('client_id')) {
      json['client_id'] = clientId;
    }
    if (_clientSecretSet || _apiMapResponse.containsKey('client_secret')) {
      json['client_secret'] = clientSecret;
    }
    if (_dialectNameSet || _apiMapResponse.containsKey('dialect_name')) {
      json['dialect_name'] = dialectName;
    }
    return json;
  }
}

/// Dynamic writeable type for FolderBase removes:
/// id, content_metadata_id, created_at, creator_id, child_count, external_id, is_embed, is_embed_shared_root, is_embed_users_root, is_personal, is_personal_descendant, is_shared_root, is_users_root, can
class WriteFolderBase {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _parentId;
  bool _parentIdSet = false;

  /// Unique Name

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Id of Parent. If the parent id is null, this is a root-level entry

  String get parentId {
    if (!_parentIdSet && _apiMapResponse.containsKey('parent_id')) {
      _parentId = _apiMapResponse['parent_id']?.toString();
      _parentIdSet = true;
    }
    return _parentId;
  }

  set parentId(String v) {
    _parentId = v;
    _parentIdSet = true;
  }

  WriteFolderBase() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteFolderBase.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_parentIdSet || _apiMapResponse.containsKey('parent_id')) {
      json['parent_id'] = parentId;
    }
    return json;
  }
}

/// Dynamic writeable type for GitBranch removes:
/// can, remote, remote_name, error, message, owner_name, readonly, personal, is_local, is_remote, is_production, ahead_count, behind_count, commit_at, remote_ref
class WriteGitBranch {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _ref;
  bool _refSet = false;

  /// The short name on the local. Updating `name` results in `git checkout <new_name>`

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// The resolved ref of this branch. Updating `ref` results in `git reset --hard <new_ref>``.

  String get ref {
    if (!_refSet && _apiMapResponse.containsKey('ref')) {
      _ref = _apiMapResponse['ref']?.toString();
      _refSet = true;
    }
    return _ref;
  }

  set ref(String v) {
    _ref = v;
    _refSet = true;
  }

  WriteGitBranch() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteGitBranch.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_refSet || _apiMapResponse.containsKey('ref')) {
      json['ref'] = ref;
    }
    return json;
  }
}

/// Dynamic writeable type for Group removes:
/// can, contains_current_user, external_group_id, externally_managed, id, include_by_default, user_count
class WriteGroup {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _canAddToContentMetadata;
  bool _canAddToContentMetadataSet = false;

  String _name;
  bool _nameSet = false;

  /// Group can be used in content access controls

  bool get canAddToContentMetadata {
    if (!_canAddToContentMetadataSet &&
        _apiMapResponse.containsKey('can_add_to_content_metadata')) {
      _canAddToContentMetadata = _apiMapResponse['can_add_to_content_metadata'];
      _canAddToContentMetadataSet = true;
    }
    return _canAddToContentMetadata;
  }

  set canAddToContentMetadata(bool v) {
    _canAddToContentMetadata = v;
    _canAddToContentMetadataSet = true;
  }

  /// Name of group

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  WriteGroup() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteGroup.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_canAddToContentMetadataSet ||
        _apiMapResponse.containsKey('can_add_to_content_metadata')) {
      json['can_add_to_content_metadata'] = canAddToContentMetadata;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    return json;
  }
}

/// Dynamic writeable type for Integration removes:
/// can, id, integration_hub_id, label, description, supported_formats, supported_action_types, supported_formattings, supported_visualization_formattings, supported_download_settings, icon_url, uses_oauth, required_fields, delegate_oauth
class WriteIntegration {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _enabled;
  bool _enabledSet = false;

  List<IntegrationParam> _params;
  bool _paramsSet = false;

  List<int> _installedDelegateOauthTargets;
  bool _installedDelegateOauthTargetsSet = false;

  /// Whether the integration is available to users.

  bool get enabled {
    if (!_enabledSet && _apiMapResponse.containsKey('enabled')) {
      _enabled = _apiMapResponse['enabled'];
      _enabledSet = true;
    }
    return _enabled;
  }

  set enabled(bool v) {
    _enabled = v;
    _enabledSet = true;
  }

  /// Array of params for the integration.

  List<IntegrationParam> get params {
    if (!_paramsSet && _apiMapResponse.containsKey('params')) {
      _params = _apiMapResponse['params'] == null
          ? null
          : (_apiMapResponse['params'] as List)
              .map((i) =>
                  IntegrationParam.fromResponse(i, apiResponseContentType))
              .toList();
      _paramsSet = true;
    }
    return _params;
  }

  set params(List<IntegrationParam> v) {
    _params = v;
    _paramsSet = true;
  }

  /// Whether the integration is available to users.

  List<int> get installedDelegateOauthTargets {
    if (!_installedDelegateOauthTargetsSet &&
        _apiMapResponse.containsKey('installed_delegate_oauth_targets')) {
      _installedDelegateOauthTargets =
          _apiMapResponse['installed_delegate_oauth_targets']
              ?.map<int>((i) => i as int)
              ?.toList();
      _installedDelegateOauthTargetsSet = true;
    }
    return _installedDelegateOauthTargets;
  }

  set installedDelegateOauthTargets(List<int> v) {
    _installedDelegateOauthTargets = v;
    _installedDelegateOauthTargetsSet = true;
  }

  WriteIntegration() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteIntegration.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_enabledSet || _apiMapResponse.containsKey('enabled')) {
      json['enabled'] = enabled;
    }
    if (_paramsSet || _apiMapResponse.containsKey('params')) {
      json['params'] = params?.map((i) => i.toJson())?.toList();
    }
    if (_installedDelegateOauthTargetsSet ||
        _apiMapResponse.containsKey('installed_delegate_oauth_targets')) {
      json['installed_delegate_oauth_targets'] = installedDelegateOauthTargets;
    }
    return json;
  }
}

/// Dynamic writeable type for IntegrationHub removes:
/// can, id, label, official, fetch_error_message, has_authorization_token, legal_agreement_signed, legal_agreement_required, legal_agreement_text
class WriteIntegrationHub {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _url;
  bool _urlSet = false;

  String _authorizationToken;
  bool _authorizationTokenSet = false;

  /// URL of the hub.

  String get url {
    if (!_urlSet && _apiMapResponse.containsKey('url')) {
      _url = _apiMapResponse['url']?.toString();
      _urlSet = true;
    }
    return _url;
  }

  set url(String v) {
    _url = v;
    _urlSet = true;
  }

  /// (Write-Only) An authorization key that will be sent to the integration hub on every request.

  String get authorizationToken {
    if (!_authorizationTokenSet &&
        _apiMapResponse.containsKey('authorization_token')) {
      _authorizationToken = _apiMapResponse['authorization_token']?.toString();
      _authorizationTokenSet = true;
    }
    return _authorizationToken;
  }

  set authorizationToken(String v) {
    _authorizationToken = v;
    _authorizationTokenSet = true;
  }

  WriteIntegrationHub() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteIntegrationHub.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_urlSet || _apiMapResponse.containsKey('url')) {
      json['url'] = url;
    }
    if (_authorizationTokenSet ||
        _apiMapResponse.containsKey('authorization_token')) {
      json['authorization_token'] = authorizationToken;
    }
    return json;
  }
}

/// Dynamic writeable type for InternalHelpResources removes:
/// can
class WriteInternalHelpResources {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _enabled;
  bool _enabledSet = false;

  /// If true and internal help resources content is not blank then the link for internal help resources will be shown in the help menu and the content displayed within Looker

  bool get enabled {
    if (!_enabledSet && _apiMapResponse.containsKey('enabled')) {
      _enabled = _apiMapResponse['enabled'];
      _enabledSet = true;
    }
    return _enabled;
  }

  set enabled(bool v) {
    _enabled = v;
    _enabledSet = true;
  }

  WriteInternalHelpResources() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteInternalHelpResources.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_enabledSet || _apiMapResponse.containsKey('enabled')) {
      json['enabled'] = enabled;
    }
    return json;
  }
}

/// Dynamic writeable type for InternalHelpResourcesContent removes:
/// can
class WriteInternalHelpResourcesContent {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _organizationName;
  bool _organizationNameSet = false;

  String _markdownContent;
  bool _markdownContentSet = false;

  /// Text to display in the help menu item which will display the internal help resources

  String get organizationName {
    if (!_organizationNameSet &&
        _apiMapResponse.containsKey('organization_name')) {
      _organizationName = _apiMapResponse['organization_name']?.toString();
      _organizationNameSet = true;
    }
    return _organizationName;
  }

  set organizationName(String v) {
    _organizationName = v;
    _organizationNameSet = true;
  }

  /// Content to be displayed in the internal help resources page/modal

  String get markdownContent {
    if (!_markdownContentSet &&
        _apiMapResponse.containsKey('markdown_content')) {
      _markdownContent = _apiMapResponse['markdown_content']?.toString();
      _markdownContentSet = true;
    }
    return _markdownContent;
  }

  set markdownContent(String v) {
    _markdownContent = v;
    _markdownContentSet = true;
  }

  WriteInternalHelpResourcesContent() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteInternalHelpResourcesContent.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_organizationNameSet ||
        _apiMapResponse.containsKey('organization_name')) {
      json['organization_name'] = organizationName;
    }
    if (_markdownContentSet ||
        _apiMapResponse.containsKey('markdown_content')) {
      json['markdown_content'] = markdownContent;
    }
    return json;
  }
}

/// Dynamic writeable type for LDAPConfig removes:
/// can, default_new_user_groups, default_new_user_roles, groups, has_auth_password, modified_at, modified_by, user_attributes, url
class WriteLDAPConfig {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _alternateEmailLoginAllowed;
  bool _alternateEmailLoginAllowedSet = false;

  String _authPassword;
  bool _authPasswordSet = false;

  bool _authRequiresRole;
  bool _authRequiresRoleSet = false;

  String _authUsername;
  bool _authUsernameSet = false;

  String _connectionHost;
  bool _connectionHostSet = false;

  String _connectionPort;
  bool _connectionPortSet = false;

  bool _connectionTls;
  bool _connectionTlsSet = false;

  bool _connectionTlsNoVerify;
  bool _connectionTlsNoVerifySet = false;

  List<int> _defaultNewUserGroupIds;
  bool _defaultNewUserGroupIdsSet = false;

  List<int> _defaultNewUserRoleIds;
  bool _defaultNewUserRoleIdsSet = false;

  bool _enabled;
  bool _enabledSet = false;

  bool _forceNoPage;
  bool _forceNoPageSet = false;

  String _groupsBaseDn;
  bool _groupsBaseDnSet = false;

  String _groupsFinderType;
  bool _groupsFinderTypeSet = false;

  String _groupsMemberAttribute;
  bool _groupsMemberAttributeSet = false;

  String _groupsObjectclasses;
  bool _groupsObjectclassesSet = false;

  String _groupsUserAttribute;
  bool _groupsUserAttributeSet = false;

  List<LDAPGroupWrite> _groupsWithRoleIds;
  bool _groupsWithRoleIdsSet = false;

  bool _mergeNewUsersByEmail;
  bool _mergeNewUsersByEmailSet = false;

  bool _setRolesFromGroups;
  bool _setRolesFromGroupsSet = false;

  String _testLdapPassword;
  bool _testLdapPasswordSet = false;

  String _testLdapUser;
  bool _testLdapUserSet = false;

  String _userAttributeMapEmail;
  bool _userAttributeMapEmailSet = false;

  String _userAttributeMapFirstName;
  bool _userAttributeMapFirstNameSet = false;

  String _userAttributeMapLastName;
  bool _userAttributeMapLastNameSet = false;

  String _userAttributeMapLdapId;
  bool _userAttributeMapLdapIdSet = false;

  List<LDAPUserAttributeWrite> _userAttributesWithIds;
  bool _userAttributesWithIdsSet = false;

  String _userBindBaseDn;
  bool _userBindBaseDnSet = false;

  String _userCustomFilter;
  bool _userCustomFilterSet = false;

  String _userIdAttributeNames;
  bool _userIdAttributeNamesSet = false;

  String _userObjectclass;
  bool _userObjectclassSet = false;

  bool _allowNormalGroupMembership;
  bool _allowNormalGroupMembershipSet = false;

  bool _allowRolesFromNormalGroups;
  bool _allowRolesFromNormalGroupsSet = false;

  bool _allowDirectRoles;
  bool _allowDirectRolesSet = false;

  /// Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.

  bool get alternateEmailLoginAllowed {
    if (!_alternateEmailLoginAllowedSet &&
        _apiMapResponse.containsKey('alternate_email_login_allowed')) {
      _alternateEmailLoginAllowed =
          _apiMapResponse['alternate_email_login_allowed'];
      _alternateEmailLoginAllowedSet = true;
    }
    return _alternateEmailLoginAllowed;
  }

  set alternateEmailLoginAllowed(bool v) {
    _alternateEmailLoginAllowed = v;
    _alternateEmailLoginAllowedSet = true;
  }

  /// (Write-Only)  Password for the LDAP account used to access the LDAP server

  String get authPassword {
    if (!_authPasswordSet && _apiMapResponse.containsKey('auth_password')) {
      _authPassword = _apiMapResponse['auth_password']?.toString();
      _authPasswordSet = true;
    }
    return _authPassword;
  }

  set authPassword(String v) {
    _authPassword = v;
    _authPasswordSet = true;
  }

  /// Users will not be allowed to login at all unless a role for them is found in LDAP if set to true

  bool get authRequiresRole {
    if (!_authRequiresRoleSet &&
        _apiMapResponse.containsKey('auth_requires_role')) {
      _authRequiresRole = _apiMapResponse['auth_requires_role'];
      _authRequiresRoleSet = true;
    }
    return _authRequiresRole;
  }

  set authRequiresRole(bool v) {
    _authRequiresRole = v;
    _authRequiresRoleSet = true;
  }

  /// Distinguished name of LDAP account used to access the LDAP server

  String get authUsername {
    if (!_authUsernameSet && _apiMapResponse.containsKey('auth_username')) {
      _authUsername = _apiMapResponse['auth_username']?.toString();
      _authUsernameSet = true;
    }
    return _authUsername;
  }

  set authUsername(String v) {
    _authUsername = v;
    _authUsernameSet = true;
  }

  /// LDAP server hostname

  String get connectionHost {
    if (!_connectionHostSet && _apiMapResponse.containsKey('connection_host')) {
      _connectionHost = _apiMapResponse['connection_host']?.toString();
      _connectionHostSet = true;
    }
    return _connectionHost;
  }

  set connectionHost(String v) {
    _connectionHost = v;
    _connectionHostSet = true;
  }

  /// LDAP host port

  String get connectionPort {
    if (!_connectionPortSet && _apiMapResponse.containsKey('connection_port')) {
      _connectionPort = _apiMapResponse['connection_port']?.toString();
      _connectionPortSet = true;
    }
    return _connectionPort;
  }

  set connectionPort(String v) {
    _connectionPort = v;
    _connectionPortSet = true;
  }

  /// Use Transport Layer Security

  bool get connectionTls {
    if (!_connectionTlsSet && _apiMapResponse.containsKey('connection_tls')) {
      _connectionTls = _apiMapResponse['connection_tls'];
      _connectionTlsSet = true;
    }
    return _connectionTls;
  }

  set connectionTls(bool v) {
    _connectionTls = v;
    _connectionTlsSet = true;
  }

  /// Do not verify peer when using TLS

  bool get connectionTlsNoVerify {
    if (!_connectionTlsNoVerifySet &&
        _apiMapResponse.containsKey('connection_tls_no_verify')) {
      _connectionTlsNoVerify = _apiMapResponse['connection_tls_no_verify'];
      _connectionTlsNoVerifySet = true;
    }
    return _connectionTlsNoVerify;
  }

  set connectionTlsNoVerify(bool v) {
    _connectionTlsNoVerify = v;
    _connectionTlsNoVerifySet = true;
  }

  /// (Write-Only)  Array of ids of groups that will be applied to new users the first time they login via LDAP

  List<int> get defaultNewUserGroupIds {
    if (!_defaultNewUserGroupIdsSet &&
        _apiMapResponse.containsKey('default_new_user_group_ids')) {
      _defaultNewUserGroupIds = _apiMapResponse['default_new_user_group_ids']
          ?.map<int>((i) => i as int)
          ?.toList();
      _defaultNewUserGroupIdsSet = true;
    }
    return _defaultNewUserGroupIds;
  }

  set defaultNewUserGroupIds(List<int> v) {
    _defaultNewUserGroupIds = v;
    _defaultNewUserGroupIdsSet = true;
  }

  /// (Write-Only)  Array of ids of roles that will be applied to new users the first time they login via LDAP

  List<int> get defaultNewUserRoleIds {
    if (!_defaultNewUserRoleIdsSet &&
        _apiMapResponse.containsKey('default_new_user_role_ids')) {
      _defaultNewUserRoleIds = _apiMapResponse['default_new_user_role_ids']
          ?.map<int>((i) => i as int)
          ?.toList();
      _defaultNewUserRoleIdsSet = true;
    }
    return _defaultNewUserRoleIds;
  }

  set defaultNewUserRoleIds(List<int> v) {
    _defaultNewUserRoleIds = v;
    _defaultNewUserRoleIdsSet = true;
  }

  /// Enable/Disable LDAP authentication for the server

  bool get enabled {
    if (!_enabledSet && _apiMapResponse.containsKey('enabled')) {
      _enabled = _apiMapResponse['enabled'];
      _enabledSet = true;
    }
    return _enabled;
  }

  set enabled(bool v) {
    _enabled = v;
    _enabledSet = true;
  }

  /// Don't attempt to do LDAP search result paging (RFC 2696) even if the LDAP server claims to support it.

  bool get forceNoPage {
    if (!_forceNoPageSet && _apiMapResponse.containsKey('force_no_page')) {
      _forceNoPage = _apiMapResponse['force_no_page'];
      _forceNoPageSet = true;
    }
    return _forceNoPage;
  }

  set forceNoPage(bool v) {
    _forceNoPage = v;
    _forceNoPageSet = true;
  }

  /// Base dn for finding groups in LDAP searches

  String get groupsBaseDn {
    if (!_groupsBaseDnSet && _apiMapResponse.containsKey('groups_base_dn')) {
      _groupsBaseDn = _apiMapResponse['groups_base_dn']?.toString();
      _groupsBaseDnSet = true;
    }
    return _groupsBaseDn;
  }

  set groupsBaseDn(String v) {
    _groupsBaseDn = v;
    _groupsBaseDnSet = true;
  }

  /// Identifier for a strategy for how Looker will search for groups in the LDAP server

  String get groupsFinderType {
    if (!_groupsFinderTypeSet &&
        _apiMapResponse.containsKey('groups_finder_type')) {
      _groupsFinderType = _apiMapResponse['groups_finder_type']?.toString();
      _groupsFinderTypeSet = true;
    }
    return _groupsFinderType;
  }

  set groupsFinderType(String v) {
    _groupsFinderType = v;
    _groupsFinderTypeSet = true;
  }

  /// LDAP Group attribute that signifies the members of the groups. Most commonly 'member'

  String get groupsMemberAttribute {
    if (!_groupsMemberAttributeSet &&
        _apiMapResponse.containsKey('groups_member_attribute')) {
      _groupsMemberAttribute =
          _apiMapResponse['groups_member_attribute']?.toString();
      _groupsMemberAttributeSet = true;
    }
    return _groupsMemberAttribute;
  }

  set groupsMemberAttribute(String v) {
    _groupsMemberAttribute = v;
    _groupsMemberAttributeSet = true;
  }

  /// Optional comma-separated list of supported LDAP objectclass for groups when doing groups searches

  String get groupsObjectclasses {
    if (!_groupsObjectclassesSet &&
        _apiMapResponse.containsKey('groups_objectclasses')) {
      _groupsObjectclasses =
          _apiMapResponse['groups_objectclasses']?.toString();
      _groupsObjectclassesSet = true;
    }
    return _groupsObjectclasses;
  }

  set groupsObjectclasses(String v) {
    _groupsObjectclasses = v;
    _groupsObjectclassesSet = true;
  }

  /// LDAP Group attribute that signifies the user in a group. Most commonly 'dn'

  String get groupsUserAttribute {
    if (!_groupsUserAttributeSet &&
        _apiMapResponse.containsKey('groups_user_attribute')) {
      _groupsUserAttribute =
          _apiMapResponse['groups_user_attribute']?.toString();
      _groupsUserAttributeSet = true;
    }
    return _groupsUserAttribute;
  }

  set groupsUserAttribute(String v) {
    _groupsUserAttribute = v;
    _groupsUserAttributeSet = true;
  }

  /// (Read/Write) Array of mappings between LDAP Groups and arrays of Looker Role ids

  List<LDAPGroupWrite> get groupsWithRoleIds {
    if (!_groupsWithRoleIdsSet &&
        _apiMapResponse.containsKey('groups_with_role_ids')) {
      _groupsWithRoleIds = _apiMapResponse['groups_with_role_ids'] == null
          ? null
          : (_apiMapResponse['groups_with_role_ids'] as List)
              .map(
                  (i) => LDAPGroupWrite.fromResponse(i, apiResponseContentType))
              .toList();
      _groupsWithRoleIdsSet = true;
    }
    return _groupsWithRoleIds;
  }

  set groupsWithRoleIds(List<LDAPGroupWrite> v) {
    _groupsWithRoleIds = v;
    _groupsWithRoleIdsSet = true;
  }

  /// Merge first-time ldap login to existing user account by email addresses. When a user logs in for the first time via ldap this option will connect this user into their existing account by finding the account with a matching email address. Otherwise a new user account will be created for the user.

  bool get mergeNewUsersByEmail {
    if (!_mergeNewUsersByEmailSet &&
        _apiMapResponse.containsKey('merge_new_users_by_email')) {
      _mergeNewUsersByEmail = _apiMapResponse['merge_new_users_by_email'];
      _mergeNewUsersByEmailSet = true;
    }
    return _mergeNewUsersByEmail;
  }

  set mergeNewUsersByEmail(bool v) {
    _mergeNewUsersByEmail = v;
    _mergeNewUsersByEmailSet = true;
  }

  /// Set user roles in Looker based on groups from LDAP

  bool get setRolesFromGroups {
    if (!_setRolesFromGroupsSet &&
        _apiMapResponse.containsKey('set_roles_from_groups')) {
      _setRolesFromGroups = _apiMapResponse['set_roles_from_groups'];
      _setRolesFromGroupsSet = true;
    }
    return _setRolesFromGroups;
  }

  set setRolesFromGroups(bool v) {
    _setRolesFromGroups = v;
    _setRolesFromGroupsSet = true;
  }

  /// (Write-Only)  Test LDAP user password. For ldap tests only.

  String get testLdapPassword {
    if (!_testLdapPasswordSet &&
        _apiMapResponse.containsKey('test_ldap_password')) {
      _testLdapPassword = _apiMapResponse['test_ldap_password']?.toString();
      _testLdapPasswordSet = true;
    }
    return _testLdapPassword;
  }

  set testLdapPassword(String v) {
    _testLdapPassword = v;
    _testLdapPasswordSet = true;
  }

  /// (Write-Only)  Test LDAP user login id. For ldap tests only.

  String get testLdapUser {
    if (!_testLdapUserSet && _apiMapResponse.containsKey('test_ldap_user')) {
      _testLdapUser = _apiMapResponse['test_ldap_user']?.toString();
      _testLdapUserSet = true;
    }
    return _testLdapUser;
  }

  set testLdapUser(String v) {
    _testLdapUser = v;
    _testLdapUserSet = true;
  }

  /// Name of user record attributes used to indicate email address field

  String get userAttributeMapEmail {
    if (!_userAttributeMapEmailSet &&
        _apiMapResponse.containsKey('user_attribute_map_email')) {
      _userAttributeMapEmail =
          _apiMapResponse['user_attribute_map_email']?.toString();
      _userAttributeMapEmailSet = true;
    }
    return _userAttributeMapEmail;
  }

  set userAttributeMapEmail(String v) {
    _userAttributeMapEmail = v;
    _userAttributeMapEmailSet = true;
  }

  /// Name of user record attributes used to indicate first name

  String get userAttributeMapFirstName {
    if (!_userAttributeMapFirstNameSet &&
        _apiMapResponse.containsKey('user_attribute_map_first_name')) {
      _userAttributeMapFirstName =
          _apiMapResponse['user_attribute_map_first_name']?.toString();
      _userAttributeMapFirstNameSet = true;
    }
    return _userAttributeMapFirstName;
  }

  set userAttributeMapFirstName(String v) {
    _userAttributeMapFirstName = v;
    _userAttributeMapFirstNameSet = true;
  }

  /// Name of user record attributes used to indicate last name

  String get userAttributeMapLastName {
    if (!_userAttributeMapLastNameSet &&
        _apiMapResponse.containsKey('user_attribute_map_last_name')) {
      _userAttributeMapLastName =
          _apiMapResponse['user_attribute_map_last_name']?.toString();
      _userAttributeMapLastNameSet = true;
    }
    return _userAttributeMapLastName;
  }

  set userAttributeMapLastName(String v) {
    _userAttributeMapLastName = v;
    _userAttributeMapLastNameSet = true;
  }

  /// Name of user record attributes used to indicate unique record id

  String get userAttributeMapLdapId {
    if (!_userAttributeMapLdapIdSet &&
        _apiMapResponse.containsKey('user_attribute_map_ldap_id')) {
      _userAttributeMapLdapId =
          _apiMapResponse['user_attribute_map_ldap_id']?.toString();
      _userAttributeMapLdapIdSet = true;
    }
    return _userAttributeMapLdapId;
  }

  set userAttributeMapLdapId(String v) {
    _userAttributeMapLdapId = v;
    _userAttributeMapLdapIdSet = true;
  }

  /// (Read/Write) Array of mappings between LDAP User Attributes and arrays of Looker User Attribute ids

  List<LDAPUserAttributeWrite> get userAttributesWithIds {
    if (!_userAttributesWithIdsSet &&
        _apiMapResponse.containsKey('user_attributes_with_ids')) {
      _userAttributesWithIds =
          _apiMapResponse['user_attributes_with_ids'] == null
              ? null
              : (_apiMapResponse['user_attributes_with_ids'] as List)
                  .map((i) => LDAPUserAttributeWrite.fromResponse(
                      i, apiResponseContentType))
                  .toList();
      _userAttributesWithIdsSet = true;
    }
    return _userAttributesWithIds;
  }

  set userAttributesWithIds(List<LDAPUserAttributeWrite> v) {
    _userAttributesWithIds = v;
    _userAttributesWithIdsSet = true;
  }

  /// Distinguished name of LDAP node used as the base for user searches

  String get userBindBaseDn {
    if (!_userBindBaseDnSet &&
        _apiMapResponse.containsKey('user_bind_base_dn')) {
      _userBindBaseDn = _apiMapResponse['user_bind_base_dn']?.toString();
      _userBindBaseDnSet = true;
    }
    return _userBindBaseDn;
  }

  set userBindBaseDn(String v) {
    _userBindBaseDn = v;
    _userBindBaseDnSet = true;
  }

  /// (Optional) Custom RFC-2254 filter clause for use in finding user during login. Combined via 'and' with the other generated filter clauses.

  String get userCustomFilter {
    if (!_userCustomFilterSet &&
        _apiMapResponse.containsKey('user_custom_filter')) {
      _userCustomFilter = _apiMapResponse['user_custom_filter']?.toString();
      _userCustomFilterSet = true;
    }
    return _userCustomFilter;
  }

  set userCustomFilter(String v) {
    _userCustomFilter = v;
    _userCustomFilterSet = true;
  }

  /// Name(s) of user record attributes used for matching user login id (comma separated list)

  String get userIdAttributeNames {
    if (!_userIdAttributeNamesSet &&
        _apiMapResponse.containsKey('user_id_attribute_names')) {
      _userIdAttributeNames =
          _apiMapResponse['user_id_attribute_names']?.toString();
      _userIdAttributeNamesSet = true;
    }
    return _userIdAttributeNames;
  }

  set userIdAttributeNames(String v) {
    _userIdAttributeNames = v;
    _userIdAttributeNamesSet = true;
  }

  /// (Optional) Name of user record objectclass used for finding user during login id

  String get userObjectclass {
    if (!_userObjectclassSet &&
        _apiMapResponse.containsKey('user_objectclass')) {
      _userObjectclass = _apiMapResponse['user_objectclass']?.toString();
      _userObjectclassSet = true;
    }
    return _userObjectclass;
  }

  set userObjectclass(String v) {
    _userObjectclass = v;
    _userObjectclassSet = true;
  }

  /// Allow LDAP auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.

  bool get allowNormalGroupMembership {
    if (!_allowNormalGroupMembershipSet &&
        _apiMapResponse.containsKey('allow_normal_group_membership')) {
      _allowNormalGroupMembership =
          _apiMapResponse['allow_normal_group_membership'];
      _allowNormalGroupMembershipSet = true;
    }
    return _allowNormalGroupMembership;
  }

  set allowNormalGroupMembership(bool v) {
    _allowNormalGroupMembership = v;
    _allowNormalGroupMembershipSet = true;
  }

  /// LDAP auth'd users will be able to inherit roles from non-reflected Looker groups.

  bool get allowRolesFromNormalGroups {
    if (!_allowRolesFromNormalGroupsSet &&
        _apiMapResponse.containsKey('allow_roles_from_normal_groups')) {
      _allowRolesFromNormalGroups =
          _apiMapResponse['allow_roles_from_normal_groups'];
      _allowRolesFromNormalGroupsSet = true;
    }
    return _allowRolesFromNormalGroups;
  }

  set allowRolesFromNormalGroups(bool v) {
    _allowRolesFromNormalGroups = v;
    _allowRolesFromNormalGroupsSet = true;
  }

  /// Allows roles to be directly assigned to LDAP auth'd users.

  bool get allowDirectRoles {
    if (!_allowDirectRolesSet &&
        _apiMapResponse.containsKey('allow_direct_roles')) {
      _allowDirectRoles = _apiMapResponse['allow_direct_roles'];
      _allowDirectRolesSet = true;
    }
    return _allowDirectRoles;
  }

  set allowDirectRoles(bool v) {
    _allowDirectRoles = v;
    _allowDirectRolesSet = true;
  }

  WriteLDAPConfig() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteLDAPConfig.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_alternateEmailLoginAllowedSet ||
        _apiMapResponse.containsKey('alternate_email_login_allowed')) {
      json['alternate_email_login_allowed'] = alternateEmailLoginAllowed;
    }
    if (_authPasswordSet || _apiMapResponse.containsKey('auth_password')) {
      json['auth_password'] = authPassword;
    }
    if (_authRequiresRoleSet ||
        _apiMapResponse.containsKey('auth_requires_role')) {
      json['auth_requires_role'] = authRequiresRole;
    }
    if (_authUsernameSet || _apiMapResponse.containsKey('auth_username')) {
      json['auth_username'] = authUsername;
    }
    if (_connectionHostSet || _apiMapResponse.containsKey('connection_host')) {
      json['connection_host'] = connectionHost;
    }
    if (_connectionPortSet || _apiMapResponse.containsKey('connection_port')) {
      json['connection_port'] = connectionPort;
    }
    if (_connectionTlsSet || _apiMapResponse.containsKey('connection_tls')) {
      json['connection_tls'] = connectionTls;
    }
    if (_connectionTlsNoVerifySet ||
        _apiMapResponse.containsKey('connection_tls_no_verify')) {
      json['connection_tls_no_verify'] = connectionTlsNoVerify;
    }
    if (_defaultNewUserGroupIdsSet ||
        _apiMapResponse.containsKey('default_new_user_group_ids')) {
      json['default_new_user_group_ids'] = defaultNewUserGroupIds;
    }
    if (_defaultNewUserRoleIdsSet ||
        _apiMapResponse.containsKey('default_new_user_role_ids')) {
      json['default_new_user_role_ids'] = defaultNewUserRoleIds;
    }
    if (_enabledSet || _apiMapResponse.containsKey('enabled')) {
      json['enabled'] = enabled;
    }
    if (_forceNoPageSet || _apiMapResponse.containsKey('force_no_page')) {
      json['force_no_page'] = forceNoPage;
    }
    if (_groupsBaseDnSet || _apiMapResponse.containsKey('groups_base_dn')) {
      json['groups_base_dn'] = groupsBaseDn;
    }
    if (_groupsFinderTypeSet ||
        _apiMapResponse.containsKey('groups_finder_type')) {
      json['groups_finder_type'] = groupsFinderType;
    }
    if (_groupsMemberAttributeSet ||
        _apiMapResponse.containsKey('groups_member_attribute')) {
      json['groups_member_attribute'] = groupsMemberAttribute;
    }
    if (_groupsObjectclassesSet ||
        _apiMapResponse.containsKey('groups_objectclasses')) {
      json['groups_objectclasses'] = groupsObjectclasses;
    }
    if (_groupsUserAttributeSet ||
        _apiMapResponse.containsKey('groups_user_attribute')) {
      json['groups_user_attribute'] = groupsUserAttribute;
    }
    if (_groupsWithRoleIdsSet ||
        _apiMapResponse.containsKey('groups_with_role_ids')) {
      json['groups_with_role_ids'] =
          groupsWithRoleIds?.map((i) => i.toJson())?.toList();
    }
    if (_mergeNewUsersByEmailSet ||
        _apiMapResponse.containsKey('merge_new_users_by_email')) {
      json['merge_new_users_by_email'] = mergeNewUsersByEmail;
    }
    if (_setRolesFromGroupsSet ||
        _apiMapResponse.containsKey('set_roles_from_groups')) {
      json['set_roles_from_groups'] = setRolesFromGroups;
    }
    if (_testLdapPasswordSet ||
        _apiMapResponse.containsKey('test_ldap_password')) {
      json['test_ldap_password'] = testLdapPassword;
    }
    if (_testLdapUserSet || _apiMapResponse.containsKey('test_ldap_user')) {
      json['test_ldap_user'] = testLdapUser;
    }
    if (_userAttributeMapEmailSet ||
        _apiMapResponse.containsKey('user_attribute_map_email')) {
      json['user_attribute_map_email'] = userAttributeMapEmail;
    }
    if (_userAttributeMapFirstNameSet ||
        _apiMapResponse.containsKey('user_attribute_map_first_name')) {
      json['user_attribute_map_first_name'] = userAttributeMapFirstName;
    }
    if (_userAttributeMapLastNameSet ||
        _apiMapResponse.containsKey('user_attribute_map_last_name')) {
      json['user_attribute_map_last_name'] = userAttributeMapLastName;
    }
    if (_userAttributeMapLdapIdSet ||
        _apiMapResponse.containsKey('user_attribute_map_ldap_id')) {
      json['user_attribute_map_ldap_id'] = userAttributeMapLdapId;
    }
    if (_userAttributesWithIdsSet ||
        _apiMapResponse.containsKey('user_attributes_with_ids')) {
      json['user_attributes_with_ids'] =
          userAttributesWithIds?.map((i) => i.toJson())?.toList();
    }
    if (_userBindBaseDnSet ||
        _apiMapResponse.containsKey('user_bind_base_dn')) {
      json['user_bind_base_dn'] = userBindBaseDn;
    }
    if (_userCustomFilterSet ||
        _apiMapResponse.containsKey('user_custom_filter')) {
      json['user_custom_filter'] = userCustomFilter;
    }
    if (_userIdAttributeNamesSet ||
        _apiMapResponse.containsKey('user_id_attribute_names')) {
      json['user_id_attribute_names'] = userIdAttributeNames;
    }
    if (_userObjectclassSet ||
        _apiMapResponse.containsKey('user_objectclass')) {
      json['user_objectclass'] = userObjectclass;
    }
    if (_allowNormalGroupMembershipSet ||
        _apiMapResponse.containsKey('allow_normal_group_membership')) {
      json['allow_normal_group_membership'] = allowNormalGroupMembership;
    }
    if (_allowRolesFromNormalGroupsSet ||
        _apiMapResponse.containsKey('allow_roles_from_normal_groups')) {
      json['allow_roles_from_normal_groups'] = allowRolesFromNormalGroups;
    }
    if (_allowDirectRolesSet ||
        _apiMapResponse.containsKey('allow_direct_roles')) {
      json['allow_direct_roles'] = allowDirectRoles;
    }
    return json;
  }
}

/// Dynamic writeable type for LegacyFeature removes:
/// can, id, name, description, enabled, disallowed_as_of_version, disable_on_upgrade_to_version, end_of_life_version, documentation_url, approximate_disable_date, approximate_end_of_life_date, has_disabled_on_upgrade
class WriteLegacyFeature {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _enabledLocally;
  bool _enabledLocallySet = false;

  /// Whether this feature has been enabled by a user

  bool get enabledLocally {
    if (!_enabledLocallySet && _apiMapResponse.containsKey('enabled_locally')) {
      _enabledLocally = _apiMapResponse['enabled_locally'];
      _enabledLocallySet = true;
    }
    return _enabledLocally;
  }

  set enabledLocally(bool v) {
    _enabledLocally = v;
    _enabledLocallySet = true;
  }

  WriteLegacyFeature() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteLegacyFeature.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_enabledLocallySet || _apiMapResponse.containsKey('enabled_locally')) {
      json['enabled_locally'] = enabledLocally;
    }
    return json;
  }
}

/// Dynamic writeable type for LookBasic removes:
/// can, content_metadata_id, id, title
class WriteLookBasic {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _userId;
  bool _userIdSet = false;

  /// User Id

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  WriteLookBasic() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteLookBasic.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    return json;
  }
}

/// Dynamic writeable type for LookmlModel removes:
/// can, explores, has_content, label
class WriteLookmlModel {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  List<String> _allowedDbConnectionNames;
  bool _allowedDbConnectionNamesSet = false;

  String _name;
  bool _nameSet = false;

  String _projectName;
  bool _projectNameSet = false;

  bool _unlimitedDbConnections;
  bool _unlimitedDbConnectionsSet = false;

  /// Array of names of connections this model is allowed to use

  List<String> get allowedDbConnectionNames {
    if (!_allowedDbConnectionNamesSet &&
        _apiMapResponse.containsKey('allowed_db_connection_names')) {
      _allowedDbConnectionNames = _apiMapResponse['allowed_db_connection_names']
          ?.map<String>((i) => i as String)
          ?.toList();
      _allowedDbConnectionNamesSet = true;
    }
    return _allowedDbConnectionNames;
  }

  set allowedDbConnectionNames(List<String> v) {
    _allowedDbConnectionNames = v;
    _allowedDbConnectionNamesSet = true;
  }

  /// Name of the model. Also used as the unique identifier

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Name of project containing the model

  String get projectName {
    if (!_projectNameSet && _apiMapResponse.containsKey('project_name')) {
      _projectName = _apiMapResponse['project_name']?.toString();
      _projectNameSet = true;
    }
    return _projectName;
  }

  set projectName(String v) {
    _projectName = v;
    _projectNameSet = true;
  }

  /// Is this model allowed to use all current and future connections

  bool get unlimitedDbConnections {
    if (!_unlimitedDbConnectionsSet &&
        _apiMapResponse.containsKey('unlimited_db_connections')) {
      _unlimitedDbConnections = _apiMapResponse['unlimited_db_connections'];
      _unlimitedDbConnectionsSet = true;
    }
    return _unlimitedDbConnections;
  }

  set unlimitedDbConnections(bool v) {
    _unlimitedDbConnections = v;
    _unlimitedDbConnectionsSet = true;
  }

  WriteLookmlModel() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteLookmlModel.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_allowedDbConnectionNamesSet ||
        _apiMapResponse.containsKey('allowed_db_connection_names')) {
      json['allowed_db_connection_names'] = allowedDbConnectionNames;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_projectNameSet || _apiMapResponse.containsKey('project_name')) {
      json['project_name'] = projectName;
    }
    if (_unlimitedDbConnectionsSet ||
        _apiMapResponse.containsKey('unlimited_db_connections')) {
      json['unlimited_db_connections'] = unlimitedDbConnections;
    }
    return json;
  }
}

/// Dynamic writeable type for LookWithQuery removes:
/// can, content_metadata_id, id, content_favorite_id, created_at, deleted_at, deleter_id, embed_url, excel_file_url, favorite_count, google_spreadsheet_formula, image_embed_url, last_accessed_at, last_updater_id, last_viewed_at, model, public_slug, public_url, short_url, updated_at, view_count, url
class WriteLookWithQuery {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _title;
  bool _titleSet = false;

  int _userId;
  bool _userIdSet = false;

  bool _deleted;
  bool _deletedSet = false;

  String _description;
  bool _descriptionSet = false;

  bool _isRunOnLoad;
  bool _isRunOnLoadSet = false;

  bool _public;
  bool _publicSet = false;

  int _queryId;
  bool _queryIdSet = false;

  WriteFolderBase _folder;
  bool _folderSet = false;

  String _folderId;
  bool _folderIdSet = false;

  WriteQuery _query;
  bool _querySet = false;

  /// Look Title

  String get title {
    if (!_titleSet && _apiMapResponse.containsKey('title')) {
      _title = _apiMapResponse['title']?.toString();
      _titleSet = true;
    }
    return _title;
  }

  set title(String v) {
    _title = v;
    _titleSet = true;
  }

  /// User Id

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  /// Whether or not a look is 'soft' deleted.

  bool get deleted {
    if (!_deletedSet && _apiMapResponse.containsKey('deleted')) {
      _deleted = _apiMapResponse['deleted'];
      _deletedSet = true;
    }
    return _deleted;
  }

  set deleted(bool v) {
    _deleted = v;
    _deletedSet = true;
  }

  /// Description

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// auto-run query when Look viewed

  bool get isRunOnLoad {
    if (!_isRunOnLoadSet && _apiMapResponse.containsKey('is_run_on_load')) {
      _isRunOnLoad = _apiMapResponse['is_run_on_load'];
      _isRunOnLoadSet = true;
    }
    return _isRunOnLoad;
  }

  set isRunOnLoad(bool v) {
    _isRunOnLoad = v;
    _isRunOnLoadSet = true;
  }

  /// Is Public

  bool get public {
    if (!_publicSet && _apiMapResponse.containsKey('public')) {
      _public = _apiMapResponse['public'];
      _publicSet = true;
    }
    return _public;
  }

  set public(bool v) {
    _public = v;
    _publicSet = true;
  }

  /// Query Id

  int get queryId {
    if (!_queryIdSet && _apiMapResponse.containsKey('query_id')) {
      _queryId = _apiMapResponse['query_id'];
      _queryIdSet = true;
    }
    return _queryId;
  }

  set queryId(int v) {
    _queryId = v;
    _queryIdSet = true;
  }

  /// Dynamic writeable type for FolderBase removes:
  /// id, content_metadata_id, created_at, creator_id, child_count, external_id, is_embed, is_embed_shared_root, is_embed_users_root, is_personal, is_personal_descendant, is_shared_root, is_users_root, can

  WriteFolderBase get folder {
    if (!_folderSet && _apiMapResponse.containsKey('folder')) {
      _folder = _apiMapResponse['folder'] == null
          ? null
          : WriteFolderBase.fromResponse(
              _apiMapResponse['folder'], apiResponseContentType);
      _folderSet = true;
    }
    return _folder;
  }

  set folder(WriteFolderBase v) {
    _folder = v;
    _folderSet = true;
  }

  /// Folder Id

  String get folderId {
    if (!_folderIdSet && _apiMapResponse.containsKey('folder_id')) {
      _folderId = _apiMapResponse['folder_id']?.toString();
      _folderIdSet = true;
    }
    return _folderId;
  }

  set folderId(String v) {
    _folderId = v;
    _folderIdSet = true;
  }

  /// Dynamic writeable type for Query removes:
  /// can, id, slug, share_url, expanded_share_url, url, has_table_calculations

  WriteQuery get query {
    if (!_querySet && _apiMapResponse.containsKey('query')) {
      _query = _apiMapResponse['query'] == null
          ? null
          : WriteQuery.fromResponse(
              _apiMapResponse['query'], apiResponseContentType);
      _querySet = true;
    }
    return _query;
  }

  set query(WriteQuery v) {
    _query = v;
    _querySet = true;
  }

  WriteLookWithQuery() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteLookWithQuery.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_titleSet || _apiMapResponse.containsKey('title')) {
      json['title'] = title;
    }
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    if (_deletedSet || _apiMapResponse.containsKey('deleted')) {
      json['deleted'] = deleted;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_isRunOnLoadSet || _apiMapResponse.containsKey('is_run_on_load')) {
      json['is_run_on_load'] = isRunOnLoad;
    }
    if (_publicSet || _apiMapResponse.containsKey('public')) {
      json['public'] = public;
    }
    if (_queryIdSet || _apiMapResponse.containsKey('query_id')) {
      json['query_id'] = queryId;
    }
    if (_folderSet || _apiMapResponse.containsKey('folder')) {
      json['folder'] = folder?.toJson();
    }
    if (_folderIdSet || _apiMapResponse.containsKey('folder_id')) {
      json['folder_id'] = folderId;
    }
    if (_querySet || _apiMapResponse.containsKey('query')) {
      json['query'] = query?.toJson();
    }
    return json;
  }
}

/// Dynamic writeable type for MergeQuery removes:
/// can, id, result_maker_id
class WriteMergeQuery {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _columnLimit;
  bool _columnLimitSet = false;

  String _dynamicFields;
  bool _dynamicFieldsSet = false;

  List<String> _pivots;
  bool _pivotsSet = false;

  List<String> _sorts;
  bool _sortsSet = false;

  List<MergeQuerySourceQuery> _sourceQueries;
  bool _sourceQueriesSet = false;

  bool _total;
  bool _totalSet = false;

  Map<String, dynamic> _visConfig;
  bool _visConfigSet = false;

  /// Column Limit

  String get columnLimit {
    if (!_columnLimitSet && _apiMapResponse.containsKey('column_limit')) {
      _columnLimit = _apiMapResponse['column_limit']?.toString();
      _columnLimitSet = true;
    }
    return _columnLimit;
  }

  set columnLimit(String v) {
    _columnLimit = v;
    _columnLimitSet = true;
  }

  /// Dynamic Fields

  String get dynamicFields {
    if (!_dynamicFieldsSet && _apiMapResponse.containsKey('dynamic_fields')) {
      _dynamicFields = _apiMapResponse['dynamic_fields']?.toString();
      _dynamicFieldsSet = true;
    }
    return _dynamicFields;
  }

  set dynamicFields(String v) {
    _dynamicFields = v;
    _dynamicFieldsSet = true;
  }

  /// Pivots

  List<String> get pivots {
    if (!_pivotsSet && _apiMapResponse.containsKey('pivots')) {
      _pivots =
          _apiMapResponse['pivots']?.map<String>((i) => i as String)?.toList();
      _pivotsSet = true;
    }
    return _pivots;
  }

  set pivots(List<String> v) {
    _pivots = v;
    _pivotsSet = true;
  }

  /// Sorts

  List<String> get sorts {
    if (!_sortsSet && _apiMapResponse.containsKey('sorts')) {
      _sorts =
          _apiMapResponse['sorts']?.map<String>((i) => i as String)?.toList();
      _sortsSet = true;
    }
    return _sorts;
  }

  set sorts(List<String> v) {
    _sorts = v;
    _sortsSet = true;
  }

  /// Source Queries defining the results to be merged.

  List<MergeQuerySourceQuery> get sourceQueries {
    if (!_sourceQueriesSet && _apiMapResponse.containsKey('source_queries')) {
      _sourceQueries = _apiMapResponse['source_queries'] == null
          ? null
          : (_apiMapResponse['source_queries'] as List)
              .map((i) =>
                  MergeQuerySourceQuery.fromResponse(i, apiResponseContentType))
              .toList();
      _sourceQueriesSet = true;
    }
    return _sourceQueries;
  }

  set sourceQueries(List<MergeQuerySourceQuery> v) {
    _sourceQueries = v;
    _sourceQueriesSet = true;
  }

  /// Total

  bool get total {
    if (!_totalSet && _apiMapResponse.containsKey('total')) {
      _total = _apiMapResponse['total'];
      _totalSet = true;
    }
    return _total;
  }

  set total(bool v) {
    _total = v;
    _totalSet = true;
  }

  /// Visualization Config

  Map<String, dynamic> get visConfig {
    if (!_visConfigSet && _apiMapResponse.containsKey('vis_config')) {
      _visConfig = _apiMapResponse['vis_config'];
      _visConfigSet = true;
    }
    return _visConfig;
  }

  set visConfig(Map<String, dynamic> v) {
    _visConfig = v;
    _visConfigSet = true;
  }

  WriteMergeQuery() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteMergeQuery.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_columnLimitSet || _apiMapResponse.containsKey('column_limit')) {
      json['column_limit'] = columnLimit;
    }
    if (_dynamicFieldsSet || _apiMapResponse.containsKey('dynamic_fields')) {
      json['dynamic_fields'] = dynamicFields;
    }
    if (_pivotsSet || _apiMapResponse.containsKey('pivots')) {
      json['pivots'] = pivots;
    }
    if (_sortsSet || _apiMapResponse.containsKey('sorts')) {
      json['sorts'] = sorts;
    }
    if (_sourceQueriesSet || _apiMapResponse.containsKey('source_queries')) {
      json['source_queries'] = sourceQueries?.map((i) => i.toJson())?.toList();
    }
    if (_totalSet || _apiMapResponse.containsKey('total')) {
      json['total'] = total;
    }
    if (_visConfigSet || _apiMapResponse.containsKey('vis_config')) {
      json['vis_config'] = visConfig;
    }
    return json;
  }
}

/// Dynamic writeable type for ModelSet removes:
/// can, all_access, built_in, id, url
class WriteModelSet {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  List<String> _models;
  bool _modelsSet = false;

  String _name;
  bool _nameSet = false;

  List<String> get models {
    if (!_modelsSet && _apiMapResponse.containsKey('models')) {
      _models =
          _apiMapResponse['models']?.map<String>((i) => i as String)?.toList();
      _modelsSet = true;
    }
    return _models;
  }

  set models(List<String> v) {
    _models = v;
    _modelsSet = true;
  }

  /// Name of ModelSet

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  WriteModelSet() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteModelSet.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_modelsSet || _apiMapResponse.containsKey('models')) {
      json['models'] = models;
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    return json;
  }
}

/// Dynamic writeable type for OauthClientApp removes:
/// can, client_guid, tokens_invalid_before, activated_users
class WriteOauthClientApp {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _redirectUri;
  bool _redirectUriSet = false;

  String _displayName;
  bool _displayNameSet = false;

  String _description;
  bool _descriptionSet = false;

  bool _enabled;
  bool _enabledSet = false;

  int _groupId;
  bool _groupIdSet = false;

  /// The uri with which this application will receive an auth code by browser redirect.

  String get redirectUri {
    if (!_redirectUriSet && _apiMapResponse.containsKey('redirect_uri')) {
      _redirectUri = _apiMapResponse['redirect_uri']?.toString();
      _redirectUriSet = true;
    }
    return _redirectUri;
  }

  set redirectUri(String v) {
    _redirectUri = v;
    _redirectUriSet = true;
  }

  /// The application's display name

  String get displayName {
    if (!_displayNameSet && _apiMapResponse.containsKey('display_name')) {
      _displayName = _apiMapResponse['display_name']?.toString();
      _displayNameSet = true;
    }
    return _displayName;
  }

  set displayName(String v) {
    _displayName = v;
    _displayNameSet = true;
  }

  /// A description of the application that will be displayed to users

  String get description {
    if (!_descriptionSet && _apiMapResponse.containsKey('description')) {
      _description = _apiMapResponse['description']?.toString();
      _descriptionSet = true;
    }
    return _description;
  }

  set description(String v) {
    _description = v;
    _descriptionSet = true;
  }

  /// When enabled is true, OAuth2 and API requests will be accepted from this app. When false, all requests from this app will be refused.

  bool get enabled {
    if (!_enabledSet && _apiMapResponse.containsKey('enabled')) {
      _enabled = _apiMapResponse['enabled'];
      _enabledSet = true;
    }
    return _enabled;
  }

  set enabled(bool v) {
    _enabled = v;
    _enabledSet = true;
  }

  /// If set, only Looker users who are members of this group can use this web app with Looker. If group_id is not set, any Looker user may use this app to access this Looker instance

  int get groupId {
    if (!_groupIdSet && _apiMapResponse.containsKey('group_id')) {
      _groupId = _apiMapResponse['group_id'];
      _groupIdSet = true;
    }
    return _groupId;
  }

  set groupId(int v) {
    _groupId = v;
    _groupIdSet = true;
  }

  WriteOauthClientApp() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteOauthClientApp.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_redirectUriSet || _apiMapResponse.containsKey('redirect_uri')) {
      json['redirect_uri'] = redirectUri;
    }
    if (_displayNameSet || _apiMapResponse.containsKey('display_name')) {
      json['display_name'] = displayName;
    }
    if (_descriptionSet || _apiMapResponse.containsKey('description')) {
      json['description'] = description;
    }
    if (_enabledSet || _apiMapResponse.containsKey('enabled')) {
      json['enabled'] = enabled;
    }
    if (_groupIdSet || _apiMapResponse.containsKey('group_id')) {
      json['group_id'] = groupId;
    }
    return json;
  }
}

/// Dynamic writeable type for OIDCConfig removes:
/// can, default_new_user_groups, default_new_user_roles, groups, modified_at, modified_by, test_slug, user_attributes, url
class WriteOIDCConfig {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _alternateEmailLoginAllowed;
  bool _alternateEmailLoginAllowedSet = false;

  String _audience;
  bool _audienceSet = false;

  bool _authRequiresRole;
  bool _authRequiresRoleSet = false;

  String _authorizationEndpoint;
  bool _authorizationEndpointSet = false;

  List<int> _defaultNewUserGroupIds;
  bool _defaultNewUserGroupIdsSet = false;

  List<int> _defaultNewUserRoleIds;
  bool _defaultNewUserRoleIdsSet = false;

  bool _enabled;
  bool _enabledSet = false;

  String _groupsAttribute;
  bool _groupsAttributeSet = false;

  List<OIDCGroupWrite> _groupsWithRoleIds;
  bool _groupsWithRoleIdsSet = false;

  String _identifier;
  bool _identifierSet = false;

  String _issuer;
  bool _issuerSet = false;

  String _newUserMigrationTypes;
  bool _newUserMigrationTypesSet = false;

  List<String> _scopes;
  bool _scopesSet = false;

  String _secret;
  bool _secretSet = false;

  bool _setRolesFromGroups;
  bool _setRolesFromGroupsSet = false;

  String _tokenEndpoint;
  bool _tokenEndpointSet = false;

  String _userAttributeMapEmail;
  bool _userAttributeMapEmailSet = false;

  String _userAttributeMapFirstName;
  bool _userAttributeMapFirstNameSet = false;

  String _userAttributeMapLastName;
  bool _userAttributeMapLastNameSet = false;

  List<OIDCUserAttributeWrite> _userAttributesWithIds;
  bool _userAttributesWithIdsSet = false;

  String _userinfoEndpoint;
  bool _userinfoEndpointSet = false;

  bool _allowNormalGroupMembership;
  bool _allowNormalGroupMembershipSet = false;

  bool _allowRolesFromNormalGroups;
  bool _allowRolesFromNormalGroupsSet = false;

  bool _allowDirectRoles;
  bool _allowDirectRolesSet = false;

  /// Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.

  bool get alternateEmailLoginAllowed {
    if (!_alternateEmailLoginAllowedSet &&
        _apiMapResponse.containsKey('alternate_email_login_allowed')) {
      _alternateEmailLoginAllowed =
          _apiMapResponse['alternate_email_login_allowed'];
      _alternateEmailLoginAllowedSet = true;
    }
    return _alternateEmailLoginAllowed;
  }

  set alternateEmailLoginAllowed(bool v) {
    _alternateEmailLoginAllowed = v;
    _alternateEmailLoginAllowedSet = true;
  }

  /// OpenID Provider Audience

  String get audience {
    if (!_audienceSet && _apiMapResponse.containsKey('audience')) {
      _audience = _apiMapResponse['audience']?.toString();
      _audienceSet = true;
    }
    return _audience;
  }

  set audience(String v) {
    _audience = v;
    _audienceSet = true;
  }

  /// Users will not be allowed to login at all unless a role for them is found in OIDC if set to true

  bool get authRequiresRole {
    if (!_authRequiresRoleSet &&
        _apiMapResponse.containsKey('auth_requires_role')) {
      _authRequiresRole = _apiMapResponse['auth_requires_role'];
      _authRequiresRoleSet = true;
    }
    return _authRequiresRole;
  }

  set authRequiresRole(bool v) {
    _authRequiresRole = v;
    _authRequiresRoleSet = true;
  }

  /// OpenID Provider Authorization Url

  String get authorizationEndpoint {
    if (!_authorizationEndpointSet &&
        _apiMapResponse.containsKey('authorization_endpoint')) {
      _authorizationEndpoint =
          _apiMapResponse['authorization_endpoint']?.toString();
      _authorizationEndpointSet = true;
    }
    return _authorizationEndpoint;
  }

  set authorizationEndpoint(String v) {
    _authorizationEndpoint = v;
    _authorizationEndpointSet = true;
  }

  /// (Write-Only) Array of ids of groups that will be applied to new users the first time they login via OIDC

  List<int> get defaultNewUserGroupIds {
    if (!_defaultNewUserGroupIdsSet &&
        _apiMapResponse.containsKey('default_new_user_group_ids')) {
      _defaultNewUserGroupIds = _apiMapResponse['default_new_user_group_ids']
          ?.map<int>((i) => i as int)
          ?.toList();
      _defaultNewUserGroupIdsSet = true;
    }
    return _defaultNewUserGroupIds;
  }

  set defaultNewUserGroupIds(List<int> v) {
    _defaultNewUserGroupIds = v;
    _defaultNewUserGroupIdsSet = true;
  }

  /// (Write-Only) Array of ids of roles that will be applied to new users the first time they login via OIDC

  List<int> get defaultNewUserRoleIds {
    if (!_defaultNewUserRoleIdsSet &&
        _apiMapResponse.containsKey('default_new_user_role_ids')) {
      _defaultNewUserRoleIds = _apiMapResponse['default_new_user_role_ids']
          ?.map<int>((i) => i as int)
          ?.toList();
      _defaultNewUserRoleIdsSet = true;
    }
    return _defaultNewUserRoleIds;
  }

  set defaultNewUserRoleIds(List<int> v) {
    _defaultNewUserRoleIds = v;
    _defaultNewUserRoleIdsSet = true;
  }

  /// Enable/Disable OIDC authentication for the server

  bool get enabled {
    if (!_enabledSet && _apiMapResponse.containsKey('enabled')) {
      _enabled = _apiMapResponse['enabled'];
      _enabledSet = true;
    }
    return _enabled;
  }

  set enabled(bool v) {
    _enabled = v;
    _enabledSet = true;
  }

  /// Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'

  String get groupsAttribute {
    if (!_groupsAttributeSet &&
        _apiMapResponse.containsKey('groups_attribute')) {
      _groupsAttribute = _apiMapResponse['groups_attribute']?.toString();
      _groupsAttributeSet = true;
    }
    return _groupsAttribute;
  }

  set groupsAttribute(String v) {
    _groupsAttribute = v;
    _groupsAttributeSet = true;
  }

  /// (Read/Write) Array of mappings between OIDC Groups and arrays of Looker Role ids

  List<OIDCGroupWrite> get groupsWithRoleIds {
    if (!_groupsWithRoleIdsSet &&
        _apiMapResponse.containsKey('groups_with_role_ids')) {
      _groupsWithRoleIds = _apiMapResponse['groups_with_role_ids'] == null
          ? null
          : (_apiMapResponse['groups_with_role_ids'] as List)
              .map(
                  (i) => OIDCGroupWrite.fromResponse(i, apiResponseContentType))
              .toList();
      _groupsWithRoleIdsSet = true;
    }
    return _groupsWithRoleIds;
  }

  set groupsWithRoleIds(List<OIDCGroupWrite> v) {
    _groupsWithRoleIds = v;
    _groupsWithRoleIdsSet = true;
  }

  /// Relying Party Identifier (provided by OpenID Provider)

  String get identifier {
    if (!_identifierSet && _apiMapResponse.containsKey('identifier')) {
      _identifier = _apiMapResponse['identifier']?.toString();
      _identifierSet = true;
    }
    return _identifier;
  }

  set identifier(String v) {
    _identifier = v;
    _identifierSet = true;
  }

  /// OpenID Provider Issuer

  String get issuer {
    if (!_issuerSet && _apiMapResponse.containsKey('issuer')) {
      _issuer = _apiMapResponse['issuer']?.toString();
      _issuerSet = true;
    }
    return _issuer;
  }

  set issuer(String v) {
    _issuer = v;
    _issuerSet = true;
  }

  /// Merge first-time oidc login to existing user account by email addresses. When a user logs in for the first time via oidc this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'

  String get newUserMigrationTypes {
    if (!_newUserMigrationTypesSet &&
        _apiMapResponse.containsKey('new_user_migration_types')) {
      _newUserMigrationTypes =
          _apiMapResponse['new_user_migration_types']?.toString();
      _newUserMigrationTypesSet = true;
    }
    return _newUserMigrationTypes;
  }

  set newUserMigrationTypes(String v) {
    _newUserMigrationTypes = v;
    _newUserMigrationTypesSet = true;
  }

  /// Array of scopes to request.

  List<String> get scopes {
    if (!_scopesSet && _apiMapResponse.containsKey('scopes')) {
      _scopes =
          _apiMapResponse['scopes']?.map<String>((i) => i as String)?.toList();
      _scopesSet = true;
    }
    return _scopes;
  }

  set scopes(List<String> v) {
    _scopes = v;
    _scopesSet = true;
  }

  /// (Write-Only) Relying Party Secret (provided by OpenID Provider)

  String get secret {
    if (!_secretSet && _apiMapResponse.containsKey('secret')) {
      _secret = _apiMapResponse['secret']?.toString();
      _secretSet = true;
    }
    return _secret;
  }

  set secret(String v) {
    _secret = v;
    _secretSet = true;
  }

  /// Set user roles in Looker based on groups from OIDC

  bool get setRolesFromGroups {
    if (!_setRolesFromGroupsSet &&
        _apiMapResponse.containsKey('set_roles_from_groups')) {
      _setRolesFromGroups = _apiMapResponse['set_roles_from_groups'];
      _setRolesFromGroupsSet = true;
    }
    return _setRolesFromGroups;
  }

  set setRolesFromGroups(bool v) {
    _setRolesFromGroups = v;
    _setRolesFromGroupsSet = true;
  }

  /// OpenID Provider Token Url

  String get tokenEndpoint {
    if (!_tokenEndpointSet && _apiMapResponse.containsKey('token_endpoint')) {
      _tokenEndpoint = _apiMapResponse['token_endpoint']?.toString();
      _tokenEndpointSet = true;
    }
    return _tokenEndpoint;
  }

  set tokenEndpoint(String v) {
    _tokenEndpoint = v;
    _tokenEndpointSet = true;
  }

  /// Name of user record attributes used to indicate email address field

  String get userAttributeMapEmail {
    if (!_userAttributeMapEmailSet &&
        _apiMapResponse.containsKey('user_attribute_map_email')) {
      _userAttributeMapEmail =
          _apiMapResponse['user_attribute_map_email']?.toString();
      _userAttributeMapEmailSet = true;
    }
    return _userAttributeMapEmail;
  }

  set userAttributeMapEmail(String v) {
    _userAttributeMapEmail = v;
    _userAttributeMapEmailSet = true;
  }

  /// Name of user record attributes used to indicate first name

  String get userAttributeMapFirstName {
    if (!_userAttributeMapFirstNameSet &&
        _apiMapResponse.containsKey('user_attribute_map_first_name')) {
      _userAttributeMapFirstName =
          _apiMapResponse['user_attribute_map_first_name']?.toString();
      _userAttributeMapFirstNameSet = true;
    }
    return _userAttributeMapFirstName;
  }

  set userAttributeMapFirstName(String v) {
    _userAttributeMapFirstName = v;
    _userAttributeMapFirstNameSet = true;
  }

  /// Name of user record attributes used to indicate last name

  String get userAttributeMapLastName {
    if (!_userAttributeMapLastNameSet &&
        _apiMapResponse.containsKey('user_attribute_map_last_name')) {
      _userAttributeMapLastName =
          _apiMapResponse['user_attribute_map_last_name']?.toString();
      _userAttributeMapLastNameSet = true;
    }
    return _userAttributeMapLastName;
  }

  set userAttributeMapLastName(String v) {
    _userAttributeMapLastName = v;
    _userAttributeMapLastNameSet = true;
  }

  /// (Read/Write) Array of mappings between OIDC User Attributes and arrays of Looker User Attribute ids

  List<OIDCUserAttributeWrite> get userAttributesWithIds {
    if (!_userAttributesWithIdsSet &&
        _apiMapResponse.containsKey('user_attributes_with_ids')) {
      _userAttributesWithIds =
          _apiMapResponse['user_attributes_with_ids'] == null
              ? null
              : (_apiMapResponse['user_attributes_with_ids'] as List)
                  .map((i) => OIDCUserAttributeWrite.fromResponse(
                      i, apiResponseContentType))
                  .toList();
      _userAttributesWithIdsSet = true;
    }
    return _userAttributesWithIds;
  }

  set userAttributesWithIds(List<OIDCUserAttributeWrite> v) {
    _userAttributesWithIds = v;
    _userAttributesWithIdsSet = true;
  }

  /// OpenID Provider User Information Url

  String get userinfoEndpoint {
    if (!_userinfoEndpointSet &&
        _apiMapResponse.containsKey('userinfo_endpoint')) {
      _userinfoEndpoint = _apiMapResponse['userinfo_endpoint']?.toString();
      _userinfoEndpointSet = true;
    }
    return _userinfoEndpoint;
  }

  set userinfoEndpoint(String v) {
    _userinfoEndpoint = v;
    _userinfoEndpointSet = true;
  }

  /// Allow OIDC auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.

  bool get allowNormalGroupMembership {
    if (!_allowNormalGroupMembershipSet &&
        _apiMapResponse.containsKey('allow_normal_group_membership')) {
      _allowNormalGroupMembership =
          _apiMapResponse['allow_normal_group_membership'];
      _allowNormalGroupMembershipSet = true;
    }
    return _allowNormalGroupMembership;
  }

  set allowNormalGroupMembership(bool v) {
    _allowNormalGroupMembership = v;
    _allowNormalGroupMembershipSet = true;
  }

  /// OIDC auth'd users will inherit roles from non-reflected Looker groups.

  bool get allowRolesFromNormalGroups {
    if (!_allowRolesFromNormalGroupsSet &&
        _apiMapResponse.containsKey('allow_roles_from_normal_groups')) {
      _allowRolesFromNormalGroups =
          _apiMapResponse['allow_roles_from_normal_groups'];
      _allowRolesFromNormalGroupsSet = true;
    }
    return _allowRolesFromNormalGroups;
  }

  set allowRolesFromNormalGroups(bool v) {
    _allowRolesFromNormalGroups = v;
    _allowRolesFromNormalGroupsSet = true;
  }

  /// Allows roles to be directly assigned to OIDC auth'd users.

  bool get allowDirectRoles {
    if (!_allowDirectRolesSet &&
        _apiMapResponse.containsKey('allow_direct_roles')) {
      _allowDirectRoles = _apiMapResponse['allow_direct_roles'];
      _allowDirectRolesSet = true;
    }
    return _allowDirectRoles;
  }

  set allowDirectRoles(bool v) {
    _allowDirectRoles = v;
    _allowDirectRolesSet = true;
  }

  WriteOIDCConfig() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteOIDCConfig.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_alternateEmailLoginAllowedSet ||
        _apiMapResponse.containsKey('alternate_email_login_allowed')) {
      json['alternate_email_login_allowed'] = alternateEmailLoginAllowed;
    }
    if (_audienceSet || _apiMapResponse.containsKey('audience')) {
      json['audience'] = audience;
    }
    if (_authRequiresRoleSet ||
        _apiMapResponse.containsKey('auth_requires_role')) {
      json['auth_requires_role'] = authRequiresRole;
    }
    if (_authorizationEndpointSet ||
        _apiMapResponse.containsKey('authorization_endpoint')) {
      json['authorization_endpoint'] = authorizationEndpoint;
    }
    if (_defaultNewUserGroupIdsSet ||
        _apiMapResponse.containsKey('default_new_user_group_ids')) {
      json['default_new_user_group_ids'] = defaultNewUserGroupIds;
    }
    if (_defaultNewUserRoleIdsSet ||
        _apiMapResponse.containsKey('default_new_user_role_ids')) {
      json['default_new_user_role_ids'] = defaultNewUserRoleIds;
    }
    if (_enabledSet || _apiMapResponse.containsKey('enabled')) {
      json['enabled'] = enabled;
    }
    if (_groupsAttributeSet ||
        _apiMapResponse.containsKey('groups_attribute')) {
      json['groups_attribute'] = groupsAttribute;
    }
    if (_groupsWithRoleIdsSet ||
        _apiMapResponse.containsKey('groups_with_role_ids')) {
      json['groups_with_role_ids'] =
          groupsWithRoleIds?.map((i) => i.toJson())?.toList();
    }
    if (_identifierSet || _apiMapResponse.containsKey('identifier')) {
      json['identifier'] = identifier;
    }
    if (_issuerSet || _apiMapResponse.containsKey('issuer')) {
      json['issuer'] = issuer;
    }
    if (_newUserMigrationTypesSet ||
        _apiMapResponse.containsKey('new_user_migration_types')) {
      json['new_user_migration_types'] = newUserMigrationTypes;
    }
    if (_scopesSet || _apiMapResponse.containsKey('scopes')) {
      json['scopes'] = scopes;
    }
    if (_secretSet || _apiMapResponse.containsKey('secret')) {
      json['secret'] = secret;
    }
    if (_setRolesFromGroupsSet ||
        _apiMapResponse.containsKey('set_roles_from_groups')) {
      json['set_roles_from_groups'] = setRolesFromGroups;
    }
    if (_tokenEndpointSet || _apiMapResponse.containsKey('token_endpoint')) {
      json['token_endpoint'] = tokenEndpoint;
    }
    if (_userAttributeMapEmailSet ||
        _apiMapResponse.containsKey('user_attribute_map_email')) {
      json['user_attribute_map_email'] = userAttributeMapEmail;
    }
    if (_userAttributeMapFirstNameSet ||
        _apiMapResponse.containsKey('user_attribute_map_first_name')) {
      json['user_attribute_map_first_name'] = userAttributeMapFirstName;
    }
    if (_userAttributeMapLastNameSet ||
        _apiMapResponse.containsKey('user_attribute_map_last_name')) {
      json['user_attribute_map_last_name'] = userAttributeMapLastName;
    }
    if (_userAttributesWithIdsSet ||
        _apiMapResponse.containsKey('user_attributes_with_ids')) {
      json['user_attributes_with_ids'] =
          userAttributesWithIds?.map((i) => i.toJson())?.toList();
    }
    if (_userinfoEndpointSet ||
        _apiMapResponse.containsKey('userinfo_endpoint')) {
      json['userinfo_endpoint'] = userinfoEndpoint;
    }
    if (_allowNormalGroupMembershipSet ||
        _apiMapResponse.containsKey('allow_normal_group_membership')) {
      json['allow_normal_group_membership'] = allowNormalGroupMembership;
    }
    if (_allowRolesFromNormalGroupsSet ||
        _apiMapResponse.containsKey('allow_roles_from_normal_groups')) {
      json['allow_roles_from_normal_groups'] = allowRolesFromNormalGroups;
    }
    if (_allowDirectRolesSet ||
        _apiMapResponse.containsKey('allow_direct_roles')) {
      json['allow_direct_roles'] = allowDirectRoles;
    }
    return json;
  }
}

/// Dynamic writeable type for PasswordConfig removes:
/// can
class WritePasswordConfig {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  int _minLength;
  bool _minLengthSet = false;

  bool _requireNumeric;
  bool _requireNumericSet = false;

  bool _requireUpperlower;
  bool _requireUpperlowerSet = false;

  bool _requireSpecial;
  bool _requireSpecialSet = false;

  /// Minimum number of characters required for a new password.  Must be between 7 and 100

  int get minLength {
    if (!_minLengthSet && _apiMapResponse.containsKey('min_length')) {
      _minLength = _apiMapResponse['min_length'];
      _minLengthSet = true;
    }
    return _minLength;
  }

  set minLength(int v) {
    _minLength = v;
    _minLengthSet = true;
  }

  /// Require at least one numeric character

  bool get requireNumeric {
    if (!_requireNumericSet && _apiMapResponse.containsKey('require_numeric')) {
      _requireNumeric = _apiMapResponse['require_numeric'];
      _requireNumericSet = true;
    }
    return _requireNumeric;
  }

  set requireNumeric(bool v) {
    _requireNumeric = v;
    _requireNumericSet = true;
  }

  /// Require at least one uppercase and one lowercase letter

  bool get requireUpperlower {
    if (!_requireUpperlowerSet &&
        _apiMapResponse.containsKey('require_upperlower')) {
      _requireUpperlower = _apiMapResponse['require_upperlower'];
      _requireUpperlowerSet = true;
    }
    return _requireUpperlower;
  }

  set requireUpperlower(bool v) {
    _requireUpperlower = v;
    _requireUpperlowerSet = true;
  }

  /// Require at least one special character

  bool get requireSpecial {
    if (!_requireSpecialSet && _apiMapResponse.containsKey('require_special')) {
      _requireSpecial = _apiMapResponse['require_special'];
      _requireSpecialSet = true;
    }
    return _requireSpecial;
  }

  set requireSpecial(bool v) {
    _requireSpecial = v;
    _requireSpecialSet = true;
  }

  WritePasswordConfig() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WritePasswordConfig.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_minLengthSet || _apiMapResponse.containsKey('min_length')) {
      json['min_length'] = minLength;
    }
    if (_requireNumericSet || _apiMapResponse.containsKey('require_numeric')) {
      json['require_numeric'] = requireNumeric;
    }
    if (_requireUpperlowerSet ||
        _apiMapResponse.containsKey('require_upperlower')) {
      json['require_upperlower'] = requireUpperlower;
    }
    if (_requireSpecialSet || _apiMapResponse.containsKey('require_special')) {
      json['require_special'] = requireSpecial;
    }
    return json;
  }
}

/// Dynamic writeable type for PermissionSet removes:
/// can, all_access, built_in, id, url
class WritePermissionSet {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  List<String> _permissions;
  bool _permissionsSet = false;

  /// Name of PermissionSet

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  List<String> get permissions {
    if (!_permissionsSet && _apiMapResponse.containsKey('permissions')) {
      _permissions = _apiMapResponse['permissions']
          ?.map<String>((i) => i as String)
          ?.toList();
      _permissionsSet = true;
    }
    return _permissions;
  }

  set permissions(List<String> v) {
    _permissions = v;
    _permissionsSet = true;
  }

  WritePermissionSet() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WritePermissionSet.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_permissionsSet || _apiMapResponse.containsKey('permissions')) {
      json['permissions'] = permissions;
    }
    return json;
  }
}

/// Dynamic writeable type for Project removes:
/// can, id, uses_git, is_example
class WriteProject {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _gitRemoteUrl;
  bool _gitRemoteUrlSet = false;

  String _gitUsername;
  bool _gitUsernameSet = false;

  String _gitPassword;
  bool _gitPasswordSet = false;

  String _gitProductionBranchName;
  bool _gitProductionBranchNameSet = false;

  bool _useGitCookieAuth;
  bool _useGitCookieAuthSet = false;

  String _gitUsernameUserAttribute;
  bool _gitUsernameUserAttributeSet = false;

  String _gitPasswordUserAttribute;
  bool _gitPasswordUserAttributeSet = false;

  String _gitServiceName;
  bool _gitServiceNameSet = false;

  int _gitApplicationServerHttpPort;
  bool _gitApplicationServerHttpPortSet = false;

  String _gitApplicationServerHttpScheme;
  bool _gitApplicationServerHttpSchemeSet = false;

  String _deploySecret;
  bool _deploySecretSet = false;

  bool _unsetDeploySecret;
  bool _unsetDeploySecretSet = false;

  PullRequestMode _pullRequestMode;
  bool _pullRequestModeSet = false;

  bool _validationRequired;
  bool _validationRequiredSet = false;

  bool _gitReleaseMgmtEnabled;
  bool _gitReleaseMgmtEnabledSet = false;

  bool _allowWarnings;
  bool _allowWarningsSet = false;

  String _dependencyStatus;
  bool _dependencyStatusSet = false;

  /// Project display name

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Git remote repository url

  String get gitRemoteUrl {
    if (!_gitRemoteUrlSet && _apiMapResponse.containsKey('git_remote_url')) {
      _gitRemoteUrl = _apiMapResponse['git_remote_url']?.toString();
      _gitRemoteUrlSet = true;
    }
    return _gitRemoteUrl;
  }

  set gitRemoteUrl(String v) {
    _gitRemoteUrl = v;
    _gitRemoteUrlSet = true;
  }

  /// Git username for HTTPS authentication. (For production only, if using user attributes.)

  String get gitUsername {
    if (!_gitUsernameSet && _apiMapResponse.containsKey('git_username')) {
      _gitUsername = _apiMapResponse['git_username']?.toString();
      _gitUsernameSet = true;
    }
    return _gitUsername;
  }

  set gitUsername(String v) {
    _gitUsername = v;
    _gitUsernameSet = true;
  }

  /// (Write-Only) Git password for HTTPS authentication. (For production only, if using user attributes.)

  String get gitPassword {
    if (!_gitPasswordSet && _apiMapResponse.containsKey('git_password')) {
      _gitPassword = _apiMapResponse['git_password']?.toString();
      _gitPasswordSet = true;
    }
    return _gitPassword;
  }

  set gitPassword(String v) {
    _gitPassword = v;
    _gitPasswordSet = true;
  }

  /// Git production branch name. Defaults to master. Supported only in Looker 21.0 and higher.

  String get gitProductionBranchName {
    if (!_gitProductionBranchNameSet &&
        _apiMapResponse.containsKey('git_production_branch_name')) {
      _gitProductionBranchName =
          _apiMapResponse['git_production_branch_name']?.toString();
      _gitProductionBranchNameSet = true;
    }
    return _gitProductionBranchName;
  }

  set gitProductionBranchName(String v) {
    _gitProductionBranchName = v;
    _gitProductionBranchNameSet = true;
  }

  /// If true, the project uses a git cookie for authentication.

  bool get useGitCookieAuth {
    if (!_useGitCookieAuthSet &&
        _apiMapResponse.containsKey('use_git_cookie_auth')) {
      _useGitCookieAuth = _apiMapResponse['use_git_cookie_auth'];
      _useGitCookieAuthSet = true;
    }
    return _useGitCookieAuth;
  }

  set useGitCookieAuth(bool v) {
    _useGitCookieAuth = v;
    _useGitCookieAuthSet = true;
  }

  /// User attribute name for username in per-user HTTPS authentication.

  String get gitUsernameUserAttribute {
    if (!_gitUsernameUserAttributeSet &&
        _apiMapResponse.containsKey('git_username_user_attribute')) {
      _gitUsernameUserAttribute =
          _apiMapResponse['git_username_user_attribute']?.toString();
      _gitUsernameUserAttributeSet = true;
    }
    return _gitUsernameUserAttribute;
  }

  set gitUsernameUserAttribute(String v) {
    _gitUsernameUserAttribute = v;
    _gitUsernameUserAttributeSet = true;
  }

  /// User attribute name for password in per-user HTTPS authentication.

  String get gitPasswordUserAttribute {
    if (!_gitPasswordUserAttributeSet &&
        _apiMapResponse.containsKey('git_password_user_attribute')) {
      _gitPasswordUserAttribute =
          _apiMapResponse['git_password_user_attribute']?.toString();
      _gitPasswordUserAttributeSet = true;
    }
    return _gitPasswordUserAttribute;
  }

  set gitPasswordUserAttribute(String v) {
    _gitPasswordUserAttribute = v;
    _gitPasswordUserAttributeSet = true;
  }

  /// Name of the git service provider

  String get gitServiceName {
    if (!_gitServiceNameSet &&
        _apiMapResponse.containsKey('git_service_name')) {
      _gitServiceName = _apiMapResponse['git_service_name']?.toString();
      _gitServiceNameSet = true;
    }
    return _gitServiceName;
  }

  set gitServiceName(String v) {
    _gitServiceName = v;
    _gitServiceNameSet = true;
  }

  /// Port that HTTP(S) application server is running on (for PRs, file browsing, etc.)

  int get gitApplicationServerHttpPort {
    if (!_gitApplicationServerHttpPortSet &&
        _apiMapResponse.containsKey('git_application_server_http_port')) {
      _gitApplicationServerHttpPort =
          _apiMapResponse['git_application_server_http_port'];
      _gitApplicationServerHttpPortSet = true;
    }
    return _gitApplicationServerHttpPort;
  }

  set gitApplicationServerHttpPort(int v) {
    _gitApplicationServerHttpPort = v;
    _gitApplicationServerHttpPortSet = true;
  }

  /// Scheme that is running on application server (for PRs, file browsing, etc.)

  String get gitApplicationServerHttpScheme {
    if (!_gitApplicationServerHttpSchemeSet &&
        _apiMapResponse.containsKey('git_application_server_http_scheme')) {
      _gitApplicationServerHttpScheme =
          _apiMapResponse['git_application_server_http_scheme']?.toString();
      _gitApplicationServerHttpSchemeSet = true;
    }
    return _gitApplicationServerHttpScheme;
  }

  set gitApplicationServerHttpScheme(String v) {
    _gitApplicationServerHttpScheme = v;
    _gitApplicationServerHttpSchemeSet = true;
  }

  /// (Write-Only) Optional secret token with which to authenticate requests to the webhook deploy endpoint. If not set, endpoint is unauthenticated.

  String get deploySecret {
    if (!_deploySecretSet && _apiMapResponse.containsKey('deploy_secret')) {
      _deploySecret = _apiMapResponse['deploy_secret']?.toString();
      _deploySecretSet = true;
    }
    return _deploySecret;
  }

  set deploySecret(String v) {
    _deploySecret = v;
    _deploySecretSet = true;
  }

  /// (Write-Only) When true, unsets the deploy secret to allow unauthenticated access to the webhook deploy endpoint.

  bool get unsetDeploySecret {
    if (!_unsetDeploySecretSet &&
        _apiMapResponse.containsKey('unset_deploy_secret')) {
      _unsetDeploySecret = _apiMapResponse['unset_deploy_secret'];
      _unsetDeploySecretSet = true;
    }
    return _unsetDeploySecret;
  }

  set unsetDeploySecret(bool v) {
    _unsetDeploySecret = v;
    _unsetDeploySecretSet = true;
  }

  /// The git pull request policy for this project. Valid values are: "off", "links", "recommended", "required".

  PullRequestMode get pullRequestMode {
    if (!_pullRequestModeSet &&
        _apiMapResponse.containsKey('pull_request_mode')) {
      _pullRequestMode = PullRequestModeMapper.fromStringValue(
          _apiMapResponse['pull_request_mode']);
      _pullRequestModeSet = true;
    }
    return _pullRequestMode;
  }

  set pullRequestMode(PullRequestMode v) {
    _pullRequestMode = v;
    _pullRequestModeSet = true;
  }

  /// Validation policy: If true, the project must pass validation checks before project changes can be committed to the git repository

  bool get validationRequired {
    if (!_validationRequiredSet &&
        _apiMapResponse.containsKey('validation_required')) {
      _validationRequired = _apiMapResponse['validation_required'];
      _validationRequiredSet = true;
    }
    return _validationRequired;
  }

  set validationRequired(bool v) {
    _validationRequired = v;
    _validationRequiredSet = true;
  }

  /// If true, advanced git release management is enabled for this project

  bool get gitReleaseMgmtEnabled {
    if (!_gitReleaseMgmtEnabledSet &&
        _apiMapResponse.containsKey('git_release_mgmt_enabled')) {
      _gitReleaseMgmtEnabled = _apiMapResponse['git_release_mgmt_enabled'];
      _gitReleaseMgmtEnabledSet = true;
    }
    return _gitReleaseMgmtEnabled;
  }

  set gitReleaseMgmtEnabled(bool v) {
    _gitReleaseMgmtEnabled = v;
    _gitReleaseMgmtEnabledSet = true;
  }

  /// Validation policy: If true, the project can be committed with warnings when `validation_required` is true. (`allow_warnings` does nothing if `validation_required` is false).

  bool get allowWarnings {
    if (!_allowWarningsSet && _apiMapResponse.containsKey('allow_warnings')) {
      _allowWarnings = _apiMapResponse['allow_warnings'];
      _allowWarningsSet = true;
    }
    return _allowWarnings;
  }

  set allowWarnings(bool v) {
    _allowWarnings = v;
    _allowWarningsSet = true;
  }

  /// Status of dependencies in your manifest & lockfile

  String get dependencyStatus {
    if (!_dependencyStatusSet &&
        _apiMapResponse.containsKey('dependency_status')) {
      _dependencyStatus = _apiMapResponse['dependency_status']?.toString();
      _dependencyStatusSet = true;
    }
    return _dependencyStatus;
  }

  set dependencyStatus(String v) {
    _dependencyStatus = v;
    _dependencyStatusSet = true;
  }

  WriteProject() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteProject.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_gitRemoteUrlSet || _apiMapResponse.containsKey('git_remote_url')) {
      json['git_remote_url'] = gitRemoteUrl;
    }
    if (_gitUsernameSet || _apiMapResponse.containsKey('git_username')) {
      json['git_username'] = gitUsername;
    }
    if (_gitPasswordSet || _apiMapResponse.containsKey('git_password')) {
      json['git_password'] = gitPassword;
    }
    if (_gitProductionBranchNameSet ||
        _apiMapResponse.containsKey('git_production_branch_name')) {
      json['git_production_branch_name'] = gitProductionBranchName;
    }
    if (_useGitCookieAuthSet ||
        _apiMapResponse.containsKey('use_git_cookie_auth')) {
      json['use_git_cookie_auth'] = useGitCookieAuth;
    }
    if (_gitUsernameUserAttributeSet ||
        _apiMapResponse.containsKey('git_username_user_attribute')) {
      json['git_username_user_attribute'] = gitUsernameUserAttribute;
    }
    if (_gitPasswordUserAttributeSet ||
        _apiMapResponse.containsKey('git_password_user_attribute')) {
      json['git_password_user_attribute'] = gitPasswordUserAttribute;
    }
    if (_gitServiceNameSet || _apiMapResponse.containsKey('git_service_name')) {
      json['git_service_name'] = gitServiceName;
    }
    if (_gitApplicationServerHttpPortSet ||
        _apiMapResponse.containsKey('git_application_server_http_port')) {
      json['git_application_server_http_port'] = gitApplicationServerHttpPort;
    }
    if (_gitApplicationServerHttpSchemeSet ||
        _apiMapResponse.containsKey('git_application_server_http_scheme')) {
      json['git_application_server_http_scheme'] =
          gitApplicationServerHttpScheme;
    }
    if (_deploySecretSet || _apiMapResponse.containsKey('deploy_secret')) {
      json['deploy_secret'] = deploySecret;
    }
    if (_unsetDeploySecretSet ||
        _apiMapResponse.containsKey('unset_deploy_secret')) {
      json['unset_deploy_secret'] = unsetDeploySecret;
    }
    if (_pullRequestModeSet ||
        _apiMapResponse.containsKey('pull_request_mode')) {
      json['pull_request_mode'] =
          PullRequestModeMapper.toStringValue(pullRequestMode);
    }
    if (_validationRequiredSet ||
        _apiMapResponse.containsKey('validation_required')) {
      json['validation_required'] = validationRequired;
    }
    if (_gitReleaseMgmtEnabledSet ||
        _apiMapResponse.containsKey('git_release_mgmt_enabled')) {
      json['git_release_mgmt_enabled'] = gitReleaseMgmtEnabled;
    }
    if (_allowWarningsSet || _apiMapResponse.containsKey('allow_warnings')) {
      json['allow_warnings'] = allowWarnings;
    }
    if (_dependencyStatusSet ||
        _apiMapResponse.containsKey('dependency_status')) {
      json['dependency_status'] = dependencyStatus;
    }
    return json;
  }
}

/// Dynamic writeable type for Query removes:
/// can, id, slug, share_url, expanded_share_url, url, has_table_calculations
class WriteQuery {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _model;
  bool _modelSet = false;

  String _view;
  bool _viewSet = false;

  List<String> _fields;
  bool _fieldsSet = false;

  List<String> _pivots;
  bool _pivotsSet = false;

  List<String> _fillFields;
  bool _fillFieldsSet = false;

  Map<String, dynamic> _filters;
  bool _filtersSet = false;

  String _filterExpression;
  bool _filterExpressionSet = false;

  List<String> _sorts;
  bool _sortsSet = false;

  String _limit;
  bool _limitSet = false;

  String _columnLimit;
  bool _columnLimitSet = false;

  bool _total;
  bool _totalSet = false;

  String _rowTotal;
  bool _rowTotalSet = false;

  List<String> _subtotals;
  bool _subtotalsSet = false;

  Map<String, dynamic> _visConfig;
  bool _visConfigSet = false;

  Map<String, dynamic> _filterConfig;
  bool _filterConfigSet = false;

  String _visibleUiSections;
  bool _visibleUiSectionsSet = false;

  String _dynamicFields;
  bool _dynamicFieldsSet = false;

  String _clientId;
  bool _clientIdSet = false;

  String _queryTimezone;
  bool _queryTimezoneSet = false;

  /// Model

  String get model {
    if (!_modelSet && _apiMapResponse.containsKey('model')) {
      _model = _apiMapResponse['model']?.toString();
      _modelSet = true;
    }
    return _model;
  }

  set model(String v) {
    _model = v;
    _modelSet = true;
  }

  /// Explore Name

  String get view {
    if (!_viewSet && _apiMapResponse.containsKey('view')) {
      _view = _apiMapResponse['view']?.toString();
      _viewSet = true;
    }
    return _view;
  }

  set view(String v) {
    _view = v;
    _viewSet = true;
  }

  /// Fields

  List<String> get fields {
    if (!_fieldsSet && _apiMapResponse.containsKey('fields')) {
      _fields =
          _apiMapResponse['fields']?.map<String>((i) => i as String)?.toList();
      _fieldsSet = true;
    }
    return _fields;
  }

  set fields(List<String> v) {
    _fields = v;
    _fieldsSet = true;
  }

  /// Pivots

  List<String> get pivots {
    if (!_pivotsSet && _apiMapResponse.containsKey('pivots')) {
      _pivots =
          _apiMapResponse['pivots']?.map<String>((i) => i as String)?.toList();
      _pivotsSet = true;
    }
    return _pivots;
  }

  set pivots(List<String> v) {
    _pivots = v;
    _pivotsSet = true;
  }

  /// Fill Fields

  List<String> get fillFields {
    if (!_fillFieldsSet && _apiMapResponse.containsKey('fill_fields')) {
      _fillFields = _apiMapResponse['fill_fields']
          ?.map<String>((i) => i as String)
          ?.toList();
      _fillFieldsSet = true;
    }
    return _fillFields;
  }

  set fillFields(List<String> v) {
    _fillFields = v;
    _fillFieldsSet = true;
  }

  /// Filters

  Map<String, dynamic> get filters {
    if (!_filtersSet && _apiMapResponse.containsKey('filters')) {
      _filters = _apiMapResponse['filters'];
      _filtersSet = true;
    }
    return _filters;
  }

  set filters(Map<String, dynamic> v) {
    _filters = v;
    _filtersSet = true;
  }

  /// Filter Expression

  String get filterExpression {
    if (!_filterExpressionSet &&
        _apiMapResponse.containsKey('filter_expression')) {
      _filterExpression = _apiMapResponse['filter_expression']?.toString();
      _filterExpressionSet = true;
    }
    return _filterExpression;
  }

  set filterExpression(String v) {
    _filterExpression = v;
    _filterExpressionSet = true;
  }

  /// Sorting for the query results. Use the format `["view.field", ...]` to sort on fields in ascending order. Use the format `["view.field desc", ...]` to sort on fields in descending order. Use `["__UNSORTED__"]` (2 underscores before and after) to disable sorting entirely. Empty sorts `[]` will trigger a default sort.

  List<String> get sorts {
    if (!_sortsSet && _apiMapResponse.containsKey('sorts')) {
      _sorts =
          _apiMapResponse['sorts']?.map<String>((i) => i as String)?.toList();
      _sortsSet = true;
    }
    return _sorts;
  }

  set sorts(List<String> v) {
    _sorts = v;
    _sortsSet = true;
  }

  /// Limit

  String get limit {
    if (!_limitSet && _apiMapResponse.containsKey('limit')) {
      _limit = _apiMapResponse['limit']?.toString();
      _limitSet = true;
    }
    return _limit;
  }

  set limit(String v) {
    _limit = v;
    _limitSet = true;
  }

  /// Column Limit

  String get columnLimit {
    if (!_columnLimitSet && _apiMapResponse.containsKey('column_limit')) {
      _columnLimit = _apiMapResponse['column_limit']?.toString();
      _columnLimitSet = true;
    }
    return _columnLimit;
  }

  set columnLimit(String v) {
    _columnLimit = v;
    _columnLimitSet = true;
  }

  /// Total

  bool get total {
    if (!_totalSet && _apiMapResponse.containsKey('total')) {
      _total = _apiMapResponse['total'];
      _totalSet = true;
    }
    return _total;
  }

  set total(bool v) {
    _total = v;
    _totalSet = true;
  }

  /// Raw Total

  String get rowTotal {
    if (!_rowTotalSet && _apiMapResponse.containsKey('row_total')) {
      _rowTotal = _apiMapResponse['row_total']?.toString();
      _rowTotalSet = true;
    }
    return _rowTotal;
  }

  set rowTotal(String v) {
    _rowTotal = v;
    _rowTotalSet = true;
  }

  /// Fields on which to run subtotals

  List<String> get subtotals {
    if (!_subtotalsSet && _apiMapResponse.containsKey('subtotals')) {
      _subtotals = _apiMapResponse['subtotals']
          ?.map<String>((i) => i as String)
          ?.toList();
      _subtotalsSet = true;
    }
    return _subtotals;
  }

  set subtotals(List<String> v) {
    _subtotals = v;
    _subtotalsSet = true;
  }

  /// Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.

  Map<String, dynamic> get visConfig {
    if (!_visConfigSet && _apiMapResponse.containsKey('vis_config')) {
      _visConfig = _apiMapResponse['vis_config'];
      _visConfigSet = true;
    }
    return _visConfig;
  }

  set visConfig(Map<String, dynamic> v) {
    _visConfig = v;
    _visConfigSet = true;
  }

  /// The filter_config represents the state of the filter UI on the explore page for a given query. When running a query via the Looker UI, this parameter takes precedence over "filters". When creating a query or modifying an existing query, "filter_config" should be set to null. Setting it to any other value could cause unexpected filtering behavior. The format should be considered opaque.

  Map<String, dynamic> get filterConfig {
    if (!_filterConfigSet && _apiMapResponse.containsKey('filter_config')) {
      _filterConfig = _apiMapResponse['filter_config'];
      _filterConfigSet = true;
    }
    return _filterConfig;
  }

  set filterConfig(Map<String, dynamic> v) {
    _filterConfig = v;
    _filterConfigSet = true;
  }

  /// Visible UI Sections

  String get visibleUiSections {
    if (!_visibleUiSectionsSet &&
        _apiMapResponse.containsKey('visible_ui_sections')) {
      _visibleUiSections = _apiMapResponse['visible_ui_sections']?.toString();
      _visibleUiSectionsSet = true;
    }
    return _visibleUiSections;
  }

  set visibleUiSections(String v) {
    _visibleUiSections = v;
    _visibleUiSectionsSet = true;
  }

  /// Dynamic Fields

  String get dynamicFields {
    if (!_dynamicFieldsSet && _apiMapResponse.containsKey('dynamic_fields')) {
      _dynamicFields = _apiMapResponse['dynamic_fields']?.toString();
      _dynamicFieldsSet = true;
    }
    return _dynamicFields;
  }

  set dynamicFields(String v) {
    _dynamicFields = v;
    _dynamicFieldsSet = true;
  }

  /// Client Id: used to generate shortened explore URLs. If set by client, must be a unique 22 character alphanumeric string. Otherwise one will be generated.

  String get clientId {
    if (!_clientIdSet && _apiMapResponse.containsKey('client_id')) {
      _clientId = _apiMapResponse['client_id']?.toString();
      _clientIdSet = true;
    }
    return _clientId;
  }

  set clientId(String v) {
    _clientId = v;
    _clientIdSet = true;
  }

  /// Query Timezone

  String get queryTimezone {
    if (!_queryTimezoneSet && _apiMapResponse.containsKey('query_timezone')) {
      _queryTimezone = _apiMapResponse['query_timezone']?.toString();
      _queryTimezoneSet = true;
    }
    return _queryTimezone;
  }

  set queryTimezone(String v) {
    _queryTimezone = v;
    _queryTimezoneSet = true;
  }

  WriteQuery() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteQuery.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_modelSet || _apiMapResponse.containsKey('model')) {
      json['model'] = model;
    }
    if (_viewSet || _apiMapResponse.containsKey('view')) {
      json['view'] = view;
    }
    if (_fieldsSet || _apiMapResponse.containsKey('fields')) {
      json['fields'] = fields;
    }
    if (_pivotsSet || _apiMapResponse.containsKey('pivots')) {
      json['pivots'] = pivots;
    }
    if (_fillFieldsSet || _apiMapResponse.containsKey('fill_fields')) {
      json['fill_fields'] = fillFields;
    }
    if (_filtersSet || _apiMapResponse.containsKey('filters')) {
      json['filters'] = filters;
    }
    if (_filterExpressionSet ||
        _apiMapResponse.containsKey('filter_expression')) {
      json['filter_expression'] = filterExpression;
    }
    if (_sortsSet || _apiMapResponse.containsKey('sorts')) {
      json['sorts'] = sorts;
    }
    if (_limitSet || _apiMapResponse.containsKey('limit')) {
      json['limit'] = limit;
    }
    if (_columnLimitSet || _apiMapResponse.containsKey('column_limit')) {
      json['column_limit'] = columnLimit;
    }
    if (_totalSet || _apiMapResponse.containsKey('total')) {
      json['total'] = total;
    }
    if (_rowTotalSet || _apiMapResponse.containsKey('row_total')) {
      json['row_total'] = rowTotal;
    }
    if (_subtotalsSet || _apiMapResponse.containsKey('subtotals')) {
      json['subtotals'] = subtotals;
    }
    if (_visConfigSet || _apiMapResponse.containsKey('vis_config')) {
      json['vis_config'] = visConfig;
    }
    if (_filterConfigSet || _apiMapResponse.containsKey('filter_config')) {
      json['filter_config'] = filterConfig;
    }
    if (_visibleUiSectionsSet ||
        _apiMapResponse.containsKey('visible_ui_sections')) {
      json['visible_ui_sections'] = visibleUiSections;
    }
    if (_dynamicFieldsSet || _apiMapResponse.containsKey('dynamic_fields')) {
      json['dynamic_fields'] = dynamicFields;
    }
    if (_clientIdSet || _apiMapResponse.containsKey('client_id')) {
      json['client_id'] = clientId;
    }
    if (_queryTimezoneSet || _apiMapResponse.containsKey('query_timezone')) {
      json['query_timezone'] = queryTimezone;
    }
    return json;
  }
}

/// Dynamic writeable type for RepositoryCredential removes:
/// can, id, root_project_id, remote_url, is_configured
class WriteRepositoryCredential {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _gitUsername;
  bool _gitUsernameSet = false;

  String _gitPassword;
  bool _gitPasswordSet = false;

  String _sshPublicKey;
  bool _sshPublicKeySet = false;

  /// Git username for HTTPS authentication.

  String get gitUsername {
    if (!_gitUsernameSet && _apiMapResponse.containsKey('git_username')) {
      _gitUsername = _apiMapResponse['git_username']?.toString();
      _gitUsernameSet = true;
    }
    return _gitUsername;
  }

  set gitUsername(String v) {
    _gitUsername = v;
    _gitUsernameSet = true;
  }

  /// (Write-Only) Git password for HTTPS authentication.

  String get gitPassword {
    if (!_gitPasswordSet && _apiMapResponse.containsKey('git_password')) {
      _gitPassword = _apiMapResponse['git_password']?.toString();
      _gitPasswordSet = true;
    }
    return _gitPassword;
  }

  set gitPassword(String v) {
    _gitPassword = v;
    _gitPasswordSet = true;
  }

  /// Public deploy key for SSH authentication.

  String get sshPublicKey {
    if (!_sshPublicKeySet && _apiMapResponse.containsKey('ssh_public_key')) {
      _sshPublicKey = _apiMapResponse['ssh_public_key']?.toString();
      _sshPublicKeySet = true;
    }
    return _sshPublicKey;
  }

  set sshPublicKey(String v) {
    _sshPublicKey = v;
    _sshPublicKeySet = true;
  }

  WriteRepositoryCredential() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteRepositoryCredential.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_gitUsernameSet || _apiMapResponse.containsKey('git_username')) {
      json['git_username'] = gitUsername;
    }
    if (_gitPasswordSet || _apiMapResponse.containsKey('git_password')) {
      json['git_password'] = gitPassword;
    }
    if (_sshPublicKeySet || _apiMapResponse.containsKey('ssh_public_key')) {
      json['ssh_public_key'] = sshPublicKey;
    }
    return json;
  }
}

/// Dynamic writeable type for ResultMakerWithIdVisConfigAndDynamicFields removes:
/// id, dynamic_fields, filterables, sorts, merge_result_id, total, query_id, sql_query_id, vis_config
class WriteResultMakerWithIdVisConfigAndDynamicFields {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  WriteQuery _query;
  bool _querySet = false;

  /// Dynamic writeable type for Query removes:
  /// can, id, slug, share_url, expanded_share_url, url, has_table_calculations

  WriteQuery get query {
    if (!_querySet && _apiMapResponse.containsKey('query')) {
      _query = _apiMapResponse['query'] == null
          ? null
          : WriteQuery.fromResponse(
              _apiMapResponse['query'], apiResponseContentType);
      _querySet = true;
    }
    return _query;
  }

  set query(WriteQuery v) {
    _query = v;
    _querySet = true;
  }

  WriteResultMakerWithIdVisConfigAndDynamicFields() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteResultMakerWithIdVisConfigAndDynamicFields.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_querySet || _apiMapResponse.containsKey('query')) {
      json['query'] = query?.toJson();
    }
    return json;
  }
}

/// Dynamic writeable type for Role removes:
/// can, id, url, users_url
class WriteRole {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  WritePermissionSet _permissionSet;
  bool _permissionSetSet = false;

  int _permissionSetId;
  bool _permissionSetIdSet = false;

  WriteModelSet _modelSet;
  bool _modelSetSet = false;

  int _modelSetId;
  bool _modelSetIdSet = false;

  /// Name of Role

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Dynamic writeable type for PermissionSet removes:
  /// can, all_access, built_in, id, url

  WritePermissionSet get permissionSet {
    if (!_permissionSetSet && _apiMapResponse.containsKey('permission_set')) {
      _permissionSet = _apiMapResponse['permission_set'] == null
          ? null
          : WritePermissionSet.fromResponse(
              _apiMapResponse['permission_set'], apiResponseContentType);
      _permissionSetSet = true;
    }
    return _permissionSet;
  }

  set permissionSet(WritePermissionSet v) {
    _permissionSet = v;
    _permissionSetSet = true;
  }

  /// (Write-Only) Id of permission set

  int get permissionSetId {
    if (!_permissionSetIdSet &&
        _apiMapResponse.containsKey('permission_set_id')) {
      _permissionSetId = _apiMapResponse['permission_set_id'];
      _permissionSetIdSet = true;
    }
    return _permissionSetId;
  }

  set permissionSetId(int v) {
    _permissionSetId = v;
    _permissionSetIdSet = true;
  }

  /// Dynamic writeable type for ModelSet removes:
  /// can, all_access, built_in, id, url

  WriteModelSet get modelSet {
    if (!_modelSetSet && _apiMapResponse.containsKey('model_set')) {
      _modelSet = _apiMapResponse['model_set'] == null
          ? null
          : WriteModelSet.fromResponse(
              _apiMapResponse['model_set'], apiResponseContentType);
      _modelSetSet = true;
    }
    return _modelSet;
  }

  set modelSet(WriteModelSet v) {
    _modelSet = v;
    _modelSetSet = true;
  }

  /// (Write-Only) Id of model set

  int get modelSetId {
    if (!_modelSetIdSet && _apiMapResponse.containsKey('model_set_id')) {
      _modelSetId = _apiMapResponse['model_set_id'];
      _modelSetIdSet = true;
    }
    return _modelSetId;
  }

  set modelSetId(int v) {
    _modelSetId = v;
    _modelSetIdSet = true;
  }

  WriteRole() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteRole.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_permissionSetSet || _apiMapResponse.containsKey('permission_set')) {
      json['permission_set'] = permissionSet?.toJson();
    }
    if (_permissionSetIdSet ||
        _apiMapResponse.containsKey('permission_set_id')) {
      json['permission_set_id'] = permissionSetId;
    }
    if (_modelSetSet || _apiMapResponse.containsKey('model_set')) {
      json['model_set'] = modelSet?.toJson();
    }
    if (_modelSetIdSet || _apiMapResponse.containsKey('model_set_id')) {
      json['model_set_id'] = modelSetId;
    }
    return json;
  }
}

/// Dynamic writeable type for SamlConfig removes:
/// can, test_slug, modified_at, modified_by, default_new_user_roles, default_new_user_groups, groups, user_attributes, url
class WriteSamlConfig {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _enabled;
  bool _enabledSet = false;

  String _idpCert;
  bool _idpCertSet = false;

  String _idpUrl;
  bool _idpUrlSet = false;

  String _idpIssuer;
  bool _idpIssuerSet = false;

  String _idpAudience;
  bool _idpAudienceSet = false;

  int _allowedClockDrift;
  bool _allowedClockDriftSet = false;

  String _userAttributeMapEmail;
  bool _userAttributeMapEmailSet = false;

  String _userAttributeMapFirstName;
  bool _userAttributeMapFirstNameSet = false;

  String _userAttributeMapLastName;
  bool _userAttributeMapLastNameSet = false;

  String _newUserMigrationTypes;
  bool _newUserMigrationTypesSet = false;

  bool _alternateEmailLoginAllowed;
  bool _alternateEmailLoginAllowedSet = false;

  List<int> _defaultNewUserRoleIds;
  bool _defaultNewUserRoleIdsSet = false;

  List<int> _defaultNewUserGroupIds;
  bool _defaultNewUserGroupIdsSet = false;

  bool _setRolesFromGroups;
  bool _setRolesFromGroupsSet = false;

  String _groupsAttribute;
  bool _groupsAttributeSet = false;

  List<SamlGroupWrite> _groupsWithRoleIds;
  bool _groupsWithRoleIdsSet = false;

  bool _authRequiresRole;
  bool _authRequiresRoleSet = false;

  List<SamlUserAttributeWrite> _userAttributesWithIds;
  bool _userAttributesWithIdsSet = false;

  String _groupsFinderType;
  bool _groupsFinderTypeSet = false;

  String _groupsMemberValue;
  bool _groupsMemberValueSet = false;

  bool _bypassLoginPage;
  bool _bypassLoginPageSet = false;

  bool _allowNormalGroupMembership;
  bool _allowNormalGroupMembershipSet = false;

  bool _allowRolesFromNormalGroups;
  bool _allowRolesFromNormalGroupsSet = false;

  bool _allowDirectRoles;
  bool _allowDirectRolesSet = false;

  /// Enable/Disable Saml authentication for the server

  bool get enabled {
    if (!_enabledSet && _apiMapResponse.containsKey('enabled')) {
      _enabled = _apiMapResponse['enabled'];
      _enabledSet = true;
    }
    return _enabled;
  }

  set enabled(bool v) {
    _enabled = v;
    _enabledSet = true;
  }

  /// Identity Provider Certificate (provided by IdP)

  String get idpCert {
    if (!_idpCertSet && _apiMapResponse.containsKey('idp_cert')) {
      _idpCert = _apiMapResponse['idp_cert']?.toString();
      _idpCertSet = true;
    }
    return _idpCert;
  }

  set idpCert(String v) {
    _idpCert = v;
    _idpCertSet = true;
  }

  /// Identity Provider Url (provided by IdP)

  String get idpUrl {
    if (!_idpUrlSet && _apiMapResponse.containsKey('idp_url')) {
      _idpUrl = _apiMapResponse['idp_url']?.toString();
      _idpUrlSet = true;
    }
    return _idpUrl;
  }

  set idpUrl(String v) {
    _idpUrl = v;
    _idpUrlSet = true;
  }

  /// Identity Provider Issuer (provided by IdP)

  String get idpIssuer {
    if (!_idpIssuerSet && _apiMapResponse.containsKey('idp_issuer')) {
      _idpIssuer = _apiMapResponse['idp_issuer']?.toString();
      _idpIssuerSet = true;
    }
    return _idpIssuer;
  }

  set idpIssuer(String v) {
    _idpIssuer = v;
    _idpIssuerSet = true;
  }

  /// Identity Provider Audience (set in IdP config). Optional in Looker. Set this only if you want Looker to validate the audience value returned by the IdP.

  String get idpAudience {
    if (!_idpAudienceSet && _apiMapResponse.containsKey('idp_audience')) {
      _idpAudience = _apiMapResponse['idp_audience']?.toString();
      _idpAudienceSet = true;
    }
    return _idpAudience;
  }

  set idpAudience(String v) {
    _idpAudience = v;
    _idpAudienceSet = true;
  }

  /// Count of seconds of clock drift to allow when validating timestamps of assertions.

  int get allowedClockDrift {
    if (!_allowedClockDriftSet &&
        _apiMapResponse.containsKey('allowed_clock_drift')) {
      _allowedClockDrift = _apiMapResponse['allowed_clock_drift'];
      _allowedClockDriftSet = true;
    }
    return _allowedClockDrift;
  }

  set allowedClockDrift(int v) {
    _allowedClockDrift = v;
    _allowedClockDriftSet = true;
  }

  /// Name of user record attributes used to indicate email address field

  String get userAttributeMapEmail {
    if (!_userAttributeMapEmailSet &&
        _apiMapResponse.containsKey('user_attribute_map_email')) {
      _userAttributeMapEmail =
          _apiMapResponse['user_attribute_map_email']?.toString();
      _userAttributeMapEmailSet = true;
    }
    return _userAttributeMapEmail;
  }

  set userAttributeMapEmail(String v) {
    _userAttributeMapEmail = v;
    _userAttributeMapEmailSet = true;
  }

  /// Name of user record attributes used to indicate first name

  String get userAttributeMapFirstName {
    if (!_userAttributeMapFirstNameSet &&
        _apiMapResponse.containsKey('user_attribute_map_first_name')) {
      _userAttributeMapFirstName =
          _apiMapResponse['user_attribute_map_first_name']?.toString();
      _userAttributeMapFirstNameSet = true;
    }
    return _userAttributeMapFirstName;
  }

  set userAttributeMapFirstName(String v) {
    _userAttributeMapFirstName = v;
    _userAttributeMapFirstNameSet = true;
  }

  /// Name of user record attributes used to indicate last name

  String get userAttributeMapLastName {
    if (!_userAttributeMapLastNameSet &&
        _apiMapResponse.containsKey('user_attribute_map_last_name')) {
      _userAttributeMapLastName =
          _apiMapResponse['user_attribute_map_last_name']?.toString();
      _userAttributeMapLastNameSet = true;
    }
    return _userAttributeMapLastName;
  }

  set userAttributeMapLastName(String v) {
    _userAttributeMapLastName = v;
    _userAttributeMapLastNameSet = true;
  }

  /// Merge first-time saml login to existing user account by email addresses. When a user logs in for the first time via saml this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'

  String get newUserMigrationTypes {
    if (!_newUserMigrationTypesSet &&
        _apiMapResponse.containsKey('new_user_migration_types')) {
      _newUserMigrationTypes =
          _apiMapResponse['new_user_migration_types']?.toString();
      _newUserMigrationTypesSet = true;
    }
    return _newUserMigrationTypes;
  }

  set newUserMigrationTypes(String v) {
    _newUserMigrationTypes = v;
    _newUserMigrationTypesSet = true;
  }

  /// Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.

  bool get alternateEmailLoginAllowed {
    if (!_alternateEmailLoginAllowedSet &&
        _apiMapResponse.containsKey('alternate_email_login_allowed')) {
      _alternateEmailLoginAllowed =
          _apiMapResponse['alternate_email_login_allowed'];
      _alternateEmailLoginAllowedSet = true;
    }
    return _alternateEmailLoginAllowed;
  }

  set alternateEmailLoginAllowed(bool v) {
    _alternateEmailLoginAllowed = v;
    _alternateEmailLoginAllowedSet = true;
  }

  /// (Write-Only) Array of ids of roles that will be applied to new users the first time they login via Saml

  List<int> get defaultNewUserRoleIds {
    if (!_defaultNewUserRoleIdsSet &&
        _apiMapResponse.containsKey('default_new_user_role_ids')) {
      _defaultNewUserRoleIds = _apiMapResponse['default_new_user_role_ids']
          ?.map<int>((i) => i as int)
          ?.toList();
      _defaultNewUserRoleIdsSet = true;
    }
    return _defaultNewUserRoleIds;
  }

  set defaultNewUserRoleIds(List<int> v) {
    _defaultNewUserRoleIds = v;
    _defaultNewUserRoleIdsSet = true;
  }

  /// (Write-Only) Array of ids of groups that will be applied to new users the first time they login via Saml

  List<int> get defaultNewUserGroupIds {
    if (!_defaultNewUserGroupIdsSet &&
        _apiMapResponse.containsKey('default_new_user_group_ids')) {
      _defaultNewUserGroupIds = _apiMapResponse['default_new_user_group_ids']
          ?.map<int>((i) => i as int)
          ?.toList();
      _defaultNewUserGroupIdsSet = true;
    }
    return _defaultNewUserGroupIds;
  }

  set defaultNewUserGroupIds(List<int> v) {
    _defaultNewUserGroupIds = v;
    _defaultNewUserGroupIdsSet = true;
  }

  /// Set user roles in Looker based on groups from Saml

  bool get setRolesFromGroups {
    if (!_setRolesFromGroupsSet &&
        _apiMapResponse.containsKey('set_roles_from_groups')) {
      _setRolesFromGroups = _apiMapResponse['set_roles_from_groups'];
      _setRolesFromGroupsSet = true;
    }
    return _setRolesFromGroups;
  }

  set setRolesFromGroups(bool v) {
    _setRolesFromGroups = v;
    _setRolesFromGroupsSet = true;
  }

  /// Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'

  String get groupsAttribute {
    if (!_groupsAttributeSet &&
        _apiMapResponse.containsKey('groups_attribute')) {
      _groupsAttribute = _apiMapResponse['groups_attribute']?.toString();
      _groupsAttributeSet = true;
    }
    return _groupsAttribute;
  }

  set groupsAttribute(String v) {
    _groupsAttribute = v;
    _groupsAttributeSet = true;
  }

  /// (Read/Write) Array of mappings between Saml Groups and arrays of Looker Role ids

  List<SamlGroupWrite> get groupsWithRoleIds {
    if (!_groupsWithRoleIdsSet &&
        _apiMapResponse.containsKey('groups_with_role_ids')) {
      _groupsWithRoleIds = _apiMapResponse['groups_with_role_ids'] == null
          ? null
          : (_apiMapResponse['groups_with_role_ids'] as List)
              .map(
                  (i) => SamlGroupWrite.fromResponse(i, apiResponseContentType))
              .toList();
      _groupsWithRoleIdsSet = true;
    }
    return _groupsWithRoleIds;
  }

  set groupsWithRoleIds(List<SamlGroupWrite> v) {
    _groupsWithRoleIds = v;
    _groupsWithRoleIdsSet = true;
  }

  /// Users will not be allowed to login at all unless a role for them is found in Saml if set to true

  bool get authRequiresRole {
    if (!_authRequiresRoleSet &&
        _apiMapResponse.containsKey('auth_requires_role')) {
      _authRequiresRole = _apiMapResponse['auth_requires_role'];
      _authRequiresRoleSet = true;
    }
    return _authRequiresRole;
  }

  set authRequiresRole(bool v) {
    _authRequiresRole = v;
    _authRequiresRoleSet = true;
  }

  /// (Read/Write) Array of mappings between Saml User Attributes and arrays of Looker User Attribute ids

  List<SamlUserAttributeWrite> get userAttributesWithIds {
    if (!_userAttributesWithIdsSet &&
        _apiMapResponse.containsKey('user_attributes_with_ids')) {
      _userAttributesWithIds =
          _apiMapResponse['user_attributes_with_ids'] == null
              ? null
              : (_apiMapResponse['user_attributes_with_ids'] as List)
                  .map((i) => SamlUserAttributeWrite.fromResponse(
                      i, apiResponseContentType))
                  .toList();
      _userAttributesWithIdsSet = true;
    }
    return _userAttributesWithIds;
  }

  set userAttributesWithIds(List<SamlUserAttributeWrite> v) {
    _userAttributesWithIds = v;
    _userAttributesWithIdsSet = true;
  }

  /// Identifier for a strategy for how Looker will find groups in the SAML response. One of ['grouped_attribute_values', 'individual_attributes']

  String get groupsFinderType {
    if (!_groupsFinderTypeSet &&
        _apiMapResponse.containsKey('groups_finder_type')) {
      _groupsFinderType = _apiMapResponse['groups_finder_type']?.toString();
      _groupsFinderTypeSet = true;
    }
    return _groupsFinderType;
  }

  set groupsFinderType(String v) {
    _groupsFinderType = v;
    _groupsFinderTypeSet = true;
  }

  /// Value for group attribute used to indicate membership. Used when 'groups_finder_type' is set to 'individual_attributes'

  String get groupsMemberValue {
    if (!_groupsMemberValueSet &&
        _apiMapResponse.containsKey('groups_member_value')) {
      _groupsMemberValue = _apiMapResponse['groups_member_value']?.toString();
      _groupsMemberValueSet = true;
    }
    return _groupsMemberValue;
  }

  set groupsMemberValue(String v) {
    _groupsMemberValue = v;
    _groupsMemberValueSet = true;
  }

  /// Bypass the login page when user authentication is required. Redirect to IdP immediately instead.

  bool get bypassLoginPage {
    if (!_bypassLoginPageSet &&
        _apiMapResponse.containsKey('bypass_login_page')) {
      _bypassLoginPage = _apiMapResponse['bypass_login_page'];
      _bypassLoginPageSet = true;
    }
    return _bypassLoginPage;
  }

  set bypassLoginPage(bool v) {
    _bypassLoginPage = v;
    _bypassLoginPageSet = true;
  }

  /// Allow SAML auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.

  bool get allowNormalGroupMembership {
    if (!_allowNormalGroupMembershipSet &&
        _apiMapResponse.containsKey('allow_normal_group_membership')) {
      _allowNormalGroupMembership =
          _apiMapResponse['allow_normal_group_membership'];
      _allowNormalGroupMembershipSet = true;
    }
    return _allowNormalGroupMembership;
  }

  set allowNormalGroupMembership(bool v) {
    _allowNormalGroupMembership = v;
    _allowNormalGroupMembershipSet = true;
  }

  /// SAML auth'd users will inherit roles from non-reflected Looker groups.

  bool get allowRolesFromNormalGroups {
    if (!_allowRolesFromNormalGroupsSet &&
        _apiMapResponse.containsKey('allow_roles_from_normal_groups')) {
      _allowRolesFromNormalGroups =
          _apiMapResponse['allow_roles_from_normal_groups'];
      _allowRolesFromNormalGroupsSet = true;
    }
    return _allowRolesFromNormalGroups;
  }

  set allowRolesFromNormalGroups(bool v) {
    _allowRolesFromNormalGroups = v;
    _allowRolesFromNormalGroupsSet = true;
  }

  /// Allows roles to be directly assigned to SAML auth'd users.

  bool get allowDirectRoles {
    if (!_allowDirectRolesSet &&
        _apiMapResponse.containsKey('allow_direct_roles')) {
      _allowDirectRoles = _apiMapResponse['allow_direct_roles'];
      _allowDirectRolesSet = true;
    }
    return _allowDirectRoles;
  }

  set allowDirectRoles(bool v) {
    _allowDirectRoles = v;
    _allowDirectRolesSet = true;
  }

  WriteSamlConfig() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteSamlConfig.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_enabledSet || _apiMapResponse.containsKey('enabled')) {
      json['enabled'] = enabled;
    }
    if (_idpCertSet || _apiMapResponse.containsKey('idp_cert')) {
      json['idp_cert'] = idpCert;
    }
    if (_idpUrlSet || _apiMapResponse.containsKey('idp_url')) {
      json['idp_url'] = idpUrl;
    }
    if (_idpIssuerSet || _apiMapResponse.containsKey('idp_issuer')) {
      json['idp_issuer'] = idpIssuer;
    }
    if (_idpAudienceSet || _apiMapResponse.containsKey('idp_audience')) {
      json['idp_audience'] = idpAudience;
    }
    if (_allowedClockDriftSet ||
        _apiMapResponse.containsKey('allowed_clock_drift')) {
      json['allowed_clock_drift'] = allowedClockDrift;
    }
    if (_userAttributeMapEmailSet ||
        _apiMapResponse.containsKey('user_attribute_map_email')) {
      json['user_attribute_map_email'] = userAttributeMapEmail;
    }
    if (_userAttributeMapFirstNameSet ||
        _apiMapResponse.containsKey('user_attribute_map_first_name')) {
      json['user_attribute_map_first_name'] = userAttributeMapFirstName;
    }
    if (_userAttributeMapLastNameSet ||
        _apiMapResponse.containsKey('user_attribute_map_last_name')) {
      json['user_attribute_map_last_name'] = userAttributeMapLastName;
    }
    if (_newUserMigrationTypesSet ||
        _apiMapResponse.containsKey('new_user_migration_types')) {
      json['new_user_migration_types'] = newUserMigrationTypes;
    }
    if (_alternateEmailLoginAllowedSet ||
        _apiMapResponse.containsKey('alternate_email_login_allowed')) {
      json['alternate_email_login_allowed'] = alternateEmailLoginAllowed;
    }
    if (_defaultNewUserRoleIdsSet ||
        _apiMapResponse.containsKey('default_new_user_role_ids')) {
      json['default_new_user_role_ids'] = defaultNewUserRoleIds;
    }
    if (_defaultNewUserGroupIdsSet ||
        _apiMapResponse.containsKey('default_new_user_group_ids')) {
      json['default_new_user_group_ids'] = defaultNewUserGroupIds;
    }
    if (_setRolesFromGroupsSet ||
        _apiMapResponse.containsKey('set_roles_from_groups')) {
      json['set_roles_from_groups'] = setRolesFromGroups;
    }
    if (_groupsAttributeSet ||
        _apiMapResponse.containsKey('groups_attribute')) {
      json['groups_attribute'] = groupsAttribute;
    }
    if (_groupsWithRoleIdsSet ||
        _apiMapResponse.containsKey('groups_with_role_ids')) {
      json['groups_with_role_ids'] =
          groupsWithRoleIds?.map((i) => i.toJson())?.toList();
    }
    if (_authRequiresRoleSet ||
        _apiMapResponse.containsKey('auth_requires_role')) {
      json['auth_requires_role'] = authRequiresRole;
    }
    if (_userAttributesWithIdsSet ||
        _apiMapResponse.containsKey('user_attributes_with_ids')) {
      json['user_attributes_with_ids'] =
          userAttributesWithIds?.map((i) => i.toJson())?.toList();
    }
    if (_groupsFinderTypeSet ||
        _apiMapResponse.containsKey('groups_finder_type')) {
      json['groups_finder_type'] = groupsFinderType;
    }
    if (_groupsMemberValueSet ||
        _apiMapResponse.containsKey('groups_member_value')) {
      json['groups_member_value'] = groupsMemberValue;
    }
    if (_bypassLoginPageSet ||
        _apiMapResponse.containsKey('bypass_login_page')) {
      json['bypass_login_page'] = bypassLoginPage;
    }
    if (_allowNormalGroupMembershipSet ||
        _apiMapResponse.containsKey('allow_normal_group_membership')) {
      json['allow_normal_group_membership'] = allowNormalGroupMembership;
    }
    if (_allowRolesFromNormalGroupsSet ||
        _apiMapResponse.containsKey('allow_roles_from_normal_groups')) {
      json['allow_roles_from_normal_groups'] = allowRolesFromNormalGroups;
    }
    if (_allowDirectRolesSet ||
        _apiMapResponse.containsKey('allow_direct_roles')) {
      json['allow_direct_roles'] = allowDirectRoles;
    }
    return json;
  }
}

/// Dynamic writeable type for ScheduledPlan removes:
/// id, created_at, updated_at, title, user, next_run_at, last_run_at, can
class WriteScheduledPlan {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  int _userId;
  bool _userIdSet = false;

  bool _runAsRecipient;
  bool _runAsRecipientSet = false;

  bool _enabled;
  bool _enabledSet = false;

  String _lookId;
  bool _lookIdSet = false;

  int _dashboardId;
  bool _dashboardIdSet = false;

  String _lookmlDashboardId;
  bool _lookmlDashboardIdSet = false;

  String _filtersString;
  bool _filtersStringSet = false;

  String _dashboardFilters;
  bool _dashboardFiltersSet = false;

  bool _requireResults;
  bool _requireResultsSet = false;

  bool _requireNoResults;
  bool _requireNoResultsSet = false;

  bool _requireChange;
  bool _requireChangeSet = false;

  bool _sendAllResults;
  bool _sendAllResultsSet = false;

  String _crontab;
  bool _crontabSet = false;

  String _datagroup;
  bool _datagroupSet = false;

  String _timezone;
  bool _timezoneSet = false;

  String _queryId;
  bool _queryIdSet = false;

  List<ScheduledPlanDestination> _scheduledPlanDestination;
  bool _scheduledPlanDestinationSet = false;

  bool _runOnce;
  bool _runOnceSet = false;

  bool _includeLinks;
  bool _includeLinksSet = false;

  String _pdfPaperSize;
  bool _pdfPaperSizeSet = false;

  bool _pdfLandscape;
  bool _pdfLandscapeSet = false;

  bool _embed;
  bool _embedSet = false;

  String _colorTheme;
  bool _colorThemeSet = false;

  bool _longTables;
  bool _longTablesSet = false;

  int _inlineTableWidth;
  bool _inlineTableWidthSet = false;

  /// Name of this scheduled plan

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// User Id which owns this scheduled plan

  int get userId {
    if (!_userIdSet && _apiMapResponse.containsKey('user_id')) {
      _userId = _apiMapResponse['user_id'];
      _userIdSet = true;
    }
    return _userId;
  }

  set userId(int v) {
    _userId = v;
    _userIdSet = true;
  }

  /// Whether schedule is run as recipient (only applicable for email recipients)

  bool get runAsRecipient {
    if (!_runAsRecipientSet &&
        _apiMapResponse.containsKey('run_as_recipient')) {
      _runAsRecipient = _apiMapResponse['run_as_recipient'];
      _runAsRecipientSet = true;
    }
    return _runAsRecipient;
  }

  set runAsRecipient(bool v) {
    _runAsRecipient = v;
    _runAsRecipientSet = true;
  }

  /// Whether the ScheduledPlan is enabled

  bool get enabled {
    if (!_enabledSet && _apiMapResponse.containsKey('enabled')) {
      _enabled = _apiMapResponse['enabled'];
      _enabledSet = true;
    }
    return _enabled;
  }

  set enabled(bool v) {
    _enabled = v;
    _enabledSet = true;
  }

  /// Id of a look

  String get lookId {
    if (!_lookIdSet && _apiMapResponse.containsKey('look_id')) {
      _lookId = _apiMapResponse['look_id']?.toString();
      _lookIdSet = true;
    }
    return _lookId;
  }

  set lookId(String v) {
    _lookId = v;
    _lookIdSet = true;
  }

  /// Id of a dashboard

  int get dashboardId {
    if (!_dashboardIdSet && _apiMapResponse.containsKey('dashboard_id')) {
      _dashboardId = _apiMapResponse['dashboard_id'];
      _dashboardIdSet = true;
    }
    return _dashboardId;
  }

  set dashboardId(int v) {
    _dashboardId = v;
    _dashboardIdSet = true;
  }

  /// Id of a LookML dashboard

  String get lookmlDashboardId {
    if (!_lookmlDashboardIdSet &&
        _apiMapResponse.containsKey('lookml_dashboard_id')) {
      _lookmlDashboardId = _apiMapResponse['lookml_dashboard_id']?.toString();
      _lookmlDashboardIdSet = true;
    }
    return _lookmlDashboardId;
  }

  set lookmlDashboardId(String v) {
    _lookmlDashboardId = v;
    _lookmlDashboardIdSet = true;
  }

  /// Query string to run look or dashboard with

  String get filtersString {
    if (!_filtersStringSet && _apiMapResponse.containsKey('filters_string')) {
      _filtersString = _apiMapResponse['filters_string']?.toString();
      _filtersStringSet = true;
    }
    return _filtersString;
  }

  set filtersString(String v) {
    _filtersString = v;
    _filtersStringSet = true;
  }

  /// (DEPRECATED) Alias for filters_string field

  String get dashboardFilters {
    if (!_dashboardFiltersSet &&
        _apiMapResponse.containsKey('dashboard_filters')) {
      _dashboardFilters = _apiMapResponse['dashboard_filters']?.toString();
      _dashboardFiltersSet = true;
    }
    return _dashboardFilters;
  }

  set dashboardFilters(String v) {
    _dashboardFilters = v;
    _dashboardFiltersSet = true;
  }

  /// Delivery should occur if running the dashboard or look returns results

  bool get requireResults {
    if (!_requireResultsSet && _apiMapResponse.containsKey('require_results')) {
      _requireResults = _apiMapResponse['require_results'];
      _requireResultsSet = true;
    }
    return _requireResults;
  }

  set requireResults(bool v) {
    _requireResults = v;
    _requireResultsSet = true;
  }

  /// Delivery should occur if the dashboard look does not return results

  bool get requireNoResults {
    if (!_requireNoResultsSet &&
        _apiMapResponse.containsKey('require_no_results')) {
      _requireNoResults = _apiMapResponse['require_no_results'];
      _requireNoResultsSet = true;
    }
    return _requireNoResults;
  }

  set requireNoResults(bool v) {
    _requireNoResults = v;
    _requireNoResultsSet = true;
  }

  /// Delivery should occur if data have changed since the last run

  bool get requireChange {
    if (!_requireChangeSet && _apiMapResponse.containsKey('require_change')) {
      _requireChange = _apiMapResponse['require_change'];
      _requireChangeSet = true;
    }
    return _requireChange;
  }

  set requireChange(bool v) {
    _requireChange = v;
    _requireChangeSet = true;
  }

  /// Will run an unlimited query and send all results.

  bool get sendAllResults {
    if (!_sendAllResultsSet &&
        _apiMapResponse.containsKey('send_all_results')) {
      _sendAllResults = _apiMapResponse['send_all_results'];
      _sendAllResultsSet = true;
    }
    return _sendAllResults;
  }

  set sendAllResults(bool v) {
    _sendAllResults = v;
    _sendAllResultsSet = true;
  }

  /// Vixie-Style crontab specification when to run

  String get crontab {
    if (!_crontabSet && _apiMapResponse.containsKey('crontab')) {
      _crontab = _apiMapResponse['crontab']?.toString();
      _crontabSet = true;
    }
    return _crontab;
  }

  set crontab(String v) {
    _crontab = v;
    _crontabSet = true;
  }

  /// Name of a datagroup; if specified will run when datagroup triggered (can't be used with cron string)

  String get datagroup {
    if (!_datagroupSet && _apiMapResponse.containsKey('datagroup')) {
      _datagroup = _apiMapResponse['datagroup']?.toString();
      _datagroupSet = true;
    }
    return _datagroup;
  }

  set datagroup(String v) {
    _datagroup = v;
    _datagroupSet = true;
  }

  /// Timezone for interpreting the specified crontab (default is Looker instance timezone)

  String get timezone {
    if (!_timezoneSet && _apiMapResponse.containsKey('timezone')) {
      _timezone = _apiMapResponse['timezone']?.toString();
      _timezoneSet = true;
    }
    return _timezone;
  }

  set timezone(String v) {
    _timezone = v;
    _timezoneSet = true;
  }

  /// Query id

  String get queryId {
    if (!_queryIdSet && _apiMapResponse.containsKey('query_id')) {
      _queryId = _apiMapResponse['query_id']?.toString();
      _queryIdSet = true;
    }
    return _queryId;
  }

  set queryId(String v) {
    _queryId = v;
    _queryIdSet = true;
  }

  /// Scheduled plan destinations

  List<ScheduledPlanDestination> get scheduledPlanDestination {
    if (!_scheduledPlanDestinationSet &&
        _apiMapResponse.containsKey('scheduled_plan_destination')) {
      _scheduledPlanDestination =
          _apiMapResponse['scheduled_plan_destination'] == null
              ? null
              : (_apiMapResponse['scheduled_plan_destination'] as List)
                  .map((i) => ScheduledPlanDestination.fromResponse(
                      i, apiResponseContentType))
                  .toList();
      _scheduledPlanDestinationSet = true;
    }
    return _scheduledPlanDestination;
  }

  set scheduledPlanDestination(List<ScheduledPlanDestination> v) {
    _scheduledPlanDestination = v;
    _scheduledPlanDestinationSet = true;
  }

  /// Whether the plan in question should only be run once (usually for testing)

  bool get runOnce {
    if (!_runOnceSet && _apiMapResponse.containsKey('run_once')) {
      _runOnce = _apiMapResponse['run_once'];
      _runOnceSet = true;
    }
    return _runOnce;
  }

  set runOnce(bool v) {
    _runOnce = v;
    _runOnceSet = true;
  }

  /// Whether links back to Looker should be included in this ScheduledPlan

  bool get includeLinks {
    if (!_includeLinksSet && _apiMapResponse.containsKey('include_links')) {
      _includeLinks = _apiMapResponse['include_links'];
      _includeLinksSet = true;
    }
    return _includeLinks;
  }

  set includeLinks(bool v) {
    _includeLinks = v;
    _includeLinksSet = true;
  }

  /// The size of paper the PDF should be formatted to fit. Valid values are: "letter", "legal", "tabloid", "a0", "a1", "a2", "a3", "a4", "a5".

  String get pdfPaperSize {
    if (!_pdfPaperSizeSet && _apiMapResponse.containsKey('pdf_paper_size')) {
      _pdfPaperSize = _apiMapResponse['pdf_paper_size']?.toString();
      _pdfPaperSizeSet = true;
    }
    return _pdfPaperSize;
  }

  set pdfPaperSize(String v) {
    _pdfPaperSize = v;
    _pdfPaperSizeSet = true;
  }

  /// Whether the PDF should be formatted for landscape orientation

  bool get pdfLandscape {
    if (!_pdfLandscapeSet && _apiMapResponse.containsKey('pdf_landscape')) {
      _pdfLandscape = _apiMapResponse['pdf_landscape'];
      _pdfLandscapeSet = true;
    }
    return _pdfLandscape;
  }

  set pdfLandscape(bool v) {
    _pdfLandscape = v;
    _pdfLandscapeSet = true;
  }

  /// Whether this schedule is in an embed context or not

  bool get embed {
    if (!_embedSet && _apiMapResponse.containsKey('embed')) {
      _embed = _apiMapResponse['embed'];
      _embedSet = true;
    }
    return _embed;
  }

  set embed(bool v) {
    _embed = v;
    _embedSet = true;
  }

  /// Color scheme of the dashboard if applicable

  String get colorTheme {
    if (!_colorThemeSet && _apiMapResponse.containsKey('color_theme')) {
      _colorTheme = _apiMapResponse['color_theme']?.toString();
      _colorThemeSet = true;
    }
    return _colorTheme;
  }

  set colorTheme(String v) {
    _colorTheme = v;
    _colorThemeSet = true;
  }

  /// Whether or not to expand table vis to full length

  bool get longTables {
    if (!_longTablesSet && _apiMapResponse.containsKey('long_tables')) {
      _longTables = _apiMapResponse['long_tables'];
      _longTablesSet = true;
    }
    return _longTables;
  }

  set longTables(bool v) {
    _longTables = v;
    _longTablesSet = true;
  }

  /// The pixel width at which we render the inline table visualizations

  int get inlineTableWidth {
    if (!_inlineTableWidthSet &&
        _apiMapResponse.containsKey('inline_table_width')) {
      _inlineTableWidth = _apiMapResponse['inline_table_width'];
      _inlineTableWidthSet = true;
    }
    return _inlineTableWidth;
  }

  set inlineTableWidth(int v) {
    _inlineTableWidth = v;
    _inlineTableWidthSet = true;
  }

  WriteScheduledPlan() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteScheduledPlan.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_userIdSet || _apiMapResponse.containsKey('user_id')) {
      json['user_id'] = userId;
    }
    if (_runAsRecipientSet || _apiMapResponse.containsKey('run_as_recipient')) {
      json['run_as_recipient'] = runAsRecipient;
    }
    if (_enabledSet || _apiMapResponse.containsKey('enabled')) {
      json['enabled'] = enabled;
    }
    if (_lookIdSet || _apiMapResponse.containsKey('look_id')) {
      json['look_id'] = lookId;
    }
    if (_dashboardIdSet || _apiMapResponse.containsKey('dashboard_id')) {
      json['dashboard_id'] = dashboardId;
    }
    if (_lookmlDashboardIdSet ||
        _apiMapResponse.containsKey('lookml_dashboard_id')) {
      json['lookml_dashboard_id'] = lookmlDashboardId;
    }
    if (_filtersStringSet || _apiMapResponse.containsKey('filters_string')) {
      json['filters_string'] = filtersString;
    }
    if (_dashboardFiltersSet ||
        _apiMapResponse.containsKey('dashboard_filters')) {
      json['dashboard_filters'] = dashboardFilters;
    }
    if (_requireResultsSet || _apiMapResponse.containsKey('require_results')) {
      json['require_results'] = requireResults;
    }
    if (_requireNoResultsSet ||
        _apiMapResponse.containsKey('require_no_results')) {
      json['require_no_results'] = requireNoResults;
    }
    if (_requireChangeSet || _apiMapResponse.containsKey('require_change')) {
      json['require_change'] = requireChange;
    }
    if (_sendAllResultsSet || _apiMapResponse.containsKey('send_all_results')) {
      json['send_all_results'] = sendAllResults;
    }
    if (_crontabSet || _apiMapResponse.containsKey('crontab')) {
      json['crontab'] = crontab;
    }
    if (_datagroupSet || _apiMapResponse.containsKey('datagroup')) {
      json['datagroup'] = datagroup;
    }
    if (_timezoneSet || _apiMapResponse.containsKey('timezone')) {
      json['timezone'] = timezone;
    }
    if (_queryIdSet || _apiMapResponse.containsKey('query_id')) {
      json['query_id'] = queryId;
    }
    if (_scheduledPlanDestinationSet ||
        _apiMapResponse.containsKey('scheduled_plan_destination')) {
      json['scheduled_plan_destination'] =
          scheduledPlanDestination?.map((i) => i.toJson())?.toList();
    }
    if (_runOnceSet || _apiMapResponse.containsKey('run_once')) {
      json['run_once'] = runOnce;
    }
    if (_includeLinksSet || _apiMapResponse.containsKey('include_links')) {
      json['include_links'] = includeLinks;
    }
    if (_pdfPaperSizeSet || _apiMapResponse.containsKey('pdf_paper_size')) {
      json['pdf_paper_size'] = pdfPaperSize;
    }
    if (_pdfLandscapeSet || _apiMapResponse.containsKey('pdf_landscape')) {
      json['pdf_landscape'] = pdfLandscape;
    }
    if (_embedSet || _apiMapResponse.containsKey('embed')) {
      json['embed'] = embed;
    }
    if (_colorThemeSet || _apiMapResponse.containsKey('color_theme')) {
      json['color_theme'] = colorTheme;
    }
    if (_longTablesSet || _apiMapResponse.containsKey('long_tables')) {
      json['long_tables'] = longTables;
    }
    if (_inlineTableWidthSet ||
        _apiMapResponse.containsKey('inline_table_width')) {
      json['inline_table_width'] = inlineTableWidth;
    }
    return json;
  }
}

/// Dynamic writeable type for SessionConfig removes:
/// can
class WriteSessionConfig {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _allowPersistentSessions;
  bool _allowPersistentSessionsSet = false;

  int _sessionMinutes;
  bool _sessionMinutesSet = false;

  bool _unlimitedSessionsPerUser;
  bool _unlimitedSessionsPerUserSet = false;

  bool _useInactivityBasedLogout;
  bool _useInactivityBasedLogoutSet = false;

  bool _trackSessionLocation;
  bool _trackSessionLocationSet = false;

  /// Allow users to have persistent sessions when they login

  bool get allowPersistentSessions {
    if (!_allowPersistentSessionsSet &&
        _apiMapResponse.containsKey('allow_persistent_sessions')) {
      _allowPersistentSessions = _apiMapResponse['allow_persistent_sessions'];
      _allowPersistentSessionsSet = true;
    }
    return _allowPersistentSessions;
  }

  set allowPersistentSessions(bool v) {
    _allowPersistentSessions = v;
    _allowPersistentSessionsSet = true;
  }

  /// Number of minutes for user sessions.  Must be between 5 and 43200

  int get sessionMinutes {
    if (!_sessionMinutesSet && _apiMapResponse.containsKey('session_minutes')) {
      _sessionMinutes = _apiMapResponse['session_minutes'];
      _sessionMinutesSet = true;
    }
    return _sessionMinutes;
  }

  set sessionMinutes(int v) {
    _sessionMinutes = v;
    _sessionMinutesSet = true;
  }

  /// Allow users to have an unbounded number of concurrent sessions (otherwise, users will be limited to only one session at a time).

  bool get unlimitedSessionsPerUser {
    if (!_unlimitedSessionsPerUserSet &&
        _apiMapResponse.containsKey('unlimited_sessions_per_user')) {
      _unlimitedSessionsPerUser =
          _apiMapResponse['unlimited_sessions_per_user'];
      _unlimitedSessionsPerUserSet = true;
    }
    return _unlimitedSessionsPerUser;
  }

  set unlimitedSessionsPerUser(bool v) {
    _unlimitedSessionsPerUser = v;
    _unlimitedSessionsPerUserSet = true;
  }

  /// Enforce session logout for sessions that are inactive for 15 minutes.

  bool get useInactivityBasedLogout {
    if (!_useInactivityBasedLogoutSet &&
        _apiMapResponse.containsKey('use_inactivity_based_logout')) {
      _useInactivityBasedLogout =
          _apiMapResponse['use_inactivity_based_logout'];
      _useInactivityBasedLogoutSet = true;
    }
    return _useInactivityBasedLogout;
  }

  set useInactivityBasedLogout(bool v) {
    _useInactivityBasedLogout = v;
    _useInactivityBasedLogoutSet = true;
  }

  /// Track location of session when user logs in.

  bool get trackSessionLocation {
    if (!_trackSessionLocationSet &&
        _apiMapResponse.containsKey('track_session_location')) {
      _trackSessionLocation = _apiMapResponse['track_session_location'];
      _trackSessionLocationSet = true;
    }
    return _trackSessionLocation;
  }

  set trackSessionLocation(bool v) {
    _trackSessionLocation = v;
    _trackSessionLocationSet = true;
  }

  WriteSessionConfig() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteSessionConfig.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_allowPersistentSessionsSet ||
        _apiMapResponse.containsKey('allow_persistent_sessions')) {
      json['allow_persistent_sessions'] = allowPersistentSessions;
    }
    if (_sessionMinutesSet || _apiMapResponse.containsKey('session_minutes')) {
      json['session_minutes'] = sessionMinutes;
    }
    if (_unlimitedSessionsPerUserSet ||
        _apiMapResponse.containsKey('unlimited_sessions_per_user')) {
      json['unlimited_sessions_per_user'] = unlimitedSessionsPerUser;
    }
    if (_useInactivityBasedLogoutSet ||
        _apiMapResponse.containsKey('use_inactivity_based_logout')) {
      json['use_inactivity_based_logout'] = useInactivityBasedLogout;
    }
    if (_trackSessionLocationSet ||
        _apiMapResponse.containsKey('track_session_location')) {
      json['track_session_location'] = trackSessionLocation;
    }
    return json;
  }
}

/// Dynamic writeable type for Setting
class WriteSetting {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  bool _extensionFrameworkEnabled;
  bool _extensionFrameworkEnabledSet = false;

  bool _marketplaceAutoInstallEnabled;
  bool _marketplaceAutoInstallEnabledSet = false;

  bool _marketplaceEnabled;
  bool _marketplaceEnabledSet = false;

  WriteWhitelabelConfiguration _whitelabelConfiguration;
  bool _whitelabelConfigurationSet = false;

  CustomWelcomeEmail _customWelcomeEmail;
  bool _customWelcomeEmailSet = false;

  /// Toggle extension framework on or off

  bool get extensionFrameworkEnabled {
    if (!_extensionFrameworkEnabledSet &&
        _apiMapResponse.containsKey('extension_framework_enabled')) {
      _extensionFrameworkEnabled =
          _apiMapResponse['extension_framework_enabled'];
      _extensionFrameworkEnabledSet = true;
    }
    return _extensionFrameworkEnabled;
  }

  set extensionFrameworkEnabled(bool v) {
    _extensionFrameworkEnabled = v;
    _extensionFrameworkEnabledSet = true;
  }

  /// Toggle marketplace auto install on or off. Note that auto install only runs if marketplace is enabled.

  bool get marketplaceAutoInstallEnabled {
    if (!_marketplaceAutoInstallEnabledSet &&
        _apiMapResponse.containsKey('marketplace_auto_install_enabled')) {
      _marketplaceAutoInstallEnabled =
          _apiMapResponse['marketplace_auto_install_enabled'];
      _marketplaceAutoInstallEnabledSet = true;
    }
    return _marketplaceAutoInstallEnabled;
  }

  set marketplaceAutoInstallEnabled(bool v) {
    _marketplaceAutoInstallEnabled = v;
    _marketplaceAutoInstallEnabledSet = true;
  }

  /// Toggle marketplace on or off

  bool get marketplaceEnabled {
    if (!_marketplaceEnabledSet &&
        _apiMapResponse.containsKey('marketplace_enabled')) {
      _marketplaceEnabled = _apiMapResponse['marketplace_enabled'];
      _marketplaceEnabledSet = true;
    }
    return _marketplaceEnabled;
  }

  set marketplaceEnabled(bool v) {
    _marketplaceEnabled = v;
    _marketplaceEnabledSet = true;
  }

  /// Dynamic writeable type for WhitelabelConfiguration removes:
  /// id, logo_url, favicon_url

  WriteWhitelabelConfiguration get whitelabelConfiguration {
    if (!_whitelabelConfigurationSet &&
        _apiMapResponse.containsKey('whitelabel_configuration')) {
      _whitelabelConfiguration =
          _apiMapResponse['whitelabel_configuration'] == null
              ? null
              : WriteWhitelabelConfiguration.fromResponse(
                  _apiMapResponse['whitelabel_configuration'],
                  apiResponseContentType);
      _whitelabelConfigurationSet = true;
    }
    return _whitelabelConfiguration;
  }

  set whitelabelConfiguration(WriteWhitelabelConfiguration v) {
    _whitelabelConfiguration = v;
    _whitelabelConfigurationSet = true;
  }

  CustomWelcomeEmail get customWelcomeEmail {
    if (!_customWelcomeEmailSet &&
        _apiMapResponse.containsKey('custom_welcome_email')) {
      _customWelcomeEmail = _apiMapResponse['custom_welcome_email'] == null
          ? null
          : CustomWelcomeEmail.fromResponse(
              _apiMapResponse['custom_welcome_email'], apiResponseContentType);
      _customWelcomeEmailSet = true;
    }
    return _customWelcomeEmail;
  }

  set customWelcomeEmail(CustomWelcomeEmail v) {
    _customWelcomeEmail = v;
    _customWelcomeEmailSet = true;
  }

  WriteSetting() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteSetting.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_extensionFrameworkEnabledSet ||
        _apiMapResponse.containsKey('extension_framework_enabled')) {
      json['extension_framework_enabled'] = extensionFrameworkEnabled;
    }
    if (_marketplaceAutoInstallEnabledSet ||
        _apiMapResponse.containsKey('marketplace_auto_install_enabled')) {
      json['marketplace_auto_install_enabled'] = marketplaceAutoInstallEnabled;
    }
    if (_marketplaceEnabledSet ||
        _apiMapResponse.containsKey('marketplace_enabled')) {
      json['marketplace_enabled'] = marketplaceEnabled;
    }
    if (_whitelabelConfigurationSet ||
        _apiMapResponse.containsKey('whitelabel_configuration')) {
      json['whitelabel_configuration'] = whitelabelConfiguration?.toJson();
    }
    if (_customWelcomeEmailSet ||
        _apiMapResponse.containsKey('custom_welcome_email')) {
      json['custom_welcome_email'] = customWelcomeEmail?.toJson();
    }
    return json;
  }
}

/// Dynamic writeable type for SshServer removes:
/// ssh_server_id, finger_print, sha_finger_print, public_key, status
class WriteSshServer {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _sshServerName;
  bool _sshServerNameSet = false;

  String _sshServerHost;
  bool _sshServerHostSet = false;

  int _sshServerPort;
  bool _sshServerPortSet = false;

  String _sshServerUser;
  bool _sshServerUserSet = false;

  /// The name to identify this SSH Server

  String get sshServerName {
    if (!_sshServerNameSet && _apiMapResponse.containsKey('ssh_server_name')) {
      _sshServerName = _apiMapResponse['ssh_server_name']?.toString();
      _sshServerNameSet = true;
    }
    return _sshServerName;
  }

  set sshServerName(String v) {
    _sshServerName = v;
    _sshServerNameSet = true;
  }

  /// The hostname or ip address of the SSH Server

  String get sshServerHost {
    if (!_sshServerHostSet && _apiMapResponse.containsKey('ssh_server_host')) {
      _sshServerHost = _apiMapResponse['ssh_server_host']?.toString();
      _sshServerHostSet = true;
    }
    return _sshServerHost;
  }

  set sshServerHost(String v) {
    _sshServerHost = v;
    _sshServerHostSet = true;
  }

  /// The port to connect to on the SSH Server

  int get sshServerPort {
    if (!_sshServerPortSet && _apiMapResponse.containsKey('ssh_server_port')) {
      _sshServerPort = _apiMapResponse['ssh_server_port'];
      _sshServerPortSet = true;
    }
    return _sshServerPort;
  }

  set sshServerPort(int v) {
    _sshServerPort = v;
    _sshServerPortSet = true;
  }

  /// The username used to connect to the SSH Server

  String get sshServerUser {
    if (!_sshServerUserSet && _apiMapResponse.containsKey('ssh_server_user')) {
      _sshServerUser = _apiMapResponse['ssh_server_user']?.toString();
      _sshServerUserSet = true;
    }
    return _sshServerUser;
  }

  set sshServerUser(String v) {
    _sshServerUser = v;
    _sshServerUserSet = true;
  }

  WriteSshServer() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteSshServer.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_sshServerNameSet || _apiMapResponse.containsKey('ssh_server_name')) {
      json['ssh_server_name'] = sshServerName;
    }
    if (_sshServerHostSet || _apiMapResponse.containsKey('ssh_server_host')) {
      json['ssh_server_host'] = sshServerHost;
    }
    if (_sshServerPortSet || _apiMapResponse.containsKey('ssh_server_port')) {
      json['ssh_server_port'] = sshServerPort;
    }
    if (_sshServerUserSet || _apiMapResponse.containsKey('ssh_server_user')) {
      json['ssh_server_user'] = sshServerUser;
    }
    return json;
  }
}

/// Dynamic writeable type for SshTunnel removes:
/// tunnel_id, ssh_server_name, ssh_server_host, ssh_server_port, ssh_server_user, last_attempt, local_host_port, status
class WriteSshTunnel {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _sshServerId;
  bool _sshServerIdSet = false;

  String _databaseHost;
  bool _databaseHostSet = false;

  int _databasePort;
  bool _databasePortSet = false;

  /// SSH Server ID

  String get sshServerId {
    if (!_sshServerIdSet && _apiMapResponse.containsKey('ssh_server_id')) {
      _sshServerId = _apiMapResponse['ssh_server_id']?.toString();
      _sshServerIdSet = true;
    }
    return _sshServerId;
  }

  set sshServerId(String v) {
    _sshServerId = v;
    _sshServerIdSet = true;
  }

  /// Hostname or IP Address of the Database Server

  String get databaseHost {
    if (!_databaseHostSet && _apiMapResponse.containsKey('database_host')) {
      _databaseHost = _apiMapResponse['database_host']?.toString();
      _databaseHostSet = true;
    }
    return _databaseHost;
  }

  set databaseHost(String v) {
    _databaseHost = v;
    _databaseHostSet = true;
  }

  /// Port that the Database Server is listening on

  int get databasePort {
    if (!_databasePortSet && _apiMapResponse.containsKey('database_port')) {
      _databasePort = _apiMapResponse['database_port'];
      _databasePortSet = true;
    }
    return _databasePort;
  }

  set databasePort(int v) {
    _databasePort = v;
    _databasePortSet = true;
  }

  WriteSshTunnel() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteSshTunnel.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_sshServerIdSet || _apiMapResponse.containsKey('ssh_server_id')) {
      json['ssh_server_id'] = sshServerId;
    }
    if (_databaseHostSet || _apiMapResponse.containsKey('database_host')) {
      json['database_host'] = databaseHost;
    }
    if (_databasePortSet || _apiMapResponse.containsKey('database_port')) {
      json['database_port'] = databasePort;
    }
    return json;
  }
}

/// Dynamic writeable type for Theme removes:
/// can, id
class WriteTheme {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  DateTime _beginAt;
  bool _beginAtSet = false;

  DateTime _endAt;
  bool _endAtSet = false;

  String _name;
  bool _nameSet = false;

  ThemeSettings _settings;
  bool _settingsSet = false;

  /// Timestamp for when this theme becomes active. Null=always

  DateTime get beginAt {
    if (!_beginAtSet && _apiMapResponse.containsKey('begin_at')) {
      _beginAt = _apiMapResponse['begin_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['begin_at']);
      _beginAtSet = true;
    }
    return _beginAt;
  }

  set beginAt(DateTime v) {
    _beginAt = v;
    _beginAtSet = true;
  }

  /// Timestamp for when this theme expires. Null=never

  DateTime get endAt {
    if (!_endAtSet && _apiMapResponse.containsKey('end_at')) {
      _endAt = _apiMapResponse['end_at'] == null
          ? null
          : DateTime.parse(_apiMapResponse['end_at']);
      _endAtSet = true;
    }
    return _endAt;
  }

  set endAt(DateTime v) {
    _endAt = v;
    _endAtSet = true;
  }

  /// Name of theme. Can only be alphanumeric and underscores.

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  ThemeSettings get settings {
    if (!_settingsSet && _apiMapResponse.containsKey('settings')) {
      _settings = _apiMapResponse['settings'] == null
          ? null
          : ThemeSettings.fromResponse(
              _apiMapResponse['settings'], apiResponseContentType);
      _settingsSet = true;
    }
    return _settings;
  }

  set settings(ThemeSettings v) {
    _settings = v;
    _settingsSet = true;
  }

  WriteTheme() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteTheme.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_beginAtSet || _apiMapResponse.containsKey('begin_at')) {
      json['begin_at'] = beginAt?.toIso8601String();
    }
    if (_endAtSet || _apiMapResponse.containsKey('end_at')) {
      json['end_at'] = endAt?.toIso8601String();
    }
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_settingsSet || _apiMapResponse.containsKey('settings')) {
      json['settings'] = settings?.toJson();
    }
    return json;
  }
}

/// Dynamic writeable type for User removes:
/// can, avatar_url, avatar_url_without_sizing, credentials_api3, credentials_embed, credentials_google, credentials_ldap, credentials_looker_openid, credentials_oidc, credentials_saml, credentials_totp, display_name, email, embed_group_space_id, group_ids, id, looker_versions, personal_folder_id, presumed_looker_employee, role_ids, sessions, verified_looker_employee, roles_externally_managed, allow_direct_roles, allow_normal_group_membership, allow_roles_from_normal_groups, url
class WriteUser {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  WriteCredentialsEmail _credentialsEmail;
  bool _credentialsEmailSet = false;

  String _firstName;
  bool _firstNameSet = false;

  String _homeFolderId;
  bool _homeFolderIdSet = false;

  bool _isDisabled;
  bool _isDisabledSet = false;

  String _lastName;
  bool _lastNameSet = false;

  String _locale;
  bool _localeSet = false;

  bool _modelsDirValidated;
  bool _modelsDirValidatedSet = false;

  Map<String, dynamic> _uiState;
  bool _uiStateSet = false;

  /// Dynamic writeable type for CredentialsEmail removes:
  /// can, created_at, is_disabled, logged_in_at, password_reset_url, type, url, user_url

  WriteCredentialsEmail get credentialsEmail {
    if (!_credentialsEmailSet &&
        _apiMapResponse.containsKey('credentials_email')) {
      _credentialsEmail = _apiMapResponse['credentials_email'] == null
          ? null
          : WriteCredentialsEmail.fromResponse(
              _apiMapResponse['credentials_email'], apiResponseContentType);
      _credentialsEmailSet = true;
    }
    return _credentialsEmail;
  }

  set credentialsEmail(WriteCredentialsEmail v) {
    _credentialsEmail = v;
    _credentialsEmailSet = true;
  }

  /// First name

  String get firstName {
    if (!_firstNameSet && _apiMapResponse.containsKey('first_name')) {
      _firstName = _apiMapResponse['first_name']?.toString();
      _firstNameSet = true;
    }
    return _firstName;
  }

  set firstName(String v) {
    _firstName = v;
    _firstNameSet = true;
  }

  /// ID string for user's home folder

  String get homeFolderId {
    if (!_homeFolderIdSet && _apiMapResponse.containsKey('home_folder_id')) {
      _homeFolderId = _apiMapResponse['home_folder_id']?.toString();
      _homeFolderIdSet = true;
    }
    return _homeFolderId;
  }

  set homeFolderId(String v) {
    _homeFolderId = v;
    _homeFolderIdSet = true;
  }

  /// Account has been disabled

  bool get isDisabled {
    if (!_isDisabledSet && _apiMapResponse.containsKey('is_disabled')) {
      _isDisabled = _apiMapResponse['is_disabled'];
      _isDisabledSet = true;
    }
    return _isDisabled;
  }

  set isDisabled(bool v) {
    _isDisabled = v;
    _isDisabledSet = true;
  }

  /// Last name

  String get lastName {
    if (!_lastNameSet && _apiMapResponse.containsKey('last_name')) {
      _lastName = _apiMapResponse['last_name']?.toString();
      _lastNameSet = true;
    }
    return _lastName;
  }

  set lastName(String v) {
    _lastName = v;
    _lastNameSet = true;
  }

  /// User's preferred locale. User locale takes precedence over Looker's system-wide default locale. Locale determines language of display strings and date and numeric formatting in API responses. Locale string must be a 2 letter language code or a combination of language code and region code: 'en' or 'en-US', for example.

  String get locale {
    if (!_localeSet && _apiMapResponse.containsKey('locale')) {
      _locale = _apiMapResponse['locale']?.toString();
      _localeSet = true;
    }
    return _locale;
  }

  set locale(String v) {
    _locale = v;
    _localeSet = true;
  }

  /// User's dev workspace has been checked for presence of applicable production projects

  bool get modelsDirValidated {
    if (!_modelsDirValidatedSet &&
        _apiMapResponse.containsKey('models_dir_validated')) {
      _modelsDirValidated = _apiMapResponse['models_dir_validated'];
      _modelsDirValidatedSet = true;
    }
    return _modelsDirValidated;
  }

  set modelsDirValidated(bool v) {
    _modelsDirValidated = v;
    _modelsDirValidatedSet = true;
  }

  /// Per user dictionary of undocumented state information owned by the Looker UI.

  Map<String, dynamic> get uiState {
    if (!_uiStateSet && _apiMapResponse.containsKey('ui_state')) {
      _uiState = _apiMapResponse['ui_state'];
      _uiStateSet = true;
    }
    return _uiState;
  }

  set uiState(Map<String, dynamic> v) {
    _uiState = v;
    _uiStateSet = true;
  }

  WriteUser() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteUser.fromResponse(Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_credentialsEmailSet ||
        _apiMapResponse.containsKey('credentials_email')) {
      json['credentials_email'] = credentialsEmail?.toJson();
    }
    if (_firstNameSet || _apiMapResponse.containsKey('first_name')) {
      json['first_name'] = firstName;
    }
    if (_homeFolderIdSet || _apiMapResponse.containsKey('home_folder_id')) {
      json['home_folder_id'] = homeFolderId;
    }
    if (_isDisabledSet || _apiMapResponse.containsKey('is_disabled')) {
      json['is_disabled'] = isDisabled;
    }
    if (_lastNameSet || _apiMapResponse.containsKey('last_name')) {
      json['last_name'] = lastName;
    }
    if (_localeSet || _apiMapResponse.containsKey('locale')) {
      json['locale'] = locale;
    }
    if (_modelsDirValidatedSet ||
        _apiMapResponse.containsKey('models_dir_validated')) {
      json['models_dir_validated'] = modelsDirValidated;
    }
    if (_uiStateSet || _apiMapResponse.containsKey('ui_state')) {
      json['ui_state'] = uiState;
    }
    return json;
  }
}

/// Dynamic writeable type for UserAttribute removes:
/// can, id, is_system, is_permanent
class WriteUserAttribute {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _name;
  bool _nameSet = false;

  String _label;
  bool _labelSet = false;

  String _type;
  bool _typeSet = false;

  String _defaultValue;
  bool _defaultValueSet = false;

  bool _valueIsHidden;
  bool _valueIsHiddenSet = false;

  bool _userCanView;
  bool _userCanViewSet = false;

  bool _userCanEdit;
  bool _userCanEditSet = false;

  String _hiddenValueDomainWhitelist;
  bool _hiddenValueDomainWhitelistSet = false;

  /// Name of user attribute

  String get name {
    if (!_nameSet && _apiMapResponse.containsKey('name')) {
      _name = _apiMapResponse['name']?.toString();
      _nameSet = true;
    }
    return _name;
  }

  set name(String v) {
    _name = v;
    _nameSet = true;
  }

  /// Human-friendly label for user attribute

  String get label {
    if (!_labelSet && _apiMapResponse.containsKey('label')) {
      _label = _apiMapResponse['label']?.toString();
      _labelSet = true;
    }
    return _label;
  }

  set label(String v) {
    _label = v;
    _labelSet = true;
  }

  /// Type of user attribute ("string", "number", "datetime", "yesno", "zipcode")

  String get type {
    if (!_typeSet && _apiMapResponse.containsKey('type')) {
      _type = _apiMapResponse['type']?.toString();
      _typeSet = true;
    }
    return _type;
  }

  set type(String v) {
    _type = v;
    _typeSet = true;
  }

  /// Default value for when no value is set on the user

  String get defaultValue {
    if (!_defaultValueSet && _apiMapResponse.containsKey('default_value')) {
      _defaultValue = _apiMapResponse['default_value']?.toString();
      _defaultValueSet = true;
    }
    return _defaultValue;
  }

  set defaultValue(String v) {
    _defaultValue = v;
    _defaultValueSet = true;
  }

  /// If true, users will not be able to view values of this attribute

  bool get valueIsHidden {
    if (!_valueIsHiddenSet && _apiMapResponse.containsKey('value_is_hidden')) {
      _valueIsHidden = _apiMapResponse['value_is_hidden'];
      _valueIsHiddenSet = true;
    }
    return _valueIsHidden;
  }

  set valueIsHidden(bool v) {
    _valueIsHidden = v;
    _valueIsHiddenSet = true;
  }

  /// Non-admin users can see the values of their attributes and use them in filters

  bool get userCanView {
    if (!_userCanViewSet && _apiMapResponse.containsKey('user_can_view')) {
      _userCanView = _apiMapResponse['user_can_view'];
      _userCanViewSet = true;
    }
    return _userCanView;
  }

  set userCanView(bool v) {
    _userCanView = v;
    _userCanViewSet = true;
  }

  /// Users can change the value of this attribute for themselves

  bool get userCanEdit {
    if (!_userCanEditSet && _apiMapResponse.containsKey('user_can_edit')) {
      _userCanEdit = _apiMapResponse['user_can_edit'];
      _userCanEditSet = true;
    }
    return _userCanEdit;
  }

  set userCanEdit(bool v) {
    _userCanEdit = v;
    _userCanEditSet = true;
  }

  /// Destinations to which a hidden attribute may be sent. Once set, cannot be edited.

  String get hiddenValueDomainWhitelist {
    if (!_hiddenValueDomainWhitelistSet &&
        _apiMapResponse.containsKey('hidden_value_domain_whitelist')) {
      _hiddenValueDomainWhitelist =
          _apiMapResponse['hidden_value_domain_whitelist']?.toString();
      _hiddenValueDomainWhitelistSet = true;
    }
    return _hiddenValueDomainWhitelist;
  }

  set hiddenValueDomainWhitelist(String v) {
    _hiddenValueDomainWhitelist = v;
    _hiddenValueDomainWhitelistSet = true;
  }

  WriteUserAttribute() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteUserAttribute.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_nameSet || _apiMapResponse.containsKey('name')) {
      json['name'] = name;
    }
    if (_labelSet || _apiMapResponse.containsKey('label')) {
      json['label'] = label;
    }
    if (_typeSet || _apiMapResponse.containsKey('type')) {
      json['type'] = type;
    }
    if (_defaultValueSet || _apiMapResponse.containsKey('default_value')) {
      json['default_value'] = defaultValue;
    }
    if (_valueIsHiddenSet || _apiMapResponse.containsKey('value_is_hidden')) {
      json['value_is_hidden'] = valueIsHidden;
    }
    if (_userCanViewSet || _apiMapResponse.containsKey('user_can_view')) {
      json['user_can_view'] = userCanView;
    }
    if (_userCanEditSet || _apiMapResponse.containsKey('user_can_edit')) {
      json['user_can_edit'] = userCanEdit;
    }
    if (_hiddenValueDomainWhitelistSet ||
        _apiMapResponse.containsKey('hidden_value_domain_whitelist')) {
      json['hidden_value_domain_whitelist'] = hiddenValueDomainWhitelist;
    }
    return json;
  }
}

/// Dynamic writeable type for UserAttributeWithValue removes:
/// can, name, label, rank, user_id, user_can_edit, value_is_hidden, user_attribute_id, source, hidden_value_domain_whitelist
class WriteUserAttributeWithValue {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _value;
  bool _valueSet = false;

  /// Value of attribute for user

  String get value {
    if (!_valueSet && _apiMapResponse.containsKey('value')) {
      _value = _apiMapResponse['value']?.toString();
      _valueSet = true;
    }
    return _value;
  }

  set value(String v) {
    _value = v;
    _valueSet = true;
  }

  WriteUserAttributeWithValue() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteUserAttributeWithValue.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_valueSet || _apiMapResponse.containsKey('value')) {
      json['value'] = value;
    }
    return json;
  }
}

/// Dynamic writeable type for WhitelabelConfiguration removes:
/// id, logo_url, favicon_url
class WriteWhitelabelConfiguration {
  Object _apiRawResponse;
  Map _apiMapResponse;
  String _apiResponseContentType;

  String _logoFile;
  bool _logoFileSet = false;

  String _faviconFile;
  bool _faviconFileSet = false;

  String _defaultTitle;
  bool _defaultTitleSet = false;

  bool _showHelpMenu;
  bool _showHelpMenuSet = false;

  bool _showDocs;
  bool _showDocsSet = false;

  bool _showEmailSubOptions;
  bool _showEmailSubOptionsSet = false;

  bool _allowLookerMentions;
  bool _allowLookerMentionsSet = false;

  bool _allowLookerLinks;
  bool _allowLookerLinksSet = false;

  bool _customWelcomeEmailAdvanced;
  bool _customWelcomeEmailAdvancedSet = false;

  bool _setupMentions;
  bool _setupMentionsSet = false;

  bool _alertsLogo;
  bool _alertsLogoSet = false;

  bool _alertsLinks;
  bool _alertsLinksSet = false;

  bool _foldersMentions;
  bool _foldersMentionsSet = false;

  /// Customer logo image. Expected base64 encoded data (write-only)

  String get logoFile {
    if (!_logoFileSet && _apiMapResponse.containsKey('logo_file')) {
      _logoFile = _apiMapResponse['logo_file']?.toString();
      _logoFileSet = true;
    }
    return _logoFile;
  }

  set logoFile(String v) {
    _logoFile = v;
    _logoFileSet = true;
  }

  /// Custom favicon image. Expected base64 encoded data (write-only)

  String get faviconFile {
    if (!_faviconFileSet && _apiMapResponse.containsKey('favicon_file')) {
      _faviconFile = _apiMapResponse['favicon_file']?.toString();
      _faviconFileSet = true;
    }
    return _faviconFile;
  }

  set faviconFile(String v) {
    _faviconFile = v;
    _faviconFileSet = true;
  }

  /// Default page title

  String get defaultTitle {
    if (!_defaultTitleSet && _apiMapResponse.containsKey('default_title')) {
      _defaultTitle = _apiMapResponse['default_title']?.toString();
      _defaultTitleSet = true;
    }
    return _defaultTitle;
  }

  set defaultTitle(String v) {
    _defaultTitle = v;
    _defaultTitleSet = true;
  }

  /// Boolean to toggle showing help menus

  bool get showHelpMenu {
    if (!_showHelpMenuSet && _apiMapResponse.containsKey('show_help_menu')) {
      _showHelpMenu = _apiMapResponse['show_help_menu'];
      _showHelpMenuSet = true;
    }
    return _showHelpMenu;
  }

  set showHelpMenu(bool v) {
    _showHelpMenu = v;
    _showHelpMenuSet = true;
  }

  /// Boolean to toggle showing docs

  bool get showDocs {
    if (!_showDocsSet && _apiMapResponse.containsKey('show_docs')) {
      _showDocs = _apiMapResponse['show_docs'];
      _showDocsSet = true;
    }
    return _showDocs;
  }

  set showDocs(bool v) {
    _showDocs = v;
    _showDocsSet = true;
  }

  /// Boolean to toggle showing email subscription options.

  bool get showEmailSubOptions {
    if (!_showEmailSubOptionsSet &&
        _apiMapResponse.containsKey('show_email_sub_options')) {
      _showEmailSubOptions = _apiMapResponse['show_email_sub_options'];
      _showEmailSubOptionsSet = true;
    }
    return _showEmailSubOptions;
  }

  set showEmailSubOptions(bool v) {
    _showEmailSubOptions = v;
    _showEmailSubOptionsSet = true;
  }

  /// Boolean to toggle mentions of Looker in emails

  bool get allowLookerMentions {
    if (!_allowLookerMentionsSet &&
        _apiMapResponse.containsKey('allow_looker_mentions')) {
      _allowLookerMentions = _apiMapResponse['allow_looker_mentions'];
      _allowLookerMentionsSet = true;
    }
    return _allowLookerMentions;
  }

  set allowLookerMentions(bool v) {
    _allowLookerMentions = v;
    _allowLookerMentionsSet = true;
  }

  /// Boolean to toggle links to Looker in emails

  bool get allowLookerLinks {
    if (!_allowLookerLinksSet &&
        _apiMapResponse.containsKey('allow_looker_links')) {
      _allowLookerLinks = _apiMapResponse['allow_looker_links'];
      _allowLookerLinksSet = true;
    }
    return _allowLookerLinks;
  }

  set allowLookerLinks(bool v) {
    _allowLookerLinks = v;
    _allowLookerLinksSet = true;
  }

  /// Allow subject line and email heading customization in customized emails”

  bool get customWelcomeEmailAdvanced {
    if (!_customWelcomeEmailAdvancedSet &&
        _apiMapResponse.containsKey('custom_welcome_email_advanced')) {
      _customWelcomeEmailAdvanced =
          _apiMapResponse['custom_welcome_email_advanced'];
      _customWelcomeEmailAdvancedSet = true;
    }
    return _customWelcomeEmailAdvanced;
  }

  set customWelcomeEmailAdvanced(bool v) {
    _customWelcomeEmailAdvanced = v;
    _customWelcomeEmailAdvancedSet = true;
  }

  /// Remove the word Looker from appearing in the account setup page

  bool get setupMentions {
    if (!_setupMentionsSet && _apiMapResponse.containsKey('setup_mentions')) {
      _setupMentions = _apiMapResponse['setup_mentions'];
      _setupMentionsSet = true;
    }
    return _setupMentions;
  }

  set setupMentions(bool v) {
    _setupMentions = v;
    _setupMentionsSet = true;
  }

  /// Remove Looker logo from Alerts

  bool get alertsLogo {
    if (!_alertsLogoSet && _apiMapResponse.containsKey('alerts_logo')) {
      _alertsLogo = _apiMapResponse['alerts_logo'];
      _alertsLogoSet = true;
    }
    return _alertsLogo;
  }

  set alertsLogo(bool v) {
    _alertsLogo = v;
    _alertsLogoSet = true;
  }

  /// Remove Looker links from Alerts

  bool get alertsLinks {
    if (!_alertsLinksSet && _apiMapResponse.containsKey('alerts_links')) {
      _alertsLinks = _apiMapResponse['alerts_links'];
      _alertsLinksSet = true;
    }
    return _alertsLinks;
  }

  set alertsLinks(bool v) {
    _alertsLinks = v;
    _alertsLinksSet = true;
  }

  /// Remove Looker mentions in home folder page when you don’t have any items saved

  bool get foldersMentions {
    if (!_foldersMentionsSet &&
        _apiMapResponse.containsKey('folders_mentions')) {
      _foldersMentions = _apiMapResponse['folders_mentions'];
      _foldersMentionsSet = true;
    }
    return _foldersMentions;
  }

  set foldersMentions(bool v) {
    _foldersMentions = v;
    _foldersMentionsSet = true;
  }

  WriteWhitelabelConfiguration() {
    _apiMapResponse = {};
  }

  Object get apiRawResponse {
    return _apiRawResponse;
  }

  Object getApiRawValue(String valueName) {
    return _apiMapResponse == null ? null : _apiMapResponse[valueName];
  }

  String get apiResponseContentType {
    return _apiResponseContentType;
  }

  WriteWhitelabelConfiguration.fromResponse(
      Object apiRawResponse, String apiResponseContentType) {
    _apiRawResponse = apiRawResponse;
    _apiMapResponse = {};
    if (apiRawResponse is Map) {
      _apiMapResponse = apiRawResponse;
    }
    _apiResponseContentType = apiResponseContentType ?? '';
  }

  Map toJson() {
    var json = {};
    if (_logoFileSet || _apiMapResponse.containsKey('logo_file')) {
      json['logo_file'] = logoFile;
    }
    if (_faviconFileSet || _apiMapResponse.containsKey('favicon_file')) {
      json['favicon_file'] = faviconFile;
    }
    if (_defaultTitleSet || _apiMapResponse.containsKey('default_title')) {
      json['default_title'] = defaultTitle;
    }
    if (_showHelpMenuSet || _apiMapResponse.containsKey('show_help_menu')) {
      json['show_help_menu'] = showHelpMenu;
    }
    if (_showDocsSet || _apiMapResponse.containsKey('show_docs')) {
      json['show_docs'] = showDocs;
    }
    if (_showEmailSubOptionsSet ||
        _apiMapResponse.containsKey('show_email_sub_options')) {
      json['show_email_sub_options'] = showEmailSubOptions;
    }
    if (_allowLookerMentionsSet ||
        _apiMapResponse.containsKey('allow_looker_mentions')) {
      json['allow_looker_mentions'] = allowLookerMentions;
    }
    if (_allowLookerLinksSet ||
        _apiMapResponse.containsKey('allow_looker_links')) {
      json['allow_looker_links'] = allowLookerLinks;
    }
    if (_customWelcomeEmailAdvancedSet ||
        _apiMapResponse.containsKey('custom_welcome_email_advanced')) {
      json['custom_welcome_email_advanced'] = customWelcomeEmailAdvanced;
    }
    if (_setupMentionsSet || _apiMapResponse.containsKey('setup_mentions')) {
      json['setup_mentions'] = setupMentions;
    }
    if (_alertsLogoSet || _apiMapResponse.containsKey('alerts_logo')) {
      json['alerts_logo'] = alertsLogo;
    }
    if (_alertsLinksSet || _apiMapResponse.containsKey('alerts_links')) {
      json['alerts_links'] = alertsLinks;
    }
    if (_foldersMentionsSet ||
        _apiMapResponse.containsKey('folders_mentions')) {
      json['folders_mentions'] = foldersMentions;
    }
    return json;
  }
}
