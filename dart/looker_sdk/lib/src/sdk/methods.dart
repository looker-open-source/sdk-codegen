/*

 MIT License

 Copyright (c) 2021 Looker Data Sciences, Inc.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.


 */

/// 437 API methods

// NOTE: Do not edit this file generated by Looker SDK Codegen for API 4.0
import '../looker_sdk.dart';

class LookerSDK extends APIMethods {
  LookerSDK(AuthSession authSession) : super(authSession);

  // #region Alert: Alert

  /// ### Search Alerts
  ///
  /// GET /alerts/search -> List<Alert>
  Future<SDKResponse<List<Alert>>> searchAlerts(
      {

      /// @param {int} limit (Optional) Number of results to return (used with `offset`).
      int limit,

      /// @param {int} offset (Optional) Number of results to skip before returning any (used with `limit`).
      int offset,

      /// @param {String} group_by (Optional) Dimension by which to order the results(`dashboard` | `owner`)
      String groupBy,

      /// @param {String} fields (Optional) Requested fields.
      String fields,

      /// @param {bool} disabled (Optional) Filter on returning only enabled or disabled alerts.
      bool disabled,

      /// @param {String} frequency (Optional) Filter on alert frequency, such as: monthly, weekly, daily, hourly, minutes
      String frequency,

      /// @param {bool} condition_met (Optional) Filter on whether the alert has met its condition when it last executed
      bool conditionMet,

      /// @param {String} last_run_start (Optional) Filter on the start range of the last time the alerts were run. Example: 2021-01-01T01:01:01-08:00.
      String lastRunStart,

      /// @param {String} last_run_end (Optional) Filter on the start range of the last time the alerts were run. Example: 2021-01-01T01:01:01-08:00.
      String lastRunEnd,

      /// @param {bool} all_owners (Admin only) (Optional) Filter for all owners.
      bool allOwners}) async {
    List<Alert> responseHandler(dynamic json, String contentType) {
      return json
          .map<Alert>((i) => Alert.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/alerts/search', {
      'limit': limit,
      'offset': offset,
      'group_by': groupBy,
      'fields': fields,
      'disabled': disabled,
      'frequency': frequency,
      'condition_met': conditionMet,
      'last_run_start': lastRunStart,
      'last_run_end': lastRunEnd,
      'all_owners': allOwners
    });
  }

  /// ### Get an alert by a given alert ID
  ///
  /// GET /alerts/{alert_id} -> Alert
  Future<SDKResponse<Alert>> getAlert(

      /// @param {int} alert_id ID of an alert
      int alertId) async {
    var pathAlertId = encodeParam(alertId);

    Alert responseHandler(dynamic json, String contentType) {
      return Alert.fromResponse(json, contentType);
    }

    return get(responseHandler, '/alerts/$pathAlertId');
  }

  /// ### Update an alert
  /// # Required fields: `owner_id`, `field`, `destinations`, `comparison_type`, `threshold`, `cron`
  /// #
  ///
  /// PUT /alerts/{alert_id} -> Alert
  Future<SDKResponse<Alert>> updateAlert(

      /// @param {int} alert_id ID of an alert
      int alertId,

      /// @param {WriteAlert} body
      WriteAlert body) async {
    var pathAlertId = encodeParam(alertId);

    Alert responseHandler(dynamic json, String contentType) {
      return Alert.fromResponse(json, contentType);
    }

    return put(responseHandler, '/alerts/$pathAlertId', null, body?.toJson());
  }

  /// ### Update select alert fields
  /// # Available fields: `owner_id`, `is_disabled`, `disabled_reason`, `is_public`, `threshold`
  /// #
  ///
  /// PATCH /alerts/{alert_id} -> Alert
  Future<SDKResponse<Alert>> updateAlertField(

      /// @param {int} alert_id ID of an alert
      int alertId,

      /// @param {AlertPatch} body
      AlertPatch body) async {
    var pathAlertId = encodeParam(alertId);

    Alert responseHandler(dynamic json, String contentType) {
      return Alert.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/alerts/$pathAlertId', null, body?.toJson());
  }

  /// ### Delete an alert by a given alert ID
  ///
  /// DELETE /alerts/{alert_id} -> void
  Future<SDKResponse<void>> deleteAlert(

      /// @param {int} alert_id ID of an alert
      int alertId) async {
    var pathAlertId = encodeParam(alertId);

    void responseHandler(dynamic json, String contentType) {}
    return delete(responseHandler, '/alerts/$pathAlertId');
  }

  /// ### Create a new alert and return details of the newly created object
  ///
  /// Required fields: `field`, `destinations`, `comparison_type`, `threshold`, `cron`
  ///
  /// Example Request:
  /// Run alert on dashboard element '103' at 5am every day. Send an email to 'test@test.com' if inventory for Los Angeles (using dashboard filter `Warehouse Name`) is lower than 1,000
  /// ```
  /// {
  ///   "cron": "0 5 * * *",
  ///   "custom_title": "Alert when LA inventory is low",
  ///   "dashboard_element_id": 103,
  ///   "applied_dashboard_filters": [
  ///     {
  ///       "filter_title": "Warehouse Name",
  ///       "field_name": "distribution_centers.name",
  ///       "filter_value": "Los Angeles CA",
  ///       "filter_description": "is Los Angeles CA"
  ///     }
  ///   ],
  ///   "comparison_type": "LESS_THAN",
  ///   "destinations": [
  ///     {
  ///       "destination_type": "EMAIL",
  ///       "email_address": "test@test.com"
  ///     }
  ///   ],
  ///   "field": {
  ///     "title": "Number on Hand",
  ///     "name": "inventory_items.number_on_hand"
  ///   },
  ///   "is_disabled": false,
  ///   "is_public": true,
  ///   "threshold": 1000
  /// }
  /// ```
  ///
  /// POST /alerts -> Alert
  Future<SDKResponse<Alert>> createAlert(

      /// @param {WriteAlert} body
      WriteAlert body) async {
    Alert responseHandler(dynamic json, String contentType) {
      return Alert.fromResponse(json, contentType);
    }

    return post(responseHandler, '/alerts', null, body?.toJson());
  }

  /// ### Enqueue an Alert by ID
  ///
  /// POST /alerts/{alert_id}/enqueue -> void
  Future<SDKResponse<void>> enqueueAlert(

      /// @param {int} alert_id ID of an alert
      int alertId,
      {

      /// @param {bool} force Whether to enqueue an alert again if its already running.
      bool force}) async {
    var pathAlertId = encodeParam(alertId);

    void responseHandler(dynamic json, String contentType) {}
    return post(
        responseHandler, '/alerts/$pathAlertId/enqueue', {'force': force});
  }

  // #endregion Alert: Alert

  // #region ApiAuth: API Authentication

  /// ### Present client credentials to obtain an authorization token
  ///
  /// Looker API implements the OAuth2 [Resource Owner Password Credentials Grant](https://looker.com/docs/r/api/outh2_resource_owner_pc) pattern.
  /// The client credentials required for this login must be obtained by creating an API3 key on a user account
  /// in the Looker Admin console. The API3 key consists of a public `client_id` and a private `client_secret`.
  ///
  /// The access token returned by `login` must be used in the HTTP Authorization header of subsequent
  /// API requests, like this:
  /// ```
  /// Authorization: token 4QDkCyCtZzYgj4C2p2cj3csJH7zqS5RzKs2kTnG4
  /// ```
  /// Replace "4QDkCy..." with the `access_token` value returned by `login`.
  /// The word `token` is a string literal and must be included exactly as shown.
  ///
  /// This function can accept `client_id` and `client_secret` parameters as URL query params or as www-form-urlencoded params in the body of the HTTP request. Since there is a small risk that URL parameters may be visible to intermediate nodes on the network route (proxies, routers, etc), passing credentials in the body of the request is considered more secure than URL params.
  ///
  /// Example of passing credentials in the HTTP request body:
  /// ````
  /// POST HTTP /login
  /// Content-Type: application/x-www-form-urlencoded
  ///
  /// client_id=CGc9B7v7J48dQSJvxxx&client_secret=nNVS9cSS3xNpSC9JdsBvvvvv
  /// ````
  ///
  /// ### Best Practice:
  /// Always pass credentials in body params. Pass credentials in URL query params **only** when you cannot pass body params due to application, tool, or other limitations.
  ///
  /// For more information and detailed examples of Looker API authorization, see [How to Authenticate to Looker API3](https://github.com/looker/looker-sdk-ruby/blob/master/authentication.md).
  ///
  /// POST /login -> AccessToken
  Future<SDKResponse<AccessToken>> login(
      {

      /// @param {String} client_id client_id part of API3 Key.
      String clientId,

      /// @param {String} client_secret client_secret part of API3 Key.
      String clientSecret}) async {
    AccessToken responseHandler(dynamic json, String contentType) {
      return AccessToken.fromResponse(json, contentType);
    }

    return post(responseHandler, '/login',
        {'client_id': clientId, 'client_secret': clientSecret});
  }

  /// ### Create an access token that runs as a given user.
  ///
  /// This can only be called by an authenticated admin user. It allows that admin to generate a new
  /// authentication token for the user with the given user id. That token can then be used for subsequent
  /// API calls - which are then performed *as* that target user.
  ///
  /// The target user does *not* need to have a pre-existing API client_id/client_secret pair. And, no such
  /// credentials are created by this call.
  ///
  /// This allows for building systems where api user authentication for an arbitrary number of users is done
  /// outside of Looker and funneled through a single 'service account' with admin permissions. Note that a
  /// new access token is generated on each call. If target users are going to be making numerous API
  /// calls in a short period then it is wise to cache this authentication token rather than call this before
  /// each of those API calls.
  ///
  /// See 'login' for more detail on the access token and how to use it.
  ///
  /// POST /login/{user_id} -> AccessToken
  Future<SDKResponse<AccessToken>> loginUser(

      /// @param {int} user_id Id of user.
      int userId,
      {

      /// @param {bool} associative When true (default), API calls using the returned access_token are attributed to the admin user who created the access_token. When false, API activity is attributed to the user the access_token runs as. False requires a looker license.
      bool associative}) async {
    var pathUserId = encodeParam(userId);

    AccessToken responseHandler(dynamic json, String contentType) {
      return AccessToken.fromResponse(json, contentType);
    }

    return post(
        responseHandler, '/login/$pathUserId', {'associative': associative});
  }

  /// ### Logout of the API and invalidate the current access token.
  ///
  /// DELETE /logout -> String
  Future<SDKResponse<String>> logout() async {
    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/logout');
  }

  // #endregion ApiAuth: API Authentication

  // #region Auth: Manage User Authentication Configuration

  /// ### Create an embed secret using the specified information.
  ///
  /// The value of the `secret` field will be set by Looker and returned.
  ///
  /// POST /embed_config/secrets -> EmbedSecret
  Future<SDKResponse<EmbedSecret>> createEmbedSecret(
      {

      /// @param {WriteEmbedSecret} body
      WriteEmbedSecret body}) async {
    EmbedSecret responseHandler(dynamic json, String contentType) {
      return EmbedSecret.fromResponse(json, contentType);
    }

    return post(responseHandler, '/embed_config/secrets', null, body?.toJson());
  }

  /// ### Delete an embed secret.
  ///
  /// DELETE /embed_config/secrets/{embed_secret_id} -> String
  Future<SDKResponse<String>> deleteEmbedSecret(

      /// @param {int} embed_secret_id Id of Embed Secret
      int embedSecretId) async {
    var pathEmbedSecretId = encodeParam(embedSecretId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/embed_config/secrets/$pathEmbedSecretId');
  }

  /// ### Create SSO Embed URL
  ///
  /// Creates an SSO embed URL and cryptographically signs it with an embed secret.
  /// This signed URL can then be used to instantiate a Looker embed session in a PBL web application.
  /// Do not make any modifications to this URL - any change may invalidate the signature and
  /// cause the URL to fail to load a Looker embed session.
  ///
  /// A signed SSO embed URL can only be used once. After it has been used to request a page from the
  /// Looker server, the URL is invalid. Future requests using the same URL will fail. This is to prevent
  /// 'replay attacks'.
  ///
  /// The `target_url` property must be a complete URL of a Looker UI page - scheme, hostname, path and query params.
  /// To load a dashboard with id 56 and with a filter of `Date=1 years`, the looker URL would look like `https:/myname.looker.com/dashboards/56?Date=1%20years`.
  /// The best way to obtain this target_url is to navigate to the desired Looker page in your web browser,
  /// copy the URL shown in the browser address bar and paste it into the `target_url` property as a quoted string value in this API request.
  ///
  /// Permissions for the embed user are defined by the groups in which the embed user is a member (group_ids property)
  /// and the lists of models and permissions assigned to the embed user.
  /// At a minimum, you must provide values for either the group_ids property, or both the models and permissions properties.
  /// These properties are additive; an embed user can be a member of certain groups AND be granted access to models and permissions.
  ///
  /// The embed user's access is the union of permissions granted by the group_ids, models, and permissions properties.
  ///
  /// This function does not strictly require all group_ids, user attribute names, or model names to exist at the moment the
  /// SSO embed url is created. Unknown group_id, user attribute names or model names will be passed through to the output URL.
  /// To diagnose potential problems with an SSO embed URL, you can copy the signed URL into the Embed URI Validator text box in `<your looker instance>/admin/embed`.
  ///
  /// The `secret_id` parameter is optional. If specified, its value must be the id of an active secret defined in the Looker instance.
  /// if not specified, the URL will be signed using the newest active secret defined in the Looker instance.
  ///
  /// #### Security Note
  /// Protect this signed URL as you would an access token or password credentials - do not write
  /// it to disk, do not pass it to a third party, and only pass it through a secure HTTPS
  /// encrypted transport.
  ///
  /// POST /embed/sso_url -> EmbedUrlResponse
  Future<SDKResponse<EmbedUrlResponse>> createSsoEmbedUrl(

      /// @param {EmbedSsoParams} body
      EmbedSsoParams body) async {
    EmbedUrlResponse responseHandler(dynamic json, String contentType) {
      return EmbedUrlResponse.fromResponse(json, contentType);
    }

    return post(responseHandler, '/embed/sso_url', null, body?.toJson());
  }

  /// ### Create an Embed URL
  ///
  /// Creates an embed URL that runs as the Looker user making this API call. ("Embed as me")
  /// This embed URL can then be used to instantiate a Looker embed session in a
  /// "Powered by Looker" (PBL) web application.
  ///
  /// This is similar to Private Embedding (https://docs.looker.com/r/admin/embed/private-embed). Instead of
  /// of logging into the Web UI to authenticate, the user has already authenticated against the API to be able to
  /// make this call. However, unlike Private Embed where the user has access to any other part of the Looker UI,
  /// the embed web session created by requesting the EmbedUrlResponse.url in a browser only has access to
  /// content visible under the `/embed` context.
  ///
  /// An embed URL can only be used once, and must be used within 5 minutes of being created. After it
  /// has been used to request a page from the Looker server, the URL is invalid. Future requests using
  /// the same URL will fail. This is to prevent 'replay attacks'.
  ///
  /// The `target_url` property must be a complete URL of a Looker Embedded UI page - scheme, hostname, path starting with "/embed" and query params.
  /// To load a dashboard with id 56 and with a filter of `Date=1 years`, the looker Embed URL would look like `https://myname.looker.com/embed/dashboards/56?Date=1%20years`.
  /// The best way to obtain this target_url is to navigate to the desired Looker page in your web browser,
  /// copy the URL shown in the browser address bar, insert "/embed" after the host/port, and paste it into the `target_url` property as a quoted string value in this API request.
  ///
  /// #### Security Note
  /// Protect this embed URL as you would an access token or password credentials - do not write
  /// it to disk, do not pass it to a third party, and only pass it through a secure HTTPS
  /// encrypted transport.
  ///
  /// POST /embed/token_url/me -> EmbedUrlResponse
  Future<SDKResponse<EmbedUrlResponse>> createEmbedUrlAsMe(

      /// @param {EmbedParams} body
      EmbedParams body) async {
    EmbedUrlResponse responseHandler(dynamic json, String contentType) {
      return EmbedUrlResponse.fromResponse(json, contentType);
    }

    return post(responseHandler, '/embed/token_url/me', null, body?.toJson());
  }

  /// ### Get the LDAP configuration.
  ///
  /// Looker can be optionally configured to authenticate users against an Active Directory or other LDAP directory server.
  /// LDAP setup requires coordination with an administrator of that directory server.
  ///
  /// Only Looker administrators can read and update the LDAP configuration.
  ///
  /// Configuring LDAP impacts authentication for all users. This configuration should be done carefully.
  ///
  /// Looker maintains a single LDAP configuration. It can be read and updated.       Updates only succeed if the new state will be valid (in the sense that all required fields are populated);       it is up to you to ensure that the configuration is appropriate and correct).
  ///
  /// LDAP is enabled or disabled for Looker using the **enabled** field.
  ///
  /// Looker will never return an **auth_password** field. That value can be set, but never retrieved.
  ///
  /// See the [Looker LDAP docs](https://www.looker.com/docs/r/api/ldap_setup) for additional information.
  ///
  /// GET /ldap_config -> LDAPConfig
  Future<SDKResponse<LDAPConfig>> ldapConfig() async {
    LDAPConfig responseHandler(dynamic json, String contentType) {
      return LDAPConfig.fromResponse(json, contentType);
    }

    return get(responseHandler, '/ldap_config');
  }

  /// ### Update the LDAP configuration.
  ///
  /// Configuring LDAP impacts authentication for all users. This configuration should be done carefully.
  ///
  /// Only Looker administrators can read and update the LDAP configuration.
  ///
  /// LDAP is enabled or disabled for Looker using the **enabled** field.
  ///
  /// It is **highly** recommended that any LDAP setting changes be tested using the APIs below before being set globally.
  ///
  /// See the [Looker LDAP docs](https://www.looker.com/docs/r/api/ldap_setup) for additional information.
  ///
  /// PATCH /ldap_config -> LDAPConfig
  Future<SDKResponse<LDAPConfig>> updateLdapConfig(

      /// @param {WriteLDAPConfig} body
      WriteLDAPConfig body) async {
    LDAPConfig responseHandler(dynamic json, String contentType) {
      return LDAPConfig.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/ldap_config', null, body?.toJson());
  }

  /// ### Test the connection settings for an LDAP configuration.
  ///
  /// This tests that the connection is possible given a connection_host and connection_port.
  ///
  /// **connection_host** and **connection_port** are required. **connection_tls** is optional.
  ///
  /// Example:
  /// ```json
  /// {
  ///   "connection_host": "ldap.example.com",
  ///   "connection_port": "636",
  ///   "connection_tls": true
  /// }
  /// ```
  ///
  /// No authentication to the LDAP server is attempted.
  ///
  /// The active LDAP settings are not modified.
  ///
  /// PUT /ldap_config/test_connection -> LDAPConfigTestResult
  Future<SDKResponse<LDAPConfigTestResult>> testLdapConfigConnection(

      /// @param {WriteLDAPConfig} body
      WriteLDAPConfig body) async {
    LDAPConfigTestResult responseHandler(dynamic json, String contentType) {
      return LDAPConfigTestResult.fromResponse(json, contentType);
    }

    return put(
        responseHandler, '/ldap_config/test_connection', null, body?.toJson());
  }

  /// ### Test the connection authentication settings for an LDAP configuration.
  ///
  /// This tests that the connection is possible and that a 'server' account to be used by Looker can       authenticate to the LDAP server given connection and authentication information.
  ///
  /// **connection_host**, **connection_port**, and **auth_username**, are required.       **connection_tls** and **auth_password** are optional.
  ///
  /// Example:
  /// ```json
  /// {
  ///   "connection_host": "ldap.example.com",
  ///   "connection_port": "636",
  ///   "connection_tls": true,
  ///   "auth_username": "cn=looker,dc=example,dc=com",
  ///   "auth_password": "secret"
  /// }
  /// ```
  ///
  /// Looker will never return an **auth_password**. If this request omits the **auth_password** field, then       the **auth_password** value from the active config (if present) will be used for the test.
  ///
  /// The active LDAP settings are not modified.
  ///
  /// PUT /ldap_config/test_auth -> LDAPConfigTestResult
  Future<SDKResponse<LDAPConfigTestResult>> testLdapConfigAuth(

      /// @param {WriteLDAPConfig} body
      WriteLDAPConfig body) async {
    LDAPConfigTestResult responseHandler(dynamic json, String contentType) {
      return LDAPConfigTestResult.fromResponse(json, contentType);
    }

    return put(responseHandler, '/ldap_config/test_auth', null, body?.toJson());
  }

  /// ### Test the user authentication settings for an LDAP configuration without authenticating the user.
  ///
  /// This test will let you easily test the mapping for user properties and roles for any user without      needing to authenticate as that user.
  ///
  /// This test accepts a full LDAP configuration along with a username and attempts to find the full info      for the user from the LDAP server without actually authenticating the user. So, user password is not      required.The configuration is validated before attempting to contact the server.
  ///
  /// **test_ldap_user** is required.
  ///
  /// The active LDAP settings are not modified.
  ///
  /// PUT /ldap_config/test_user_info -> LDAPConfigTestResult
  Future<SDKResponse<LDAPConfigTestResult>> testLdapConfigUserInfo(

      /// @param {WriteLDAPConfig} body
      WriteLDAPConfig body) async {
    LDAPConfigTestResult responseHandler(dynamic json, String contentType) {
      return LDAPConfigTestResult.fromResponse(json, contentType);
    }

    return put(
        responseHandler, '/ldap_config/test_user_info', null, body?.toJson());
  }

  /// ### Test the user authentication settings for an LDAP configuration.
  ///
  /// This test accepts a full LDAP configuration along with a username/password pair and attempts to       authenticate the user with the LDAP server. The configuration is validated before attempting the       authentication.
  ///
  /// Looker will never return an **auth_password**. If this request omits the **auth_password** field, then       the **auth_password** value from the active config (if present) will be used for the test.
  ///
  /// **test_ldap_user** and **test_ldap_password** are required.
  ///
  /// The active LDAP settings are not modified.
  ///
  /// PUT /ldap_config/test_user_auth -> LDAPConfigTestResult
  Future<SDKResponse<LDAPConfigTestResult>> testLdapConfigUserAuth(

      /// @param {WriteLDAPConfig} body
      WriteLDAPConfig body) async {
    LDAPConfigTestResult responseHandler(dynamic json, String contentType) {
      return LDAPConfigTestResult.fromResponse(json, contentType);
    }

    return put(
        responseHandler, '/ldap_config/test_user_auth', null, body?.toJson());
  }

  /// ### List All OAuth Client Apps
  ///
  /// Lists all applications registered to use OAuth2 login with this Looker instance, including
  /// enabled and disabled apps.
  ///
  /// Results are filtered to include only the apps that the caller (current user)
  /// has permission to see.
  ///
  /// GET /oauth_client_apps -> List<OauthClientApp>
  Future<SDKResponse<List<OauthClientApp>>> allOauthClientApps(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<OauthClientApp> responseHandler(dynamic json, String contentType) {
      return json
          .map<OauthClientApp>(
              (i) => OauthClientApp.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/oauth_client_apps', {'fields': fields});
  }

  /// ### Get Oauth Client App
  ///
  /// Returns the registered app client with matching client_guid.
  ///
  /// GET /oauth_client_apps/{client_guid} -> OauthClientApp
  Future<SDKResponse<OauthClientApp>> oauthClientApp(

      /// @param {String} client_guid The unique id of this application
      String clientGuid,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathClientGuid = encodeParam(clientGuid);

    OauthClientApp responseHandler(dynamic json, String contentType) {
      return OauthClientApp.fromResponse(json, contentType);
    }

    return get(responseHandler, '/oauth_client_apps/$pathClientGuid',
        {'fields': fields});
  }

  /// ### Register an OAuth2 Client App
  ///
  /// Registers details identifying an external web app or native app as an OAuth2 login client of the Looker instance.
  /// The app registration must provide a unique client_guid and redirect_uri that the app will present
  /// in OAuth login requests. If the client_guid and redirect_uri parameters in the login request do not match
  /// the app details registered with the Looker instance, the request is assumed to be a forgery and is rejected.
  ///
  /// POST /oauth_client_apps/{client_guid} -> OauthClientApp
  Future<SDKResponse<OauthClientApp>> registerOauthClientApp(

      /// @param {String} client_guid The unique id of this application
      String clientGuid,

      /// @param {WriteOauthClientApp} body
      WriteOauthClientApp body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathClientGuid = encodeParam(clientGuid);

    OauthClientApp responseHandler(dynamic json, String contentType) {
      return OauthClientApp.fromResponse(json, contentType);
    }

    return post(responseHandler, '/oauth_client_apps/$pathClientGuid',
        {'fields': fields}, body?.toJson());
  }

  /// ### Update OAuth2 Client App Details
  ///
  /// Modifies the details a previously registered OAuth2 login client app.
  ///
  /// PATCH /oauth_client_apps/{client_guid} -> OauthClientApp
  Future<SDKResponse<OauthClientApp>> updateOauthClientApp(

      /// @param {String} client_guid The unique id of this application
      String clientGuid,

      /// @param {WriteOauthClientApp} body
      WriteOauthClientApp body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathClientGuid = encodeParam(clientGuid);

    OauthClientApp responseHandler(dynamic json, String contentType) {
      return OauthClientApp.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/oauth_client_apps/$pathClientGuid',
        {'fields': fields}, body?.toJson());
  }

  /// ### Delete OAuth Client App
  ///
  /// Deletes the registration info of the app with the matching client_guid.
  /// All active sessions and tokens issued for this app will immediately become invalid.
  ///
  /// ### Note: this deletion cannot be undone.
  ///
  /// DELETE /oauth_client_apps/{client_guid} -> String
  Future<SDKResponse<String>> deleteOauthClientApp(

      /// @param {String} client_guid The unique id of this application
      String clientGuid) async {
    var pathClientGuid = encodeParam(clientGuid);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/oauth_client_apps/$pathClientGuid');
  }

  /// ### Invalidate All Issued Tokens
  ///
  /// Immediately invalidates all auth codes, sessions, access tokens and refresh tokens issued for
  /// this app for ALL USERS of this app.
  ///
  /// DELETE /oauth_client_apps/{client_guid}/tokens -> String
  Future<SDKResponse<String>> invalidateTokens(

      /// @param {String} client_guid The unique id of the application
      String clientGuid) async {
    var pathClientGuid = encodeParam(clientGuid);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/oauth_client_apps/$pathClientGuid/tokens');
  }

  /// ### Activate an app for a user
  ///
  /// Activates a user for a given oauth client app. This indicates the user has been informed that
  /// the app will have access to the user's looker data, and that the user has accepted and allowed
  /// the app to use their Looker account.
  ///
  /// Activating a user for an app that the user is already activated with returns a success response.
  ///
  /// POST /oauth_client_apps/{client_guid}/users/{user_id} -> String
  Future<SDKResponse<dynamic>> activateAppUser(

      /// @param {String} client_guid The unique id of this application
      String clientGuid,

      /// @param {int} user_id The id of the user to enable use of this app
      int userId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathClientGuid = encodeParam(clientGuid);
    var pathUserId = encodeParam(userId);

    dynamic responseHandler(dynamic json, String contentType) {
      return json;
    }

    return post(
        responseHandler,
        '/oauth_client_apps/$pathClientGuid/users/$pathUserId',
        {'fields': fields});
  }

  /// ### Deactivate an app for a user
  ///
  /// Deactivate a user for a given oauth client app. All tokens issued to the app for
  /// this user will be invalid immediately. Before the user can use the app with their
  /// Looker account, the user will have to read and accept an account use disclosure statement for the app.
  ///
  /// Admin users can deactivate other users, but non-admin users can only deactivate themselves.
  ///
  /// As with most REST DELETE operations, this endpoint does not return an error if the indicated
  /// resource (app or user) does not exist or has already been deactivated.
  ///
  /// DELETE /oauth_client_apps/{client_guid}/users/{user_id} -> String
  Future<SDKResponse<String>> deactivateAppUser(

      /// @param {String} client_guid The unique id of this application
      String clientGuid,

      /// @param {int} user_id The id of the user to enable use of this app
      int userId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathClientGuid = encodeParam(clientGuid);
    var pathUserId = encodeParam(userId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(
        responseHandler,
        '/oauth_client_apps/$pathClientGuid/users/$pathUserId',
        {'fields': fields});
  }

  /// ### Get the OIDC configuration.
  ///
  /// Looker can be optionally configured to authenticate users against an OpenID Connect (OIDC)
  /// authentication server. OIDC setup requires coordination with an administrator of that server.
  ///
  /// Only Looker administrators can read and update the OIDC configuration.
  ///
  /// Configuring OIDC impacts authentication for all users. This configuration should be done carefully.
  ///
  /// Looker maintains a single OIDC configuation. It can be read and updated.       Updates only succeed if the new state will be valid (in the sense that all required fields are populated);       it is up to you to ensure that the configuration is appropriate and correct).
  ///
  /// OIDC is enabled or disabled for Looker using the **enabled** field.
  ///
  /// GET /oidc_config -> OIDCConfig
  Future<SDKResponse<OIDCConfig>> oidcConfig() async {
    OIDCConfig responseHandler(dynamic json, String contentType) {
      return OIDCConfig.fromResponse(json, contentType);
    }

    return get(responseHandler, '/oidc_config');
  }

  /// ### Update the OIDC configuration.
  ///
  /// Configuring OIDC impacts authentication for all users. This configuration should be done carefully.
  ///
  /// Only Looker administrators can read and update the OIDC configuration.
  ///
  /// OIDC is enabled or disabled for Looker using the **enabled** field.
  ///
  /// It is **highly** recommended that any OIDC setting changes be tested using the APIs below before being set globally.
  ///
  /// PATCH /oidc_config -> OIDCConfig
  Future<SDKResponse<OIDCConfig>> updateOidcConfig(

      /// @param {WriteOIDCConfig} body
      WriteOIDCConfig body) async {
    OIDCConfig responseHandler(dynamic json, String contentType) {
      return OIDCConfig.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/oidc_config', null, body?.toJson());
  }

  /// ### Get a OIDC test configuration by test_slug.
  ///
  /// GET /oidc_test_configs/{test_slug} -> OIDCConfig
  Future<SDKResponse<OIDCConfig>> oidcTestConfig(

      /// @param {String} test_slug Slug of test config
      String testSlug) async {
    var pathTestSlug = encodeParam(testSlug);

    OIDCConfig responseHandler(dynamic json, String contentType) {
      return OIDCConfig.fromResponse(json, contentType);
    }

    return get(responseHandler, '/oidc_test_configs/$pathTestSlug');
  }

  /// ### Delete a OIDC test configuration.
  ///
  /// DELETE /oidc_test_configs/{test_slug} -> String
  Future<SDKResponse<String>> deleteOidcTestConfig(

      /// @param {String} test_slug Slug of test config
      String testSlug) async {
    var pathTestSlug = encodeParam(testSlug);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/oidc_test_configs/$pathTestSlug');
  }

  /// ### Create a OIDC test configuration.
  ///
  /// POST /oidc_test_configs -> OIDCConfig
  Future<SDKResponse<OIDCConfig>> createOidcTestConfig(

      /// @param {WriteOIDCConfig} body
      WriteOIDCConfig body) async {
    OIDCConfig responseHandler(dynamic json, String contentType) {
      return OIDCConfig.fromResponse(json, contentType);
    }

    return post(responseHandler, '/oidc_test_configs', null, body?.toJson());
  }

  /// ### Get password config.
  ///
  /// GET /password_config -> PasswordConfig
  Future<SDKResponse<PasswordConfig>> passwordConfig() async {
    PasswordConfig responseHandler(dynamic json, String contentType) {
      return PasswordConfig.fromResponse(json, contentType);
    }

    return get(responseHandler, '/password_config');
  }

  /// ### Update password config.
  ///
  /// PATCH /password_config -> PasswordConfig
  Future<SDKResponse<PasswordConfig>> updatePasswordConfig(

      /// @param {WritePasswordConfig} body
      WritePasswordConfig body) async {
    PasswordConfig responseHandler(dynamic json, String contentType) {
      return PasswordConfig.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/password_config', null, body?.toJson());
  }

  /// ### Force all credentials_email users to reset their login passwords upon their next login.
  ///
  /// PUT /password_config/force_password_reset_at_next_login_for_all_users -> String
  Future<SDKResponse<String>> forcePasswordResetAtNextLoginForAllUsers() async {
    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return put(responseHandler,
        '/password_config/force_password_reset_at_next_login_for_all_users');
  }

  /// ### Get the SAML configuration.
  ///
  /// Looker can be optionally configured to authenticate users against a SAML authentication server.
  /// SAML setup requires coordination with an administrator of that server.
  ///
  /// Only Looker administrators can read and update the SAML configuration.
  ///
  /// Configuring SAML impacts authentication for all users. This configuration should be done carefully.
  ///
  /// Looker maintains a single SAML configuation. It can be read and updated.       Updates only succeed if the new state will be valid (in the sense that all required fields are populated);       it is up to you to ensure that the configuration is appropriate and correct).
  ///
  /// SAML is enabled or disabled for Looker using the **enabled** field.
  ///
  /// GET /saml_config -> SamlConfig
  Future<SDKResponse<SamlConfig>> samlConfig() async {
    SamlConfig responseHandler(dynamic json, String contentType) {
      return SamlConfig.fromResponse(json, contentType);
    }

    return get(responseHandler, '/saml_config');
  }

  /// ### Update the SAML configuration.
  ///
  /// Configuring SAML impacts authentication for all users. This configuration should be done carefully.
  ///
  /// Only Looker administrators can read and update the SAML configuration.
  ///
  /// SAML is enabled or disabled for Looker using the **enabled** field.
  ///
  /// It is **highly** recommended that any SAML setting changes be tested using the APIs below before being set globally.
  ///
  /// PATCH /saml_config -> SamlConfig
  Future<SDKResponse<SamlConfig>> updateSamlConfig(

      /// @param {WriteSamlConfig} body
      WriteSamlConfig body) async {
    SamlConfig responseHandler(dynamic json, String contentType) {
      return SamlConfig.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/saml_config', null, body?.toJson());
  }

  /// ### Get a SAML test configuration by test_slug.
  ///
  /// GET /saml_test_configs/{test_slug} -> SamlConfig
  Future<SDKResponse<SamlConfig>> samlTestConfig(

      /// @param {String} test_slug Slug of test config
      String testSlug) async {
    var pathTestSlug = encodeParam(testSlug);

    SamlConfig responseHandler(dynamic json, String contentType) {
      return SamlConfig.fromResponse(json, contentType);
    }

    return get(responseHandler, '/saml_test_configs/$pathTestSlug');
  }

  /// ### Delete a SAML test configuration.
  ///
  /// DELETE /saml_test_configs/{test_slug} -> String
  Future<SDKResponse<String>> deleteSamlTestConfig(

      /// @param {String} test_slug Slug of test config
      String testSlug) async {
    var pathTestSlug = encodeParam(testSlug);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/saml_test_configs/$pathTestSlug');
  }

  /// ### Create a SAML test configuration.
  ///
  /// POST /saml_test_configs -> SamlConfig
  Future<SDKResponse<SamlConfig>> createSamlTestConfig(

      /// @param {WriteSamlConfig} body
      WriteSamlConfig body) async {
    SamlConfig responseHandler(dynamic json, String contentType) {
      return SamlConfig.fromResponse(json, contentType);
    }

    return post(responseHandler, '/saml_test_configs', null, body?.toJson());
  }

  /// ### Parse the given xml as a SAML IdP metadata document and return the result.
  ///
  /// POST /parse_saml_idp_metadata -> SamlMetadataParseResult
  Future<SDKResponse<SamlMetadataParseResult>> parseSamlIdpMetadata(

      /// @param {String} body
      String body) async {
    SamlMetadataParseResult responseHandler(dynamic json, String contentType) {
      return SamlMetadataParseResult.fromResponse(json, contentType);
    }

    return post(responseHandler, '/parse_saml_idp_metadata', null, body);
  }

  /// ### Fetch the given url and parse it as a SAML IdP metadata document and return the result.
  /// Note that this requires that the url be public or at least at a location where the Looker instance
  /// can fetch it without requiring any special authentication.
  ///
  /// POST /fetch_and_parse_saml_idp_metadata -> SamlMetadataParseResult
  Future<SDKResponse<SamlMetadataParseResult>> fetchAndParseSamlIdpMetadata(

      /// @param {String} body
      String body) async {
    SamlMetadataParseResult responseHandler(dynamic json, String contentType) {
      return SamlMetadataParseResult.fromResponse(json, contentType);
    }

    return post(
        responseHandler, '/fetch_and_parse_saml_idp_metadata', null, body);
  }

  /// ### Get session config.
  ///
  /// GET /session_config -> SessionConfig
  Future<SDKResponse<SessionConfig>> sessionConfig() async {
    SessionConfig responseHandler(dynamic json, String contentType) {
      return SessionConfig.fromResponse(json, contentType);
    }

    return get(responseHandler, '/session_config');
  }

  /// ### Update session config.
  ///
  /// PATCH /session_config -> SessionConfig
  Future<SDKResponse<SessionConfig>> updateSessionConfig(

      /// @param {WriteSessionConfig} body
      WriteSessionConfig body) async {
    SessionConfig responseHandler(dynamic json, String contentType) {
      return SessionConfig.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/session_config', null, body?.toJson());
  }

  /// ### Get Support Access Allowlist Users
  ///
  /// Returns the users that have been added to the Support Access Allowlist
  ///
  /// GET /support_access/allowlist -> List<SupportAccessAllowlistEntry>
  Future<SDKResponse<List<SupportAccessAllowlistEntry>>>
      getSupportAccessAllowlistEntries(
          {

          /// @param {String} fields Requested fields.
          String fields}) async {
    List<SupportAccessAllowlistEntry> responseHandler(
        dynamic json, String contentType) {
      return json
          .map<SupportAccessAllowlistEntry>(
              (i) => SupportAccessAllowlistEntry.fromResponse(i, contentType))
          .toList();
    }

    return get(
        responseHandler, '/support_access/allowlist', {'fields': fields});
  }

  /// ### Add Support Access Allowlist Users
  ///
  /// Adds a list of emails to the Allowlist, using the provided reason
  ///
  /// POST /support_access/allowlist -> List<SupportAccessAllowlistEntry>
  Future<SDKResponse<List<SupportAccessAllowlistEntry>>>
      addSupportAccessAllowlistEntries(

          /// @param {SupportAccessAddEntries} body
          SupportAccessAddEntries body) async {
    List<SupportAccessAllowlistEntry> responseHandler(
        dynamic json, String contentType) {
      return json
          .map<SupportAccessAllowlistEntry>(
              (i) => SupportAccessAllowlistEntry.fromResponse(i, contentType))
          .toList();
    }

    return post(
        responseHandler, '/support_access/allowlist', null, body?.toJson());
  }

  /// ### Delete Support Access Allowlist User
  ///
  /// Deletes the specified Allowlist Entry Id
  ///
  /// DELETE /support_access/allowlist/{entry_id} -> String
  Future<SDKResponse<String>> deleteSupportAccessAllowlistEntry(

      /// @param {String} entry_id Id of Allowlist Entry
      String entryId) async {
    var pathEntryId = encodeParam(entryId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/support_access/allowlist/$pathEntryId');
  }

  /// ### Enable Support Access
  ///
  /// Enables Support Access for the provided duration
  ///
  /// PUT /support_access/enable -> SupportAccessStatus
  Future<SDKResponse<SupportAccessStatus>> enableSupportAccess(

      /// @param {SupportAccessEnable} body
      SupportAccessEnable body) async {
    SupportAccessStatus responseHandler(dynamic json, String contentType) {
      return SupportAccessStatus.fromResponse(json, contentType);
    }

    return put(responseHandler, '/support_access/enable', null, body?.toJson());
  }

  /// ### Disable Support Access
  ///
  /// Disables Support Access immediately
  ///
  /// PUT /support_access/disable -> SupportAccessStatus
  Future<SDKResponse<SupportAccessStatus>> disableSupportAccess() async {
    SupportAccessStatus responseHandler(dynamic json, String contentType) {
      return SupportAccessStatus.fromResponse(json, contentType);
    }

    return put(responseHandler, '/support_access/disable');
  }

  /// ### Support Access Status
  ///
  /// Returns the current Support Access Status
  ///
  /// GET /support_access/status -> SupportAccessStatus
  Future<SDKResponse<SupportAccessStatus>> supportAccessStatus() async {
    SupportAccessStatus responseHandler(dynamic json, String contentType) {
      return SupportAccessStatus.fromResponse(json, contentType);
    }

    return get(responseHandler, '/support_access/status');
  }

  /// ### Get currently locked-out users.
  ///
  /// GET /user_login_lockouts -> List<UserLoginLockout>
  Future<SDKResponse<List<UserLoginLockout>>> allUserLoginLockouts(
      {

      /// @param {String} fields Include only these fields in the response
      String fields}) async {
    List<UserLoginLockout> responseHandler(dynamic json, String contentType) {
      return json
          .map<UserLoginLockout>(
              (i) => UserLoginLockout.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/user_login_lockouts', {'fields': fields});
  }

  /// ### Search currently locked-out users.
  ///
  /// GET /user_login_lockouts/search -> List<UserLoginLockout>
  Future<SDKResponse<List<UserLoginLockout>>> searchUserLoginLockouts(
      {

      /// @param {String} fields Include only these fields in the response
      String fields,

      /// @param {int} page Return only page N of paginated results
      int page,

      /// @param {int} per_page Return N rows of data per page
      int perPage,

      /// @param {String} sorts Fields to sort by.
      String sorts,

      /// @param {String} auth_type Auth type user is locked out for (email, ldap, totp, api)
      String authType,

      /// @param {String} full_name Match name
      String fullName,

      /// @param {String} email Match email
      String email,

      /// @param {String} remote_id Match remote LDAP ID
      String remoteId,

      /// @param {bool} filter_or Combine given search criteria in a boolean OR expression
      bool filterOr}) async {
    List<UserLoginLockout> responseHandler(dynamic json, String contentType) {
      return json
          .map<UserLoginLockout>(
              (i) => UserLoginLockout.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/user_login_lockouts/search', {
      'fields': fields,
      'page': page,
      'per_page': perPage,
      'sorts': sorts,
      'auth_type': authType,
      'full_name': fullName,
      'email': email,
      'remote_id': remoteId,
      'filter_or': filterOr
    });
  }

  /// ### Removes login lockout for the associated user.
  ///
  /// DELETE /user_login_lockout/{key} -> String
  Future<SDKResponse<String>> deleteUserLoginLockout(

      /// @param {String} key The key associated with the locked user
      String key) async {
    var pathKey = encodeParam(key);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/user_login_lockout/$pathKey');
  }

  // #endregion Auth: Manage User Authentication Configuration

  // #region Board: Manage Boards

  /// ### Get information about all boards.
  ///
  /// GET /boards -> List<Board>
  Future<SDKResponse<List<Board>>> allBoards(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<Board> responseHandler(dynamic json, String contentType) {
      return json
          .map<Board>((i) => Board.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/boards', {'fields': fields});
  }

  /// ### Create a new board.
  ///
  /// POST /boards -> Board
  Future<SDKResponse<Board>> createBoard(

      /// @param {WriteBoard} body
      WriteBoard body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    Board responseHandler(dynamic json, String contentType) {
      return Board.fromResponse(json, contentType);
    }

    return post(responseHandler, '/boards', {'fields': fields}, body?.toJson());
  }

  /// ### Search Boards
  ///
  /// If multiple search params are given and `filter_or` is FALSE or not specified,
  /// search params are combined in a logical AND operation.
  /// Only rows that match *all* search param criteria will be returned.
  ///
  /// If `filter_or` is TRUE, multiple search params are combined in a logical OR operation.
  /// Results will include rows that match **any** of the search criteria.
  ///
  /// String search params use case-insensitive matching.
  /// String search params can contain `%` and '_' as SQL LIKE pattern match wildcard expressions.
  /// example="dan%" will match "danger" and "Danzig" but not "David"
  /// example="D_m%" will match "Damage" and "dump"
  ///
  /// Integer search params can accept a single value or a comma separated list of values. The multiple
  /// values will be combined under a logical OR operation - results will match at least one of
  /// the given values.
  ///
  /// Most search params can accept "IS NULL" and "NOT NULL" as special expressions to match
  /// or exclude (respectively) rows where the column is null.
  ///
  /// Boolean search params accept only "true" and "false" as values.
  ///
  /// GET /boards/search -> List<Board>
  Future<SDKResponse<List<Board>>> searchBoards(
      {

      /// @param {String} title Matches board title.
      String title,

      /// @param {String} created_at Matches the timestamp for when the board was created.
      String createdAt,

      /// @param {String} first_name The first name of the user who created this board.
      String firstName,

      /// @param {String} last_name The last name of the user who created this board.
      String lastName,

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {bool} favorited Return favorited boards when true.
      bool favorited,

      /// @param {String} creator_id Filter on boards created by a particular user.
      String creatorId,

      /// @param {String} sorts The fields to sort the results by
      String sorts,

      /// @param {int} page The page to return.
      int page,

      /// @param {int} per_page The number of items in the returned page.
      int perPage,

      /// @param {int} offset The number of items to skip before returning any. (used with limit and takes priority over page and per_page)
      int offset,

      /// @param {int} limit The maximum number of items to return. (used with offset and takes priority over page and per_page)
      int limit,

      /// @param {bool} filter_or Combine given search criteria in a boolean OR expression
      bool filterOr}) async {
    List<Board> responseHandler(dynamic json, String contentType) {
      return json
          .map<Board>((i) => Board.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/boards/search', {
      'title': title,
      'created_at': createdAt,
      'first_name': firstName,
      'last_name': lastName,
      'fields': fields,
      'favorited': favorited,
      'creator_id': creatorId,
      'sorts': sorts,
      'page': page,
      'per_page': perPage,
      'offset': offset,
      'limit': limit,
      'filter_or': filterOr
    });
  }

  /// ### Get information about a board.
  ///
  /// GET /boards/{board_id} -> Board
  Future<SDKResponse<Board>> board(

      /// @param {int} board_id Id of board
      int boardId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathBoardId = encodeParam(boardId);

    Board responseHandler(dynamic json, String contentType) {
      return Board.fromResponse(json, contentType);
    }

    return get(responseHandler, '/boards/$pathBoardId', {'fields': fields});
  }

  /// ### Update a board definition.
  ///
  /// PATCH /boards/{board_id} -> Board
  Future<SDKResponse<Board>> updateBoard(

      /// @param {int} board_id Id of board
      int boardId,

      /// @param {WriteBoard} body
      WriteBoard body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathBoardId = encodeParam(boardId);

    Board responseHandler(dynamic json, String contentType) {
      return Board.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/boards/$pathBoardId', {'fields': fields},
        body?.toJson());
  }

  /// ### Delete a board.
  ///
  /// DELETE /boards/{board_id} -> String
  Future<SDKResponse<String>> deleteBoard(

      /// @param {int} board_id Id of board
      int boardId) async {
    var pathBoardId = encodeParam(boardId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/boards/$pathBoardId');
  }

  /// ### Get information about all board items.
  ///
  /// GET /board_items -> List<BoardItem>
  Future<SDKResponse<List<BoardItem>>> allBoardItems(
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {String} sorts Fields to sort by.
      String sorts,

      /// @param {String} board_section_id Filter to a specific board section
      String boardSectionId}) async {
    List<BoardItem> responseHandler(dynamic json, String contentType) {
      return json
          .map<BoardItem>((i) => BoardItem.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/board_items',
        {'fields': fields, 'sorts': sorts, 'board_section_id': boardSectionId});
  }

  /// ### Create a new board item.
  ///
  /// POST /board_items -> BoardItem
  Future<SDKResponse<BoardItem>> createBoardItem(

      /// @param {WriteBoardItem} body
      WriteBoardItem body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    BoardItem responseHandler(dynamic json, String contentType) {
      return BoardItem.fromResponse(json, contentType);
    }

    return post(
        responseHandler, '/board_items', {'fields': fields}, body?.toJson());
  }

  /// ### Get information about a board item.
  ///
  /// GET /board_items/{board_item_id} -> BoardItem
  Future<SDKResponse<BoardItem>> boardItem(

      /// @param {int} board_item_id Id of board item
      int boardItemId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathBoardItemId = encodeParam(boardItemId);

    BoardItem responseHandler(dynamic json, String contentType) {
      return BoardItem.fromResponse(json, contentType);
    }

    return get(
        responseHandler, '/board_items/$pathBoardItemId', {'fields': fields});
  }

  /// ### Update a board item definition.
  ///
  /// PATCH /board_items/{board_item_id} -> BoardItem
  Future<SDKResponse<BoardItem>> updateBoardItem(

      /// @param {int} board_item_id Id of board item
      int boardItemId,

      /// @param {WriteBoardItem} body
      WriteBoardItem body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathBoardItemId = encodeParam(boardItemId);

    BoardItem responseHandler(dynamic json, String contentType) {
      return BoardItem.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/board_items/$pathBoardItemId',
        {'fields': fields}, body?.toJson());
  }

  /// ### Delete a board item.
  ///
  /// DELETE /board_items/{board_item_id} -> String
  Future<SDKResponse<String>> deleteBoardItem(

      /// @param {int} board_item_id Id of board_item
      int boardItemId) async {
    var pathBoardItemId = encodeParam(boardItemId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/board_items/$pathBoardItemId');
  }

  /// ### Get information about all board sections.
  ///
  /// GET /board_sections -> List<BoardSection>
  Future<SDKResponse<List<BoardSection>>> allBoardSections(
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {String} sorts Fields to sort by.
      String sorts}) async {
    List<BoardSection> responseHandler(dynamic json, String contentType) {
      return json
          .map<BoardSection>((i) => BoardSection.fromResponse(i, contentType))
          .toList();
    }

    return get(
        responseHandler, '/board_sections', {'fields': fields, 'sorts': sorts});
  }

  /// ### Create a new board section.
  ///
  /// POST /board_sections -> BoardSection
  Future<SDKResponse<BoardSection>> createBoardSection(

      /// @param {WriteBoardSection} body
      WriteBoardSection body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    BoardSection responseHandler(dynamic json, String contentType) {
      return BoardSection.fromResponse(json, contentType);
    }

    return post(
        responseHandler, '/board_sections', {'fields': fields}, body?.toJson());
  }

  /// ### Get information about a board section.
  ///
  /// GET /board_sections/{board_section_id} -> BoardSection
  Future<SDKResponse<BoardSection>> boardSection(

      /// @param {int} board_section_id Id of board section
      int boardSectionId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathBoardSectionId = encodeParam(boardSectionId);

    BoardSection responseHandler(dynamic json, String contentType) {
      return BoardSection.fromResponse(json, contentType);
    }

    return get(responseHandler, '/board_sections/$pathBoardSectionId',
        {'fields': fields});
  }

  /// ### Update a board section definition.
  ///
  /// PATCH /board_sections/{board_section_id} -> BoardSection
  Future<SDKResponse<BoardSection>> updateBoardSection(

      /// @param {int} board_section_id Id of board section
      int boardSectionId,

      /// @param {WriteBoardSection} body
      WriteBoardSection body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathBoardSectionId = encodeParam(boardSectionId);

    BoardSection responseHandler(dynamic json, String contentType) {
      return BoardSection.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/board_sections/$pathBoardSectionId',
        {'fields': fields}, body?.toJson());
  }

  /// ### Delete a board section.
  ///
  /// DELETE /board_sections/{board_section_id} -> String
  Future<SDKResponse<String>> deleteBoardSection(

      /// @param {int} board_section_id Id of board section
      int boardSectionId) async {
    var pathBoardSectionId = encodeParam(boardSectionId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/board_sections/$pathBoardSectionId');
  }

  // #endregion Board: Manage Boards

  // #region ColorCollection: Manage Color Collections

  /// ### Get an array of all existing Color Collections
  /// Get a **single** color collection by id with [ColorCollection](#!/ColorCollection/color_collection)
  ///
  /// Get all **standard** color collections with [ColorCollection](#!/ColorCollection/color_collections_standard)
  ///
  /// Get all **custom** color collections with [ColorCollection](#!/ColorCollection/color_collections_custom)
  ///
  /// **Note**: Only an API user with the Admin role can call this endpoint. Unauthorized requests will return `Not Found` (404) errors.
  ///
  /// GET /color_collections -> List<ColorCollection>
  Future<SDKResponse<List<ColorCollection>>> allColorCollections(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<ColorCollection> responseHandler(dynamic json, String contentType) {
      return json
          .map<ColorCollection>(
              (i) => ColorCollection.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/color_collections', {'fields': fields});
  }

  /// ### Create a custom color collection with the specified information
  ///
  /// Creates a new custom color collection object, returning the details, including the created id.
  ///
  /// **Update** an existing color collection with [Update Color Collection](#!/ColorCollection/update_color_collection)
  ///
  /// **Permanently delete** an existing custom color collection with [Delete Color Collection](#!/ColorCollection/delete_color_collection)
  ///
  /// **Note**: Only an API user with the Admin role can call this endpoint. Unauthorized requests will return `Not Found` (404) errors.
  ///
  /// POST /color_collections -> ColorCollection
  Future<SDKResponse<ColorCollection>> createColorCollection(

      /// @param {WriteColorCollection} body
      WriteColorCollection body) async {
    ColorCollection responseHandler(dynamic json, String contentType) {
      return ColorCollection.fromResponse(json, contentType);
    }

    return post(responseHandler, '/color_collections', null, body?.toJson());
  }

  /// ### Get an array of all existing **Custom** Color Collections
  /// Get a **single** color collection by id with [ColorCollection](#!/ColorCollection/color_collection)
  ///
  /// Get all **standard** color collections with [ColorCollection](#!/ColorCollection/color_collections_standard)
  ///
  /// **Note**: Only an API user with the Admin role can call this endpoint. Unauthorized requests will return `Not Found` (404) errors.
  ///
  /// GET /color_collections/custom -> List<ColorCollection>
  Future<SDKResponse<List<ColorCollection>>> colorCollectionsCustom(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<ColorCollection> responseHandler(dynamic json, String contentType) {
      return json
          .map<ColorCollection>(
              (i) => ColorCollection.fromResponse(i, contentType))
          .toList();
    }

    return get(
        responseHandler, '/color_collections/custom', {'fields': fields});
  }

  /// ### Get an array of all existing **Standard** Color Collections
  /// Get a **single** color collection by id with [ColorCollection](#!/ColorCollection/color_collection)
  ///
  /// Get all **custom** color collections with [ColorCollection](#!/ColorCollection/color_collections_custom)
  ///
  /// **Note**: Only an API user with the Admin role can call this endpoint. Unauthorized requests will return `Not Found` (404) errors.
  ///
  /// GET /color_collections/standard -> List<ColorCollection>
  Future<SDKResponse<List<ColorCollection>>> colorCollectionsStandard(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<ColorCollection> responseHandler(dynamic json, String contentType) {
      return json
          .map<ColorCollection>(
              (i) => ColorCollection.fromResponse(i, contentType))
          .toList();
    }

    return get(
        responseHandler, '/color_collections/standard', {'fields': fields});
  }

  /// ### Get the default color collection
  ///
  /// Use this to retrieve the default Color Collection.
  ///
  /// Set the default color collection with [ColorCollection](#!/ColorCollection/set_default_color_collection)
  ///
  /// GET /color_collections/default -> ColorCollection
  Future<SDKResponse<ColorCollection>> defaultColorCollection() async {
    ColorCollection responseHandler(dynamic json, String contentType) {
      return ColorCollection.fromResponse(json, contentType);
    }

    return get(responseHandler, '/color_collections/default');
  }

  /// ### Set the global default Color Collection by ID
  ///
  /// Returns the new specified default Color Collection object.
  /// **Note**: Only an API user with the Admin role can call this endpoint. Unauthorized requests will return `Not Found` (404) errors.
  ///
  /// PUT /color_collections/default -> ColorCollection
  Future<SDKResponse<ColorCollection>> setDefaultColorCollection(

      /// @param {String} collection_id ID of color collection to set as default
      String collectionId) async {
    ColorCollection responseHandler(dynamic json, String contentType) {
      return ColorCollection.fromResponse(json, contentType);
    }

    return put(responseHandler, '/color_collections/default',
        {'collection_id': collectionId});
  }

  /// ### Get a Color Collection by ID
  ///
  /// Use this to retrieve a specific Color Collection.
  /// Get a **single** color collection by id with [ColorCollection](#!/ColorCollection/color_collection)
  ///
  /// Get all **standard** color collections with [ColorCollection](#!/ColorCollection/color_collections_standard)
  ///
  /// Get all **custom** color collections with [ColorCollection](#!/ColorCollection/color_collections_custom)
  ///
  /// **Note**: Only an API user with the Admin role can call this endpoint. Unauthorized requests will return `Not Found` (404) errors.
  ///
  /// GET /color_collections/{collection_id} -> ColorCollection
  Future<SDKResponse<ColorCollection>> colorCollection(

      /// @param {String} collection_id Id of Color Collection
      String collectionId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathCollectionId = encodeParam(collectionId);

    ColorCollection responseHandler(dynamic json, String contentType) {
      return ColorCollection.fromResponse(json, contentType);
    }

    return get(responseHandler, '/color_collections/$pathCollectionId',
        {'fields': fields});
  }

  /// ### Update a custom color collection by id.
  /// **Note**: Only an API user with the Admin role can call this endpoint. Unauthorized requests will return `Not Found` (404) errors.
  ///
  /// PATCH /color_collections/{collection_id} -> ColorCollection
  Future<SDKResponse<ColorCollection>> updateColorCollection(

      /// @param {String} collection_id Id of Custom Color Collection
      String collectionId,

      /// @param {WriteColorCollection} body
      WriteColorCollection body) async {
    var pathCollectionId = encodeParam(collectionId);

    ColorCollection responseHandler(dynamic json, String contentType) {
      return ColorCollection.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/color_collections/$pathCollectionId', null,
        body?.toJson());
  }

  /// ### Delete a custom color collection by id
  ///
  /// This operation permanently deletes the identified **Custom** color collection.
  ///
  /// **Standard** color collections cannot be deleted
  ///
  /// Because multiple color collections can have the same label, they must be deleted by ID, not name.
  /// **Note**: Only an API user with the Admin role can call this endpoint. Unauthorized requests will return `Not Found` (404) errors.
  ///
  /// DELETE /color_collections/{collection_id} -> String
  Future<SDKResponse<String>> deleteColorCollection(

      /// @param {String} collection_id Id of Color Collection
      String collectionId) async {
    var pathCollectionId = encodeParam(collectionId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/color_collections/$pathCollectionId');
  }

  // #endregion ColorCollection: Manage Color Collections

  // #region Command: Manage Commands

  /// ### Get All Commands.
  ///
  /// GET /commands -> List<Command>
  Future<SDKResponse<List<Command>>> getAllCommands(
      {

      /// @param {String} content_id Id of the associated content. This must be accompanied with content_type.
      String contentId,

      /// @param {String} content_type Type of the associated content. This must be accompanied with content_id.
      String contentType,

      /// @param {int} limit Number of results to return.
      int limit}) async {
    List<Command> responseHandler(dynamic json, String contentType) {
      return json
          .map<Command>((i) => Command.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/commands',
        {'content_id': contentId, 'content_type': contentType, 'limit': limit});
  }

  /// ### Create a new command.
  /// # Required fields: [:name, :linked_content_id, :linked_content_type]
  /// # `linked_content_type` must be one of ["dashboard", "lookml_dashboard"]
  /// #
  ///
  /// POST /commands -> Command
  Future<SDKResponse<Command>> createCommand(

      /// @param {WriteCommand} body
      WriteCommand body) async {
    Command responseHandler(dynamic json, String contentType) {
      return Command.fromResponse(json, contentType);
    }

    return post(responseHandler, '/commands', null, body?.toJson());
  }

  /// ### Update an existing custom command.
  /// # Optional fields: ['name', 'description']
  /// #
  ///
  /// PATCH /commands/{command_id} -> Command
  Future<SDKResponse<Command>> updateCommand(

      /// @param {int} command_id ID of a command
      int commandId,

      /// @param {UpdateCommand} body
      UpdateCommand body) async {
    var pathCommandId = encodeParam(commandId);

    Command responseHandler(dynamic json, String contentType) {
      return Command.fromResponse(json, contentType);
    }

    return patch(
        responseHandler, '/commands/$pathCommandId', null, body?.toJson());
  }

  /// ### Delete an existing custom command.
  ///
  /// DELETE /commands/{command_id} -> void
  Future<SDKResponse<void>> deleteCommand(

      /// @param {int} command_id ID of a command
      int commandId) async {
    var pathCommandId = encodeParam(commandId);

    void responseHandler(dynamic json, String contentType) {}
    return delete(responseHandler, '/commands/$pathCommandId');
  }

  // #endregion Command: Manage Commands

  // #region Config: Manage General Configuration

  /// Get the current Cloud Storage Configuration.
  ///
  /// GET /cloud_storage -> BackupConfiguration
  Future<SDKResponse<BackupConfiguration>> cloudStorageConfiguration() async {
    BackupConfiguration responseHandler(dynamic json, String contentType) {
      return BackupConfiguration.fromResponse(json, contentType);
    }

    return get(responseHandler, '/cloud_storage');
  }

  /// Update the current Cloud Storage Configuration.
  ///
  /// PATCH /cloud_storage -> BackupConfiguration
  Future<SDKResponse<BackupConfiguration>> updateCloudStorageConfiguration(

      /// @param {WriteBackupConfiguration} body
      WriteBackupConfiguration body) async {
    BackupConfiguration responseHandler(dynamic json, String contentType) {
      return BackupConfiguration.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/cloud_storage', null, body?.toJson());
  }

  /// ### Get the current status and content of custom welcome emails
  ///
  /// GET /custom_welcome_email -> CustomWelcomeEmail
  Future<SDKResponse<CustomWelcomeEmail>> customWelcomeEmail() async {
    CustomWelcomeEmail responseHandler(dynamic json, String contentType) {
      return CustomWelcomeEmail.fromResponse(json, contentType);
    }

    return get(responseHandler, '/custom_welcome_email');
  }

  /// Update custom welcome email setting and values. Optionally send a test email with the new content to the currently logged in user.
  ///
  /// PATCH /custom_welcome_email -> CustomWelcomeEmail
  Future<SDKResponse<CustomWelcomeEmail>> updateCustomWelcomeEmail(

      /// @param {CustomWelcomeEmail} body
      CustomWelcomeEmail body,
      {

      /// @param {bool} send_test_welcome_email If true a test email with the content from the request will be sent to the current user after saving
      bool sendTestWelcomeEmail}) async {
    CustomWelcomeEmail responseHandler(dynamic json, String contentType) {
      return CustomWelcomeEmail.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/custom_welcome_email',
        {'send_test_welcome_email': sendTestWelcomeEmail}, body?.toJson());
  }

  /// Requests to this endpoint will send a welcome email with the custom content provided in the body to the currently logged in user.
  ///
  /// PUT /custom_welcome_email_test -> WelcomeEmailTest
  Future<SDKResponse<WelcomeEmailTest>> updateCustomWelcomeEmailTest(

      /// @param {WelcomeEmailTest} body
      WelcomeEmailTest body) async {
    WelcomeEmailTest responseHandler(dynamic json, String contentType) {
      return WelcomeEmailTest.fromResponse(json, contentType);
    }

    return put(
        responseHandler, '/custom_welcome_email_test', null, body?.toJson());
  }

  /// ### Retrieve the value for whether or not digest emails is enabled
  ///
  /// GET /digest_emails_enabled -> DigestEmails
  Future<SDKResponse<DigestEmails>> digestEmailsEnabled() async {
    DigestEmails responseHandler(dynamic json, String contentType) {
      return DigestEmails.fromResponse(json, contentType);
    }

    return get(responseHandler, '/digest_emails_enabled');
  }

  /// ### Update the setting for enabling/disabling digest emails
  ///
  /// PATCH /digest_emails_enabled -> DigestEmails
  Future<SDKResponse<DigestEmails>> updateDigestEmailsEnabled(

      /// @param {DigestEmails} body
      DigestEmails body) async {
    DigestEmails responseHandler(dynamic json, String contentType) {
      return DigestEmails.fromResponse(json, contentType);
    }

    return patch(
        responseHandler, '/digest_emails_enabled', null, body?.toJson());
  }

  /// ### Trigger the generation of digest email records and send them to Looker's internal system. This does not send
  /// any actual emails, it generates records containing content which may be of interest for users who have become inactive.
  /// Emails will be sent at a later time from Looker's internal system if the Digest Emails feature is enabled in settings.
  ///
  /// POST /digest_email_send -> DigestEmailSend
  Future<SDKResponse<DigestEmailSend>> createDigestEmailSend() async {
    DigestEmailSend responseHandler(dynamic json, String contentType) {
      return DigestEmailSend.fromResponse(json, contentType);
    }

    return post(responseHandler, '/digest_email_send');
  }

  /// ### Set the menu item name and content for internal help resources
  ///
  /// GET /internal_help_resources_content -> InternalHelpResourcesContent
  Future<SDKResponse<InternalHelpResourcesContent>>
      internalHelpResourcesContent() async {
    InternalHelpResourcesContent responseHandler(
        dynamic json, String contentType) {
      return InternalHelpResourcesContent.fromResponse(json, contentType);
    }

    return get(responseHandler, '/internal_help_resources_content');
  }

  /// Update internal help resources content
  ///
  /// PATCH /internal_help_resources_content -> InternalHelpResourcesContent
  Future<SDKResponse<InternalHelpResourcesContent>>
      updateInternalHelpResourcesContent(

          /// @param {WriteInternalHelpResourcesContent} body
          WriteInternalHelpResourcesContent body) async {
    InternalHelpResourcesContent responseHandler(
        dynamic json, String contentType) {
      return InternalHelpResourcesContent.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/internal_help_resources_content', null,
        body?.toJson());
  }

  /// ### Get and set the options for internal help resources
  ///
  /// GET /internal_help_resources_enabled -> InternalHelpResources
  Future<SDKResponse<InternalHelpResources>> internalHelpResources() async {
    InternalHelpResources responseHandler(dynamic json, String contentType) {
      return InternalHelpResources.fromResponse(json, contentType);
    }

    return get(responseHandler, '/internal_help_resources_enabled');
  }

  /// Update internal help resources settings
  ///
  /// PATCH /internal_help_resources -> InternalHelpResources
  Future<SDKResponse<InternalHelpResources>> updateInternalHelpResources(

      /// @param {WriteInternalHelpResources} body
      WriteInternalHelpResources body) async {
    InternalHelpResources responseHandler(dynamic json, String contentType) {
      return InternalHelpResources.fromResponse(json, contentType);
    }

    return patch(
        responseHandler, '/internal_help_resources', null, body?.toJson());
  }

  /// ### Get all legacy features.
  ///
  /// GET /legacy_features -> List<LegacyFeature>
  Future<SDKResponse<List<LegacyFeature>>> allLegacyFeatures() async {
    List<LegacyFeature> responseHandler(dynamic json, String contentType) {
      return json
          .map<LegacyFeature>((i) => LegacyFeature.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/legacy_features');
  }

  /// ### Get information about the legacy feature with a specific id.
  ///
  /// GET /legacy_features/{legacy_feature_id} -> LegacyFeature
  Future<SDKResponse<LegacyFeature>> legacyFeature(

      /// @param {String} legacy_feature_id id of legacy feature
      String legacyFeatureId) async {
    var pathLegacyFeatureId = encodeParam(legacyFeatureId);

    LegacyFeature responseHandler(dynamic json, String contentType) {
      return LegacyFeature.fromResponse(json, contentType);
    }

    return get(responseHandler, '/legacy_features/$pathLegacyFeatureId');
  }

  /// ### Update information about the legacy feature with a specific id.
  ///
  /// PATCH /legacy_features/{legacy_feature_id} -> LegacyFeature
  Future<SDKResponse<LegacyFeature>> updateLegacyFeature(

      /// @param {String} legacy_feature_id id of legacy feature
      String legacyFeatureId,

      /// @param {WriteLegacyFeature} body
      WriteLegacyFeature body) async {
    var pathLegacyFeatureId = encodeParam(legacyFeatureId);

    LegacyFeature responseHandler(dynamic json, String contentType) {
      return LegacyFeature.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/legacy_features/$pathLegacyFeatureId', null,
        body?.toJson());
  }

  /// ### Get a list of locales that Looker supports.
  ///
  /// GET /locales -> List<Locale>
  Future<SDKResponse<List<Locale>>> allLocales() async {
    List<Locale> responseHandler(dynamic json, String contentType) {
      return json
          .map<Locale>((i) => Locale.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/locales');
  }

  /// ### Get all mobile settings.
  ///
  /// GET /mobile/settings -> MobileSettings
  Future<SDKResponse<MobileSettings>> mobileSettings() async {
    MobileSettings responseHandler(dynamic json, String contentType) {
      return MobileSettings.fromResponse(json, contentType);
    }

    return get(responseHandler, '/mobile/settings');
  }

  /// ### Get Looker Settings
  ///
  /// Available settings are:
  ///  - extension_framework_enabled
  ///  - marketplace_auto_install_enabled
  ///  - marketplace_enabled
  ///  - whitelabel_configuration
  ///  - custom_welcome_email
  ///
  /// GET /setting -> Setting
  Future<SDKResponse<Setting>> getSetting(
      {

      /// @param {String} fields Requested fields
      String fields}) async {
    Setting responseHandler(dynamic json, String contentType) {
      return Setting.fromResponse(json, contentType);
    }

    return get(responseHandler, '/setting', {'fields': fields});
  }

  /// ### Configure Looker Settings
  ///
  /// Available settings are:
  ///  - extension_framework_enabled
  ///  - marketplace_auto_install_enabled
  ///  - marketplace_enabled
  ///  - whitelabel_configuration
  ///  - custom_welcome_email
  ///
  /// See the `Setting` type for more information on the specific values that can be configured.
  ///
  /// PATCH /setting -> Setting
  Future<SDKResponse<Setting>> setSetting(

      /// @param {WriteSetting} body
      WriteSetting body,
      {

      /// @param {String} fields Requested fields
      String fields}) async {
    Setting responseHandler(dynamic json, String contentType) {
      return Setting.fromResponse(json, contentType);
    }

    return patch(
        responseHandler, '/setting', {'fields': fields}, body?.toJson());
  }

  /// ### Get current SMTP status.
  ///
  /// GET /smtp_status -> SmtpStatus
  Future<SDKResponse<SmtpStatus>> smtpStatus(
      {

      /// @param {String} fields Include only these fields in the response
      String fields}) async {
    SmtpStatus responseHandler(dynamic json, String contentType) {
      return SmtpStatus.fromResponse(json, contentType);
    }

    return get(responseHandler, '/smtp_status', {'fields': fields});
  }

  /// ### Get a list of timezones that Looker supports (e.g. useful for scheduling tasks).
  ///
  /// GET /timezones -> List<Timezone>
  Future<SDKResponse<List<Timezone>>> allTimezones() async {
    List<Timezone> responseHandler(dynamic json, String contentType) {
      return json
          .map<Timezone>((i) => Timezone.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/timezones');
  }

  /// ### Get information about all API versions supported by this Looker instance.
  ///
  /// GET /versions -> ApiVersion
  Future<SDKResponse<ApiVersion>> versions(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    ApiVersion responseHandler(dynamic json, String contentType) {
      return ApiVersion.fromResponse(json, contentType);
    }

    return get(responseHandler, '/versions', {'fields': fields});
  }

  /// ### Get an API specification for this Looker instance.
  ///
  /// The specification is returned as a JSON document in Swagger 2.x format
  ///
  /// GET /api_spec/{api_version}/{specification} -> dynamic
  Future<SDKResponse<dynamic>> apiSpec(

      /// @param {String} api_version API version
      String apiVersion,

      /// @param {String} specification Specification name. Typically, this is "swagger.json"
      String specification) async {
    var pathApiVersion = encodeParam(apiVersion);
    var pathSpecification = encodeParam(specification);

    dynamic responseHandler(dynamic json, String contentType) {
      return json;
    }

    return get(responseHandler, '/api_spec/$pathApiVersion/$pathSpecification');
  }

  /// ### This feature is enabled only by special license.
  /// ### Gets the whitelabel configuration, which includes hiding documentation links, custom favicon uploading, etc.
  ///
  /// GET /whitelabel_configuration -> WhitelabelConfiguration
  Future<SDKResponse<WhitelabelConfiguration>> whitelabelConfiguration(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    WhitelabelConfiguration responseHandler(dynamic json, String contentType) {
      return WhitelabelConfiguration.fromResponse(json, contentType);
    }

    return get(
        responseHandler, '/whitelabel_configuration', {'fields': fields});
  }

  /// ### Update the whitelabel configuration
  ///
  /// PUT /whitelabel_configuration -> WhitelabelConfiguration
  Future<SDKResponse<WhitelabelConfiguration>> updateWhitelabelConfiguration(

      /// @param {WriteWhitelabelConfiguration} body
      WriteWhitelabelConfiguration body) async {
    WhitelabelConfiguration responseHandler(dynamic json, String contentType) {
      return WhitelabelConfiguration.fromResponse(json, contentType);
    }

    return put(
        responseHandler, '/whitelabel_configuration', null, body?.toJson());
  }

  // #endregion Config: Manage General Configuration

  // #region Connection: Manage Database Connections

  /// ### Get information about all connections.
  ///
  /// GET /connections -> List<DBConnection>
  Future<SDKResponse<List<DBConnection>>> allConnections(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<DBConnection> responseHandler(dynamic json, String contentType) {
      return json
          .map<DBConnection>((i) => DBConnection.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/connections', {'fields': fields});
  }

  /// ### Create a connection using the specified configuration.
  ///
  /// POST /connections -> DBConnection
  Future<SDKResponse<DBConnection>> createConnection(

      /// @param {WriteDBConnection} body
      WriteDBConnection body) async {
    DBConnection responseHandler(dynamic json, String contentType) {
      return DBConnection.fromResponse(json, contentType);
    }

    return post(responseHandler, '/connections', null, body?.toJson());
  }

  /// ### Get information about a connection.
  ///
  /// GET /connections/{connection_name} -> DBConnection
  Future<SDKResponse<DBConnection>> connection(

      /// @param {String} connection_name Name of connection
      String connectionName,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathConnectionName = encodeParam(connectionName);

    DBConnection responseHandler(dynamic json, String contentType) {
      return DBConnection.fromResponse(json, contentType);
    }

    return get(responseHandler, '/connections/$pathConnectionName',
        {'fields': fields});
  }

  /// ### Update a connection using the specified configuration.
  ///
  /// PATCH /connections/{connection_name} -> DBConnection
  Future<SDKResponse<DBConnection>> updateConnection(

      /// @param {String} connection_name Name of connection
      String connectionName,

      /// @param {WriteDBConnection} body
      WriteDBConnection body) async {
    var pathConnectionName = encodeParam(connectionName);

    DBConnection responseHandler(dynamic json, String contentType) {
      return DBConnection.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/connections/$pathConnectionName', null,
        body?.toJson());
  }

  /// ### Delete a connection.
  ///
  /// DELETE /connections/{connection_name} -> String
  Future<SDKResponse<String>> deleteConnection(

      /// @param {String} connection_name Name of connection
      String connectionName) async {
    var pathConnectionName = encodeParam(connectionName);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/connections/$pathConnectionName');
  }

  /// ### Delete a connection override.
  ///
  /// DELETE /connections/{connection_name}/connection_override/{override_context} -> String
  Future<SDKResponse<String>> deleteConnectionOverride(

      /// @param {String} connection_name Name of connection
      String connectionName,

      /// @param {String} override_context Context of connection override
      String overrideContext) async {
    var pathConnectionName = encodeParam(connectionName);
    var pathOverrideContext = encodeParam(overrideContext);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler,
        '/connections/$pathConnectionName/connection_override/$pathOverrideContext');
  }

  /// ### Test an existing connection.
  ///
  /// Note that a connection's 'dialect' property has a 'connection_tests' property that lists the
  /// specific types of tests that the connection supports.
  ///
  /// This API is rate limited.
  ///
  /// Unsupported tests in the request will be ignored.
  ///
  /// PUT /connections/{connection_name}/test -> List<DBConnectionTestResult>
  Future<SDKResponse<List<DBConnectionTestResult>>> testConnection(

      /// @param {String} connection_name Name of connection
      String connectionName,
      {

      /// @param {DelimList<String>} tests Array of names of tests to run
      DelimList<String> tests}) async {
    var pathConnectionName = encodeParam(connectionName);

    List<DBConnectionTestResult> responseHandler(
        dynamic json, String contentType) {
      return json
          .map<DBConnectionTestResult>(
              (i) => DBConnectionTestResult.fromResponse(i, contentType))
          .toList();
    }

    return put(responseHandler, '/connections/$pathConnectionName/test',
        {'tests': tests});
  }

  /// ### Test a connection configuration.
  ///
  /// Note that a connection's 'dialect' property has a 'connection_tests' property that lists the
  /// specific types of tests that the connection supports.
  ///
  /// This API is rate limited.
  ///
  /// Unsupported tests in the request will be ignored.
  ///
  /// PUT /connections/test -> List<DBConnectionTestResult>
  Future<SDKResponse<List<DBConnectionTestResult>>> testConnectionConfig(

      /// @param {WriteDBConnection} body
      WriteDBConnection body,
      {

      /// @param {DelimList<String>} tests Array of names of tests to run
      DelimList<String> tests}) async {
    List<DBConnectionTestResult> responseHandler(
        dynamic json, String contentType) {
      return json
          .map<DBConnectionTestResult>(
              (i) => DBConnectionTestResult.fromResponse(i, contentType))
          .toList();
    }

    return put(
        responseHandler, '/connections/test', {'tests': tests}, body?.toJson());
  }

  /// ### Get information about all dialects.
  ///
  /// GET /dialect_info -> List<DialectInfo>
  Future<SDKResponse<List<DialectInfo>>> allDialectInfos(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<DialectInfo> responseHandler(dynamic json, String contentType) {
      return json
          .map<DialectInfo>((i) => DialectInfo.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/dialect_info', {'fields': fields});
  }

  /// ### Get all External OAuth Applications.
  ///
  /// This is an OAuth Application which Looker uses to access external systems.
  ///
  /// GET /external_oauth_applications -> List<ExternalOauthApplication>
  Future<SDKResponse<List<ExternalOauthApplication>>>
      allExternalOauthApplications(
          {

          /// @param {String} name Application name
          String name,

          /// @param {String} client_id Application Client ID
          String clientId}) async {
    List<ExternalOauthApplication> responseHandler(
        dynamic json, String contentType) {
      return json
          .map<ExternalOauthApplication>(
              (i) => ExternalOauthApplication.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/external_oauth_applications',
        {'name': name, 'client_id': clientId});
  }

  /// ### Create an OAuth Application using the specified configuration.
  ///
  /// This is an OAuth Application which Looker uses to access external systems.
  ///
  /// POST /external_oauth_applications -> ExternalOauthApplication
  Future<SDKResponse<ExternalOauthApplication>> createExternalOauthApplication(

      /// @param {WriteExternalOauthApplication} body
      WriteExternalOauthApplication body) async {
    ExternalOauthApplication responseHandler(dynamic json, String contentType) {
      return ExternalOauthApplication.fromResponse(json, contentType);
    }

    return post(
        responseHandler, '/external_oauth_applications', null, body?.toJson());
  }

  /// ### Create OAuth User state.
  ///
  /// POST /external_oauth_applications/user_state -> CreateOAuthApplicationUserStateResponse
  Future<SDKResponse<CreateOAuthApplicationUserStateResponse>>
      createOauthApplicationUserState(

          /// @param {CreateOAuthApplicationUserStateRequest} body
          CreateOAuthApplicationUserStateRequest body) async {
    CreateOAuthApplicationUserStateResponse responseHandler(
        dynamic json, String contentType) {
      return CreateOAuthApplicationUserStateResponse.fromResponse(
          json, contentType);
    }

    return post(responseHandler, '/external_oauth_applications/user_state',
        null, body?.toJson());
  }

  /// ### Get information about all SSH Servers.
  ///
  /// GET /ssh_servers -> List<SshServer>
  Future<SDKResponse<List<SshServer>>> allSshServers(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<SshServer> responseHandler(dynamic json, String contentType) {
      return json
          .map<SshServer>((i) => SshServer.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/ssh_servers', {'fields': fields});
  }

  /// ### Create an SSH Server.
  ///
  /// POST /ssh_servers -> SshServer
  Future<SDKResponse<SshServer>> createSshServer(

      /// @param {WriteSshServer} body
      WriteSshServer body) async {
    SshServer responseHandler(dynamic json, String contentType) {
      return SshServer.fromResponse(json, contentType);
    }

    return post(responseHandler, '/ssh_servers', null, body?.toJson());
  }

  /// ### Get information about an SSH Server.
  ///
  /// GET /ssh_server/{ssh_server_id} -> SshServer
  Future<SDKResponse<SshServer>> sshServer(

      /// @param {String} ssh_server_id Id of SSH Server
      String sshServerId) async {
    var pathSshServerId = encodeParam(sshServerId);

    SshServer responseHandler(dynamic json, String contentType) {
      return SshServer.fromResponse(json, contentType);
    }

    return get(responseHandler, '/ssh_server/$pathSshServerId');
  }

  /// ### Update an SSH Server.
  ///
  /// PATCH /ssh_server/{ssh_server_id} -> SshServer
  Future<SDKResponse<SshServer>> updateSshServer(

      /// @param {String} ssh_server_id Id of SSH Server
      String sshServerId,

      /// @param {WriteSshServer} body
      WriteSshServer body) async {
    var pathSshServerId = encodeParam(sshServerId);

    SshServer responseHandler(dynamic json, String contentType) {
      return SshServer.fromResponse(json, contentType);
    }

    return patch(
        responseHandler, '/ssh_server/$pathSshServerId', null, body?.toJson());
  }

  /// ### Delete an SSH Server.
  ///
  /// DELETE /ssh_server/{ssh_server_id} -> String
  Future<SDKResponse<String>> deleteSshServer(

      /// @param {String} ssh_server_id Id of SSH Server
      String sshServerId) async {
    var pathSshServerId = encodeParam(sshServerId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/ssh_server/$pathSshServerId');
  }

  /// ### Test the SSH Server
  ///
  /// GET /ssh_server/{ssh_server_id}/test -> SshServer
  Future<SDKResponse<SshServer>> testSshServer(

      /// @param {String} ssh_server_id Id of SSH Server
      String sshServerId) async {
    var pathSshServerId = encodeParam(sshServerId);

    SshServer responseHandler(dynamic json, String contentType) {
      return SshServer.fromResponse(json, contentType);
    }

    return get(responseHandler, '/ssh_server/$pathSshServerId/test');
  }

  /// ### Get information about all SSH Tunnels.
  ///
  /// GET /ssh_tunnels -> List<SshTunnel>
  Future<SDKResponse<List<SshTunnel>>> allSshTunnels(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<SshTunnel> responseHandler(dynamic json, String contentType) {
      return json
          .map<SshTunnel>((i) => SshTunnel.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/ssh_tunnels', {'fields': fields});
  }

  /// ### Create an SSH Tunnel
  ///
  /// POST /ssh_tunnels -> SshTunnel
  Future<SDKResponse<SshTunnel>> createSshTunnel(

      /// @param {WriteSshTunnel} body
      WriteSshTunnel body) async {
    SshTunnel responseHandler(dynamic json, String contentType) {
      return SshTunnel.fromResponse(json, contentType);
    }

    return post(responseHandler, '/ssh_tunnels', null, body?.toJson());
  }

  /// ### Get information about an SSH Tunnel.
  ///
  /// GET /ssh_tunnel/{ssh_tunnel_id} -> SshTunnel
  Future<SDKResponse<SshTunnel>> sshTunnel(

      /// @param {String} ssh_tunnel_id Id of SSH Tunnel
      String sshTunnelId) async {
    var pathSshTunnelId = encodeParam(sshTunnelId);

    SshTunnel responseHandler(dynamic json, String contentType) {
      return SshTunnel.fromResponse(json, contentType);
    }

    return get(responseHandler, '/ssh_tunnel/$pathSshTunnelId');
  }

  /// ### Update an SSH Tunnel
  ///
  /// PATCH /ssh_tunnel/{ssh_tunnel_id} -> SshTunnel
  Future<SDKResponse<SshTunnel>> updateSshTunnel(

      /// @param {String} ssh_tunnel_id Id of SSH Tunnel
      String sshTunnelId,

      /// @param {WriteSshTunnel} body
      WriteSshTunnel body) async {
    var pathSshTunnelId = encodeParam(sshTunnelId);

    SshTunnel responseHandler(dynamic json, String contentType) {
      return SshTunnel.fromResponse(json, contentType);
    }

    return patch(
        responseHandler, '/ssh_tunnel/$pathSshTunnelId', null, body?.toJson());
  }

  /// ### Delete an SSH Tunnel
  ///
  /// DELETE /ssh_tunnel/{ssh_tunnel_id} -> String
  Future<SDKResponse<String>> deleteSshTunnel(

      /// @param {String} ssh_tunnel_id Id of SSH Tunnel
      String sshTunnelId) async {
    var pathSshTunnelId = encodeParam(sshTunnelId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/ssh_tunnel/$pathSshTunnelId');
  }

  /// ### Test the SSH Tunnel
  ///
  /// GET /ssh_tunnel/{ssh_tunnel_id}/test -> SshTunnel
  Future<SDKResponse<SshTunnel>> testSshTunnel(

      /// @param {String} ssh_tunnel_id Id of SSH Tunnel
      String sshTunnelId) async {
    var pathSshTunnelId = encodeParam(sshTunnelId);

    SshTunnel responseHandler(dynamic json, String contentType) {
      return SshTunnel.fromResponse(json, contentType);
    }

    return get(responseHandler, '/ssh_tunnel/$pathSshTunnelId/test');
  }

  /// ### Get the SSH public key
  ///
  /// Get the public key created for this instance to identify itself to a remote SSH server.
  ///
  /// GET /ssh_public_key -> SshPublicKey
  Future<SDKResponse<SshPublicKey>> sshPublicKey() async {
    SshPublicKey responseHandler(dynamic json, String contentType) {
      return SshPublicKey.fromResponse(json, contentType);
    }

    return get(responseHandler, '/ssh_public_key');
  }

  // #endregion Connection: Manage Database Connections

  // #region Content: Manage Content

  /// ### Search Favorite Content
  ///
  /// If multiple search params are given and `filter_or` is FALSE or not specified,
  /// search params are combined in a logical AND operation.
  /// Only rows that match *all* search param criteria will be returned.
  ///
  /// If `filter_or` is TRUE, multiple search params are combined in a logical OR operation.
  /// Results will include rows that match **any** of the search criteria.
  ///
  /// String search params use case-insensitive matching.
  /// String search params can contain `%` and '_' as SQL LIKE pattern match wildcard expressions.
  /// example="dan%" will match "danger" and "Danzig" but not "David"
  /// example="D_m%" will match "Damage" and "dump"
  ///
  /// Integer search params can accept a single value or a comma separated list of values. The multiple
  /// values will be combined under a logical OR operation - results will match at least one of
  /// the given values.
  ///
  /// Most search params can accept "IS NULL" and "NOT NULL" as special expressions to match
  /// or exclude (respectively) rows where the column is null.
  ///
  /// Boolean search params accept only "true" and "false" as values.
  ///
  /// GET /content_favorite/search -> List<ContentFavorite>
  Future<SDKResponse<List<ContentFavorite>>> searchContentFavorites(
      {

      /// @param {int} id Match content favorite id(s)
      int id,

      /// @param {String} user_id Match user id(s).To create a list of multiple ids, use commas as separators
      String userId,

      /// @param {String} content_metadata_id Match content metadata id(s).To create a list of multiple ids, use commas as separators
      String contentMetadataId,

      /// @param {String} dashboard_id Match dashboard id(s).To create a list of multiple ids, use commas as separators
      String dashboardId,

      /// @param {String} look_id Match look id(s).To create a list of multiple ids, use commas as separators
      String lookId,

      /// @param {String} board_id Match board id(s).To create a list of multiple ids, use commas as separators
      String boardId,

      /// @param {int} limit Number of results to return. (used with offset)
      int limit,

      /// @param {int} offset Number of results to skip before returning any. (used with limit)
      int offset,

      /// @param {String} sorts Fields to sort by.
      String sorts,

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {bool} filter_or Combine given search criteria in a boolean OR expression
      bool filterOr}) async {
    List<ContentFavorite> responseHandler(dynamic json, String contentType) {
      return json
          .map<ContentFavorite>(
              (i) => ContentFavorite.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/content_favorite/search', {
      'id': id,
      'user_id': userId,
      'content_metadata_id': contentMetadataId,
      'dashboard_id': dashboardId,
      'look_id': lookId,
      'board_id': boardId,
      'limit': limit,
      'offset': offset,
      'sorts': sorts,
      'fields': fields,
      'filter_or': filterOr
    });
  }

  /// ### Get favorite content by its id
  ///
  /// GET /content_favorite/{content_favorite_id} -> ContentFavorite
  Future<SDKResponse<ContentFavorite>> contentFavorite(

      /// @param {int} content_favorite_id Id of favorite content
      int contentFavoriteId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathContentFavoriteId = encodeParam(contentFavoriteId);

    ContentFavorite responseHandler(dynamic json, String contentType) {
      return ContentFavorite.fromResponse(json, contentType);
    }

    return get(responseHandler, '/content_favorite/$pathContentFavoriteId',
        {'fields': fields});
  }

  /// ### Delete favorite content
  ///
  /// DELETE /content_favorite/{content_favorite_id} -> String
  Future<SDKResponse<String>> deleteContentFavorite(

      /// @param {int} content_favorite_id Id of favorite content
      int contentFavoriteId) async {
    var pathContentFavoriteId = encodeParam(contentFavoriteId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/content_favorite/$pathContentFavoriteId');
  }

  /// ### Create favorite content
  ///
  /// POST /content_favorite -> ContentFavorite
  Future<SDKResponse<ContentFavorite>> createContentFavorite(

      /// @param {WriteContentFavorite} body
      WriteContentFavorite body) async {
    ContentFavorite responseHandler(dynamic json, String contentType) {
      return ContentFavorite.fromResponse(json, contentType);
    }

    return post(responseHandler, '/content_favorite', null, body?.toJson());
  }

  /// ### Get information about all content metadata in a space.
  ///
  /// GET /content_metadata -> List<ContentMeta>
  Future<SDKResponse<List<ContentMeta>>> allContentMetadatas(

      /// @param {int} parent_id Parent space of content.
      int parentId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<ContentMeta> responseHandler(dynamic json, String contentType) {
      return json
          .map<ContentMeta>((i) => ContentMeta.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/content_metadata',
        {'parent_id': parentId, 'fields': fields});
  }

  /// ### Get information about an individual content metadata record.
  ///
  /// GET /content_metadata/{content_metadata_id} -> ContentMeta
  Future<SDKResponse<ContentMeta>> contentMetadata(

      /// @param {int} content_metadata_id Id of content metadata
      int contentMetadataId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathContentMetadataId = encodeParam(contentMetadataId);

    ContentMeta responseHandler(dynamic json, String contentType) {
      return ContentMeta.fromResponse(json, contentType);
    }

    return get(responseHandler, '/content_metadata/$pathContentMetadataId',
        {'fields': fields});
  }

  /// ### Move a piece of content.
  ///
  /// PATCH /content_metadata/{content_metadata_id} -> ContentMeta
  Future<SDKResponse<ContentMeta>> updateContentMetadata(

      /// @param {int} content_metadata_id Id of content metadata
      int contentMetadataId,

      /// @param {WriteContentMeta} body
      WriteContentMeta body) async {
    var pathContentMetadataId = encodeParam(contentMetadataId);

    ContentMeta responseHandler(dynamic json, String contentType) {
      return ContentMeta.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/content_metadata/$pathContentMetadataId',
        null, body?.toJson());
  }

  /// ### All content metadata access records for a content metadata item.
  ///
  /// GET /content_metadata_access -> List<ContentMetaGroupUser>
  Future<SDKResponse<List<ContentMetaGroupUser>>> allContentMetadataAccesses(

      /// @param {int} content_metadata_id Id of content metadata
      int contentMetadataId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<ContentMetaGroupUser> responseHandler(
        dynamic json, String contentType) {
      return json
          .map<ContentMetaGroupUser>(
              (i) => ContentMetaGroupUser.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/content_metadata_access',
        {'content_metadata_id': contentMetadataId, 'fields': fields});
  }

  /// ### Create content metadata access.
  ///
  /// POST /content_metadata_access -> ContentMetaGroupUser
  Future<SDKResponse<ContentMetaGroupUser>> createContentMetadataAccess(

      /// @param {ContentMetaGroupUser} body
      ContentMetaGroupUser body,
      {

      /// @param {bool} send_boards_notification_email Optionally sends notification email when granting access to a board.
      bool sendBoardsNotificationEmail}) async {
    ContentMetaGroupUser responseHandler(dynamic json, String contentType) {
      return ContentMetaGroupUser.fromResponse(json, contentType);
    }

    return post(
        responseHandler,
        '/content_metadata_access',
        {'send_boards_notification_email': sendBoardsNotificationEmail},
        body?.toJson());
  }

  /// ### Update type of access for content metadata.
  ///
  /// PUT /content_metadata_access/{content_metadata_access_id} -> ContentMetaGroupUser
  Future<SDKResponse<ContentMetaGroupUser>> updateContentMetadataAccess(

      /// @param {String} content_metadata_access_id Id of content metadata access
      String contentMetadataAccessId,

      /// @param {ContentMetaGroupUser} body
      ContentMetaGroupUser body) async {
    var pathContentMetadataAccessId = encodeParam(contentMetadataAccessId);

    ContentMetaGroupUser responseHandler(dynamic json, String contentType) {
      return ContentMetaGroupUser.fromResponse(json, contentType);
    }

    return put(
        responseHandler,
        '/content_metadata_access/$pathContentMetadataAccessId',
        null,
        body?.toJson());
  }

  /// ### Remove content metadata access.
  ///
  /// DELETE /content_metadata_access/{content_metadata_access_id} -> String
  Future<SDKResponse<String>> deleteContentMetadataAccess(

      /// @param {int} content_metadata_access_id Id of content metadata access
      int contentMetadataAccessId) async {
    var pathContentMetadataAccessId = encodeParam(contentMetadataAccessId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler,
        '/content_metadata_access/$pathContentMetadataAccessId');
  }

  /// ### Get an image representing the contents of a dashboard or look.
  ///
  /// The returned thumbnail is an abstract representation of the contents of a dashbord or look and does not
  /// reflect the actual data displayed in the respective visualizations.
  ///
  /// GET /content_thumbnail/{type}/{resource_id} -> String
  ///
  /// **Note**: Binary content may be returned by this method.
  Future<SDKResponse<dynamic>> contentThumbnail(

      /// @param {String} type Either dashboard or look
      String type,

      /// @param {String} resource_id ID of the dashboard or look to render
      String resourceId,
      {

      /// @param {String} reload Whether or not to refresh the rendered image with the latest content
      String reload,

      /// @param {String} format A value of png produces a thumbnail in PNG format instead of SVG (default)
      String format,

      /// @param {int} width The width of the image if format is supplied
      int width,

      /// @param {int} height The height of the image if format is supplied
      int height}) async {
    var pathType = encodeParam(type);
    var pathResourceId = encodeParam(resourceId);

    dynamic responseHandler(dynamic json, String contentType) {
      return json;
    }

    return get(responseHandler, '/content_thumbnail/$pathType/$pathResourceId',
        {'reload': reload, 'format': format, 'width': width, 'height': height});
  }

  /// ### Validate All Content
  ///
  /// Performs validation of all looks and dashboards
  /// Returns a list of errors found as well as metadata about the content validation run.
  ///
  /// GET /content_validation -> ContentValidation
  Future<SDKResponse<ContentValidation>> contentValidation(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    ContentValidation responseHandler(dynamic json, String contentType) {
      return ContentValidation.fromResponse(json, contentType);
    }

    return get(responseHandler, '/content_validation', {'fields': fields});
  }

  /// ### Search Content Views
  ///
  /// If multiple search params are given and `filter_or` is FALSE or not specified,
  /// search params are combined in a logical AND operation.
  /// Only rows that match *all* search param criteria will be returned.
  ///
  /// If `filter_or` is TRUE, multiple search params are combined in a logical OR operation.
  /// Results will include rows that match **any** of the search criteria.
  ///
  /// String search params use case-insensitive matching.
  /// String search params can contain `%` and '_' as SQL LIKE pattern match wildcard expressions.
  /// example="dan%" will match "danger" and "Danzig" but not "David"
  /// example="D_m%" will match "Damage" and "dump"
  ///
  /// Integer search params can accept a single value or a comma separated list of values. The multiple
  /// values will be combined under a logical OR operation - results will match at least one of
  /// the given values.
  ///
  /// Most search params can accept "IS NULL" and "NOT NULL" as special expressions to match
  /// or exclude (respectively) rows where the column is null.
  ///
  /// Boolean search params accept only "true" and "false" as values.
  ///
  /// GET /content_view/search -> List<ContentView>
  Future<SDKResponse<List<ContentView>>> searchContentViews(
      {

      /// @param {String} view_count Match view count
      String viewCount,

      /// @param {String} group_id Match Group Id
      String groupId,

      /// @param {String} look_id Match look_id
      String lookId,

      /// @param {String} dashboard_id Match dashboard_id
      String dashboardId,

      /// @param {String} content_metadata_id Match content metadata id
      String contentMetadataId,

      /// @param {String} start_of_week_date Match start of week date (format is "YYYY-MM-DD")
      String startOfWeekDate,

      /// @param {bool} all_time True if only all time view records should be returned
      bool allTime,

      /// @param {String} user_id Match user id
      String userId,

      /// @param {String} fields Requested fields
      String fields,

      /// @param {int} limit Number of results to return. Use with `offset` to manage pagination of results
      int limit,

      /// @param {int} offset Number of results to skip before returning data
      int offset,

      /// @param {String} sorts Fields to sort by
      String sorts,

      /// @param {bool} filter_or Combine given search criteria in a boolean OR expression
      bool filterOr}) async {
    List<ContentView> responseHandler(dynamic json, String contentType) {
      return json
          .map<ContentView>((i) => ContentView.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/content_view/search', {
      'view_count': viewCount,
      'group_id': groupId,
      'look_id': lookId,
      'dashboard_id': dashboardId,
      'content_metadata_id': contentMetadataId,
      'start_of_week_date': startOfWeekDate,
      'all_time': allTime,
      'user_id': userId,
      'fields': fields,
      'limit': limit,
      'offset': offset,
      'sorts': sorts,
      'filter_or': filterOr
    });
  }

  /// ### Get a vector image representing the contents of a dashboard or look.
  ///
  /// # DEPRECATED:  Use [content_thumbnail()](#!/Content/content_thumbnail)
  ///
  /// The returned thumbnail is an abstract representation of the contents of a dashbord or look and does not
  /// reflect the actual data displayed in the respective visualizations.
  ///
  /// GET /vector_thumbnail/{type}/{resource_id} -> String
  Future<SDKResponse<String>> vectorThumbnail(

      /// @param {String} type Either dashboard or look
      String type,

      /// @param {String} resource_id ID of the dashboard or look to render
      String resourceId,
      {

      /// @param {String} reload Whether or not to refresh the rendered image with the latest content
      String reload}) async {
    var pathType = encodeParam(type);
    var pathResourceId = encodeParam(resourceId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return get(responseHandler, '/vector_thumbnail/$pathType/$pathResourceId',
        {'reload': reload});
  }

  // #endregion Content: Manage Content

  // #region Dashboard: Manage Dashboards

  /// ### Get information about all active dashboards.
  ///
  /// Returns an array of **abbreviated dashboard objects**. Dashboards marked as deleted are excluded from this list.
  ///
  /// Get the **full details** of a specific dashboard by id with [dashboard()](#!/Dashboard/dashboard)
  ///
  /// Find **deleted dashboards** with [search_dashboards()](#!/Dashboard/search_dashboards)
  ///
  /// GET /dashboards -> List<DashboardBase>
  Future<SDKResponse<List<DashboardBase>>> allDashboards(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<DashboardBase> responseHandler(dynamic json, String contentType) {
      return json
          .map<DashboardBase>((i) => DashboardBase.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/dashboards', {'fields': fields});
  }

  /// ### Create a new dashboard
  ///
  /// Creates a new dashboard object and returns the details of the newly created dashboard.
  ///
  /// `Title`, `user_id`, and `space_id` are all required fields.
  /// `Space_id` and `user_id` must contain the id of an existing space or user, respectively.
  /// A dashboard's `title` must be unique within the space in which it resides.
  ///
  /// If you receive a 422 error response when creating a dashboard, be sure to look at the
  /// response body for information about exactly which fields are missing or contain invalid data.
  ///
  /// You can **update** an existing dashboard with [update_dashboard()](#!/Dashboard/update_dashboard)
  ///
  /// You can **permanently delete** an existing dashboard with [delete_dashboard()](#!/Dashboard/delete_dashboard)
  ///
  /// POST /dashboards -> Dashboard
  Future<SDKResponse<Dashboard>> createDashboard(

      /// @param {WriteDashboard} body
      WriteDashboard body) async {
    Dashboard responseHandler(dynamic json, String contentType) {
      return Dashboard.fromResponse(json, contentType);
    }

    return post(responseHandler, '/dashboards', null, body?.toJson());
  }

  /// ### Search Dashboards
  ///
  /// Returns an **array of dashboard objects** that match the specified search criteria.
  ///
  /// If multiple search params are given and `filter_or` is FALSE or not specified,
  /// search params are combined in a logical AND operation.
  /// Only rows that match *all* search param criteria will be returned.
  ///
  /// If `filter_or` is TRUE, multiple search params are combined in a logical OR operation.
  /// Results will include rows that match **any** of the search criteria.
  ///
  /// String search params use case-insensitive matching.
  /// String search params can contain `%` and '_' as SQL LIKE pattern match wildcard expressions.
  /// example="dan%" will match "danger" and "Danzig" but not "David"
  /// example="D_m%" will match "Damage" and "dump"
  ///
  /// Integer search params can accept a single value or a comma separated list of values. The multiple
  /// values will be combined under a logical OR operation - results will match at least one of
  /// the given values.
  ///
  /// Most search params can accept "IS NULL" and "NOT NULL" as special expressions to match
  /// or exclude (respectively) rows where the column is null.
  ///
  /// Boolean search params accept only "true" and "false" as values.
  ///
  ///
  /// The parameters `limit`, and `offset` are recommended for fetching results in page-size chunks.
  ///
  /// Get a **single dashboard** by id with [dashboard()](#!/Dashboard/dashboard)
  ///
  /// GET /dashboards/search -> List<Dashboard>
  Future<SDKResponse<List<Dashboard>>> searchDashboards(
      {

      /// @param {String} id Match dashboard id.
      String id,

      /// @param {String} slug Match dashboard slug.
      String slug,

      /// @param {String} title Match Dashboard title.
      String title,

      /// @param {String} description Match Dashboard description.
      String description,

      /// @param {String} content_favorite_id Filter on a content favorite id.
      String contentFavoriteId,

      /// @param {String} folder_id Filter on a particular space.
      String folderId,

      /// @param {String} deleted Filter on dashboards deleted status.
      String deleted,

      /// @param {String} user_id Filter on dashboards created by a particular user.
      String userId,

      /// @param {String} view_count Filter on a particular value of view_count
      String viewCount,

      /// @param {String} content_metadata_id Filter on a content favorite id.
      String contentMetadataId,

      /// @param {bool} curate Exclude items that exist only in personal spaces other than the users
      bool curate,

      /// @param {String} last_viewed_at Select dashboards based on when they were last viewed
      String lastViewedAt,

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {int} page Requested page.
      int page,

      /// @param {int} per_page Results per page.
      int perPage,

      /// @param {int} limit Number of results to return. (used with offset and takes priority over page and per_page)
      int limit,

      /// @param {int} offset Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
      int offset,

      /// @param {String} sorts One or more fields to sort by. Sortable fields: [:title, :user_id, :id, :created_at, :space_id, :folder_id, :description, :view_count, :favorite_count, :slug, :content_favorite_id, :content_metadata_id, :deleted, :deleted_at, :last_viewed_at, :last_accessed_at]
      String sorts,

      /// @param {bool} filter_or Combine given search criteria in a boolean OR expression
      bool filterOr}) async {
    List<Dashboard> responseHandler(dynamic json, String contentType) {
      return json
          .map<Dashboard>((i) => Dashboard.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/dashboards/search', {
      'id': id,
      'slug': slug,
      'title': title,
      'description': description,
      'content_favorite_id': contentFavoriteId,
      'folder_id': folderId,
      'deleted': deleted,
      'user_id': userId,
      'view_count': viewCount,
      'content_metadata_id': contentMetadataId,
      'curate': curate,
      'last_viewed_at': lastViewedAt,
      'fields': fields,
      'page': page,
      'per_page': perPage,
      'limit': limit,
      'offset': offset,
      'sorts': sorts,
      'filter_or': filterOr
    });
  }

  /// ### Import a LookML dashboard to a space as a UDD
  /// Creates a UDD (a dashboard which exists in the Looker database rather than as a LookML file) from the LookML dashboard
  /// and places it in the space specified. The created UDD will have a lookml_link_id which links to the original LookML dashboard.
  ///
  /// To give the imported dashboard specify a (e.g. title: "my title") in the body of your request, otherwise the imported
  /// dashboard will have the same title as the original LookML dashboard.
  ///
  /// For this operation to succeed the user must have permission to see the LookML dashboard in question, and have permission to
  /// create content in the space the dashboard is being imported to.
  ///
  /// **Sync** a linked UDD with [sync_lookml_dashboard()](#!/Dashboard/sync_lookml_dashboard)
  /// **Unlink** a linked UDD by setting lookml_link_id to null with [update_dashboard()](#!/Dashboard/update_dashboard)
  ///
  /// POST /dashboards/{lookml_dashboard_id}/import/{space_id} -> Dashboard
  Future<SDKResponse<Dashboard>> importLookmlDashboard(

      /// @param {String} lookml_dashboard_id Id of LookML dashboard
      String lookmlDashboardId,

      /// @param {String} space_id Id of space to import the dashboard to
      String spaceId,
      {

      /// @param {WriteDashboard} body
      WriteDashboard body,

      /// @param {bool} raw_locale If true, and this dashboard is localized, export it with the raw keys, not localized.
      bool rawLocale}) async {
    var pathLookmlDashboardId = encodeParam(lookmlDashboardId);
    var pathSpaceId = encodeParam(spaceId);

    Dashboard responseHandler(dynamic json, String contentType) {
      return Dashboard.fromResponse(json, contentType);
    }

    return post(
        responseHandler,
        '/dashboards/$pathLookmlDashboardId/import/$pathSpaceId',
        {'raw_locale': rawLocale},
        body?.toJson());
  }

  /// ### Update all linked dashboards to match the specified LookML dashboard.
  ///
  /// Any UDD (a dashboard which exists in the Looker database rather than as a LookML file) which has a `lookml_link_id`
  /// property value referring to a LookML dashboard's id (model::dashboardname) will be updated so that it matches the current state of the LookML dashboard.
  ///
  /// For this operation to succeed the user must have permission to view the LookML dashboard, and only linked dashboards
  /// that the user has permission to update will be synced.
  ///
  /// To **link** or **unlink** a UDD set the `lookml_link_id` property with [update_dashboard()](#!/Dashboard/update_dashboard)
  ///
  /// PATCH /dashboards/{lookml_dashboard_id}/sync -> List<int>
  Future<SDKResponse<List<int>>> syncLookmlDashboard(

      /// @param {String} lookml_dashboard_id Id of LookML dashboard, in the form 'model::dashboardname'
      String lookmlDashboardId,

      /// @param {WriteDashboard} body
      WriteDashboard body,
      {

      /// @param {bool} raw_locale If true, and this dashboard is localized, export it with the raw keys, not localized.
      bool rawLocale}) async {
    var pathLookmlDashboardId = encodeParam(lookmlDashboardId);

    List<int> responseHandler(dynamic json, String contentType) {
      return json;
    }

    return patch(responseHandler, '/dashboards/$pathLookmlDashboardId/sync',
        {'raw_locale': rawLocale}, body?.toJson());
  }

  /// ### Get information about a dashboard
  ///
  /// Returns the full details of the identified dashboard object
  ///
  /// Get a **summary list** of all active dashboards with [all_dashboards()](#!/Dashboard/all_dashboards)
  ///
  /// You can **Search** for dashboards with [search_dashboards()](#!/Dashboard/search_dashboards)
  ///
  /// GET /dashboards/{dashboard_id} -> Dashboard
  Future<SDKResponse<Dashboard>> dashboard(

      /// @param {String} dashboard_id Id of dashboard
      String dashboardId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathDashboardId = encodeParam(dashboardId);

    Dashboard responseHandler(dynamic json, String contentType) {
      return Dashboard.fromResponse(json, contentType);
    }

    return get(
        responseHandler, '/dashboards/$pathDashboardId', {'fields': fields});
  }

  /// ### Update a dashboard
  ///
  /// You can use this function to change the string and integer properties of
  /// a dashboard. Nested objects such as filters, dashboard elements, or dashboard layout components
  /// cannot be modified by this function - use the update functions for the respective
  /// nested object types (like [update_dashboard_filter()](#!/3.1/Dashboard/update_dashboard_filter) to change a filter)
  /// to modify nested objects referenced by a dashboard.
  ///
  /// If you receive a 422 error response when updating a dashboard, be sure to look at the
  /// response body for information about exactly which fields are missing or contain invalid data.
  ///
  /// PATCH /dashboards/{dashboard_id} -> Dashboard
  Future<SDKResponse<Dashboard>> updateDashboard(

      /// @param {String} dashboard_id Id of dashboard
      String dashboardId,

      /// @param {WriteDashboard} body
      WriteDashboard body) async {
    var pathDashboardId = encodeParam(dashboardId);

    Dashboard responseHandler(dynamic json, String contentType) {
      return Dashboard.fromResponse(json, contentType);
    }

    return patch(
        responseHandler, '/dashboards/$pathDashboardId', null, body?.toJson());
  }

  /// ### Delete the dashboard with the specified id
  ///
  /// Permanently **deletes** a dashboard. (The dashboard cannot be recovered after this operation.)
  ///
  /// "Soft" delete or hide a dashboard by setting its `deleted` status to `True` with [update_dashboard()](#!/Dashboard/update_dashboard).
  ///
  /// Note: When a dashboard is deleted in the UI, it is soft deleted. Use this API call to permanently remove it, if desired.
  ///
  /// DELETE /dashboards/{dashboard_id} -> String
  Future<SDKResponse<String>> deleteDashboard(

      /// @param {String} dashboard_id Id of dashboard
      String dashboardId) async {
    var pathDashboardId = encodeParam(dashboardId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/dashboards/$pathDashboardId');
  }

  /// ### Get Aggregate Table LookML for Each Query on a Dahboard
  ///
  /// Returns a JSON object that contains the dashboard id and Aggregate Table lookml
  ///
  /// GET /dashboards/aggregate_table_lookml/{dashboard_id} -> DashboardAggregateTableLookml
  Future<SDKResponse<DashboardAggregateTableLookml>>
      dashboardAggregateTableLookml(

          /// @param {String} dashboard_id Id of dashboard
          String dashboardId) async {
    var pathDashboardId = encodeParam(dashboardId);

    DashboardAggregateTableLookml responseHandler(
        dynamic json, String contentType) {
      return DashboardAggregateTableLookml.fromResponse(json, contentType);
    }

    return get(
        responseHandler, '/dashboards/aggregate_table_lookml/$pathDashboardId');
  }

  /// ### Get lookml of a UDD
  ///
  /// Returns a JSON object that contains the dashboard id and the full lookml
  ///
  /// GET /dashboards/lookml/{dashboard_id} -> DashboardLookml
  Future<SDKResponse<DashboardLookml>> dashboardLookml(

      /// @param {String} dashboard_id Id of dashboard
      String dashboardId) async {
    var pathDashboardId = encodeParam(dashboardId);

    DashboardLookml responseHandler(dynamic json, String contentType) {
      return DashboardLookml.fromResponse(json, contentType);
    }

    return get(responseHandler, '/dashboards/lookml/$pathDashboardId');
  }

  /// ### Move an existing dashboard
  ///
  /// Moves a dashboard to a specified folder, and returns the moved dashboard.
  ///
  /// `dashboard_id` and `folder_id` are required.
  /// `dashboard_id` and `folder_id` must already exist, and `folder_id` must be different from the current `folder_id` of the dashboard.
  ///
  /// PATCH /dashboards/{dashboard_id}/move -> Dashboard
  Future<SDKResponse<Dashboard>> moveDashboard(

      /// @param {String} dashboard_id Dashboard id to move.
      String dashboardId,

      /// @param {String} folder_id Folder id to move to.
      String folderId) async {
    var pathDashboardId = encodeParam(dashboardId);

    Dashboard responseHandler(dynamic json, String contentType) {
      return Dashboard.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/dashboards/$pathDashboardId/move',
        {'folder_id': folderId});
  }

  /// ### Copy an existing dashboard
  ///
  /// Creates a copy of an existing dashboard, in a specified folder, and returns the copied dashboard.
  ///
  /// `dashboard_id` is required, `dashboard_id` and `folder_id` must already exist if specified.
  /// `folder_id` will default to the existing folder.
  ///
  /// If a dashboard with the same title already exists in the target folder, the copy will have '(copy)'
  ///   or '(copy <# of copies>)' appended.
  ///
  /// POST /dashboards/{dashboard_id}/copy -> Dashboard
  Future<SDKResponse<Dashboard>> copyDashboard(

      /// @param {String} dashboard_id Dashboard id to copy.
      String dashboardId,
      {

      /// @param {String} folder_id Folder id to copy to.
      String folderId}) async {
    var pathDashboardId = encodeParam(dashboardId);

    Dashboard responseHandler(dynamic json, String contentType) {
      return Dashboard.fromResponse(json, contentType);
    }

    return post(responseHandler, '/dashboards/$pathDashboardId/copy',
        {'folder_id': folderId});
  }

  /// ### Search Dashboard Elements
  ///
  /// Returns an **array of DashboardElement objects** that match the specified search criteria.
  ///
  /// If multiple search params are given and `filter_or` is FALSE or not specified,
  /// search params are combined in a logical AND operation.
  /// Only rows that match *all* search param criteria will be returned.
  ///
  /// If `filter_or` is TRUE, multiple search params are combined in a logical OR operation.
  /// Results will include rows that match **any** of the search criteria.
  ///
  /// String search params use case-insensitive matching.
  /// String search params can contain `%` and '_' as SQL LIKE pattern match wildcard expressions.
  /// example="dan%" will match "danger" and "Danzig" but not "David"
  /// example="D_m%" will match "Damage" and "dump"
  ///
  /// Integer search params can accept a single value or a comma separated list of values. The multiple
  /// values will be combined under a logical OR operation - results will match at least one of
  /// the given values.
  ///
  /// Most search params can accept "IS NULL" and "NOT NULL" as special expressions to match
  /// or exclude (respectively) rows where the column is null.
  ///
  /// Boolean search params accept only "true" and "false" as values.
  ///
  /// GET /dashboard_elements/search -> List<DashboardElement>
  Future<SDKResponse<List<DashboardElement>>> searchDashboardElements(
      {

      /// @param {int} dashboard_id Select elements that refer to a given dashboard id
      int dashboardId,

      /// @param {int} look_id Select elements that refer to a given look id
      int lookId,

      /// @param {String} title Match the title of element
      String title,

      /// @param {bool} deleted Select soft-deleted dashboard elements
      bool deleted,

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {bool} filter_or Combine given search criteria in a boolean OR expression
      bool filterOr,

      /// @param {String} sorts Fields to sort by. Sortable fields: [:look_id, :dashboard_id, :deleted, :title]
      String sorts}) async {
    List<DashboardElement> responseHandler(dynamic json, String contentType) {
      return json
          .map<DashboardElement>(
              (i) => DashboardElement.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/dashboard_elements/search', {
      'dashboard_id': dashboardId,
      'look_id': lookId,
      'title': title,
      'deleted': deleted,
      'fields': fields,
      'filter_or': filterOr,
      'sorts': sorts
    });
  }

  /// ### Get information about the dashboard element with a specific id.
  ///
  /// GET /dashboard_elements/{dashboard_element_id} -> DashboardElement
  Future<SDKResponse<DashboardElement>> dashboardElement(

      /// @param {String} dashboard_element_id Id of dashboard element
      String dashboardElementId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathDashboardElementId = encodeParam(dashboardElementId);

    DashboardElement responseHandler(dynamic json, String contentType) {
      return DashboardElement.fromResponse(json, contentType);
    }

    return get(responseHandler, '/dashboard_elements/$pathDashboardElementId',
        {'fields': fields});
  }

  /// ### Update the dashboard element with a specific id.
  ///
  /// PATCH /dashboard_elements/{dashboard_element_id} -> DashboardElement
  Future<SDKResponse<DashboardElement>> updateDashboardElement(

      /// @param {String} dashboard_element_id Id of dashboard element
      String dashboardElementId,

      /// @param {WriteDashboardElement} body
      WriteDashboardElement body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathDashboardElementId = encodeParam(dashboardElementId);

    DashboardElement responseHandler(dynamic json, String contentType) {
      return DashboardElement.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/dashboard_elements/$pathDashboardElementId',
        {'fields': fields}, body?.toJson());
  }

  /// ### Delete a dashboard element with a specific id.
  ///
  /// DELETE /dashboard_elements/{dashboard_element_id} -> String
  Future<SDKResponse<String>> deleteDashboardElement(

      /// @param {String} dashboard_element_id Id of dashboard element
      String dashboardElementId) async {
    var pathDashboardElementId = encodeParam(dashboardElementId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(
        responseHandler, '/dashboard_elements/$pathDashboardElementId');
  }

  /// ### Get information about all the dashboard elements on a dashboard with a specific id.
  ///
  /// GET /dashboards/{dashboard_id}/dashboard_elements -> List<DashboardElement>
  Future<SDKResponse<List<DashboardElement>>> dashboardDashboardElements(

      /// @param {String} dashboard_id Id of dashboard
      String dashboardId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathDashboardId = encodeParam(dashboardId);

    List<DashboardElement> responseHandler(dynamic json, String contentType) {
      return json
          .map<DashboardElement>(
              (i) => DashboardElement.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler,
        '/dashboards/$pathDashboardId/dashboard_elements', {'fields': fields});
  }

  /// ### Create a dashboard element on the dashboard with a specific id.
  ///
  /// POST /dashboard_elements -> DashboardElement
  Future<SDKResponse<DashboardElement>> createDashboardElement(

      /// @param {WriteDashboardElement} body
      WriteDashboardElement body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    DashboardElement responseHandler(dynamic json, String contentType) {
      return DashboardElement.fromResponse(json, contentType);
    }

    return post(responseHandler, '/dashboard_elements', {'fields': fields},
        body?.toJson());
  }

  /// ### Get information about the dashboard filters with a specific id.
  ///
  /// GET /dashboard_filters/{dashboard_filter_id} -> DashboardFilter
  Future<SDKResponse<DashboardFilter>> dashboardFilter(

      /// @param {String} dashboard_filter_id Id of dashboard filters
      String dashboardFilterId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathDashboardFilterId = encodeParam(dashboardFilterId);

    DashboardFilter responseHandler(dynamic json, String contentType) {
      return DashboardFilter.fromResponse(json, contentType);
    }

    return get(responseHandler, '/dashboard_filters/$pathDashboardFilterId',
        {'fields': fields});
  }

  /// ### Update the dashboard filter with a specific id.
  ///
  /// PATCH /dashboard_filters/{dashboard_filter_id} -> DashboardFilter
  Future<SDKResponse<DashboardFilter>> updateDashboardFilter(

      /// @param {String} dashboard_filter_id Id of dashboard filter
      String dashboardFilterId,

      /// @param {WriteDashboardFilter} body
      WriteDashboardFilter body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathDashboardFilterId = encodeParam(dashboardFilterId);

    DashboardFilter responseHandler(dynamic json, String contentType) {
      return DashboardFilter.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/dashboard_filters/$pathDashboardFilterId',
        {'fields': fields}, body?.toJson());
  }

  /// ### Delete a dashboard filter with a specific id.
  ///
  /// DELETE /dashboard_filters/{dashboard_filter_id} -> String
  Future<SDKResponse<String>> deleteDashboardFilter(

      /// @param {String} dashboard_filter_id Id of dashboard filter
      String dashboardFilterId) async {
    var pathDashboardFilterId = encodeParam(dashboardFilterId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/dashboard_filters/$pathDashboardFilterId');
  }

  /// ### Get information about all the dashboard filters on a dashboard with a specific id.
  ///
  /// GET /dashboards/{dashboard_id}/dashboard_filters -> List<DashboardFilter>
  Future<SDKResponse<List<DashboardFilter>>> dashboardDashboardFilters(

      /// @param {String} dashboard_id Id of dashboard
      String dashboardId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathDashboardId = encodeParam(dashboardId);

    List<DashboardFilter> responseHandler(dynamic json, String contentType) {
      return json
          .map<DashboardFilter>(
              (i) => DashboardFilter.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler,
        '/dashboards/$pathDashboardId/dashboard_filters', {'fields': fields});
  }

  /// ### Create a dashboard filter on the dashboard with a specific id.
  ///
  /// POST /dashboard_filters -> DashboardFilter
  Future<SDKResponse<DashboardFilter>> createDashboardFilter(

      /// @param {WriteCreateDashboardFilter} body
      WriteCreateDashboardFilter body,
      {

      /// @param {String} fields Requested fields
      String fields}) async {
    DashboardFilter responseHandler(dynamic json, String contentType) {
      return DashboardFilter.fromResponse(json, contentType);
    }

    return post(responseHandler, '/dashboard_filters', {'fields': fields},
        body?.toJson());
  }

  /// ### Get information about the dashboard elements with a specific id.
  ///
  /// GET /dashboard_layout_components/{dashboard_layout_component_id} -> DashboardLayoutComponent
  Future<SDKResponse<DashboardLayoutComponent>> dashboardLayoutComponent(

      /// @param {String} dashboard_layout_component_id Id of dashboard layout component
      String dashboardLayoutComponentId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathDashboardLayoutComponentId =
        encodeParam(dashboardLayoutComponentId);

    DashboardLayoutComponent responseHandler(dynamic json, String contentType) {
      return DashboardLayoutComponent.fromResponse(json, contentType);
    }

    return get(
        responseHandler,
        '/dashboard_layout_components/$pathDashboardLayoutComponentId',
        {'fields': fields});
  }

  /// ### Update the dashboard element with a specific id.
  ///
  /// PATCH /dashboard_layout_components/{dashboard_layout_component_id} -> DashboardLayoutComponent
  Future<SDKResponse<DashboardLayoutComponent>> updateDashboardLayoutComponent(

      /// @param {String} dashboard_layout_component_id Id of dashboard layout component
      String dashboardLayoutComponentId,

      /// @param {WriteDashboardLayoutComponent} body
      WriteDashboardLayoutComponent body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathDashboardLayoutComponentId =
        encodeParam(dashboardLayoutComponentId);

    DashboardLayoutComponent responseHandler(dynamic json, String contentType) {
      return DashboardLayoutComponent.fromResponse(json, contentType);
    }

    return patch(
        responseHandler,
        '/dashboard_layout_components/$pathDashboardLayoutComponentId',
        {'fields': fields},
        body?.toJson());
  }

  /// ### Get information about all the dashboard layout components for a dashboard layout with a specific id.
  ///
  /// GET /dashboard_layouts/{dashboard_layout_id}/dashboard_layout_components -> List<DashboardLayoutComponent>
  Future<SDKResponse<List<DashboardLayoutComponent>>>
      dashboardLayoutDashboardLayoutComponents(

          /// @param {String} dashboard_layout_id Id of dashboard layout component
          String dashboardLayoutId,
          {

          /// @param {String} fields Requested fields.
          String fields}) async {
    var pathDashboardLayoutId = encodeParam(dashboardLayoutId);

    List<DashboardLayoutComponent> responseHandler(
        dynamic json, String contentType) {
      return json
          .map<DashboardLayoutComponent>(
              (i) => DashboardLayoutComponent.fromResponse(i, contentType))
          .toList();
    }

    return get(
        responseHandler,
        '/dashboard_layouts/$pathDashboardLayoutId/dashboard_layout_components',
        {'fields': fields});
  }

  /// ### Get information about the dashboard layouts with a specific id.
  ///
  /// GET /dashboard_layouts/{dashboard_layout_id} -> DashboardLayout
  Future<SDKResponse<DashboardLayout>> dashboardLayout(

      /// @param {String} dashboard_layout_id Id of dashboard layouts
      String dashboardLayoutId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathDashboardLayoutId = encodeParam(dashboardLayoutId);

    DashboardLayout responseHandler(dynamic json, String contentType) {
      return DashboardLayout.fromResponse(json, contentType);
    }

    return get(responseHandler, '/dashboard_layouts/$pathDashboardLayoutId',
        {'fields': fields});
  }

  /// ### Update the dashboard layout with a specific id.
  ///
  /// PATCH /dashboard_layouts/{dashboard_layout_id} -> DashboardLayout
  Future<SDKResponse<DashboardLayout>> updateDashboardLayout(

      /// @param {String} dashboard_layout_id Id of dashboard layout
      String dashboardLayoutId,

      /// @param {WriteDashboardLayout} body
      WriteDashboardLayout body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathDashboardLayoutId = encodeParam(dashboardLayoutId);

    DashboardLayout responseHandler(dynamic json, String contentType) {
      return DashboardLayout.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/dashboard_layouts/$pathDashboardLayoutId',
        {'fields': fields}, body?.toJson());
  }

  /// ### Delete a dashboard layout with a specific id.
  ///
  /// DELETE /dashboard_layouts/{dashboard_layout_id} -> String
  Future<SDKResponse<String>> deleteDashboardLayout(

      /// @param {String} dashboard_layout_id Id of dashboard layout
      String dashboardLayoutId) async {
    var pathDashboardLayoutId = encodeParam(dashboardLayoutId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/dashboard_layouts/$pathDashboardLayoutId');
  }

  /// ### Get information about all the dashboard elements on a dashboard with a specific id.
  ///
  /// GET /dashboards/{dashboard_id}/dashboard_layouts -> List<DashboardLayout>
  Future<SDKResponse<List<DashboardLayout>>> dashboardDashboardLayouts(

      /// @param {String} dashboard_id Id of dashboard
      String dashboardId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathDashboardId = encodeParam(dashboardId);

    List<DashboardLayout> responseHandler(dynamic json, String contentType) {
      return json
          .map<DashboardLayout>(
              (i) => DashboardLayout.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler,
        '/dashboards/$pathDashboardId/dashboard_layouts', {'fields': fields});
  }

  /// ### Create a dashboard layout on the dashboard with a specific id.
  ///
  /// POST /dashboard_layouts -> DashboardLayout
  Future<SDKResponse<DashboardLayout>> createDashboardLayout(

      /// @param {WriteDashboardLayout} body
      WriteDashboardLayout body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    DashboardLayout responseHandler(dynamic json, String contentType) {
      return DashboardLayout.fromResponse(json, contentType);
    }

    return post(responseHandler, '/dashboard_layouts', {'fields': fields},
        body?.toJson());
  }

  // #endregion Dashboard: Manage Dashboards

  // #region DataAction: Run Data Actions

  /// Perform a data action. The data action object can be obtained from query results, and used to perform an arbitrary action.
  ///
  /// POST /data_actions -> DataActionResponse
  Future<SDKResponse<DataActionResponse>> performDataAction(

      /// @param {DataActionRequest} body
      DataActionRequest body) async {
    DataActionResponse responseHandler(dynamic json, String contentType) {
      return DataActionResponse.fromResponse(json, contentType);
    }

    return post(responseHandler, '/data_actions', null, body?.toJson());
  }

  /// For some data actions, the remote server may supply a form requesting further user input. This endpoint takes a data action, asks the remote server to generate a form for it, and returns that form to you for presentation to the user.
  ///
  /// POST /data_actions/form -> DataActionForm
  Future<SDKResponse<DataActionForm>> fetchRemoteDataActionForm(

      /// @param {Map<String,dynamic>} body
      Map<String, dynamic> body) async {
    DataActionForm responseHandler(dynamic json, String contentType) {
      return DataActionForm.fromResponse(json, contentType);
    }

    return post(responseHandler, '/data_actions/form', null, body);
  }

  // #endregion DataAction: Run Data Actions

  // #region Datagroup: Manage Datagroups

  /// ### Get information about all datagroups.
  ///
  /// GET /datagroups -> List<Datagroup>
  Future<SDKResponse<List<Datagroup>>> allDatagroups() async {
    List<Datagroup> responseHandler(dynamic json, String contentType) {
      return json
          .map<Datagroup>((i) => Datagroup.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/datagroups');
  }

  /// ### Get information about a datagroup.
  ///
  /// GET /datagroups/{datagroup_id} -> Datagroup
  Future<SDKResponse<Datagroup>> datagroup(

      /// @param {int} datagroup_id ID of datagroup.
      int datagroupId) async {
    var pathDatagroupId = encodeParam(datagroupId);

    Datagroup responseHandler(dynamic json, String contentType) {
      return Datagroup.fromResponse(json, contentType);
    }

    return get(responseHandler, '/datagroups/$pathDatagroupId');
  }

  /// ### Update a datagroup using the specified params.
  ///
  /// PATCH /datagroups/{datagroup_id} -> Datagroup
  Future<SDKResponse<Datagroup>> updateDatagroup(

      /// @param {int} datagroup_id ID of datagroup.
      int datagroupId,

      /// @param {WriteDatagroup} body
      WriteDatagroup body) async {
    var pathDatagroupId = encodeParam(datagroupId);

    Datagroup responseHandler(dynamic json, String contentType) {
      return Datagroup.fromResponse(json, contentType);
    }

    return patch(
        responseHandler, '/datagroups/$pathDatagroupId', null, body?.toJson());
  }

  // #endregion Datagroup: Manage Datagroups

  // #region DerivedTable: View Derived Table graphs

  /// ### Discover information about derived tables
  ///
  /// GET /derived_table/graph/model/{model} -> DependencyGraph
  Future<SDKResponse<DependencyGraph>> graphDerivedTablesForModel(

      /// @param {String} model The name of the Lookml model.
      String model,
      {

      /// @param {String} format The format of the graph. Valid values are [dot]. Default is `dot`
      String format,

      /// @param {String} color Color denoting the build status of the graph. Grey = not built, green = built, yellow = building, red = error.
      String color}) async {
    var pathModel = encodeParam(model);

    DependencyGraph responseHandler(dynamic json, String contentType) {
      return DependencyGraph.fromResponse(json, contentType);
    }

    return get(responseHandler, '/derived_table/graph/model/$pathModel',
        {'format': format, 'color': color});
  }

  /// ### Get the subgraph representing this derived table and its dependencies.
  ///
  /// GET /derived_table/graph/view/{view} -> DependencyGraph
  Future<SDKResponse<DependencyGraph>> graphDerivedTablesForView(

      /// @param {String} view The derived table's view name.
      String view,
      {

      /// @param {String} models The models where this derived table is defined.
      String models,

      /// @param {String} workspace The model directory to look in, either `dev` or `production`.
      String workspace}) async {
    var pathView = encodeParam(view);

    DependencyGraph responseHandler(dynamic json, String contentType) {
      return DependencyGraph.fromResponse(json, contentType);
    }

    return get(responseHandler, '/derived_table/graph/view/$pathView',
        {'models': models, 'workspace': workspace});
  }

  // #endregion DerivedTable: View Derived Table graphs

  // #region Folder: Manage Folders

  /// Search for folders by creator id, parent id, name, etc
  ///
  /// GET /folders/search -> List<Folder>
  Future<SDKResponse<List<Folder>>> searchFolders(
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {int} page Requested page.
      int page,

      /// @param {int} per_page Results per page.
      int perPage,

      /// @param {int} limit Number of results to return. (used with offset and takes priority over page and per_page)
      int limit,

      /// @param {int} offset Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
      int offset,

      /// @param {String} sorts Fields to sort by.
      String sorts,

      /// @param {String} name Match Space title.
      String name,

      /// @param {int} id Match Space id
      int id,

      /// @param {String} parent_id Filter on a children of a particular folder.
      String parentId,

      /// @param {String} creator_id Filter on folder created by a particular user.
      String creatorId,

      /// @param {bool} filter_or Combine given search criteria in a boolean OR expression
      bool filterOr,

      /// @param {bool} is_shared_root Match is shared root
      bool isSharedRoot}) async {
    List<Folder> responseHandler(dynamic json, String contentType) {
      return json
          .map<Folder>((i) => Folder.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/folders/search', {
      'fields': fields,
      'page': page,
      'per_page': perPage,
      'limit': limit,
      'offset': offset,
      'sorts': sorts,
      'name': name,
      'id': id,
      'parent_id': parentId,
      'creator_id': creatorId,
      'filter_or': filterOr,
      'is_shared_root': isSharedRoot
    });
  }

  /// ### Get information about the folder with a specific id.
  ///
  /// GET /folders/{folder_id} -> Folder
  Future<SDKResponse<Folder>> folder(

      /// @param {String} folder_id Id of folder
      String folderId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathFolderId = encodeParam(folderId);

    Folder responseHandler(dynamic json, String contentType) {
      return Folder.fromResponse(json, contentType);
    }

    return get(responseHandler, '/folders/$pathFolderId', {'fields': fields});
  }

  /// ### Update the folder with a specific id.
  ///
  /// PATCH /folders/{folder_id} -> Folder
  Future<SDKResponse<Folder>> updateFolder(

      /// @param {String} folder_id Id of folder
      String folderId,

      /// @param {UpdateFolder} body
      UpdateFolder body) async {
    var pathFolderId = encodeParam(folderId);

    Folder responseHandler(dynamic json, String contentType) {
      return Folder.fromResponse(json, contentType);
    }

    return patch(
        responseHandler, '/folders/$pathFolderId', null, body?.toJson());
  }

  /// ### Delete the folder with a specific id including any children folders.
  /// **DANGER** this will delete all looks and dashboards in the folder.
  ///
  /// DELETE /folders/{folder_id} -> String
  Future<SDKResponse<String>> deleteFolder(

      /// @param {String} folder_id Id of folder
      String folderId) async {
    var pathFolderId = encodeParam(folderId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/folders/$pathFolderId');
  }

  /// ### Get information about all folders.
  ///
  /// In API 3.x, this will not return empty personal folders, unless they belong to the calling user,
  /// or if they contain soft-deleted content.
  ///
  /// In API 4.0+, all personal folders will be returned.
  ///
  /// GET /folders -> List<Folder>
  Future<SDKResponse<List<Folder>>> allFolders(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<Folder> responseHandler(dynamic json, String contentType) {
      return json
          .map<Folder>((i) => Folder.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/folders', {'fields': fields});
  }

  /// ### Create a folder with specified information.
  ///
  /// Caller must have permission to edit the parent folder and to create folders, otherwise the request
  /// returns 404 Not Found.
  ///
  /// POST /folders -> Folder
  Future<SDKResponse<Folder>> createFolder(

      /// @param {CreateFolder} body
      CreateFolder body) async {
    Folder responseHandler(dynamic json, String contentType) {
      return Folder.fromResponse(json, contentType);
    }

    return post(responseHandler, '/folders', null, body?.toJson());
  }

  /// ### Get the children of a folder.
  ///
  /// GET /folders/{folder_id}/children -> List<Folder>
  Future<SDKResponse<List<Folder>>> folderChildren(

      /// @param {String} folder_id Id of folder
      String folderId,
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {int} page Requested page.
      int page,

      /// @param {int} per_page Results per page.
      int perPage,

      /// @param {String} sorts Fields to sort by.
      String sorts}) async {
    var pathFolderId = encodeParam(folderId);

    List<Folder> responseHandler(dynamic json, String contentType) {
      return json
          .map<Folder>((i) => Folder.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/folders/$pathFolderId/children',
        {'fields': fields, 'page': page, 'per_page': perPage, 'sorts': sorts});
  }

  /// ### Search the children of a folder
  ///
  /// GET /folders/{folder_id}/children/search -> List<Folder>
  Future<SDKResponse<List<Folder>>> folderChildrenSearch(

      /// @param {String} folder_id Id of folder
      String folderId,
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {String} sorts Fields to sort by.
      String sorts,

      /// @param {String} name Match folder name.
      String name}) async {
    var pathFolderId = encodeParam(folderId);

    List<Folder> responseHandler(dynamic json, String contentType) {
      return json
          .map<Folder>((i) => Folder.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/folders/$pathFolderId/children/search',
        {'fields': fields, 'sorts': sorts, 'name': name});
  }

  /// ### Get the parent of a folder
  ///
  /// GET /folders/{folder_id}/parent -> Folder
  Future<SDKResponse<Folder>> folderParent(

      /// @param {String} folder_id Id of folder
      String folderId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathFolderId = encodeParam(folderId);

    Folder responseHandler(dynamic json, String contentType) {
      return Folder.fromResponse(json, contentType);
    }

    return get(
        responseHandler, '/folders/$pathFolderId/parent', {'fields': fields});
  }

  /// ### Get the ancestors of a folder
  ///
  /// GET /folders/{folder_id}/ancestors -> List<Folder>
  Future<SDKResponse<List<Folder>>> folderAncestors(

      /// @param {String} folder_id Id of folder
      String folderId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathFolderId = encodeParam(folderId);

    List<Folder> responseHandler(dynamic json, String contentType) {
      return json
          .map<Folder>((i) => Folder.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/folders/$pathFolderId/ancestors',
        {'fields': fields});
  }

  /// ### Get all looks in a folder.
  /// In API 3.x, this will return all looks in a folder, including looks in the trash.
  /// In API 4.0+, all looks in a folder will be returned, excluding looks in the trash.
  ///
  /// GET /folders/{folder_id}/looks -> List<LookWithQuery>
  Future<SDKResponse<List<LookWithQuery>>> folderLooks(

      /// @param {String} folder_id Id of folder
      String folderId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathFolderId = encodeParam(folderId);

    List<LookWithQuery> responseHandler(dynamic json, String contentType) {
      return json
          .map<LookWithQuery>((i) => LookWithQuery.fromResponse(i, contentType))
          .toList();
    }

    return get(
        responseHandler, '/folders/$pathFolderId/looks', {'fields': fields});
  }

  /// ### Get the dashboards in a folder
  ///
  /// GET /folders/{folder_id}/dashboards -> List<Dashboard>
  Future<SDKResponse<List<Dashboard>>> folderDashboards(

      /// @param {String} folder_id Id of folder
      String folderId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathFolderId = encodeParam(folderId);

    List<Dashboard> responseHandler(dynamic json, String contentType) {
      return json
          .map<Dashboard>((i) => Dashboard.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/folders/$pathFolderId/dashboards',
        {'fields': fields});
  }

  // #endregion Folder: Manage Folders

  // #region Group: Manage Groups

  /// ### Get information about all groups.
  ///
  /// GET /groups -> List<Group>
  Future<SDKResponse<List<Group>>> allGroups(
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {int} page Requested page.
      int page,

      /// @param {int} per_page Results per page.
      int perPage,

      /// @param {String} sorts Fields to sort by.
      String sorts,

      /// @param {DelimList<int>} ids Optional of ids to get specific groups.
      DelimList<int> ids,

      /// @param {int} content_metadata_id Id of content metadata to which groups must have access.
      int contentMetadataId,

      /// @param {bool} can_add_to_content_metadata Select only groups that either can/cannot be given access to content.
      bool canAddToContentMetadata}) async {
    List<Group> responseHandler(dynamic json, String contentType) {
      return json
          .map<Group>((i) => Group.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/groups', {
      'fields': fields,
      'page': page,
      'per_page': perPage,
      'sorts': sorts,
      'ids': ids,
      'content_metadata_id': contentMetadataId,
      'can_add_to_content_metadata': canAddToContentMetadata
    });
  }

  /// ### Creates a new group (admin only).
  ///
  /// POST /groups -> Group
  Future<SDKResponse<Group>> createGroup(

      /// @param {WriteGroup} body
      WriteGroup body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    Group responseHandler(dynamic json, String contentType) {
      return Group.fromResponse(json, contentType);
    }

    return post(responseHandler, '/groups', {'fields': fields}, body?.toJson());
  }

  /// ### Search groups
  ///
  /// Returns all group records that match the given search criteria.
  ///
  /// If multiple search params are given and `filter_or` is FALSE or not specified,
  /// search params are combined in a logical AND operation.
  /// Only rows that match *all* search param criteria will be returned.
  ///
  /// If `filter_or` is TRUE, multiple search params are combined in a logical OR operation.
  /// Results will include rows that match **any** of the search criteria.
  ///
  /// String search params use case-insensitive matching.
  /// String search params can contain `%` and '_' as SQL LIKE pattern match wildcard expressions.
  /// example="dan%" will match "danger" and "Danzig" but not "David"
  /// example="D_m%" will match "Damage" and "dump"
  ///
  /// Integer search params can accept a single value or a comma separated list of values. The multiple
  /// values will be combined under a logical OR operation - results will match at least one of
  /// the given values.
  ///
  /// Most search params can accept "IS NULL" and "NOT NULL" as special expressions to match
  /// or exclude (respectively) rows where the column is null.
  ///
  /// Boolean search params accept only "true" and "false" as values.
  ///
  /// GET /groups/search -> List<Group>
  Future<SDKResponse<List<Group>>> searchGroups(
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {int} limit Number of results to return (used with `offset`).
      int limit,

      /// @param {int} offset Number of results to skip before returning any (used with `limit`).
      int offset,

      /// @param {String} sorts Fields to sort by.
      String sorts,

      /// @param {bool} filter_or Combine given search criteria in a boolean OR expression
      bool filterOr,

      /// @param {int} id Match group id.
      int id,

      /// @param {String} name Match group name.
      String name,

      /// @param {String} external_group_id Match group external_group_id.
      String externalGroupId,

      /// @param {bool} externally_managed Match group externally_managed.
      bool externallyManaged,

      /// @param {bool} externally_orphaned Match group externally_orphaned.
      bool externallyOrphaned}) async {
    List<Group> responseHandler(dynamic json, String contentType) {
      return json
          .map<Group>((i) => Group.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/groups/search', {
      'fields': fields,
      'limit': limit,
      'offset': offset,
      'sorts': sorts,
      'filter_or': filterOr,
      'id': id,
      'name': name,
      'external_group_id': externalGroupId,
      'externally_managed': externallyManaged,
      'externally_orphaned': externallyOrphaned
    });
  }

  /// ### Search groups include roles
  ///
  /// Returns all group records that match the given search criteria, and attaches any associated roles.
  ///
  /// If multiple search params are given and `filter_or` is FALSE or not specified,
  /// search params are combined in a logical AND operation.
  /// Only rows that match *all* search param criteria will be returned.
  ///
  /// If `filter_or` is TRUE, multiple search params are combined in a logical OR operation.
  /// Results will include rows that match **any** of the search criteria.
  ///
  /// String search params use case-insensitive matching.
  /// String search params can contain `%` and '_' as SQL LIKE pattern match wildcard expressions.
  /// example="dan%" will match "danger" and "Danzig" but not "David"
  /// example="D_m%" will match "Damage" and "dump"
  ///
  /// Integer search params can accept a single value or a comma separated list of values. The multiple
  /// values will be combined under a logical OR operation - results will match at least one of
  /// the given values.
  ///
  /// Most search params can accept "IS NULL" and "NOT NULL" as special expressions to match
  /// or exclude (respectively) rows where the column is null.
  ///
  /// Boolean search params accept only "true" and "false" as values.
  ///
  /// GET /groups/search/with_roles -> List<GroupSearch>
  Future<SDKResponse<List<GroupSearch>>> searchGroupsWithRoles(
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {int} limit Number of results to return (used with `offset`).
      int limit,

      /// @param {int} offset Number of results to skip before returning any (used with `limit`).
      int offset,

      /// @param {String} sorts Fields to sort by.
      String sorts,

      /// @param {bool} filter_or Combine given search criteria in a boolean OR expression
      bool filterOr,

      /// @param {int} id Match group id.
      int id,

      /// @param {String} name Match group name.
      String name,

      /// @param {String} external_group_id Match group external_group_id.
      String externalGroupId,

      /// @param {bool} externally_managed Match group externally_managed.
      bool externallyManaged,

      /// @param {bool} externally_orphaned Match group externally_orphaned.
      bool externallyOrphaned}) async {
    List<GroupSearch> responseHandler(dynamic json, String contentType) {
      return json
          .map<GroupSearch>((i) => GroupSearch.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/groups/search/with_roles', {
      'fields': fields,
      'limit': limit,
      'offset': offset,
      'sorts': sorts,
      'filter_or': filterOr,
      'id': id,
      'name': name,
      'external_group_id': externalGroupId,
      'externally_managed': externallyManaged,
      'externally_orphaned': externallyOrphaned
    });
  }

  /// ### Search groups include hierarchy
  ///
  /// Returns all group records that match the given search criteria, and attaches
  /// associated role_ids and parent group_ids.
  ///
  /// If multiple search params are given and `filter_or` is FALSE or not specified,
  /// search params are combined in a logical AND operation.
  /// Only rows that match *all* search param criteria will be returned.
  ///
  /// If `filter_or` is TRUE, multiple search params are combined in a logical OR operation.
  /// Results will include rows that match **any** of the search criteria.
  ///
  /// String search params use case-insensitive matching.
  /// String search params can contain `%` and '_' as SQL LIKE pattern match wildcard expressions.
  /// example="dan%" will match "danger" and "Danzig" but not "David"
  /// example="D_m%" will match "Damage" and "dump"
  ///
  /// Integer search params can accept a single value or a comma separated list of values. The multiple
  /// values will be combined under a logical OR operation - results will match at least one of
  /// the given values.
  ///
  /// Most search params can accept "IS NULL" and "NOT NULL" as special expressions to match
  /// or exclude (respectively) rows where the column is null.
  ///
  /// Boolean search params accept only "true" and "false" as values.
  ///
  /// GET /groups/search/with_hierarchy -> List<GroupHierarchy>
  Future<SDKResponse<List<GroupHierarchy>>> searchGroupsWithHierarchy(
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {int} limit Number of results to return (used with `offset`).
      int limit,

      /// @param {int} offset Number of results to skip before returning any (used with `limit`).
      int offset,

      /// @param {String} sorts Fields to sort by.
      String sorts,

      /// @param {bool} filter_or Combine given search criteria in a boolean OR expression
      bool filterOr,

      /// @param {int} id Match group id.
      int id,

      /// @param {String} name Match group name.
      String name,

      /// @param {String} external_group_id Match group external_group_id.
      String externalGroupId,

      /// @param {bool} externally_managed Match group externally_managed.
      bool externallyManaged,

      /// @param {bool} externally_orphaned Match group externally_orphaned.
      bool externallyOrphaned}) async {
    List<GroupHierarchy> responseHandler(dynamic json, String contentType) {
      return json
          .map<GroupHierarchy>(
              (i) => GroupHierarchy.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/groups/search/with_hierarchy', {
      'fields': fields,
      'limit': limit,
      'offset': offset,
      'sorts': sorts,
      'filter_or': filterOr,
      'id': id,
      'name': name,
      'external_group_id': externalGroupId,
      'externally_managed': externallyManaged,
      'externally_orphaned': externallyOrphaned
    });
  }

  /// ### Get information about a group.
  ///
  /// GET /groups/{group_id} -> Group
  Future<SDKResponse<Group>> group(

      /// @param {int} group_id Id of group
      int groupId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathGroupId = encodeParam(groupId);

    Group responseHandler(dynamic json, String contentType) {
      return Group.fromResponse(json, contentType);
    }

    return get(responseHandler, '/groups/$pathGroupId', {'fields': fields});
  }

  /// ### Updates the a group (admin only).
  ///
  /// PATCH /groups/{group_id} -> Group
  Future<SDKResponse<Group>> updateGroup(

      /// @param {int} group_id Id of group
      int groupId,

      /// @param {WriteGroup} body
      WriteGroup body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathGroupId = encodeParam(groupId);

    Group responseHandler(dynamic json, String contentType) {
      return Group.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/groups/$pathGroupId', {'fields': fields},
        body?.toJson());
  }

  /// ### Deletes a group (admin only).
  ///
  /// DELETE /groups/{group_id} -> String
  Future<SDKResponse<String>> deleteGroup(

      /// @param {int} group_id Id of group
      int groupId) async {
    var pathGroupId = encodeParam(groupId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/groups/$pathGroupId');
  }

  /// ### Get information about all the groups in a group
  ///
  /// GET /groups/{group_id}/groups -> List<Group>
  Future<SDKResponse<List<Group>>> allGroupGroups(

      /// @param {int} group_id Id of group
      int groupId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathGroupId = encodeParam(groupId);

    List<Group> responseHandler(dynamic json, String contentType) {
      return json
          .map<Group>((i) => Group.fromResponse(i, contentType))
          .toList();
    }

    return get(
        responseHandler, '/groups/$pathGroupId/groups', {'fields': fields});
  }

  /// ### Adds a new group to a group.
  ///
  /// POST /groups/{group_id}/groups -> Group
  Future<SDKResponse<Group>> addGroupGroup(

      /// @param {int} group_id Id of group
      int groupId,

      /// @param {GroupIdForGroupInclusion} body
      GroupIdForGroupInclusion body) async {
    var pathGroupId = encodeParam(groupId);

    Group responseHandler(dynamic json, String contentType) {
      return Group.fromResponse(json, contentType);
    }

    return post(
        responseHandler, '/groups/$pathGroupId/groups', null, body?.toJson());
  }

  /// ### Get information about all the users directly included in a group.
  ///
  /// GET /groups/{group_id}/users -> List<User>
  Future<SDKResponse<List<User>>> allGroupUsers(

      /// @param {int} group_id Id of group
      int groupId,
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {int} page Requested page.
      int page,

      /// @param {int} per_page Results per page.
      int perPage,

      /// @param {String} sorts Fields to sort by.
      String sorts}) async {
    var pathGroupId = encodeParam(groupId);

    List<User> responseHandler(dynamic json, String contentType) {
      return json.map<User>((i) => User.fromResponse(i, contentType)).toList();
    }

    return get(responseHandler, '/groups/$pathGroupId/users',
        {'fields': fields, 'page': page, 'per_page': perPage, 'sorts': sorts});
  }

  /// ### Adds a new user to a group.
  ///
  /// POST /groups/{group_id}/users -> User
  Future<SDKResponse<User>> addGroupUser(

      /// @param {int} group_id Id of group
      int groupId,

      /// @param {GroupIdForGroupUserInclusion} body
      GroupIdForGroupUserInclusion body) async {
    var pathGroupId = encodeParam(groupId);

    User responseHandler(dynamic json, String contentType) {
      return User.fromResponse(json, contentType);
    }

    return post(
        responseHandler, '/groups/$pathGroupId/users', null, body?.toJson());
  }

  /// ### Removes a user from a group.
  ///
  /// DELETE /groups/{group_id}/users/{user_id} -> void
  Future<SDKResponse<void>> deleteGroupUser(

      /// @param {int} group_id Id of group
      int groupId,

      /// @param {int} user_id Id of user to remove from group
      int userId) async {
    var pathGroupId = encodeParam(groupId);
    var pathUserId = encodeParam(userId);

    void responseHandler(dynamic json, String contentType) {}
    return delete(responseHandler, '/groups/$pathGroupId/users/$pathUserId');
  }

  /// ### Removes a group from a group.
  ///
  /// DELETE /groups/{group_id}/groups/{deleting_group_id} -> void
  Future<SDKResponse<void>> deleteGroupFromGroup(

      /// @param {int} group_id Id of group
      int groupId,

      /// @param {int} deleting_group_id Id of group to delete
      int deletingGroupId) async {
    var pathGroupId = encodeParam(groupId);
    var pathDeletingGroupId = encodeParam(deletingGroupId);

    void responseHandler(dynamic json, String contentType) {}
    return delete(
        responseHandler, '/groups/$pathGroupId/groups/$pathDeletingGroupId');
  }

  /// ### Set the value of a user attribute for a group.
  ///
  /// For information about how user attribute values are calculated, see [Set User Attribute Group Values](#!/UserAttribute/set_user_attribute_group_values).
  ///
  /// PATCH /groups/{group_id}/attribute_values/{user_attribute_id} -> UserAttributeGroupValue
  Future<SDKResponse<UserAttributeGroupValue>> updateUserAttributeGroupValue(

      /// @param {int} group_id Id of group
      int groupId,

      /// @param {int} user_attribute_id Id of user attribute
      int userAttributeId,

      /// @param {UserAttributeGroupValue} body
      UserAttributeGroupValue body) async {
    var pathGroupId = encodeParam(groupId);
    var pathUserAttributeId = encodeParam(userAttributeId);

    UserAttributeGroupValue responseHandler(dynamic json, String contentType) {
      return UserAttributeGroupValue.fromResponse(json, contentType);
    }

    return patch(
        responseHandler,
        '/groups/$pathGroupId/attribute_values/$pathUserAttributeId',
        null,
        body?.toJson());
  }

  /// ### Remove a user attribute value from a group.
  ///
  /// DELETE /groups/{group_id}/attribute_values/{user_attribute_id} -> void
  Future<SDKResponse<void>> deleteUserAttributeGroupValue(

      /// @param {int} group_id Id of group
      int groupId,

      /// @param {int} user_attribute_id Id of user attribute
      int userAttributeId) async {
    var pathGroupId = encodeParam(groupId);
    var pathUserAttributeId = encodeParam(userAttributeId);

    void responseHandler(dynamic json, String contentType) {}
    return delete(responseHandler,
        '/groups/$pathGroupId/attribute_values/$pathUserAttributeId');
  }

  // #endregion Group: Manage Groups

  // #region Homepage: Manage Homepage

  /// ### Get information about the primary homepage's sections.
  ///
  /// GET /primary_homepage_sections -> List<HomepageSection>
  Future<SDKResponse<List<HomepageSection>>> allPrimaryHomepageSections(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<HomepageSection> responseHandler(dynamic json, String contentType) {
      return json
          .map<HomepageSection>(
              (i) => HomepageSection.fromResponse(i, contentType))
          .toList();
    }

    return get(
        responseHandler, '/primary_homepage_sections', {'fields': fields});
  }

  // #endregion Homepage: Manage Homepage

  // #region Integration: Manage Integrations

  /// ### Get information about all Integration Hubs.
  ///
  /// GET /integration_hubs -> List<IntegrationHub>
  Future<SDKResponse<List<IntegrationHub>>> allIntegrationHubs(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<IntegrationHub> responseHandler(dynamic json, String contentType) {
      return json
          .map<IntegrationHub>(
              (i) => IntegrationHub.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/integration_hubs', {'fields': fields});
  }

  /// ### Create a new Integration Hub.
  ///
  /// This API is rate limited to prevent it from being used for SSRF attacks
  ///
  /// POST /integration_hubs -> IntegrationHub
  Future<SDKResponse<IntegrationHub>> createIntegrationHub(

      /// @param {WriteIntegrationHub} body
      WriteIntegrationHub body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    IntegrationHub responseHandler(dynamic json, String contentType) {
      return IntegrationHub.fromResponse(json, contentType);
    }

    return post(responseHandler, '/integration_hubs', {'fields': fields},
        body?.toJson());
  }

  /// ### Get information about a Integration Hub.
  ///
  /// GET /integration_hubs/{integration_hub_id} -> IntegrationHub
  Future<SDKResponse<IntegrationHub>> integrationHub(

      /// @param {int} integration_hub_id Id of Integration Hub
      int integrationHubId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathIntegrationHubId = encodeParam(integrationHubId);

    IntegrationHub responseHandler(dynamic json, String contentType) {
      return IntegrationHub.fromResponse(json, contentType);
    }

    return get(responseHandler, '/integration_hubs/$pathIntegrationHubId',
        {'fields': fields});
  }

  /// ### Update a Integration Hub definition.
  ///
  /// This API is rate limited to prevent it from being used for SSRF attacks
  ///
  /// PATCH /integration_hubs/{integration_hub_id} -> IntegrationHub
  Future<SDKResponse<IntegrationHub>> updateIntegrationHub(

      /// @param {int} integration_hub_id Id of Integration Hub
      int integrationHubId,

      /// @param {WriteIntegrationHub} body
      WriteIntegrationHub body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathIntegrationHubId = encodeParam(integrationHubId);

    IntegrationHub responseHandler(dynamic json, String contentType) {
      return IntegrationHub.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/integration_hubs/$pathIntegrationHubId',
        {'fields': fields}, body?.toJson());
  }

  /// ### Delete a Integration Hub.
  ///
  /// DELETE /integration_hubs/{integration_hub_id} -> String
  Future<SDKResponse<String>> deleteIntegrationHub(

      /// @param {int} integration_hub_id Id of integration_hub
      int integrationHubId) async {
    var pathIntegrationHubId = encodeParam(integrationHubId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/integration_hubs/$pathIntegrationHubId');
  }

  /// Accepts the legal agreement for a given integration hub. This only works for integration hubs that have legal_agreement_required set to true and legal_agreement_signed set to false.
  ///
  /// POST /integration_hubs/{integration_hub_id}/accept_legal_agreement -> IntegrationHub
  Future<SDKResponse<IntegrationHub>> acceptIntegrationHubLegalAgreement(

      /// @param {int} integration_hub_id Id of integration_hub
      int integrationHubId) async {
    var pathIntegrationHubId = encodeParam(integrationHubId);

    IntegrationHub responseHandler(dynamic json, String contentType) {
      return IntegrationHub.fromResponse(json, contentType);
    }

    return post(responseHandler,
        '/integration_hubs/$pathIntegrationHubId/accept_legal_agreement');
  }

  /// ### Get information about all Integrations.
  ///
  /// GET /integrations -> List<Integration>
  Future<SDKResponse<List<Integration>>> allIntegrations(
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {String} integration_hub_id Filter to a specific provider
      String integrationHubId}) async {
    List<Integration> responseHandler(dynamic json, String contentType) {
      return json
          .map<Integration>((i) => Integration.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/integrations',
        {'fields': fields, 'integration_hub_id': integrationHubId});
  }

  /// ### Get information about a Integration.
  ///
  /// GET /integrations/{integration_id} -> Integration
  Future<SDKResponse<Integration>> integration(

      /// @param {String} integration_id Id of integration
      String integrationId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathIntegrationId = encodeParam(integrationId);

    Integration responseHandler(dynamic json, String contentType) {
      return Integration.fromResponse(json, contentType);
    }

    return get(responseHandler, '/integrations/$pathIntegrationId',
        {'fields': fields});
  }

  /// ### Update parameters on a Integration.
  ///
  /// PATCH /integrations/{integration_id} -> Integration
  Future<SDKResponse<Integration>> updateIntegration(

      /// @param {String} integration_id Id of integration
      String integrationId,

      /// @param {WriteIntegration} body
      WriteIntegration body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathIntegrationId = encodeParam(integrationId);

    Integration responseHandler(dynamic json, String contentType) {
      return Integration.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/integrations/$pathIntegrationId',
        {'fields': fields}, body?.toJson());
  }

  /// Returns the Integration form for presentation to the user.
  ///
  /// POST /integrations/{integration_id}/form -> DataActionForm
  Future<SDKResponse<DataActionForm>> fetchIntegrationForm(

      /// @param {String} integration_id Id of integration
      String integrationId,
      {

      /// @param {Map<String,dynamic>} body
      Map<String, dynamic> body}) async {
    var pathIntegrationId = encodeParam(integrationId);

    DataActionForm responseHandler(dynamic json, String contentType) {
      return DataActionForm.fromResponse(json, contentType);
    }

    return post(
        responseHandler, '/integrations/$pathIntegrationId/form', null, body);
  }

  /// Tests the integration to make sure all the settings are working.
  ///
  /// POST /integrations/{integration_id}/test -> IntegrationTestResult
  Future<SDKResponse<IntegrationTestResult>> testIntegration(

      /// @param {String} integration_id Id of integration
      String integrationId) async {
    var pathIntegrationId = encodeParam(integrationId);

    IntegrationTestResult responseHandler(dynamic json, String contentType) {
      return IntegrationTestResult.fromResponse(json, contentType);
    }

    return post(responseHandler, '/integrations/$pathIntegrationId/test');
  }

  // #endregion Integration: Manage Integrations

  // #region Look: Run and Manage Looks

  /// ### Get information about all active Looks
  ///
  /// Returns an array of **abbreviated Look objects** describing all the looks that the caller has access to. Soft-deleted Looks are **not** included.
  ///
  /// Get the **full details** of a specific look by id with [look(id)](#!/Look/look)
  ///
  /// Find **soft-deleted looks** with [search_looks()](#!/Look/search_looks)
  ///
  /// GET /looks -> List<Look>
  Future<SDKResponse<List<Look>>> allLooks(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<Look> responseHandler(dynamic json, String contentType) {
      return json.map<Look>((i) => Look.fromResponse(i, contentType)).toList();
    }

    return get(responseHandler, '/looks', {'fields': fields});
  }

  /// ### Create a Look
  ///
  /// To create a look to display query data, first create the query with [create_query()](#!/Query/create_query)
  /// then assign the query's id to the `query_id` property in the call to `create_look()`.
  ///
  /// To place the look into a particular space, assign the space's id to the `space_id` property
  /// in the call to `create_look()`.
  ///
  /// POST /looks -> LookWithQuery
  Future<SDKResponse<LookWithQuery>> createLook(

      /// @param {WriteLookWithQuery} body
      WriteLookWithQuery body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    LookWithQuery responseHandler(dynamic json, String contentType) {
      return LookWithQuery.fromResponse(json, contentType);
    }

    return post(responseHandler, '/looks', {'fields': fields}, body?.toJson());
  }

  /// ### Search Looks
  ///
  /// Returns an **array of Look objects** that match the specified search criteria.
  ///
  /// If multiple search params are given and `filter_or` is FALSE or not specified,
  /// search params are combined in a logical AND operation.
  /// Only rows that match *all* search param criteria will be returned.
  ///
  /// If `filter_or` is TRUE, multiple search params are combined in a logical OR operation.
  /// Results will include rows that match **any** of the search criteria.
  ///
  /// String search params use case-insensitive matching.
  /// String search params can contain `%` and '_' as SQL LIKE pattern match wildcard expressions.
  /// example="dan%" will match "danger" and "Danzig" but not "David"
  /// example="D_m%" will match "Damage" and "dump"
  ///
  /// Integer search params can accept a single value or a comma separated list of values. The multiple
  /// values will be combined under a logical OR operation - results will match at least one of
  /// the given values.
  ///
  /// Most search params can accept "IS NULL" and "NOT NULL" as special expressions to match
  /// or exclude (respectively) rows where the column is null.
  ///
  /// Boolean search params accept only "true" and "false" as values.
  ///
  ///
  /// Get a **single look** by id with [look(id)](#!/Look/look)
  ///
  /// GET /looks/search -> List<Look>
  Future<SDKResponse<List<Look>>> searchLooks(
      {

      /// @param {String} id Match look id.
      String id,

      /// @param {String} title Match Look title.
      String title,

      /// @param {String} description Match Look description.
      String description,

      /// @param {String} content_favorite_id Select looks with a particular content favorite id
      String contentFavoriteId,

      /// @param {String} folder_id Select looks in a particular folder.
      String folderId,

      /// @param {String} user_id Select looks created by a particular user.
      String userId,

      /// @param {String} view_count Select looks with particular view_count value
      String viewCount,

      /// @param {bool} deleted Select soft-deleted looks
      bool deleted,

      /// @param {int} query_id Select looks that reference a particular query by query_id
      int queryId,

      /// @param {bool} curate Exclude items that exist only in personal spaces other than the users
      bool curate,

      /// @param {String} last_viewed_at Select looks based on when they were last viewed
      String lastViewedAt,

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {int} page Requested page.
      int page,

      /// @param {int} per_page Results per page.
      int perPage,

      /// @param {int} limit Number of results to return. (used with offset and takes priority over page and per_page)
      int limit,

      /// @param {int} offset Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
      int offset,

      /// @param {String} sorts One or more fields to sort results by. Sortable fields: [:title, :user_id, :id, :created_at, :space_id, :folder_id, :description, :updated_at, :last_updater_id, :view_count, :favorite_count, :content_favorite_id, :deleted, :deleted_at, :last_viewed_at, :last_accessed_at, :query_id]
      String sorts,

      /// @param {bool} filter_or Combine given search criteria in a boolean OR expression
      bool filterOr}) async {
    List<Look> responseHandler(dynamic json, String contentType) {
      return json.map<Look>((i) => Look.fromResponse(i, contentType)).toList();
    }

    return get(responseHandler, '/looks/search', {
      'id': id,
      'title': title,
      'description': description,
      'content_favorite_id': contentFavoriteId,
      'folder_id': folderId,
      'user_id': userId,
      'view_count': viewCount,
      'deleted': deleted,
      'query_id': queryId,
      'curate': curate,
      'last_viewed_at': lastViewedAt,
      'fields': fields,
      'page': page,
      'per_page': perPage,
      'limit': limit,
      'offset': offset,
      'sorts': sorts,
      'filter_or': filterOr
    });
  }

  /// ### Get a Look.
  ///
  /// Returns detailed information about a Look and its associated Query.
  ///
  /// GET /looks/{look_id} -> LookWithQuery
  Future<SDKResponse<LookWithQuery>> look(

      /// @param {String} look_id Id of look
      String lookId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathLookId = encodeParam(lookId);

    LookWithQuery responseHandler(dynamic json, String contentType) {
      return LookWithQuery.fromResponse(json, contentType);
    }

    return get(responseHandler, '/looks/$pathLookId', {'fields': fields});
  }

  /// ### Modify a Look
  ///
  /// Use this function to modify parts of a look. Property values given in a call to `update_look` are
  /// applied to the existing look, so there's no need to include properties whose values are not changing.
  /// It's best to specify only the properties you want to change and leave everything else out
  /// of your `update_look` call. **Look properties marked 'read-only' will be ignored.**
  ///
  /// When a user deletes a look in the Looker UI, the look data remains in the database but is
  /// marked with a deleted flag ("soft-deleted"). Soft-deleted looks can be undeleted (by an admin)
  /// if the delete was in error.
  ///
  /// To soft-delete a look via the API, use [update_look()](#!/Look/update_look) to change the look's `deleted` property to `true`.
  /// You can undelete a look by calling `update_look` to change the look's `deleted` property to `false`.
  ///
  /// Soft-deleted looks are excluded from the results of [all_looks()](#!/Look/all_looks) and [search_looks()](#!/Look/search_looks), so they
  /// essentially disappear from view even though they still reside in the db.
  /// In API 3.1 and later, you can pass `deleted: true` as a parameter to [search_looks()](#!/3.1/Look/search_looks) to list soft-deleted looks.
  ///
  /// NOTE: [delete_look()](#!/Look/delete_look) performs a "hard delete" - the look data is removed from the Looker
  /// database and destroyed. There is no "undo" for `delete_look()`.
  ///
  /// PATCH /looks/{look_id} -> LookWithQuery
  Future<SDKResponse<LookWithQuery>> updateLook(

      /// @param {String} look_id Id of look
      String lookId,

      /// @param {WriteLookWithQuery} body
      WriteLookWithQuery body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathLookId = encodeParam(lookId);

    LookWithQuery responseHandler(dynamic json, String contentType) {
      return LookWithQuery.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/looks/$pathLookId', {'fields': fields},
        body?.toJson());
  }

  /// ### Permanently Delete a Look
  ///
  /// This operation **permanently** removes a look from the Looker database.
  ///
  /// NOTE: There is no "undo" for this kind of delete.
  ///
  /// For information about soft-delete (which can be undone) see [update_look()](#!/Look/update_look).
  ///
  /// DELETE /looks/{look_id} -> String
  Future<SDKResponse<String>> deleteLook(

      /// @param {String} look_id Id of look
      String lookId) async {
    var pathLookId = encodeParam(lookId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/looks/$pathLookId');
  }

  /// ### Run a Look
  ///
  /// Runs a given look's query and returns the results in the requested format.
  ///
  /// Supported formats:
  ///
  /// | result_format | Description
  /// | :-----------: | :--- |
  /// | json | Plain json
  /// | json_detail | Row data plus metadata describing the fields, pivots, table calcs, and other aspects of the query
  /// | csv | Comma separated values with a header
  /// | txt | Tab separated values with a header
  /// | html | Simple html
  /// | md | Simple markdown
  /// | xlsx | MS Excel spreadsheet
  /// | sql | Returns the generated SQL rather than running the query
  /// | png | A PNG image of the visualization of the query
  /// | jpg | A JPG image of the visualization of the query
  ///
  /// GET /looks/{look_id}/run/{result_format} -> String
  ///
  /// **Note**: Binary content may be returned by this method.
  Future<SDKResponse<dynamic>> runLook(

      /// @param {String} look_id Id of look
      String lookId,

      /// @param {String} result_format Format of result
      String resultFormat,
      {

      /// @param {int} limit Row limit (may override the limit in the saved query).
      int limit,

      /// @param {bool} apply_formatting Apply model-specified formatting to each result.
      bool applyFormatting,

      /// @param {bool} apply_vis Apply visualization options to results.
      bool applyVis,

      /// @param {bool} cache Get results from cache if available.
      bool cache,

      /// @param {int} image_width Render width for image formats.
      int imageWidth,

      /// @param {int} image_height Render height for image formats.
      int imageHeight,

      /// @param {bool} generate_drill_links Generate drill links (only applicable to 'json_detail' format.
      bool generateDrillLinks,

      /// @param {bool} force_production Force use of production models even if the user is in development mode.
      bool forceProduction,

      /// @param {bool} cache_only Retrieve any results from cache even if the results have expired.
      bool cacheOnly,

      /// @param {String} path_prefix Prefix to use for drill links (url encoded).
      String pathPrefix,

      /// @param {bool} rebuild_pdts Rebuild PDTS used in query.
      bool rebuildPdts,

      /// @param {bool} server_table_calcs Perform table calculations on query results
      bool serverTableCalcs}) async {
    var pathLookId = encodeParam(lookId);
    var pathResultFormat = encodeParam(resultFormat);

    dynamic responseHandler(dynamic json, String contentType) {
      return json;
    }

    return get(responseHandler, '/looks/$pathLookId/run/$pathResultFormat', {
      'limit': limit,
      'apply_formatting': applyFormatting,
      'apply_vis': applyVis,
      'cache': cache,
      'image_width': imageWidth,
      'image_height': imageHeight,
      'generate_drill_links': generateDrillLinks,
      'force_production': forceProduction,
      'cache_only': cacheOnly,
      'path_prefix': pathPrefix,
      'rebuild_pdts': rebuildPdts,
      'server_table_calcs': serverTableCalcs
    });
  }

  /// ### Copy an existing look
  ///
  /// Creates a copy of an existing look, in a specified folder, and returns the copied look.
  ///
  /// `look_id` and `folder_id` are required.
  ///
  /// `look_id` and `folder_id` must already exist, and `folder_id` must be different from the current `folder_id` of the dashboard.
  ///
  /// POST /looks/{look_id}/copy -> LookWithQuery
  Future<SDKResponse<LookWithQuery>> copyLook(

      /// @param {String} look_id Look id to copy.
      String lookId,
      {

      /// @param {String} folder_id Folder id to copy to.
      String folderId}) async {
    var pathLookId = encodeParam(lookId);

    LookWithQuery responseHandler(dynamic json, String contentType) {
      return LookWithQuery.fromResponse(json, contentType);
    }

    return post(
        responseHandler, '/looks/$pathLookId/copy', {'folder_id': folderId});
  }

  /// ### Move an existing look
  ///
  /// Moves a look to a specified folder, and returns the moved look.
  ///
  /// `look_id` and `folder_id` are required.
  /// `look_id` and `folder_id` must already exist, and `folder_id` must be different from the current `folder_id` of the dashboard.
  ///
  /// PATCH /looks/{look_id}/move -> LookWithQuery
  Future<SDKResponse<LookWithQuery>> moveLook(

      /// @param {String} look_id Look id to move.
      String lookId,

      /// @param {String} folder_id Folder id to move to.
      String folderId) async {
    var pathLookId = encodeParam(lookId);

    LookWithQuery responseHandler(dynamic json, String contentType) {
      return LookWithQuery.fromResponse(json, contentType);
    }

    return patch(
        responseHandler, '/looks/$pathLookId/move', {'folder_id': folderId});
  }

  // #endregion Look: Run and Manage Looks

  // #region LookmlModel: Manage LookML Models

  /// ### Get information about all lookml models.
  ///
  /// GET /lookml_models -> List<LookmlModel>
  Future<SDKResponse<List<LookmlModel>>> allLookmlModels(
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {int} limit Number of results to return. (can be used with offset)
      int limit,

      /// @param {int} offset Number of results to skip before returning any. (Defaults to 0 if not set when limit is used)
      int offset}) async {
    List<LookmlModel> responseHandler(dynamic json, String contentType) {
      return json
          .map<LookmlModel>((i) => LookmlModel.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/lookml_models',
        {'fields': fields, 'limit': limit, 'offset': offset});
  }

  /// ### Create a lookml model using the specified configuration.
  ///
  /// POST /lookml_models -> LookmlModel
  Future<SDKResponse<LookmlModel>> createLookmlModel(

      /// @param {WriteLookmlModel} body
      WriteLookmlModel body) async {
    LookmlModel responseHandler(dynamic json, String contentType) {
      return LookmlModel.fromResponse(json, contentType);
    }

    return post(responseHandler, '/lookml_models', null, body?.toJson());
  }

  /// ### Get information about a lookml model.
  ///
  /// GET /lookml_models/{lookml_model_name} -> LookmlModel
  Future<SDKResponse<LookmlModel>> lookmlModel(

      /// @param {String} lookml_model_name Name of lookml model.
      String lookmlModelName,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathLookmlModelName = encodeParam(lookmlModelName);

    LookmlModel responseHandler(dynamic json, String contentType) {
      return LookmlModel.fromResponse(json, contentType);
    }

    return get(responseHandler, '/lookml_models/$pathLookmlModelName',
        {'fields': fields});
  }

  /// ### Update a lookml model using the specified configuration.
  ///
  /// PATCH /lookml_models/{lookml_model_name} -> LookmlModel
  Future<SDKResponse<LookmlModel>> updateLookmlModel(

      /// @param {String} lookml_model_name Name of lookml model.
      String lookmlModelName,

      /// @param {WriteLookmlModel} body
      WriteLookmlModel body) async {
    var pathLookmlModelName = encodeParam(lookmlModelName);

    LookmlModel responseHandler(dynamic json, String contentType) {
      return LookmlModel.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/lookml_models/$pathLookmlModelName', null,
        body?.toJson());
  }

  /// ### Delete a lookml model.
  ///
  /// DELETE /lookml_models/{lookml_model_name} -> String
  Future<SDKResponse<String>> deleteLookmlModel(

      /// @param {String} lookml_model_name Name of lookml model.
      String lookmlModelName) async {
    var pathLookmlModelName = encodeParam(lookmlModelName);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/lookml_models/$pathLookmlModelName');
  }

  /// ### Get information about a lookml model explore.
  ///
  /// GET /lookml_models/{lookml_model_name}/explores/{explore_name} -> LookmlModelExplore
  Future<SDKResponse<LookmlModelExplore>> lookmlModelExplore(

      /// @param {String} lookml_model_name Name of lookml model.
      String lookmlModelName,

      /// @param {String} explore_name Name of explore.
      String exploreName,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathLookmlModelName = encodeParam(lookmlModelName);
    var pathExploreName = encodeParam(exploreName);

    LookmlModelExplore responseHandler(dynamic json, String contentType) {
      return LookmlModelExplore.fromResponse(json, contentType);
    }

    return get(
        responseHandler,
        '/lookml_models/$pathLookmlModelName/explores/$pathExploreName',
        {'fields': fields});
  }

  // #endregion LookmlModel: Manage LookML Models

  // #region Metadata: Connection Metadata Features

  /// ### Field name suggestions for a model and view
  ///
  /// `filters` is a string hash of values, with the key as the field name and the string value as the filter expression:
  ///
  /// ```ruby
  /// {'users.age': '>=60'}
  /// ```
  ///
  /// or
  ///
  /// ```ruby
  /// {'users.age': '<30'}
  /// ```
  ///
  /// or
  ///
  /// ```ruby
  /// {'users.age': '=50'}
  /// ```
  ///
  /// GET /models/{model_name}/views/{view_name}/fields/{field_name}/suggestions -> ModelFieldSuggestions
  Future<SDKResponse<ModelFieldSuggestions>> modelFieldnameSuggestions(

      /// @param {String} model_name Name of model
      String modelName,

      /// @param {String} view_name Name of view
      String viewName,

      /// @param {String} field_name Name of field to use for suggestions
      String fieldName,
      {

      /// @param {String} term Search term pattern (evaluated as as `%term%`)
      String term,

      /// @param {Map} filters Suggestion filters with field name keys and comparison expressions
      Map filters}) async {
    var pathModelName = encodeParam(modelName);
    var pathViewName = encodeParam(viewName);
    var pathFieldName = encodeParam(fieldName);

    ModelFieldSuggestions responseHandler(dynamic json, String contentType) {
      return ModelFieldSuggestions.fromResponse(json, contentType);
    }

    return get(
        responseHandler,
        '/models/$pathModelName/views/$pathViewName/fields/$pathFieldName/suggestions',
        {'term': term, 'filters': filters});
  }

  /// ### Get a single model
  ///
  /// GET /models/{model_name} -> Model
  Future<SDKResponse<Model>> getModel(

      /// @param {String} model_name Name of model
      String modelName) async {
    var pathModelName = encodeParam(modelName);

    Model responseHandler(dynamic json, String contentType) {
      return Model.fromResponse(json, contentType);
    }

    return get(responseHandler, '/models/$pathModelName');
  }

  /// ### List databases available to this connection
  ///
  /// Certain dialects can support multiple databases per single connection.
  /// If this connection supports multiple databases, the database names will be returned in an array.
  ///
  /// Connections using dialects that do not support multiple databases will return an empty array.
  ///
  /// **Note**: [Connection Features](#!/Metadata/connection_features) can be used to determine if a connection supports
  /// multiple databases.
  ///
  /// GET /connections/{connection_name}/databases -> List<String>
  Future<SDKResponse<List<String>>> connectionDatabases(

      /// @param {String} connection_name Name of connection
      String connectionName) async {
    var pathConnectionName = encodeParam(connectionName);

    List<String> responseHandler(dynamic json, String contentType) {
      return json;
    }

    return get(responseHandler, '/connections/$pathConnectionName/databases');
  }

  /// ### Retrieve metadata features for this connection
  ///
  /// Returns a list of feature names with `true` (available) or `false` (not available)
  ///
  /// GET /connections/{connection_name}/features -> ConnectionFeatures
  Future<SDKResponse<ConnectionFeatures>> connectionFeatures(

      /// @param {String} connection_name Name of connection
      String connectionName,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathConnectionName = encodeParam(connectionName);

    ConnectionFeatures responseHandler(dynamic json, String contentType) {
      return ConnectionFeatures.fromResponse(json, contentType);
    }

    return get(responseHandler, '/connections/$pathConnectionName/features',
        {'fields': fields});
  }

  /// ### Get the list of schemas and tables for a connection
  ///
  /// GET /connections/{connection_name}/schemas -> List<Schema>
  Future<SDKResponse<List<Schema>>> connectionSchemas(

      /// @param {String} connection_name Name of connection
      String connectionName,
      {

      /// @param {String} database For dialects that support multiple databases, optionally identify which to use
      String database,

      /// @param {bool} cache True to use fetch from cache, false to load fresh
      bool cache,

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathConnectionName = encodeParam(connectionName);

    List<Schema> responseHandler(dynamic json, String contentType) {
      return json
          .map<Schema>((i) => Schema.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/connections/$pathConnectionName/schemas',
        {'database': database, 'cache': cache, 'fields': fields});
  }

  /// ### Get the list of tables for a schema
  ///
  /// For dialects that support multiple databases, optionally identify which to use. If not provided, the default
  /// database for the connection will be used.
  ///
  /// For dialects that do **not** support multiple databases, **do not use** the database parameter
  ///
  /// GET /connections/{connection_name}/tables -> List<SchemaTables>
  Future<SDKResponse<List<SchemaTables>>> connectionTables(

      /// @param {String} connection_name Name of connection
      String connectionName,
      {

      /// @param {String} database Optional. Name of database to use for the query, only if applicable
      String database,

      /// @param {String} schema_name Optional. Return only tables for this schema
      String schemaName,

      /// @param {bool} cache True to fetch from cache, false to load fresh
      bool cache,

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {String} table_filter Optional. Return tables with names that contain this value
      String tableFilter,

      /// @param {int} table_limit Optional. Return tables up to the table_limit
      int tableLimit}) async {
    var pathConnectionName = encodeParam(connectionName);

    List<SchemaTables> responseHandler(dynamic json, String contentType) {
      return json
          .map<SchemaTables>((i) => SchemaTables.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/connections/$pathConnectionName/tables', {
      'database': database,
      'schema_name': schemaName,
      'cache': cache,
      'fields': fields,
      'table_filter': tableFilter,
      'table_limit': tableLimit
    });
  }

  /// ### Get the columns (and therefore also the tables) in a specific schema
  ///
  /// GET /connections/{connection_name}/columns -> List<SchemaColumns>
  Future<SDKResponse<List<SchemaColumns>>> connectionColumns(

      /// @param {String} connection_name Name of connection
      String connectionName,
      {

      /// @param {String} database For dialects that support multiple databases, optionally identify which to use
      String database,

      /// @param {String} schema_name Name of schema to use.
      String schemaName,

      /// @param {bool} cache True to fetch from cache, false to load fresh
      bool cache,

      /// @param {int} table_limit limits the tables per schema returned
      int tableLimit,

      /// @param {String} table_names only fetch columns for a given (comma-separated) list of tables
      String tableNames,

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathConnectionName = encodeParam(connectionName);

    List<SchemaColumns> responseHandler(dynamic json, String contentType) {
      return json
          .map<SchemaColumns>((i) => SchemaColumns.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/connections/$pathConnectionName/columns', {
      'database': database,
      'schema_name': schemaName,
      'cache': cache,
      'table_limit': tableLimit,
      'table_names': tableNames,
      'fields': fields
    });
  }

  /// ### Search a connection for columns matching the specified name
  ///
  /// **Note**: `column_name` must be a valid column name. It is not a search pattern.
  ///
  /// GET /connections/{connection_name}/search_columns -> List<ColumnSearch>
  Future<SDKResponse<List<ColumnSearch>>> connectionSearchColumns(

      /// @param {String} connection_name Name of connection
      String connectionName,
      {

      /// @param {String} column_name Column name to find
      String columnName,

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathConnectionName = encodeParam(connectionName);

    List<ColumnSearch> responseHandler(dynamic json, String contentType) {
      return json
          .map<ColumnSearch>((i) => ColumnSearch.fromResponse(i, contentType))
          .toList();
    }

    return get(
        responseHandler,
        '/connections/$pathConnectionName/search_columns',
        {'column_name': columnName, 'fields': fields});
  }

  /// ### Connection cost estimating
  ///
  /// Assign a `sql` statement to the body of the request. e.g., for Ruby, `{sql: 'select * from users'}`
  ///
  /// **Note**: If the connection's dialect has no support for cost estimates, an error will be returned
  ///
  /// POST /connections/{connection_name}/cost_estimate -> CostEstimate
  Future<SDKResponse<CostEstimate>> connectionCostEstimate(

      /// @param {String} connection_name Name of connection
      String connectionName,

      /// @param {CreateCostEstimate} body
      CreateCostEstimate body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathConnectionName = encodeParam(connectionName);

    CostEstimate responseHandler(dynamic json, String contentType) {
      return CostEstimate.fromResponse(json, contentType);
    }

    return post(
        responseHandler,
        '/connections/$pathConnectionName/cost_estimate',
        {'fields': fields},
        body?.toJson());
  }

  // #endregion Metadata: Connection Metadata Features

  // #region Project: Manage Projects

  /// ### Generate Lockfile for All LookML Dependencies
  ///
  ///       Git must have been configured, must be in dev mode and deploy permission required
  ///
  ///       Install_all is a two step process
  ///       1. For each remote_dependency in a project the dependency manager will resolve any ambiguous ref.
  ///       2. The project will then write out a lockfile including each remote_dependency with its resolved ref.
  ///
  /// POST /projects/{project_id}/manifest/lock_all -> String
  Future<SDKResponse<dynamic>> lockAll(

      /// @param {String} project_id Id of project
      String projectId,
      {

      /// @param {String} fields Requested fields
      String fields}) async {
    var pathProjectId = encodeParam(projectId);

    dynamic responseHandler(dynamic json, String contentType) {
      return json;
    }

    return post(responseHandler, '/projects/$pathProjectId/manifest/lock_all',
        {'fields': fields});
  }

  /// ### Get All Git Branches
  ///
  /// Returns a list of git branches in the project repository
  ///
  /// GET /projects/{project_id}/git_branches -> List<GitBranch>
  Future<SDKResponse<List<GitBranch>>> allGitBranches(

      /// @param {String} project_id Project Id
      String projectId) async {
    var pathProjectId = encodeParam(projectId);

    List<GitBranch> responseHandler(dynamic json, String contentType) {
      return json
          .map<GitBranch>((i) => GitBranch.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/projects/$pathProjectId/git_branches');
  }

  /// ### Get the Current Git Branch
  ///
  /// Returns the git branch currently checked out in the given project repository
  ///
  /// GET /projects/{project_id}/git_branch -> GitBranch
  Future<SDKResponse<GitBranch>> gitBranch(

      /// @param {String} project_id Project Id
      String projectId) async {
    var pathProjectId = encodeParam(projectId);

    GitBranch responseHandler(dynamic json, String contentType) {
      return GitBranch.fromResponse(json, contentType);
    }

    return get(responseHandler, '/projects/$pathProjectId/git_branch');
  }

  /// ### Checkout and/or reset --hard an existing Git Branch
  ///
  /// Only allowed in development mode
  ///   - Call `update_session` to select the 'dev' workspace.
  ///
  /// Checkout an existing branch if name field is different from the name of the currently checked out branch.
  ///
  /// Optionally specify a branch name, tag name or commit SHA to which the branch should be reset.
  ///   **DANGER** hard reset will be force pushed to the remote. Unsaved changes and commits may be permanently lost.
  ///
  /// PUT /projects/{project_id}/git_branch -> GitBranch
  Future<SDKResponse<GitBranch>> updateGitBranch(

      /// @param {String} project_id Project Id
      String projectId,

      /// @param {WriteGitBranch} body
      WriteGitBranch body) async {
    var pathProjectId = encodeParam(projectId);

    GitBranch responseHandler(dynamic json, String contentType) {
      return GitBranch.fromResponse(json, contentType);
    }

    return put(responseHandler, '/projects/$pathProjectId/git_branch', null,
        body?.toJson());
  }

  /// ### Create and Checkout a Git Branch
  ///
  /// Creates and checks out a new branch in the given project repository
  /// Only allowed in development mode
  ///   - Call `update_session` to select the 'dev' workspace.
  ///
  /// Optionally specify a branch name, tag name or commit SHA as the start point in the ref field.
  ///   If no ref is specified, HEAD of the current branch will be used as the start point for the new branch.
  ///
  /// POST /projects/{project_id}/git_branch -> GitBranch
  Future<SDKResponse<GitBranch>> createGitBranch(

      /// @param {String} project_id Project Id
      String projectId,

      /// @param {WriteGitBranch} body
      WriteGitBranch body) async {
    var pathProjectId = encodeParam(projectId);

    GitBranch responseHandler(dynamic json, String contentType) {
      return GitBranch.fromResponse(json, contentType);
    }

    return post(responseHandler, '/projects/$pathProjectId/git_branch', null,
        body?.toJson());
  }

  /// ### Get the specified Git Branch
  ///
  /// Returns the git branch specified in branch_name path param if it exists in the given project repository
  ///
  /// GET /projects/{project_id}/git_branch/{branch_name} -> GitBranch
  Future<SDKResponse<GitBranch>> findGitBranch(

      /// @param {String} project_id Project Id
      String projectId,

      /// @param {String} branch_name Branch Name
      String branchName) async {
    var pathProjectId = encodeParam(projectId);
    var pathBranchName = encodeParam(branchName);

    GitBranch responseHandler(dynamic json, String contentType) {
      return GitBranch.fromResponse(json, contentType);
    }

    return get(
        responseHandler, '/projects/$pathProjectId/git_branch/$pathBranchName');
  }

  /// ### Delete the specified Git Branch
  ///
  /// Delete git branch specified in branch_name path param from local and remote of specified project repository
  ///
  /// DELETE /projects/{project_id}/git_branch/{branch_name} -> String
  Future<SDKResponse<String>> deleteGitBranch(

      /// @param {String} project_id Project Id
      String projectId,

      /// @param {String} branch_name Branch Name
      String branchName) async {
    var pathProjectId = encodeParam(projectId);
    var pathBranchName = encodeParam(branchName);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(
        responseHandler, '/projects/$pathProjectId/git_branch/$pathBranchName');
  }

  /// ### Deploy a Remote Branch or Ref to Production
  ///
  /// Git must have been configured and deploy permission required.
  ///
  /// Deploy is a one/two step process
  /// 1. If this is the first deploy of this project, create the production project with git repository.
  /// 2. Pull the branch or ref into the production project.
  ///
  /// Can only specify either a branch or a ref.
  ///
  /// POST /projects/{project_id}/deploy_ref_to_production -> String
  Future<SDKResponse<dynamic>> deployRefToProduction(

      /// @param {String} project_id Id of project
      String projectId,
      {

      /// @param {String} branch Branch to deploy to production
      String branch,

      /// @param {String} ref Ref to deploy to production
      String ref}) async {
    var pathProjectId = encodeParam(projectId);

    dynamic responseHandler(dynamic json, String contentType) {
      return json;
    }

    return post(
        responseHandler,
        '/projects/$pathProjectId/deploy_ref_to_production',
        {'branch': branch, 'ref': ref});
  }

  /// ### Deploy LookML from this Development Mode Project to Production
  ///
  /// Git must have been configured, must be in dev mode and deploy permission required
  ///
  /// Deploy is a two / three step process:
  ///
  /// 1. Push commits in current branch of dev mode project to the production branch (origin/master).
  ///    Note a. This step is skipped in read-only projects.
  ///    Note b. If this step is unsuccessful for any reason (e.g. rejected non-fastforward because production branch has
  ///              commits not in current branch), subsequent steps will be skipped.
  /// 2. If this is the first deploy of this project, create the production project with git repository.
  /// 3. Pull the production branch into the production project.
  ///
  /// POST /projects/{project_id}/deploy_to_production -> String
  Future<SDKResponse<dynamic>> deployToProduction(

      /// @param {String} project_id Id of project
      String projectId) async {
    var pathProjectId = encodeParam(projectId);

    dynamic responseHandler(dynamic json, String contentType) {
      return json;
    }

    return post(
        responseHandler, '/projects/$pathProjectId/deploy_to_production');
  }

  /// ### Reset a project to the revision of the project that is in production.
  ///
  /// **DANGER** this will delete any changes that have not been pushed to a remote repository.
  ///
  /// POST /projects/{project_id}/reset_to_production -> String
  Future<SDKResponse<dynamic>> resetProjectToProduction(

      /// @param {String} project_id Id of project
      String projectId) async {
    var pathProjectId = encodeParam(projectId);

    dynamic responseHandler(dynamic json, String contentType) {
      return json;
    }

    return post(
        responseHandler, '/projects/$pathProjectId/reset_to_production');
  }

  /// ### Reset a project development branch to the revision of the project that is on the remote.
  ///
  /// **DANGER** this will delete any changes that have not been pushed to a remote repository.
  ///
  /// POST /projects/{project_id}/reset_to_remote -> String
  Future<SDKResponse<dynamic>> resetProjectToRemote(

      /// @param {String} project_id Id of project
      String projectId) async {
    var pathProjectId = encodeParam(projectId);

    dynamic responseHandler(dynamic json, String contentType) {
      return json;
    }

    return post(responseHandler, '/projects/$pathProjectId/reset_to_remote');
  }

  /// ### Get All Projects
  ///
  /// Returns all projects visible to the current user
  ///
  /// GET /projects -> List<Project>
  Future<SDKResponse<List<Project>>> allProjects(
      {

      /// @param {String} fields Requested fields
      String fields}) async {
    List<Project> responseHandler(dynamic json, String contentType) {
      return json
          .map<Project>((i) => Project.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/projects', {'fields': fields});
  }

  /// ### Create A Project
  ///
  /// dev mode required.
  /// - Call `update_session` to select the 'dev' workspace.
  ///
  /// `name` is required.
  /// `git_remote_url` is not allowed. To configure Git for the newly created project, follow the instructions in `update_project`.
  ///
  /// POST /projects -> Project
  Future<SDKResponse<Project>> createProject(

      /// @param {WriteProject} body
      WriteProject body) async {
    Project responseHandler(dynamic json, String contentType) {
      return Project.fromResponse(json, contentType);
    }

    return post(responseHandler, '/projects', null, body?.toJson());
  }

  /// ### Get A Project
  ///
  /// Returns the project with the given project id
  ///
  /// GET /projects/{project_id} -> Project
  Future<SDKResponse<Project>> project(

      /// @param {String} project_id Project Id
      String projectId,
      {

      /// @param {String} fields Requested fields
      String fields}) async {
    var pathProjectId = encodeParam(projectId);

    Project responseHandler(dynamic json, String contentType) {
      return Project.fromResponse(json, contentType);
    }

    return get(responseHandler, '/projects/$pathProjectId', {'fields': fields});
  }

  /// ### Update Project Configuration
  ///
  /// Apply changes to a project's configuration.
  ///
  ///
  /// #### Configuring Git for a Project
  ///
  /// To set up a Looker project with a remote git repository, follow these steps:
  ///
  /// 1. Call `update_session` to select the 'dev' workspace.
  /// 1. Call `create_git_deploy_key` to create a new deploy key for the project
  /// 1. Copy the deploy key text into the remote git repository's ssh key configuration
  /// 1. Call `update_project` to set project's `git_remote_url` ()and `git_service_name`, if necessary).
  ///
  /// When you modify a project's `git_remote_url`, Looker connects to the remote repository to fetch
  /// metadata. The remote git repository MUST be configured with the Looker-generated deploy
  /// key for this project prior to setting the project's `git_remote_url`.
  ///
  /// To set up a Looker project with a git repository residing on the Looker server (a 'bare' git repo):
  ///
  /// 1. Call `update_session` to select the 'dev' workspace.
  /// 1. Call `update_project` setting `git_remote_url` to null and `git_service_name` to "bare".
  ///
  /// PATCH /projects/{project_id} -> Project
  Future<SDKResponse<Project>> updateProject(

      /// @param {String} project_id Project Id
      String projectId,

      /// @param {WriteProject} body
      WriteProject body,
      {

      /// @param {String} fields Requested fields
      String fields}) async {
    var pathProjectId = encodeParam(projectId);

    Project responseHandler(dynamic json, String contentType) {
      return Project.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/projects/$pathProjectId',
        {'fields': fields}, body?.toJson());
  }

  /// ### Get A Projects Manifest object
  ///
  /// Returns the project with the given project id
  ///
  /// GET /projects/{project_id}/manifest -> Manifest
  Future<SDKResponse<Manifest>> manifest(

      /// @param {String} project_id Project Id
      String projectId) async {
    var pathProjectId = encodeParam(projectId);

    Manifest responseHandler(dynamic json, String contentType) {
      return Manifest.fromResponse(json, contentType);
    }

    return get(responseHandler, '/projects/$pathProjectId/manifest');
  }

  /// ### Git Deploy Key
  ///
  /// Returns the ssh public key previously created for a project's git repository.
  ///
  /// GET /projects/{project_id}/git/deploy_key -> String
  Future<SDKResponse<String>> gitDeployKey(

      /// @param {String} project_id Project Id
      String projectId) async {
    var pathProjectId = encodeParam(projectId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return get(responseHandler, '/projects/$pathProjectId/git/deploy_key');
  }

  /// ### Create Git Deploy Key
  ///
  /// Create a public/private key pair for authenticating ssh git requests from Looker to a remote git repository
  /// for a particular Looker project.
  ///
  /// Returns the public key of the generated ssh key pair.
  ///
  /// Copy this public key to your remote git repository's ssh keys configuration so that the remote git service can
  /// validate and accept git requests from the Looker server.
  ///
  /// POST /projects/{project_id}/git/deploy_key -> String
  Future<SDKResponse<String>> createGitDeployKey(

      /// @param {String} project_id Project Id
      String projectId) async {
    var pathProjectId = encodeParam(projectId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return post(responseHandler, '/projects/$pathProjectId/git/deploy_key');
  }

  /// ### Get Cached Project Validation Results
  ///
  /// Returns the cached results of a previous project validation calculation, if any.
  /// Returns http status 204 No Content if no validation results exist.
  ///
  /// Validating the content of all the files in a project can be computationally intensive
  /// for large projects. Use this API to simply fetch the results of the most recent
  /// project validation rather than revalidating the entire project from scratch.
  ///
  /// A value of `"stale": true` in the response indicates that the project has changed since
  /// the cached validation results were computed. The cached validation results may no longer
  /// reflect the current state of the project.
  ///
  /// GET /projects/{project_id}/validate -> ProjectValidationCache
  Future<SDKResponse<ProjectValidationCache>> projectValidationResults(

      /// @param {String} project_id Project Id
      String projectId,
      {

      /// @param {String} fields Requested fields
      String fields}) async {
    var pathProjectId = encodeParam(projectId);

    ProjectValidationCache responseHandler(dynamic json, String contentType) {
      return ProjectValidationCache.fromResponse(json, contentType);
    }

    return get(responseHandler, '/projects/$pathProjectId/validate',
        {'fields': fields});
  }

  /// ### Validate Project
  ///
  /// Performs lint validation of all lookml files in the project.
  /// Returns a list of errors found, if any.
  ///
  /// Validating the content of all the files in a project can be computationally intensive
  /// for large projects. For best performance, call `validate_project(project_id)` only
  /// when you really want to recompute project validation. To quickly display the results of
  /// the most recent project validation (without recomputing), use `project_validation_results(project_id)`
  ///
  /// POST /projects/{project_id}/validate -> ProjectValidation
  Future<SDKResponse<ProjectValidation>> validateProject(

      /// @param {String} project_id Project Id
      String projectId,
      {

      /// @param {String} fields Requested fields
      String fields}) async {
    var pathProjectId = encodeParam(projectId);

    ProjectValidation responseHandler(dynamic json, String contentType) {
      return ProjectValidation.fromResponse(json, contentType);
    }

    return post(responseHandler, '/projects/$pathProjectId/validate',
        {'fields': fields});
  }

  /// ### Get Project Workspace
  ///
  /// Returns information about the state of the project files in the currently selected workspace
  ///
  /// GET /projects/{project_id}/current_workspace -> ProjectWorkspace
  Future<SDKResponse<ProjectWorkspace>> projectWorkspace(

      /// @param {String} project_id Project Id
      String projectId,
      {

      /// @param {String} fields Requested fields
      String fields}) async {
    var pathProjectId = encodeParam(projectId);

    ProjectWorkspace responseHandler(dynamic json, String contentType) {
      return ProjectWorkspace.fromResponse(json, contentType);
    }

    return get(responseHandler, '/projects/$pathProjectId/current_workspace',
        {'fields': fields});
  }

  /// ### Get All Project Files
  ///
  /// Returns a list of the files in the project
  ///
  /// GET /projects/{project_id}/files -> List<ProjectFile>
  Future<SDKResponse<List<ProjectFile>>> allProjectFiles(

      /// @param {String} project_id Project Id
      String projectId,
      {

      /// @param {String} fields Requested fields
      String fields}) async {
    var pathProjectId = encodeParam(projectId);

    List<ProjectFile> responseHandler(dynamic json, String contentType) {
      return json
          .map<ProjectFile>((i) => ProjectFile.fromResponse(i, contentType))
          .toList();
    }

    return get(
        responseHandler, '/projects/$pathProjectId/files', {'fields': fields});
  }

  /// ### Get Project File Info
  ///
  /// Returns information about a file in the project
  ///
  /// GET /projects/{project_id}/files/file -> ProjectFile
  Future<SDKResponse<ProjectFile>> projectFile(

      /// @param {String} project_id Project Id
      String projectId,

      /// @param {String} file_id File Id
      String fileId,
      {

      /// @param {String} fields Requested fields
      String fields}) async {
    var pathProjectId = encodeParam(projectId);

    ProjectFile responseHandler(dynamic json, String contentType) {
      return ProjectFile.fromResponse(json, contentType);
    }

    return get(responseHandler, '/projects/$pathProjectId/files/file',
        {'file_id': fileId, 'fields': fields});
  }

  /// ### Get All Git Connection Tests
  ///
  /// dev mode required.
  ///   - Call `update_session` to select the 'dev' workspace.
  ///
  /// Returns a list of tests which can be run against a project's (or the dependency project for the provided remote_url) git connection. Call [Run Git Connection Test](#!/Project/run_git_connection_test) to execute each test in sequence.
  ///
  /// Tests are ordered by increasing specificity. Tests should be run in the order returned because later tests require functionality tested by tests earlier in the test list.
  ///
  /// For example, a late-stage test for write access is meaningless if connecting to the git server (an early test) is failing.
  ///
  /// GET /projects/{project_id}/git_connection_tests -> List<GitConnectionTest>
  Future<SDKResponse<List<GitConnectionTest>>> allGitConnectionTests(

      /// @param {String} project_id Project Id
      String projectId,
      {

      /// @param {String} remote_url (Optional: leave blank for root project) The remote url for remote dependency to test.
      String remoteUrl}) async {
    var pathProjectId = encodeParam(projectId);

    List<GitConnectionTest> responseHandler(dynamic json, String contentType) {
      return json
          .map<GitConnectionTest>(
              (i) => GitConnectionTest.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/projects/$pathProjectId/git_connection_tests',
        {'remote_url': remoteUrl});
  }

  /// ### Run a git connection test
  ///
  /// Run the named test on the git service used by this project (or the dependency project for the provided remote_url) and return the result. This
  /// is intended to help debug git connections when things do not work properly, to give
  /// more helpful information about why a git url is not working with Looker.
  ///
  /// Tests should be run in the order they are returned by [Get All Git Connection Tests](#!/Project/all_git_connection_tests).
  ///
  /// GET /projects/{project_id}/git_connection_tests/{test_id} -> GitConnectionTestResult
  Future<SDKResponse<GitConnectionTestResult>> runGitConnectionTest(

      /// @param {String} project_id Project Id
      String projectId,

      /// @param {String} test_id Test Id
      String testId,
      {

      /// @param {String} remote_url (Optional: leave blank for root project) The remote url for remote dependency to test.
      String remoteUrl,

      /// @param {String} use_production (Optional: leave blank for dev credentials) Whether to use git production credentials.
      String useProduction}) async {
    var pathProjectId = encodeParam(projectId);
    var pathTestId = encodeParam(testId);

    GitConnectionTestResult responseHandler(dynamic json, String contentType) {
      return GitConnectionTestResult.fromResponse(json, contentType);
    }

    return get(
        responseHandler,
        '/projects/$pathProjectId/git_connection_tests/$pathTestId',
        {'remote_url': remoteUrl, 'use_production': useProduction});
  }

  /// ### Get All LookML Tests
  ///
  /// Returns a list of tests which can be run to validate a project's LookML code and/or the underlying data,
  /// optionally filtered by the file id.
  /// Call [Run LookML Test](#!/Project/run_lookml_test) to execute tests.
  ///
  /// GET /projects/{project_id}/lookml_tests -> List<LookmlTest>
  Future<SDKResponse<List<LookmlTest>>> allLookmlTests(

      /// @param {String} project_id Project Id
      String projectId,
      {

      /// @param {String} file_id File Id
      String fileId}) async {
    var pathProjectId = encodeParam(projectId);

    List<LookmlTest> responseHandler(dynamic json, String contentType) {
      return json
          .map<LookmlTest>((i) => LookmlTest.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/projects/$pathProjectId/lookml_tests',
        {'file_id': fileId});
  }

  /// ### Run LookML Tests
  ///
  /// Runs all tests in the project, optionally filtered by file, test, and/or model.
  ///
  /// GET /projects/{project_id}/lookml_tests/run -> List<LookmlTestResult>
  Future<SDKResponse<List<LookmlTestResult>>> runLookmlTest(

      /// @param {String} project_id Project Id
      String projectId,
      {

      /// @param {String} file_id File Name
      String fileId,

      /// @param {String} test Test Name
      String test,

      /// @param {String} model Model Name
      String model}) async {
    var pathProjectId = encodeParam(projectId);

    List<LookmlTestResult> responseHandler(dynamic json, String contentType) {
      return json
          .map<LookmlTestResult>(
              (i) => LookmlTestResult.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/projects/$pathProjectId/lookml_tests/run',
        {'file_id': fileId, 'test': test, 'model': model});
  }

  /// ### Creates a tag for the most recent commit, or a specific ref is a SHA is provided
  ///
  /// This is an internal-only, undocumented route.
  ///
  /// POST /projects/{project_id}/tag -> Project
  Future<SDKResponse<Project>> tagRef(

      /// @param {String} project_id Project Id
      String projectId,

      /// @param {WriteProject} body
      WriteProject body,
      {

      /// @param {String} commit_sha (Optional): Commit Sha to Tag
      String commitSha,

      /// @param {String} tag_name Tag Name
      String tagName,

      /// @param {String} tag_message (Optional): Tag Message
      String tagMessage}) async {
    var pathProjectId = encodeParam(projectId);

    Project responseHandler(dynamic json, String contentType) {
      return Project.fromResponse(json, contentType);
    }

    return post(
        responseHandler,
        '/projects/$pathProjectId/tag',
        {
          'commit_sha': commitSha,
          'tag_name': tagName,
          'tag_message': tagMessage
        },
        body?.toJson());
  }

  /// ### Configure Repository Credential for a remote dependency
  ///
  /// Admin required.
  ///
  /// `root_project_id` is required.
  /// `credential_id` is required.
  ///
  /// PUT /projects/{root_project_id}/credential/{credential_id} -> RepositoryCredential
  Future<SDKResponse<RepositoryCredential>> updateRepositoryCredential(

      /// @param {String} root_project_id Root Project Id
      String rootProjectId,

      /// @param {String} credential_id Credential Id
      String credentialId,

      /// @param {WriteRepositoryCredential} body
      WriteRepositoryCredential body) async {
    var pathRootProjectId = encodeParam(rootProjectId);
    var pathCredentialId = encodeParam(credentialId);

    RepositoryCredential responseHandler(dynamic json, String contentType) {
      return RepositoryCredential.fromResponse(json, contentType);
    }

    return put(
        responseHandler,
        '/projects/$pathRootProjectId/credential/$pathCredentialId',
        null,
        body?.toJson());
  }

  /// ### Repository Credential for a remote dependency
  ///
  /// Admin required.
  ///
  /// `root_project_id` is required.
  /// `credential_id` is required.
  ///
  /// DELETE /projects/{root_project_id}/credential/{credential_id} -> String
  Future<SDKResponse<String>> deleteRepositoryCredential(

      /// @param {String} root_project_id Root Project Id
      String rootProjectId,

      /// @param {String} credential_id Credential Id
      String credentialId) async {
    var pathRootProjectId = encodeParam(rootProjectId);
    var pathCredentialId = encodeParam(credentialId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler,
        '/projects/$pathRootProjectId/credential/$pathCredentialId');
  }

  /// ### Get all Repository Credentials for a project
  ///
  /// `root_project_id` is required.
  ///
  /// GET /projects/{root_project_id}/credentials -> List<RepositoryCredential>
  Future<SDKResponse<List<RepositoryCredential>>> getAllRepositoryCredentials(

      /// @param {String} root_project_id Root Project Id
      String rootProjectId) async {
    var pathRootProjectId = encodeParam(rootProjectId);

    List<RepositoryCredential> responseHandler(
        dynamic json, String contentType) {
      return json
          .map<RepositoryCredential>(
              (i) => RepositoryCredential.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/projects/$pathRootProjectId/credentials');
  }

  // #endregion Project: Manage Projects

  // #region Query: Run and Manage Queries

  /// ### Create an async query task
  ///
  /// Creates a query task (job) to run a previously created query asynchronously. Returns a Query Task ID.
  ///
  /// Use [query_task(query_task_id)](#!/Query/query_task) to check the execution status of the query task.
  /// After the query task status reaches "Complete", use [query_task_results(query_task_id)](#!/Query/query_task_results) to fetch the results of the query.
  ///
  /// POST /query_tasks -> QueryTask
  Future<SDKResponse<QueryTask>> createQueryTask(

      /// @param {WriteCreateQueryTask} body
      WriteCreateQueryTask body,
      {

      /// @param {int} limit Row limit (may override the limit in the saved query).
      int limit,

      /// @param {bool} apply_formatting Apply model-specified formatting to each result.
      bool applyFormatting,

      /// @param {bool} apply_vis Apply visualization options to results.
      bool applyVis,

      /// @param {bool} cache Get results from cache if available.
      bool cache,

      /// @param {int} image_width Render width for image formats.
      int imageWidth,

      /// @param {int} image_height Render height for image formats.
      int imageHeight,

      /// @param {bool} generate_drill_links Generate drill links (only applicable to 'json_detail' format.
      bool generateDrillLinks,

      /// @param {bool} force_production Force use of production models even if the user is in development mode.
      bool forceProduction,

      /// @param {bool} cache_only Retrieve any results from cache even if the results have expired.
      bool cacheOnly,

      /// @param {String} path_prefix Prefix to use for drill links (url encoded).
      String pathPrefix,

      /// @param {bool} rebuild_pdts Rebuild PDTS used in query.
      bool rebuildPdts,

      /// @param {bool} server_table_calcs Perform table calculations on query results
      bool serverTableCalcs,

      /// @param {String} fields Requested fields
      String fields}) async {
    QueryTask responseHandler(dynamic json, String contentType) {
      return QueryTask.fromResponse(json, contentType);
    }

    return post(
        responseHandler,
        '/query_tasks',
        {
          'limit': limit,
          'apply_formatting': applyFormatting,
          'apply_vis': applyVis,
          'cache': cache,
          'image_width': imageWidth,
          'image_height': imageHeight,
          'generate_drill_links': generateDrillLinks,
          'force_production': forceProduction,
          'cache_only': cacheOnly,
          'path_prefix': pathPrefix,
          'rebuild_pdts': rebuildPdts,
          'server_table_calcs': serverTableCalcs,
          'fields': fields
        },
        body?.toJson());
  }

  /// ### Fetch results of multiple async queries
  ///
  /// Returns the results of multiple async queries in one request.
  ///
  /// For Query Tasks that are not completed, the response will include the execution status of the Query Task but will not include query results.
  /// Query Tasks whose results have expired will have a status of 'expired'.
  /// If the user making the API request does not have sufficient privileges to view a Query Task result, the result will have a status of 'missing'
  ///
  /// GET /query_tasks/multi_results -> Map<String,dynamic>
  Future<SDKResponse<Map<String, dynamic>>> queryTaskMultiResults(

      /// @param {DelimList<String>} query_task_ids List of Query Task IDs
      DelimList<String> queryTaskIds) async {
    Map<String, dynamic> responseHandler(dynamic json, String contentType) {
      return json;
    }

    return get(responseHandler, '/query_tasks/multi_results',
        {'query_task_ids': queryTaskIds});
  }

  /// ### Get Query Task details
  ///
  /// Use this function to check the status of an async query task. After the status
  /// reaches "Complete", you can call [query_task_results(query_task_id)](#!/Query/query_task_results) to
  /// retrieve the results of the query.
  ///
  /// Use [create_query_task()](#!/Query/create_query_task) to create an async query task.
  ///
  /// GET /query_tasks/{query_task_id} -> QueryTask
  Future<SDKResponse<QueryTask>> queryTask(

      /// @param {String} query_task_id ID of the Query Task
      String queryTaskId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathQueryTaskId = encodeParam(queryTaskId);

    QueryTask responseHandler(dynamic json, String contentType) {
      return QueryTask.fromResponse(json, contentType);
    }

    return get(
        responseHandler, '/query_tasks/$pathQueryTaskId', {'fields': fields});
  }

  /// ### Get Async Query Results
  ///
  /// Returns the results of an async query task if the query has completed.
  ///
  /// If the query task is still running or waiting to run, this function returns 204 No Content.
  ///
  /// If the query task ID is invalid or the cached results of the query task have expired, this function returns 404 Not Found.
  ///
  /// Use [query_task(query_task_id)](#!/Query/query_task) to check the execution status of the query task
  /// Call query_task_results only after the query task status reaches "Complete".
  ///
  /// You can also use [query_task_multi_results()](#!/Query/query_task_multi_results) retrieve the
  /// results of multiple async query tasks at the same time.
  ///
  /// #### SQL Error Handling:
  /// If the query fails due to a SQL db error, how this is communicated depends on the result_format you requested in `create_query_task()`.
  ///
  /// For `json_detail` result_format: `query_task_results()` will respond with HTTP status '200 OK' and db SQL error info
  /// will be in the `errors` property of the response object. The 'data' property will be empty.
  ///
  /// For all other result formats: `query_task_results()` will respond with HTTP status `400 Bad Request` and some db SQL error info
  /// will be in the message of the 400 error response, but not as detailed as expressed in `json_detail.errors`.
  /// These data formats can only carry row data, and error info is not row data.
  ///
  /// GET /query_tasks/{query_task_id}/results -> String
  Future<SDKResponse<dynamic>> queryTaskResults(

      /// @param {String} query_task_id ID of the Query Task
      String queryTaskId) async {
    var pathQueryTaskId = encodeParam(queryTaskId);

    dynamic responseHandler(dynamic json, String contentType) {
      return json;
    }

    return get(responseHandler, '/query_tasks/$pathQueryTaskId/results');
  }

  /// ### Get a previously created query by id.
  ///
  /// A Looker query object includes the various parameters that define a database query that has been run or
  /// could be run in the future. These parameters include: model, view, fields, filters, pivots, etc.
  /// Query *results* are not part of the query object.
  ///
  /// Query objects are unique and immutable. Query objects are created automatically in Looker as users explore data.
  /// Looker does not delete them; they become part of the query history. When asked to create a query for
  /// any given set of parameters, Looker will first try to find an existing query object with matching
  /// parameters and will only create a new object when an appropriate object can not be found.
  ///
  /// This 'get' method is used to get the details about a query for a given id. See the other methods here
  /// to 'create' and 'run' queries.
  ///
  /// Note that some fields like 'filter_config' and 'vis_config' etc are specific to how the Looker UI
  /// builds queries and visualizations and are not generally useful for API use. They are not required when
  /// creating new queries and can usually just be ignored.
  ///
  /// GET /queries/{query_id} -> Query
  Future<SDKResponse<Query>> query(

      /// @param {int} query_id Id of query
      int queryId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathQueryId = encodeParam(queryId);

    Query responseHandler(dynamic json, String contentType) {
      return Query.fromResponse(json, contentType);
    }

    return get(responseHandler, '/queries/$pathQueryId', {'fields': fields});
  }

  /// ### Get the query for a given query slug.
  ///
  /// This returns the query for the 'slug' in a query share URL.
  ///
  /// The 'slug' is a randomly chosen short string that is used as an alternative to the query's id value
  /// for use in URLs etc. This method exists as a convenience to help you use the API to 'find' queries that
  /// have been created using the Looker UI.
  ///
  /// You can use the Looker explore page to build a query and then choose the 'Share' option to
  /// show the share url for the query. Share urls generally look something like 'https://looker.yourcompany/x/vwGSbfc'.
  /// The trailing 'vwGSbfc' is the share slug. You can pass that string to this api method to get details about the query.
  /// Those details include the 'id' that you can use to run the query. Or, you can copy the query body
  /// (perhaps with your own modification) and use that as the basis to make/run new queries.
  ///
  /// This will also work with slugs from Looker explore urls like
  /// 'https://looker.yourcompany/explore/ecommerce/orders?qid=aogBgL6o3cKK1jN3RoZl5s'. In this case
  /// 'aogBgL6o3cKK1jN3RoZl5s' is the slug.
  ///
  /// GET /queries/slug/{slug} -> Query
  Future<SDKResponse<Query>> queryForSlug(

      /// @param {String} slug Slug of query
      String slug,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathSlug = encodeParam(slug);

    Query responseHandler(dynamic json, String contentType) {
      return Query.fromResponse(json, contentType);
    }

    return get(responseHandler, '/queries/slug/$pathSlug', {'fields': fields});
  }

  /// ### Create a query.
  ///
  /// This allows you to create a new query that you can later run. Looker queries are immutable once created
  /// and are not deleted. If you create a query that is exactly like an existing query then the existing query
  /// will be returned and no new query will be created. Whether a new query is created or not, you can use
  /// the 'id' in the returned query with the 'run' method.
  ///
  /// The query parameters are passed as json in the body of the request.
  ///
  /// POST /queries -> Query
  Future<SDKResponse<Query>> createQuery(

      /// @param {WriteQuery} body
      WriteQuery body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    Query responseHandler(dynamic json, String contentType) {
      return Query.fromResponse(json, contentType);
    }

    return post(
        responseHandler, '/queries', {'fields': fields}, body?.toJson());
  }

  /// ### Run a saved query.
  ///
  /// This runs a previously saved query. You can use this on a query that was generated in the Looker UI
  /// or one that you have explicitly created using the API. You can also use a query 'id' from a saved 'Look'.
  ///
  /// The 'result_format' parameter specifies the desired structure and format of the response.
  ///
  /// Supported formats:
  ///
  /// | result_format | Description
  /// | :-----------: | :--- |
  /// | json | Plain json
  /// | json_detail | Row data plus metadata describing the fields, pivots, table calcs, and other aspects of the query
  /// | csv | Comma separated values with a header
  /// | txt | Tab separated values with a header
  /// | html | Simple html
  /// | md | Simple markdown
  /// | xlsx | MS Excel spreadsheet
  /// | sql | Returns the generated SQL rather than running the query
  /// | png | A PNG image of the visualization of the query
  /// | jpg | A JPG image of the visualization of the query
  ///
  /// GET /queries/{query_id}/run/{result_format} -> String
  ///
  /// **Note**: Binary content may be returned by this method.
  Future<SDKResponse<dynamic>> runQuery(

      /// @param {int} query_id Id of query
      int queryId,

      /// @param {String} result_format Format of result
      String resultFormat,
      {

      /// @param {int} limit Row limit (may override the limit in the saved query).
      int limit,

      /// @param {bool} apply_formatting Apply model-specified formatting to each result.
      bool applyFormatting,

      /// @param {bool} apply_vis Apply visualization options to results.
      bool applyVis,

      /// @param {bool} cache Get results from cache if available.
      bool cache,

      /// @param {int} image_width Render width for image formats.
      int imageWidth,

      /// @param {int} image_height Render height for image formats.
      int imageHeight,

      /// @param {bool} generate_drill_links Generate drill links (only applicable to 'json_detail' format.
      bool generateDrillLinks,

      /// @param {bool} force_production Force use of production models even if the user is in development mode.
      bool forceProduction,

      /// @param {bool} cache_only Retrieve any results from cache even if the results have expired.
      bool cacheOnly,

      /// @param {String} path_prefix Prefix to use for drill links (url encoded).
      String pathPrefix,

      /// @param {bool} rebuild_pdts Rebuild PDTS used in query.
      bool rebuildPdts,

      /// @param {bool} server_table_calcs Perform table calculations on query results
      bool serverTableCalcs,

      /// @param {String} source Specifies the source of this call.
      String source}) async {
    var pathQueryId = encodeParam(queryId);
    var pathResultFormat = encodeParam(resultFormat);

    dynamic responseHandler(dynamic json, String contentType) {
      return json;
    }

    return get(responseHandler, '/queries/$pathQueryId/run/$pathResultFormat', {
      'limit': limit,
      'apply_formatting': applyFormatting,
      'apply_vis': applyVis,
      'cache': cache,
      'image_width': imageWidth,
      'image_height': imageHeight,
      'generate_drill_links': generateDrillLinks,
      'force_production': forceProduction,
      'cache_only': cacheOnly,
      'path_prefix': pathPrefix,
      'rebuild_pdts': rebuildPdts,
      'server_table_calcs': serverTableCalcs,
      'source': source
    });
  }

  /// ### Run the query that is specified inline in the posted body.
  ///
  /// This allows running a query as defined in json in the posted body. This combines
  /// the two actions of posting & running a query into one step.
  ///
  /// Here is an example body in json:
  /// ```
  /// {
  ///   "model":"thelook",
  ///   "view":"inventory_items",
  ///   "fields":["category.name","inventory_items.days_in_inventory_tier","products.count"],
  ///   "filters":{"category.name":"socks"},
  ///   "sorts":["products.count desc 0"],
  ///   "limit":"500",
  ///   "query_timezone":"America/Los_Angeles"
  /// }
  /// ```
  ///
  /// When using the Ruby SDK this would be passed as a Ruby hash like:
  /// ```
  /// {
  ///  :model=>"thelook",
  ///  :view=>"inventory_items",
  ///  :fields=>
  ///   ["category.name",
  ///    "inventory_items.days_in_inventory_tier",
  ///    "products.count"],
  ///  :filters=>{:"category.name"=>"socks"},
  ///  :sorts=>["products.count desc 0"],
  ///  :limit=>"500",
  ///  :query_timezone=>"America/Los_Angeles",
  /// }
  /// ```
  ///
  /// This will return the result of running the query in the format specified by the 'result_format' parameter.
  ///
  /// Supported formats:
  ///
  /// | result_format | Description
  /// | :-----------: | :--- |
  /// | json | Plain json
  /// | json_detail | Row data plus metadata describing the fields, pivots, table calcs, and other aspects of the query
  /// | csv | Comma separated values with a header
  /// | txt | Tab separated values with a header
  /// | html | Simple html
  /// | md | Simple markdown
  /// | xlsx | MS Excel spreadsheet
  /// | sql | Returns the generated SQL rather than running the query
  /// | png | A PNG image of the visualization of the query
  /// | jpg | A JPG image of the visualization of the query
  ///
  /// POST /queries/run/{result_format} -> String
  ///
  /// **Note**: Binary content may be returned by this method.
  Future<SDKResponse<dynamic>> runInlineQuery(

      /// @param {String} result_format Format of result
      String resultFormat,

      /// @param {WriteQuery} body
      WriteQuery body,
      {

      /// @param {int} limit Row limit (may override the limit in the saved query).
      int limit,

      /// @param {bool} apply_formatting Apply model-specified formatting to each result.
      bool applyFormatting,

      /// @param {bool} apply_vis Apply visualization options to results.
      bool applyVis,

      /// @param {bool} cache Get results from cache if available.
      bool cache,

      /// @param {int} image_width Render width for image formats.
      int imageWidth,

      /// @param {int} image_height Render height for image formats.
      int imageHeight,

      /// @param {bool} generate_drill_links Generate drill links (only applicable to 'json_detail' format.
      bool generateDrillLinks,

      /// @param {bool} force_production Force use of production models even if the user is in development mode.
      bool forceProduction,

      /// @param {bool} cache_only Retrieve any results from cache even if the results have expired.
      bool cacheOnly,

      /// @param {String} path_prefix Prefix to use for drill links (url encoded).
      String pathPrefix,

      /// @param {bool} rebuild_pdts Rebuild PDTS used in query.
      bool rebuildPdts,

      /// @param {bool} server_table_calcs Perform table calculations on query results
      bool serverTableCalcs}) async {
    var pathResultFormat = encodeParam(resultFormat);

    dynamic responseHandler(dynamic json, String contentType) {
      return json;
    }

    return post(
        responseHandler,
        '/queries/run/$pathResultFormat',
        {
          'limit': limit,
          'apply_formatting': applyFormatting,
          'apply_vis': applyVis,
          'cache': cache,
          'image_width': imageWidth,
          'image_height': imageHeight,
          'generate_drill_links': generateDrillLinks,
          'force_production': forceProduction,
          'cache_only': cacheOnly,
          'path_prefix': pathPrefix,
          'rebuild_pdts': rebuildPdts,
          'server_table_calcs': serverTableCalcs
        },
        body?.toJson());
  }

  /// ### Run an URL encoded query.
  ///
  /// This requires the caller to encode the specifiers for the query into the URL query part using
  /// Looker-specific syntax as explained below.
  ///
  /// Generally, you would want to use one of the methods that takes the parameters as json in the POST body
  /// for creating and/or running queries. This method exists for cases where one really needs to encode the
  /// parameters into the URL of a single 'GET' request. This matches the way that the Looker UI formats
  /// 'explore' URLs etc.
  ///
  /// The parameters here are very similar to the json body formatting except that the filter syntax is
  /// tricky. Unfortunately, this format makes this method not currently callable via the 'Try it out!' button
  /// in this documentation page. But, this is callable when creating URLs manually or when using the Looker SDK.
  ///
  /// Here is an example inline query URL:
  ///
  /// ```
  /// https://looker.mycompany.com:19999/api/3.0/queries/models/thelook/views/inventory_items/run/json?fields=category.name,inventory_items.days_in_inventory_tier,products.count&f[category.name]=socks&sorts=products.count+desc+0&limit=500&query_timezone=America/Los_Angeles
  /// ```
  ///
  /// When invoking this endpoint with the Ruby SDK, pass the query parameter parts as a hash. The hash to match the above would look like:
  ///
  /// ```ruby
  /// query_params =
  /// {
  ///   :fields => "category.name,inventory_items.days_in_inventory_tier,products.count",
  ///   :"f[category.name]" => "socks",
  ///   :sorts => "products.count desc 0",
  ///   :limit => "500",
  ///   :query_timezone => "America/Los_Angeles"
  /// }
  /// response = ruby_sdk.run_url_encoded_query('thelook','inventory_items','json', query_params)
  ///
  /// ```
  ///
  /// Again, it is generally easier to use the variant of this method that passes the full query in the POST body.
  /// This method is available for cases where other alternatives won't fit the need.
  ///
  /// Supported formats:
  ///
  /// | result_format | Description
  /// | :-----------: | :--- |
  /// | json | Plain json
  /// | json_detail | Row data plus metadata describing the fields, pivots, table calcs, and other aspects of the query
  /// | csv | Comma separated values with a header
  /// | txt | Tab separated values with a header
  /// | html | Simple html
  /// | md | Simple markdown
  /// | xlsx | MS Excel spreadsheet
  /// | sql | Returns the generated SQL rather than running the query
  /// | png | A PNG image of the visualization of the query
  /// | jpg | A JPG image of the visualization of the query
  ///
  /// GET /queries/models/{model_name}/views/{view_name}/run/{result_format} -> String
  ///
  /// **Note**: Binary content may be returned by this method.
  Future<SDKResponse<dynamic>> runUrlEncodedQuery(

      /// @param {String} model_name Model name
      String modelName,

      /// @param {String} view_name View name
      String viewName,

      /// @param {String} result_format Format of result
      String resultFormat) async {
    var pathModelName = encodeParam(modelName);
    var pathViewName = encodeParam(viewName);
    var pathResultFormat = encodeParam(resultFormat);

    dynamic responseHandler(dynamic json, String contentType) {
      return json;
    }

    return get(responseHandler,
        '/queries/models/$pathModelName/views/$pathViewName/run/$pathResultFormat');
  }

  /// ### Get Merge Query
  ///
  /// Returns a merge query object given its id.
  ///
  /// GET /merge_queries/{merge_query_id} -> MergeQuery
  Future<SDKResponse<MergeQuery>> mergeQuery(

      /// @param {String} merge_query_id Merge Query Id
      String mergeQueryId,
      {

      /// @param {String} fields Requested fields
      String fields}) async {
    var pathMergeQueryId = encodeParam(mergeQueryId);

    MergeQuery responseHandler(dynamic json, String contentType) {
      return MergeQuery.fromResponse(json, contentType);
    }

    return get(responseHandler, '/merge_queries/$pathMergeQueryId',
        {'fields': fields});
  }

  /// ### Create Merge Query
  ///
  /// Creates a new merge query object.
  ///
  /// A merge query takes the results of one or more queries and combines (merges) the results
  /// according to field mapping definitions. The result is similar to a SQL left outer join.
  ///
  /// A merge query can merge results of queries from different SQL databases.
  ///
  /// The order that queries are defined in the source_queries array property is significant. The
  /// first query in the array defines the primary key into which the results of subsequent
  /// queries will be merged.
  ///
  /// Like model/view query objects, merge queries are immutable and have structural identity - if
  /// you make a request to create a new merge query that is identical to an existing merge query,
  /// the existing merge query will be returned instead of creating a duplicate. Conversely, any
  /// change to the contents of a merge query will produce a new object with a new id.
  ///
  /// POST /merge_queries -> MergeQuery
  Future<SDKResponse<MergeQuery>> createMergeQuery(
      {

      /// @param {WriteMergeQuery} body
      WriteMergeQuery body,

      /// @param {String} fields Requested fields
      String fields}) async {
    MergeQuery responseHandler(dynamic json, String contentType) {
      return MergeQuery.fromResponse(json, contentType);
    }

    return post(
        responseHandler, '/merge_queries', {'fields': fields}, body?.toJson());
  }

  /// Get information about all running queries.
  ///
  /// GET /running_queries -> List<RunningQueries>
  Future<SDKResponse<List<RunningQueries>>> allRunningQueries() async {
    List<RunningQueries> responseHandler(dynamic json, String contentType) {
      return json
          .map<RunningQueries>(
              (i) => RunningQueries.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/running_queries');
  }

  /// Kill a query with a specific query_task_id.
  ///
  /// DELETE /running_queries/{query_task_id} -> String
  Future<SDKResponse<String>> killQuery(

      /// @param {String} query_task_id Query task id.
      String queryTaskId) async {
    var pathQueryTaskId = encodeParam(queryTaskId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/running_queries/$pathQueryTaskId');
  }

  /// Get a SQL Runner query.
  ///
  /// GET /sql_queries/{slug} -> SqlQuery
  Future<SDKResponse<SqlQuery>> sqlQuery(

      /// @param {String} slug slug of query
      String slug) async {
    var pathSlug = encodeParam(slug);

    SqlQuery responseHandler(dynamic json, String contentType) {
      return SqlQuery.fromResponse(json, contentType);
    }

    return get(responseHandler, '/sql_queries/$pathSlug');
  }

  /// ### Create a SQL Runner Query
  ///
  /// Either the `connection_name` or `model_name` parameter MUST be provided.
  ///
  /// POST /sql_queries -> SqlQuery
  Future<SDKResponse<SqlQuery>> createSqlQuery(

      /// @param {SqlQueryCreate} body
      SqlQueryCreate body) async {
    SqlQuery responseHandler(dynamic json, String contentType) {
      return SqlQuery.fromResponse(json, contentType);
    }

    return post(responseHandler, '/sql_queries', null, body?.toJson());
  }

  /// Execute a SQL Runner query in a given result_format.
  ///
  /// POST /sql_queries/{slug}/run/{result_format} -> String
  ///
  /// **Note**: Binary content may be returned by this method.
  Future<SDKResponse<dynamic>> runSqlQuery(

      /// @param {String} slug slug of query
      String slug,

      /// @param {String} result_format Format of result, options are: ["inline_json", "json", "json_detail", "json_fe", "csv", "html", "md", "txt", "xlsx", "gsxml", "json_label"]
      String resultFormat,
      {

      /// @param {String} download Defaults to false. If set to true, the HTTP response will have content-disposition and other headers set to make the HTTP response behave as a downloadable attachment instead of as inline content.
      String download}) async {
    var pathSlug = encodeParam(slug);
    var pathResultFormat = encodeParam(resultFormat);

    dynamic responseHandler(dynamic json, String contentType) {
      return json;
    }

    return post(responseHandler, '/sql_queries/$pathSlug/run/$pathResultFormat',
        {'download': download});
  }

  // #endregion Query: Run and Manage Queries

  // #region RenderTask: Manage Render Tasks

  /// ### Create a new task to render a look to an image.
  ///
  /// Returns a render task object.
  /// To check the status of a render task, pass the render_task.id to [Get Render Task](#!/RenderTask/get_render_task).
  /// Once the render task is complete, you can download the resulting document or image using [Get Render Task Results](#!/RenderTask/get_render_task_results).
  ///
  /// POST /render_tasks/looks/{look_id}/{result_format} -> RenderTask
  Future<SDKResponse<RenderTask>> createLookRenderTask(

      /// @param {int} look_id Id of look to render
      int lookId,

      /// @param {String} result_format Output type: png, or jpg
      String resultFormat,

      /// @param {int} width Output width in pixels
      int width,

      /// @param {int} height Output height in pixels
      int height,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathLookId = encodeParam(lookId);
    var pathResultFormat = encodeParam(resultFormat);

    RenderTask responseHandler(dynamic json, String contentType) {
      return RenderTask.fromResponse(json, contentType);
    }

    return post(
        responseHandler,
        '/render_tasks/looks/$pathLookId/$pathResultFormat',
        {'width': width, 'height': height, 'fields': fields});
  }

  /// ### Create a new task to render an existing query to an image.
  ///
  /// Returns a render task object.
  /// To check the status of a render task, pass the render_task.id to [Get Render Task](#!/RenderTask/get_render_task).
  /// Once the render task is complete, you can download the resulting document or image using [Get Render Task Results](#!/RenderTask/get_render_task_results).
  ///
  /// POST /render_tasks/queries/{query_id}/{result_format} -> RenderTask
  Future<SDKResponse<RenderTask>> createQueryRenderTask(

      /// @param {int} query_id Id of the query to render
      int queryId,

      /// @param {String} result_format Output type: png or jpg
      String resultFormat,

      /// @param {int} width Output width in pixels
      int width,

      /// @param {int} height Output height in pixels
      int height,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathQueryId = encodeParam(queryId);
    var pathResultFormat = encodeParam(resultFormat);

    RenderTask responseHandler(dynamic json, String contentType) {
      return RenderTask.fromResponse(json, contentType);
    }

    return post(
        responseHandler,
        '/render_tasks/queries/$pathQueryId/$pathResultFormat',
        {'width': width, 'height': height, 'fields': fields});
  }

  /// ### Create a new task to render a dashboard to a document or image.
  ///
  /// Returns a render task object.
  /// To check the status of a render task, pass the render_task.id to [Get Render Task](#!/RenderTask/get_render_task).
  /// Once the render task is complete, you can download the resulting document or image using [Get Render Task Results](#!/RenderTask/get_render_task_results).
  ///
  /// POST /render_tasks/dashboards/{dashboard_id}/{result_format} -> RenderTask
  Future<SDKResponse<RenderTask>> createDashboardRenderTask(

      /// @param {String} dashboard_id Id of dashboard to render. The ID can be a LookML dashboard also.
      String dashboardId,

      /// @param {String} result_format Output type: pdf, png, or jpg
      String resultFormat,

      /// @param {CreateDashboardRenderTask} body
      CreateDashboardRenderTask body,

      /// @param {int} width Output width in pixels
      int width,

      /// @param {int} height Output height in pixels
      int height,
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {String} pdf_paper_size Paper size for pdf. Value can be one of: ["letter","legal","tabloid","a0","a1","a2","a3","a4","a5"]
      String pdfPaperSize,

      /// @param {bool} pdf_landscape Whether to render pdf in landscape paper orientation
      bool pdfLandscape,

      /// @param {bool} long_tables Whether or not to expand table vis to full length
      bool longTables}) async {
    var pathDashboardId = encodeParam(dashboardId);
    var pathResultFormat = encodeParam(resultFormat);

    RenderTask responseHandler(dynamic json, String contentType) {
      return RenderTask.fromResponse(json, contentType);
    }

    return post(
        responseHandler,
        '/render_tasks/dashboards/$pathDashboardId/$pathResultFormat',
        {
          'width': width,
          'height': height,
          'fields': fields,
          'pdf_paper_size': pdfPaperSize,
          'pdf_landscape': pdfLandscape,
          'long_tables': longTables
        },
        body?.toJson());
  }

  /// ### Get information about a render task.
  ///
  /// Returns a render task object.
  /// To check the status of a render task, pass the render_task.id to [Get Render Task](#!/RenderTask/get_render_task).
  /// Once the render task is complete, you can download the resulting document or image using [Get Render Task Results](#!/RenderTask/get_render_task_results).
  ///
  /// GET /render_tasks/{render_task_id} -> RenderTask
  Future<SDKResponse<RenderTask>> renderTask(

      /// @param {String} render_task_id Id of render task
      String renderTaskId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathRenderTaskId = encodeParam(renderTaskId);

    RenderTask responseHandler(dynamic json, String contentType) {
      return RenderTask.fromResponse(json, contentType);
    }

    return get(
        responseHandler, '/render_tasks/$pathRenderTaskId', {'fields': fields});
  }

  /// ### Get the document or image produced by a completed render task.
  ///
  /// Note that the PDF or image result will be a binary blob in the HTTP response, as indicated by the
  /// Content-Type in the response headers. This may require specialized (or at least different) handling than text
  /// responses such as JSON. You may need to tell your HTTP client that the response is binary so that it does not
  /// attempt to parse the binary data as text.
  ///
  /// If the render task exists but has not finished rendering the results, the response HTTP status will be
  /// **202 Accepted**, the response body will be empty, and the response will have a Retry-After header indicating
  /// that the caller should repeat the request at a later time.
  ///
  /// Returns 404 if the render task cannot be found, if the cached result has expired, or if the caller
  /// does not have permission to view the results.
  ///
  /// For detailed information about the status of the render task, use [Render Task](#!/RenderTask/render_task).
  /// Polling loops waiting for completion of a render task would be better served by polling **render_task(id)** until
  /// the task status reaches completion (or error) instead of polling **render_task_results(id)** alone.
  ///
  /// GET /render_tasks/{render_task_id}/results -> String
  ///
  /// **Note**: Binary content is returned by this method.
  ///
  Future<SDKResponse<dynamic>> renderTaskResults(

      /// @param {String} render_task_id Id of render task
      String renderTaskId) async {
    var pathRenderTaskId = encodeParam(renderTaskId);

    dynamic responseHandler(dynamic json, String contentType) {
      return json;
    }

    return get(responseHandler, '/render_tasks/$pathRenderTaskId/results');
  }

  /// ### Create a new task to render a dashboard element to an image.
  ///
  /// Returns a render task object.
  /// To check the status of a render task, pass the render_task.id to [Get Render Task](#!/RenderTask/get_render_task).
  /// Once the render task is complete, you can download the resulting document or image using [Get Render Task Results](#!/RenderTask/get_render_task_results).
  ///
  /// POST /render_tasks/dashboard_elements/{dashboard_element_id}/{result_format} -> RenderTask
  Future<SDKResponse<RenderTask>> createDashboardElementRenderTask(

      /// @param {String} dashboard_element_id Id of dashboard element to render: UDD dashboard element would be numeric and LookML dashboard element would be model_name::dashboard_title::lookml_link_id
      String dashboardElementId,

      /// @param {String} result_format Output type: png or jpg
      String resultFormat,

      /// @param {int} width Output width in pixels
      int width,

      /// @param {int} height Output height in pixels
      int height,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathDashboardElementId = encodeParam(dashboardElementId);
    var pathResultFormat = encodeParam(resultFormat);

    RenderTask responseHandler(dynamic json, String contentType) {
      return RenderTask.fromResponse(json, contentType);
    }

    return post(
        responseHandler,
        '/render_tasks/dashboard_elements/$pathDashboardElementId/$pathResultFormat',
        {'width': width, 'height': height, 'fields': fields});
  }

  // #endregion RenderTask: Manage Render Tasks

  // #region Role: Manage Roles

  /// ### Search model sets
  /// Returns all model set records that match the given search criteria.
  /// If multiple search params are given and `filter_or` is FALSE or not specified,
  /// search params are combined in a logical AND operation.
  /// Only rows that match *all* search param criteria will be returned.
  ///
  /// If `filter_or` is TRUE, multiple search params are combined in a logical OR operation.
  /// Results will include rows that match **any** of the search criteria.
  ///
  /// String search params use case-insensitive matching.
  /// String search params can contain `%` and '_' as SQL LIKE pattern match wildcard expressions.
  /// example="dan%" will match "danger" and "Danzig" but not "David"
  /// example="D_m%" will match "Damage" and "dump"
  ///
  /// Integer search params can accept a single value or a comma separated list of values. The multiple
  /// values will be combined under a logical OR operation - results will match at least one of
  /// the given values.
  ///
  /// Most search params can accept "IS NULL" and "NOT NULL" as special expressions to match
  /// or exclude (respectively) rows where the column is null.
  ///
  /// Boolean search params accept only "true" and "false" as values.
  ///
  /// GET /model_sets/search -> List<ModelSet>
  Future<SDKResponse<List<ModelSet>>> searchModelSets(
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {int} limit Number of results to return (used with `offset`).
      int limit,

      /// @param {int} offset Number of results to skip before returning any (used with `limit`).
      int offset,

      /// @param {String} sorts Fields to sort by.
      String sorts,

      /// @param {int} id Match model set id.
      int id,

      /// @param {String} name Match model set name.
      String name,

      /// @param {bool} all_access Match model sets by all_access status.
      bool allAccess,

      /// @param {bool} built_in Match model sets by built_in status.
      bool builtIn,

      /// @param {bool} filter_or Combine given search criteria in a boolean OR expression.
      bool filterOr}) async {
    List<ModelSet> responseHandler(dynamic json, String contentType) {
      return json
          .map<ModelSet>((i) => ModelSet.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/model_sets/search', {
      'fields': fields,
      'limit': limit,
      'offset': offset,
      'sorts': sorts,
      'id': id,
      'name': name,
      'all_access': allAccess,
      'built_in': builtIn,
      'filter_or': filterOr
    });
  }

  /// ### Get information about the model set with a specific id.
  ///
  /// GET /model_sets/{model_set_id} -> ModelSet
  Future<SDKResponse<ModelSet>> modelSet(

      /// @param {int} model_set_id Id of model set
      int modelSetId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathModelSetId = encodeParam(modelSetId);

    ModelSet responseHandler(dynamic json, String contentType) {
      return ModelSet.fromResponse(json, contentType);
    }

    return get(
        responseHandler, '/model_sets/$pathModelSetId', {'fields': fields});
  }

  /// ### Update information about the model set with a specific id.
  ///
  /// PATCH /model_sets/{model_set_id} -> ModelSet
  Future<SDKResponse<ModelSet>> updateModelSet(

      /// @param {int} model_set_id id of model set
      int modelSetId,

      /// @param {WriteModelSet} body
      WriteModelSet body) async {
    var pathModelSetId = encodeParam(modelSetId);

    ModelSet responseHandler(dynamic json, String contentType) {
      return ModelSet.fromResponse(json, contentType);
    }

    return patch(
        responseHandler, '/model_sets/$pathModelSetId', null, body?.toJson());
  }

  /// ### Delete the model set with a specific id.
  ///
  /// DELETE /model_sets/{model_set_id} -> String
  Future<SDKResponse<String>> deleteModelSet(

      /// @param {int} model_set_id id of model set
      int modelSetId) async {
    var pathModelSetId = encodeParam(modelSetId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/model_sets/$pathModelSetId');
  }

  /// ### Get information about all model sets.
  ///
  /// GET /model_sets -> List<ModelSet>
  Future<SDKResponse<List<ModelSet>>> allModelSets(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<ModelSet> responseHandler(dynamic json, String contentType) {
      return json
          .map<ModelSet>((i) => ModelSet.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/model_sets', {'fields': fields});
  }

  /// ### Create a model set with the specified information. Model sets are used by Roles.
  ///
  /// POST /model_sets -> ModelSet
  Future<SDKResponse<ModelSet>> createModelSet(

      /// @param {WriteModelSet} body
      WriteModelSet body) async {
    ModelSet responseHandler(dynamic json, String contentType) {
      return ModelSet.fromResponse(json, contentType);
    }

    return post(responseHandler, '/model_sets', null, body?.toJson());
  }

  /// ### Get all supported permissions.
  ///
  /// GET /permissions -> List<Permission>
  Future<SDKResponse<List<Permission>>> allPermissions() async {
    List<Permission> responseHandler(dynamic json, String contentType) {
      return json
          .map<Permission>((i) => Permission.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/permissions');
  }

  /// ### Search permission sets
  /// Returns all permission set records that match the given search criteria.
  /// If multiple search params are given and `filter_or` is FALSE or not specified,
  /// search params are combined in a logical AND operation.
  /// Only rows that match *all* search param criteria will be returned.
  ///
  /// If `filter_or` is TRUE, multiple search params are combined in a logical OR operation.
  /// Results will include rows that match **any** of the search criteria.
  ///
  /// String search params use case-insensitive matching.
  /// String search params can contain `%` and '_' as SQL LIKE pattern match wildcard expressions.
  /// example="dan%" will match "danger" and "Danzig" but not "David"
  /// example="D_m%" will match "Damage" and "dump"
  ///
  /// Integer search params can accept a single value or a comma separated list of values. The multiple
  /// values will be combined under a logical OR operation - results will match at least one of
  /// the given values.
  ///
  /// Most search params can accept "IS NULL" and "NOT NULL" as special expressions to match
  /// or exclude (respectively) rows where the column is null.
  ///
  /// Boolean search params accept only "true" and "false" as values.
  ///
  /// GET /permission_sets/search -> List<PermissionSet>
  Future<SDKResponse<List<PermissionSet>>> searchPermissionSets(
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {int} limit Number of results to return (used with `offset`).
      int limit,

      /// @param {int} offset Number of results to skip before returning any (used with `limit`).
      int offset,

      /// @param {String} sorts Fields to sort by.
      String sorts,

      /// @param {int} id Match permission set id.
      int id,

      /// @param {String} name Match permission set name.
      String name,

      /// @param {bool} all_access Match permission sets by all_access status.
      bool allAccess,

      /// @param {bool} built_in Match permission sets by built_in status.
      bool builtIn,

      /// @param {bool} filter_or Combine given search criteria in a boolean OR expression.
      bool filterOr}) async {
    List<PermissionSet> responseHandler(dynamic json, String contentType) {
      return json
          .map<PermissionSet>((i) => PermissionSet.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/permission_sets/search', {
      'fields': fields,
      'limit': limit,
      'offset': offset,
      'sorts': sorts,
      'id': id,
      'name': name,
      'all_access': allAccess,
      'built_in': builtIn,
      'filter_or': filterOr
    });
  }

  /// ### Get information about the permission set with a specific id.
  ///
  /// GET /permission_sets/{permission_set_id} -> PermissionSet
  Future<SDKResponse<PermissionSet>> permissionSet(

      /// @param {int} permission_set_id Id of permission set
      int permissionSetId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathPermissionSetId = encodeParam(permissionSetId);

    PermissionSet responseHandler(dynamic json, String contentType) {
      return PermissionSet.fromResponse(json, contentType);
    }

    return get(responseHandler, '/permission_sets/$pathPermissionSetId',
        {'fields': fields});
  }

  /// ### Update information about the permission set with a specific id.
  ///
  /// PATCH /permission_sets/{permission_set_id} -> PermissionSet
  Future<SDKResponse<PermissionSet>> updatePermissionSet(

      /// @param {int} permission_set_id id of permission set
      int permissionSetId,

      /// @param {WritePermissionSet} body
      WritePermissionSet body) async {
    var pathPermissionSetId = encodeParam(permissionSetId);

    PermissionSet responseHandler(dynamic json, String contentType) {
      return PermissionSet.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/permission_sets/$pathPermissionSetId', null,
        body?.toJson());
  }

  /// ### Delete the permission set with a specific id.
  ///
  /// DELETE /permission_sets/{permission_set_id} -> String
  Future<SDKResponse<String>> deletePermissionSet(

      /// @param {int} permission_set_id Id of permission set
      int permissionSetId) async {
    var pathPermissionSetId = encodeParam(permissionSetId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/permission_sets/$pathPermissionSetId');
  }

  /// ### Get information about all permission sets.
  ///
  /// GET /permission_sets -> List<PermissionSet>
  Future<SDKResponse<List<PermissionSet>>> allPermissionSets(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<PermissionSet> responseHandler(dynamic json, String contentType) {
      return json
          .map<PermissionSet>((i) => PermissionSet.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/permission_sets', {'fields': fields});
  }

  /// ### Create a permission set with the specified information. Permission sets are used by Roles.
  ///
  /// POST /permission_sets -> PermissionSet
  Future<SDKResponse<PermissionSet>> createPermissionSet(

      /// @param {WritePermissionSet} body
      WritePermissionSet body) async {
    PermissionSet responseHandler(dynamic json, String contentType) {
      return PermissionSet.fromResponse(json, contentType);
    }

    return post(responseHandler, '/permission_sets', null, body?.toJson());
  }

  /// ### Get information about all roles.
  ///
  /// GET /roles -> List<Role>
  Future<SDKResponse<List<Role>>> allRoles(
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {DelimList<int>} ids Optional list of ids to get specific roles.
      DelimList<int> ids}) async {
    List<Role> responseHandler(dynamic json, String contentType) {
      return json.map<Role>((i) => Role.fromResponse(i, contentType)).toList();
    }

    return get(responseHandler, '/roles', {'fields': fields, 'ids': ids});
  }

  /// ### Create a role with the specified information.
  ///
  /// POST /roles -> Role
  Future<SDKResponse<Role>> createRole(

      /// @param {WriteRole} body
      WriteRole body) async {
    Role responseHandler(dynamic json, String contentType) {
      return Role.fromResponse(json, contentType);
    }

    return post(responseHandler, '/roles', null, body?.toJson());
  }

  /// ### Search roles
  ///
  /// Returns all role records that match the given search criteria.
  ///
  /// If multiple search params are given and `filter_or` is FALSE or not specified,
  /// search params are combined in a logical AND operation.
  /// Only rows that match *all* search param criteria will be returned.
  ///
  /// If `filter_or` is TRUE, multiple search params are combined in a logical OR operation.
  /// Results will include rows that match **any** of the search criteria.
  ///
  /// String search params use case-insensitive matching.
  /// String search params can contain `%` and '_' as SQL LIKE pattern match wildcard expressions.
  /// example="dan%" will match "danger" and "Danzig" but not "David"
  /// example="D_m%" will match "Damage" and "dump"
  ///
  /// Integer search params can accept a single value or a comma separated list of values. The multiple
  /// values will be combined under a logical OR operation - results will match at least one of
  /// the given values.
  ///
  /// Most search params can accept "IS NULL" and "NOT NULL" as special expressions to match
  /// or exclude (respectively) rows where the column is null.
  ///
  /// Boolean search params accept only "true" and "false" as values.
  ///
  /// GET /roles/search -> List<Role>
  Future<SDKResponse<List<Role>>> searchRoles(
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {int} limit Number of results to return (used with `offset`).
      int limit,

      /// @param {int} offset Number of results to skip before returning any (used with `limit`).
      int offset,

      /// @param {String} sorts Fields to sort by.
      String sorts,

      /// @param {int} id Match role id.
      int id,

      /// @param {String} name Match role name.
      String name,

      /// @param {bool} built_in Match roles by built_in status.
      bool builtIn,

      /// @param {bool} filter_or Combine given search criteria in a boolean OR expression.
      bool filterOr}) async {
    List<Role> responseHandler(dynamic json, String contentType) {
      return json.map<Role>((i) => Role.fromResponse(i, contentType)).toList();
    }

    return get(responseHandler, '/roles/search', {
      'fields': fields,
      'limit': limit,
      'offset': offset,
      'sorts': sorts,
      'id': id,
      'name': name,
      'built_in': builtIn,
      'filter_or': filterOr
    });
  }

  /// ### Search roles include user count
  ///
  /// Returns all role records that match the given search criteria, and attaches
  /// associated user counts.
  ///
  /// If multiple search params are given and `filter_or` is FALSE or not specified,
  /// search params are combined in a logical AND operation.
  /// Only rows that match *all* search param criteria will be returned.
  ///
  /// If `filter_or` is TRUE, multiple search params are combined in a logical OR operation.
  /// Results will include rows that match **any** of the search criteria.
  ///
  /// String search params use case-insensitive matching.
  /// String search params can contain `%` and '_' as SQL LIKE pattern match wildcard expressions.
  /// example="dan%" will match "danger" and "Danzig" but not "David"
  /// example="D_m%" will match "Damage" and "dump"
  ///
  /// Integer search params can accept a single value or a comma separated list of values. The multiple
  /// values will be combined under a logical OR operation - results will match at least one of
  /// the given values.
  ///
  /// Most search params can accept "IS NULL" and "NOT NULL" as special expressions to match
  /// or exclude (respectively) rows where the column is null.
  ///
  /// Boolean search params accept only "true" and "false" as values.
  ///
  /// GET /roles/search/with_user_count -> List<RoleSearch>
  Future<SDKResponse<List<RoleSearch>>> searchRolesWithUserCount(
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {int} limit Number of results to return (used with `offset`).
      int limit,

      /// @param {int} offset Number of results to skip before returning any (used with `limit`).
      int offset,

      /// @param {String} sorts Fields to sort by.
      String sorts,

      /// @param {int} id Match role id.
      int id,

      /// @param {String} name Match role name.
      String name,

      /// @param {bool} built_in Match roles by built_in status.
      bool builtIn,

      /// @param {bool} filter_or Combine given search criteria in a boolean OR expression.
      bool filterOr}) async {
    List<RoleSearch> responseHandler(dynamic json, String contentType) {
      return json
          .map<RoleSearch>((i) => RoleSearch.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/roles/search/with_user_count', {
      'fields': fields,
      'limit': limit,
      'offset': offset,
      'sorts': sorts,
      'id': id,
      'name': name,
      'built_in': builtIn,
      'filter_or': filterOr
    });
  }

  /// ### Get information about the role with a specific id.
  ///
  /// GET /roles/{role_id} -> Role
  Future<SDKResponse<Role>> role(

      /// @param {int} role_id id of role
      int roleId) async {
    var pathRoleId = encodeParam(roleId);

    Role responseHandler(dynamic json, String contentType) {
      return Role.fromResponse(json, contentType);
    }

    return get(responseHandler, '/roles/$pathRoleId');
  }

  /// ### Update information about the role with a specific id.
  ///
  /// PATCH /roles/{role_id} -> Role
  Future<SDKResponse<Role>> updateRole(

      /// @param {int} role_id id of role
      int roleId,

      /// @param {WriteRole} body
      WriteRole body) async {
    var pathRoleId = encodeParam(roleId);

    Role responseHandler(dynamic json, String contentType) {
      return Role.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/roles/$pathRoleId', null, body?.toJson());
  }

  /// ### Delete the role with a specific id.
  ///
  /// DELETE /roles/{role_id} -> String
  Future<SDKResponse<String>> deleteRole(

      /// @param {int} role_id id of role
      int roleId) async {
    var pathRoleId = encodeParam(roleId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/roles/$pathRoleId');
  }

  /// ### Get information about all the groups with the role that has a specific id.
  ///
  /// GET /roles/{role_id}/groups -> List<Group>
  Future<SDKResponse<List<Group>>> roleGroups(

      /// @param {int} role_id id of role
      int roleId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathRoleId = encodeParam(roleId);

    List<Group> responseHandler(dynamic json, String contentType) {
      return json
          .map<Group>((i) => Group.fromResponse(i, contentType))
          .toList();
    }

    return get(
        responseHandler, '/roles/$pathRoleId/groups', {'fields': fields});
  }

  /// ### Set all groups for a role, removing all existing group associations from that role.
  ///
  /// PUT /roles/{role_id}/groups -> List<Group>
  Future<SDKResponse<List<Group>>> setRoleGroups(

      /// @param {int} role_id Id of Role
      int roleId,

      /// @param {List<int>} body
      List<int> body) async {
    var pathRoleId = encodeParam(roleId);

    List<Group> responseHandler(dynamic json, String contentType) {
      return json
          .map<Group>((i) => Group.fromResponse(i, contentType))
          .toList();
    }

    return put(responseHandler, '/roles/$pathRoleId/groups', null, body);
  }

  /// ### Get information about all the users with the role that has a specific id.
  ///
  /// GET /roles/{role_id}/users -> List<User>
  Future<SDKResponse<List<User>>> roleUsers(

      /// @param {int} role_id id of user
      int roleId,
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {bool} direct_association_only Get only users associated directly with the role: exclude those only associated through groups.
      bool directAssociationOnly}) async {
    var pathRoleId = encodeParam(roleId);

    List<User> responseHandler(dynamic json, String contentType) {
      return json.map<User>((i) => User.fromResponse(i, contentType)).toList();
    }

    return get(responseHandler, '/roles/$pathRoleId/users',
        {'fields': fields, 'direct_association_only': directAssociationOnly});
  }

  /// ### Set all the users of the role with a specific id.
  ///
  /// PUT /roles/{role_id}/users -> List<User>
  Future<SDKResponse<List<User>>> setRoleUsers(

      /// @param {int} role_id id of role
      int roleId,

      /// @param {List<int>} body
      List<int> body) async {
    var pathRoleId = encodeParam(roleId);

    List<User> responseHandler(dynamic json, String contentType) {
      return json.map<User>((i) => User.fromResponse(i, contentType)).toList();
    }

    return put(responseHandler, '/roles/$pathRoleId/users', null, body);
  }

  // #endregion Role: Manage Roles

  // #region ScheduledPlan: Manage Scheduled Plans

  /// ### Get Scheduled Plans for a Space
  ///
  /// Returns scheduled plans owned by the caller for a given space id.
  ///
  /// GET /scheduled_plans/space/{space_id} -> List<ScheduledPlan>
  Future<SDKResponse<List<ScheduledPlan>>> scheduledPlansForSpace(

      /// @param {int} space_id Space Id
      int spaceId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathSpaceId = encodeParam(spaceId);

    List<ScheduledPlan> responseHandler(dynamic json, String contentType) {
      return json
          .map<ScheduledPlan>((i) => ScheduledPlan.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/scheduled_plans/space/$pathSpaceId',
        {'fields': fields});
  }

  /// ### Get Information About a Scheduled Plan
  ///
  /// Admins can fetch information about other users' Scheduled Plans.
  ///
  /// GET /scheduled_plans/{scheduled_plan_id} -> ScheduledPlan
  Future<SDKResponse<ScheduledPlan>> scheduledPlan(

      /// @param {int} scheduled_plan_id Scheduled Plan Id
      int scheduledPlanId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathScheduledPlanId = encodeParam(scheduledPlanId);

    ScheduledPlan responseHandler(dynamic json, String contentType) {
      return ScheduledPlan.fromResponse(json, contentType);
    }

    return get(responseHandler, '/scheduled_plans/$pathScheduledPlanId',
        {'fields': fields});
  }

  /// ### Update a Scheduled Plan
  ///
  /// Admins can update other users' Scheduled Plans.
  ///
  /// Note: Any scheduled plan destinations specified in an update will **replace** all scheduled plan destinations
  /// currently defined for the scheduled plan.
  ///
  /// For Example: If a scheduled plan has destinations A, B, and C, and you call update on this scheduled plan
  /// specifying only B in the destinations, then destinations A and C will be deleted by the update.
  ///
  /// Updating a scheduled plan to assign null or an empty array to the scheduled_plan_destinations property is an error, as a scheduled plan must always have at least one destination.
  ///
  /// If you omit the scheduled_plan_destinations property from the object passed to update, then the destinations
  /// defined on the original scheduled plan will remain unchanged.
  ///
  /// #### Email Permissions:
  ///
  /// For details about permissions required to schedule delivery to email and the safeguards
  /// Looker offers to protect against sending to unauthorized email destinations, see [Email Domain Whitelist for Scheduled Looks](https://docs.looker.com/r/api/embed-permissions).
  ///
  ///
  /// #### Scheduled Plan Destination Formats
  ///
  /// Scheduled plan destinations must specify the data format to produce and send to the destination.
  ///
  /// Formats:
  ///
  /// | format | Description
  /// | :-----------: | :--- |
  /// | json | A JSON object containing a `data` property which contains an array of JSON objects, one per row. No metadata.
  /// | json_detail | Row data plus metadata describing the fields, pivots, table calcs, and other aspects of the query
  /// | inline_json | Same as the JSON format, except that the `data` property is a string containing JSON-escaped row data. Additional properties describe the data operation. This format is primarily used to send data to web hooks so that the web hook doesn't have to re-encode the JSON row data in order to pass it on to its ultimate destination.
  /// | csv | Comma separated values with a header
  /// | txt | Tab separated values with a header
  /// | html | Simple html
  /// | xlsx | MS Excel spreadsheet
  /// | wysiwyg_pdf | Dashboard rendered in a tiled layout to produce a PDF document
  /// | assembled_pdf | Dashboard rendered in a single column layout to produce a PDF document
  /// | wysiwyg_png | Dashboard rendered in a tiled layout to produce a PNG image
  /// ||
  ///
  /// Valid formats vary by destination type and source object. `wysiwyg_pdf` is only valid for dashboards, for example.
  ///
  /// PATCH /scheduled_plans/{scheduled_plan_id} -> ScheduledPlan
  Future<SDKResponse<ScheduledPlan>> updateScheduledPlan(

      /// @param {int} scheduled_plan_id Scheduled Plan Id
      int scheduledPlanId,

      /// @param {WriteScheduledPlan} body
      WriteScheduledPlan body) async {
    var pathScheduledPlanId = encodeParam(scheduledPlanId);

    ScheduledPlan responseHandler(dynamic json, String contentType) {
      return ScheduledPlan.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/scheduled_plans/$pathScheduledPlanId', null,
        body?.toJson());
  }

  /// ### Delete a Scheduled Plan
  ///
  /// Normal users can only delete their own scheduled plans.
  /// Admins can delete other users' scheduled plans.
  /// This delete cannot be undone.
  ///
  /// DELETE /scheduled_plans/{scheduled_plan_id} -> String
  Future<SDKResponse<String>> deleteScheduledPlan(

      /// @param {int} scheduled_plan_id Scheduled Plan Id
      int scheduledPlanId) async {
    var pathScheduledPlanId = encodeParam(scheduledPlanId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/scheduled_plans/$pathScheduledPlanId');
  }

  /// ### List All Scheduled Plans
  ///
  /// Returns all scheduled plans which belong to the caller or given user.
  ///
  /// If no user_id is provided, this function returns the scheduled plans owned by the caller.
  ///
  ///
  /// To list all schedules for all users, pass `all_users=true`.
  ///
  ///
  /// The caller must have `see_schedules` permission to see other users' scheduled plans.
  ///
  /// GET /scheduled_plans -> List<ScheduledPlan>
  Future<SDKResponse<List<ScheduledPlan>>> allScheduledPlans(
      {

      /// @param {int} user_id Return scheduled plans belonging to this user_id. If not provided, returns scheduled plans owned by the caller.
      int userId,

      /// @param {String} fields Comma delimited list of field names. If provided, only the fields specified will be included in the response
      String fields,

      /// @param {bool} all_users Return scheduled plans belonging to all users (caller needs see_schedules permission)
      bool allUsers}) async {
    List<ScheduledPlan> responseHandler(dynamic json, String contentType) {
      return json
          .map<ScheduledPlan>((i) => ScheduledPlan.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/scheduled_plans',
        {'user_id': userId, 'fields': fields, 'all_users': allUsers});
  }

  /// ### Create a Scheduled Plan
  ///
  /// Create a scheduled plan to render a Look or Dashboard on a recurring schedule.
  ///
  /// To create a scheduled plan, you MUST provide values for the following fields:
  /// `name`
  /// and
  /// `look_id`, `dashboard_id`, `lookml_dashboard_id`, or `query_id`
  /// and
  /// `cron_tab` or `datagroup`
  /// and
  /// at least one scheduled_plan_destination
  ///
  /// A scheduled plan MUST have at least one scheduled_plan_destination defined.
  ///
  /// When `look_id` is set, `require_no_results`, `require_results`, and `require_change` are all required.
  ///
  /// If `create_scheduled_plan` fails with a 422 error, be sure to look at the error messages in the response which will explain exactly what fields are missing or values that are incompatible.
  ///
  /// The queries that provide the data for the look or dashboard are run in the context of user account that owns the scheduled plan.
  ///
  /// When `run_as_recipient` is `false` or not specified, the queries that provide the data for the
  /// look or dashboard are run in the context of user account that owns the scheduled plan.
  ///
  /// When `run_as_recipient` is `true` and all the email recipients are Looker user accounts, the
  /// queries are run in the context of each recipient, so different recipients may see different
  /// data from the same scheduled render of a look or dashboard. For more details, see [Run As Recipient](https://looker.com/docs/r/admin/run-as-recipient).
  ///
  /// Admins can create and modify scheduled plans on behalf of other users by specifying a user id.
  /// Non-admin users may not create or modify scheduled plans by or for other users.
  ///
  /// #### Email Permissions:
  ///
  /// For details about permissions required to schedule delivery to email and the safeguards
  /// Looker offers to protect against sending to unauthorized email destinations, see [Email Domain Whitelist for Scheduled Looks](https://docs.looker.com/r/api/embed-permissions).
  ///
  ///
  /// #### Scheduled Plan Destination Formats
  ///
  /// Scheduled plan destinations must specify the data format to produce and send to the destination.
  ///
  /// Formats:
  ///
  /// | format | Description
  /// | :-----------: | :--- |
  /// | json | A JSON object containing a `data` property which contains an array of JSON objects, one per row. No metadata.
  /// | json_detail | Row data plus metadata describing the fields, pivots, table calcs, and other aspects of the query
  /// | inline_json | Same as the JSON format, except that the `data` property is a string containing JSON-escaped row data. Additional properties describe the data operation. This format is primarily used to send data to web hooks so that the web hook doesn't have to re-encode the JSON row data in order to pass it on to its ultimate destination.
  /// | csv | Comma separated values with a header
  /// | txt | Tab separated values with a header
  /// | html | Simple html
  /// | xlsx | MS Excel spreadsheet
  /// | wysiwyg_pdf | Dashboard rendered in a tiled layout to produce a PDF document
  /// | assembled_pdf | Dashboard rendered in a single column layout to produce a PDF document
  /// | wysiwyg_png | Dashboard rendered in a tiled layout to produce a PNG image
  /// ||
  ///
  /// Valid formats vary by destination type and source object. `wysiwyg_pdf` is only valid for dashboards, for example.
  ///
  /// POST /scheduled_plans -> ScheduledPlan
  Future<SDKResponse<ScheduledPlan>> createScheduledPlan(

      /// @param {WriteScheduledPlan} body
      WriteScheduledPlan body) async {
    ScheduledPlan responseHandler(dynamic json, String contentType) {
      return ScheduledPlan.fromResponse(json, contentType);
    }

    return post(responseHandler, '/scheduled_plans', null, body?.toJson());
  }

  /// ### Run a Scheduled Plan Immediately
  ///
  /// Create a scheduled plan that runs only once, and immediately.
  ///
  /// This can be useful for testing a Scheduled Plan before committing to a production schedule.
  ///
  /// Admins can create scheduled plans on behalf of other users by specifying a user id.
  ///
  /// This API is rate limited to prevent it from being used for relay spam or DoS attacks
  ///
  /// #### Email Permissions:
  ///
  /// For details about permissions required to schedule delivery to email and the safeguards
  /// Looker offers to protect against sending to unauthorized email destinations, see [Email Domain Whitelist for Scheduled Looks](https://docs.looker.com/r/api/embed-permissions).
  ///
  ///
  /// #### Scheduled Plan Destination Formats
  ///
  /// Scheduled plan destinations must specify the data format to produce and send to the destination.
  ///
  /// Formats:
  ///
  /// | format | Description
  /// | :-----------: | :--- |
  /// | json | A JSON object containing a `data` property which contains an array of JSON objects, one per row. No metadata.
  /// | json_detail | Row data plus metadata describing the fields, pivots, table calcs, and other aspects of the query
  /// | inline_json | Same as the JSON format, except that the `data` property is a string containing JSON-escaped row data. Additional properties describe the data operation. This format is primarily used to send data to web hooks so that the web hook doesn't have to re-encode the JSON row data in order to pass it on to its ultimate destination.
  /// | csv | Comma separated values with a header
  /// | txt | Tab separated values with a header
  /// | html | Simple html
  /// | xlsx | MS Excel spreadsheet
  /// | wysiwyg_pdf | Dashboard rendered in a tiled layout to produce a PDF document
  /// | assembled_pdf | Dashboard rendered in a single column layout to produce a PDF document
  /// | wysiwyg_png | Dashboard rendered in a tiled layout to produce a PNG image
  /// ||
  ///
  /// Valid formats vary by destination type and source object. `wysiwyg_pdf` is only valid for dashboards, for example.
  ///
  /// POST /scheduled_plans/run_once -> ScheduledPlan
  Future<SDKResponse<ScheduledPlan>> scheduledPlanRunOnce(

      /// @param {WriteScheduledPlan} body
      WriteScheduledPlan body) async {
    ScheduledPlan responseHandler(dynamic json, String contentType) {
      return ScheduledPlan.fromResponse(json, contentType);
    }

    return post(
        responseHandler, '/scheduled_plans/run_once', null, body?.toJson());
  }

  /// ### Get Scheduled Plans for a Look
  ///
  /// Returns all scheduled plans for a look which belong to the caller or given user.
  ///
  /// If no user_id is provided, this function returns the scheduled plans owned by the caller.
  ///
  ///
  /// To list all schedules for all users, pass `all_users=true`.
  ///
  ///
  /// The caller must have `see_schedules` permission to see other users' scheduled plans.
  ///
  /// GET /scheduled_plans/look/{look_id} -> List<ScheduledPlan>
  Future<SDKResponse<List<ScheduledPlan>>> scheduledPlansForLook(

      /// @param {int} look_id Look Id
      int lookId,
      {

      /// @param {int} user_id User Id (default is requesting user if not specified)
      int userId,

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {bool} all_users Return scheduled plans belonging to all users for the look
      bool allUsers}) async {
    var pathLookId = encodeParam(lookId);

    List<ScheduledPlan> responseHandler(dynamic json, String contentType) {
      return json
          .map<ScheduledPlan>((i) => ScheduledPlan.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/scheduled_plans/look/$pathLookId',
        {'user_id': userId, 'fields': fields, 'all_users': allUsers});
  }

  /// ### Get Scheduled Plans for a Dashboard
  ///
  /// Returns all scheduled plans for a dashboard which belong to the caller or given user.
  ///
  /// If no user_id is provided, this function returns the scheduled plans owned by the caller.
  ///
  ///
  /// To list all schedules for all users, pass `all_users=true`.
  ///
  ///
  /// The caller must have `see_schedules` permission to see other users' scheduled plans.
  ///
  /// GET /scheduled_plans/dashboard/{dashboard_id} -> List<ScheduledPlan>
  Future<SDKResponse<List<ScheduledPlan>>> scheduledPlansForDashboard(

      /// @param {int} dashboard_id Dashboard Id
      int dashboardId,
      {

      /// @param {int} user_id User Id (default is requesting user if not specified)
      int userId,

      /// @param {bool} all_users Return scheduled plans belonging to all users for the dashboard
      bool allUsers,

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathDashboardId = encodeParam(dashboardId);

    List<ScheduledPlan> responseHandler(dynamic json, String contentType) {
      return json
          .map<ScheduledPlan>((i) => ScheduledPlan.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/scheduled_plans/dashboard/$pathDashboardId',
        {'user_id': userId, 'all_users': allUsers, 'fields': fields});
  }

  /// ### Get Scheduled Plans for a LookML Dashboard
  ///
  /// Returns all scheduled plans for a LookML Dashboard which belong to the caller or given user.
  ///
  /// If no user_id is provided, this function returns the scheduled plans owned by the caller.
  ///
  ///
  /// To list all schedules for all users, pass `all_users=true`.
  ///
  ///
  /// The caller must have `see_schedules` permission to see other users' scheduled plans.
  ///
  /// GET /scheduled_plans/lookml_dashboard/{lookml_dashboard_id} -> List<ScheduledPlan>
  Future<SDKResponse<List<ScheduledPlan>>> scheduledPlansForLookmlDashboard(

      /// @param {String} lookml_dashboard_id LookML Dashboard Id
      String lookmlDashboardId,
      {

      /// @param {int} user_id User Id (default is requesting user if not specified)
      int userId,

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {bool} all_users Return scheduled plans belonging to all users for the dashboard
      bool allUsers}) async {
    var pathLookmlDashboardId = encodeParam(lookmlDashboardId);

    List<ScheduledPlan> responseHandler(dynamic json, String contentType) {
      return json
          .map<ScheduledPlan>((i) => ScheduledPlan.fromResponse(i, contentType))
          .toList();
    }

    return get(
        responseHandler,
        '/scheduled_plans/lookml_dashboard/$pathLookmlDashboardId',
        {'user_id': userId, 'fields': fields, 'all_users': allUsers});
  }

  /// ### Run a Scheduled Plan By Id Immediately
  /// This function creates a run-once schedule plan based on an existing scheduled plan,
  /// applies modifications (if any) to the new scheduled plan, and runs the new schedule plan immediately.
  /// This can be useful for testing modifications to an existing scheduled plan before committing to a production schedule.
  ///
  /// This function internally performs the following operations:
  ///
  /// 1. Copies the properties of the existing scheduled plan into a new scheduled plan
  /// 2. Copies any properties passed in the JSON body of this request into the new scheduled plan (replacing the original values)
  /// 3. Creates the new scheduled plan
  /// 4. Runs the new scheduled plan
  ///
  /// The original scheduled plan is not modified by this operation.
  /// Admins can create, modify, and run scheduled plans on behalf of other users by specifying a user id.
  /// Non-admins can only create, modify, and run their own scheduled plans.
  ///
  /// #### Email Permissions:
  ///
  /// For details about permissions required to schedule delivery to email and the safeguards
  /// Looker offers to protect against sending to unauthorized email destinations, see [Email Domain Whitelist for Scheduled Looks](https://docs.looker.com/r/api/embed-permissions).
  ///
  ///
  /// #### Scheduled Plan Destination Formats
  ///
  /// Scheduled plan destinations must specify the data format to produce and send to the destination.
  ///
  /// Formats:
  ///
  /// | format | Description
  /// | :-----------: | :--- |
  /// | json | A JSON object containing a `data` property which contains an array of JSON objects, one per row. No metadata.
  /// | json_detail | Row data plus metadata describing the fields, pivots, table calcs, and other aspects of the query
  /// | inline_json | Same as the JSON format, except that the `data` property is a string containing JSON-escaped row data. Additional properties describe the data operation. This format is primarily used to send data to web hooks so that the web hook doesn't have to re-encode the JSON row data in order to pass it on to its ultimate destination.
  /// | csv | Comma separated values with a header
  /// | txt | Tab separated values with a header
  /// | html | Simple html
  /// | xlsx | MS Excel spreadsheet
  /// | wysiwyg_pdf | Dashboard rendered in a tiled layout to produce a PDF document
  /// | assembled_pdf | Dashboard rendered in a single column layout to produce a PDF document
  /// | wysiwyg_png | Dashboard rendered in a tiled layout to produce a PNG image
  /// ||
  ///
  /// Valid formats vary by destination type and source object. `wysiwyg_pdf` is only valid for dashboards, for example.
  ///
  ///
  ///
  /// This API is rate limited to prevent it from being used for relay spam or DoS attacks
  ///
  /// POST /scheduled_plans/{scheduled_plan_id}/run_once -> ScheduledPlan
  Future<SDKResponse<ScheduledPlan>> scheduledPlanRunOnceById(

      /// @param {int} scheduled_plan_id Id of schedule plan to copy and run
      int scheduledPlanId,
      {

      /// @param {WriteScheduledPlan} body
      WriteScheduledPlan body}) async {
    var pathScheduledPlanId = encodeParam(scheduledPlanId);

    ScheduledPlan responseHandler(dynamic json, String contentType) {
      return ScheduledPlan.fromResponse(json, contentType);
    }

    return post(responseHandler,
        '/scheduled_plans/$pathScheduledPlanId/run_once', null, body?.toJson());
  }

  // #endregion ScheduledPlan: Manage Scheduled Plans

  // #region Session: Session Information

  /// ### Get API Session
  ///
  /// Returns information about the current API session, such as which workspace is selected for the session.
  ///
  /// GET /session -> ApiSession
  Future<SDKResponse<ApiSession>> session() async {
    ApiSession responseHandler(dynamic json, String contentType) {
      return ApiSession.fromResponse(json, contentType);
    }

    return get(responseHandler, '/session');
  }

  /// ### Update API Session
  ///
  /// #### API Session Workspace
  ///
  /// You can use this endpoint to change the active workspace for the current API session.
  ///
  /// Only one workspace can be active in a session. The active workspace can be changed
  /// any number of times in a session.
  ///
  /// The default workspace for API sessions is the "production" workspace.
  ///
  /// All Looker APIs that use projects or lookml models (such as running queries) will
  /// use the version of project and model files defined by this workspace for the lifetime of the
  /// current API session or until the session workspace is changed again.
  ///
  /// An API session has the same lifetime as the access_token used to authenticate API requests. Each successful
  /// API login generates a new access_token and a new API session.
  ///
  /// If your Looker API client application needs to work in a dev workspace across multiple
  /// API sessions, be sure to select the dev workspace after each login.
  ///
  /// PATCH /session -> ApiSession
  Future<SDKResponse<ApiSession>> updateSession(

      /// @param {WriteApiSession} body
      WriteApiSession body) async {
    ApiSession responseHandler(dynamic json, String contentType) {
      return ApiSession.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/session', null, body?.toJson());
  }

  // #endregion Session: Session Information

  // #region Theme: Manage Themes

  /// ### Get an array of all existing themes
  ///
  /// Get a **single theme** by id with [Theme](#!/Theme/theme)
  ///
  /// This method returns an array of all existing themes. The active time for the theme is not considered.
  ///
  /// **Note**: Custom themes needs to be enabled by Looker. Unless custom themes are enabled, only the automatically generated default theme can be used. Please contact your Account Manager or help.looker.com to update your license for this feature.
  ///
  /// GET /themes -> List<Theme>
  Future<SDKResponse<List<Theme>>> allThemes(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<Theme> responseHandler(dynamic json, String contentType) {
      return json
          .map<Theme>((i) => Theme.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/themes', {'fields': fields});
  }

  /// ### Create a theme
  ///
  /// Creates a new theme object, returning the theme details, including the created id.
  ///
  /// If `settings` are not specified, the default theme settings will be copied into the new theme.
  ///
  /// The theme `name` can only contain alphanumeric characters or underscores. Theme names should not contain any confidential information, such as customer names.
  ///
  /// **Update** an existing theme with [Update Theme](#!/Theme/update_theme)
  ///
  /// **Permanently delete** an existing theme with [Delete Theme](#!/Theme/delete_theme)
  ///
  /// For more information, see [Creating and Applying Themes](https://looker.com/docs/r/admin/themes).
  ///
  /// **Note**: Custom themes needs to be enabled by Looker. Unless custom themes are enabled, only the automatically generated default theme can be used. Please contact your Account Manager or help.looker.com to update your license for this feature.
  ///
  /// POST /themes -> Theme
  Future<SDKResponse<Theme>> createTheme(

      /// @param {WriteTheme} body
      WriteTheme body) async {
    Theme responseHandler(dynamic json, String contentType) {
      return Theme.fromResponse(json, contentType);
    }

    return post(responseHandler, '/themes', null, body?.toJson());
  }

  /// ### Search all themes for matching criteria.
  ///
  /// Returns an **array of theme objects** that match the specified search criteria.
  ///
  /// | Search Parameters | Description
  /// | :-------------------: | :------ |
  /// | `begin_at` only | Find themes active at or after `begin_at`
  /// | `end_at` only | Find themes active at or before `end_at`
  /// | both set | Find themes with an active inclusive period between `begin_at` and `end_at`
  ///
  /// Note: Range matching requires boolean AND logic.
  /// When using `begin_at` and `end_at` together, do not use `filter_or`=TRUE
  ///
  /// If multiple search params are given and `filter_or` is FALSE or not specified,
  /// search params are combined in a logical AND operation.
  /// Only rows that match *all* search param criteria will be returned.
  ///
  /// If `filter_or` is TRUE, multiple search params are combined in a logical OR operation.
  /// Results will include rows that match **any** of the search criteria.
  ///
  /// String search params use case-insensitive matching.
  /// String search params can contain `%` and '_' as SQL LIKE pattern match wildcard expressions.
  /// example="dan%" will match "danger" and "Danzig" but not "David"
  /// example="D_m%" will match "Damage" and "dump"
  ///
  /// Integer search params can accept a single value or a comma separated list of values. The multiple
  /// values will be combined under a logical OR operation - results will match at least one of
  /// the given values.
  ///
  /// Most search params can accept "IS NULL" and "NOT NULL" as special expressions to match
  /// or exclude (respectively) rows where the column is null.
  ///
  /// Boolean search params accept only "true" and "false" as values.
  ///
  ///
  /// Get a **single theme** by id with [Theme](#!/Theme/theme)
  ///
  /// **Note**: Custom themes needs to be enabled by Looker. Unless custom themes are enabled, only the automatically generated default theme can be used. Please contact your Account Manager or help.looker.com to update your license for this feature.
  ///
  /// GET /themes/search -> List<Theme>
  Future<SDKResponse<List<Theme>>> searchThemes(
      {

      /// @param {int} id Match theme id.
      int id,

      /// @param {String} name Match theme name.
      String name,

      /// @param {DateTime} begin_at Timestamp for activation.
      DateTime beginAt,

      /// @param {DateTime} end_at Timestamp for expiration.
      DateTime endAt,

      /// @param {int} limit Number of results to return (used with `offset`).
      int limit,

      /// @param {int} offset Number of results to skip before returning any (used with `limit`).
      int offset,

      /// @param {String} sorts Fields to sort by.
      String sorts,

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {bool} filter_or Combine given search criteria in a boolean OR expression
      bool filterOr}) async {
    List<Theme> responseHandler(dynamic json, String contentType) {
      return json
          .map<Theme>((i) => Theme.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/themes/search', {
      'id': id,
      'name': name,
      'begin_at': beginAt,
      'end_at': endAt,
      'limit': limit,
      'offset': offset,
      'sorts': sorts,
      'fields': fields,
      'filter_or': filterOr
    });
  }

  /// ### Get the default theme
  ///
  /// Returns the active theme object set as the default.
  ///
  /// The **default** theme name can be set in the UI on the Admin|Theme UI page
  ///
  /// The optional `ts` parameter can specify a different timestamp than "now." If specified, it returns the default theme at the time indicated.
  ///
  /// GET /themes/default -> Theme
  Future<SDKResponse<Theme>> defaultTheme(
      {

      /// @param {DateTime} ts Timestamp representing the target datetime for the active period. Defaults to 'now'
      DateTime ts}) async {
    Theme responseHandler(dynamic json, String contentType) {
      return Theme.fromResponse(json, contentType);
    }

    return get(responseHandler, '/themes/default', {'ts': ts});
  }

  /// ### Set the global default theme by theme name
  ///
  /// Only Admin users can call this function.
  ///
  /// Only an active theme with no expiration (`end_at` not set) can be assigned as the default theme. As long as a theme has an active record with no expiration, it can be set as the default.
  ///
  /// [Create Theme](#!/Theme/create) has detailed information on rules for default and active themes
  ///
  /// Returns the new specified default theme object.
  ///
  /// **Note**: Custom themes needs to be enabled by Looker. Unless custom themes are enabled, only the automatically generated default theme can be used. Please contact your Account Manager or help.looker.com to update your license for this feature.
  ///
  /// PUT /themes/default -> Theme
  Future<SDKResponse<Theme>> setDefaultTheme(

      /// @param {String} name Name of theme to set as default
      String name) async {
    Theme responseHandler(dynamic json, String contentType) {
      return Theme.fromResponse(json, contentType);
    }

    return put(responseHandler, '/themes/default', {'name': name});
  }

  /// ### Get active themes
  ///
  /// Returns an array of active themes.
  ///
  /// If the `name` parameter is specified, it will return an array with one theme if it's active and found.
  ///
  /// The optional `ts` parameter can specify a different timestamp than "now."
  ///
  /// **Note**: Custom themes needs to be enabled by Looker. Unless custom themes are enabled, only the automatically generated default theme can be used. Please contact your Account Manager or help.looker.com to update your license for this feature.
  ///
  /// GET /themes/active -> List<Theme>
  Future<SDKResponse<List<Theme>>> activeThemes(
      {

      /// @param {String} name Name of theme
      String name,

      /// @param {DateTime} ts Timestamp representing the target datetime for the active period. Defaults to 'now'
      DateTime ts,

      /// @param {String} fields Requested fields.
      String fields}) async {
    List<Theme> responseHandler(dynamic json, String contentType) {
      return json
          .map<Theme>((i) => Theme.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/themes/active',
        {'name': name, 'ts': ts, 'fields': fields});
  }

  /// ### Get the named theme if it's active. Otherwise, return the default theme
  ///
  /// The optional `ts` parameter can specify a different timestamp than "now."
  /// Note: API users with `show` ability can call this function
  ///
  /// **Note**: Custom themes needs to be enabled by Looker. Unless custom themes are enabled, only the automatically generated default theme can be used. Please contact your Account Manager or help.looker.com to update your license for this feature.
  ///
  /// GET /themes/theme_or_default -> Theme
  Future<SDKResponse<Theme>> themeOrDefault(

      /// @param {String} name Name of theme
      String name,
      {

      /// @param {DateTime} ts Timestamp representing the target datetime for the active period. Defaults to 'now'
      DateTime ts}) async {
    Theme responseHandler(dynamic json, String contentType) {
      return Theme.fromResponse(json, contentType);
    }

    return get(
        responseHandler, '/themes/theme_or_default', {'name': name, 'ts': ts});
  }

  /// ### Validate a theme with the specified information
  ///
  /// Validates all values set for the theme, returning any errors encountered, or 200 OK if valid
  ///
  /// See [Create Theme](#!/Theme/create_theme) for constraints
  ///
  /// **Note**: Custom themes needs to be enabled by Looker. Unless custom themes are enabled, only the automatically generated default theme can be used. Please contact your Account Manager or help.looker.com to update your license for this feature.
  ///
  /// POST /themes/validate -> ValidationError
  Future<SDKResponse<ValidationError>> validateTheme(

      /// @param {WriteTheme} body
      WriteTheme body) async {
    ValidationError responseHandler(dynamic json, String contentType) {
      return ValidationError.fromResponse(json, contentType);
    }

    return post(responseHandler, '/themes/validate', null, body?.toJson());
  }

  /// ### Get a theme by ID
  ///
  /// Use this to retrieve a specific theme, whether or not it's currently active.
  ///
  /// **Note**: Custom themes needs to be enabled by Looker. Unless custom themes are enabled, only the automatically generated default theme can be used. Please contact your Account Manager or help.looker.com to update your license for this feature.
  ///
  /// GET /themes/{theme_id} -> Theme
  Future<SDKResponse<Theme>> theme(

      /// @param {int} theme_id Id of theme
      int themeId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathThemeId = encodeParam(themeId);

    Theme responseHandler(dynamic json, String contentType) {
      return Theme.fromResponse(json, contentType);
    }

    return get(responseHandler, '/themes/$pathThemeId', {'fields': fields});
  }

  /// ### Update the theme by id.
  ///
  /// **Note**: Custom themes needs to be enabled by Looker. Unless custom themes are enabled, only the automatically generated default theme can be used. Please contact your Account Manager or help.looker.com to update your license for this feature.
  ///
  /// PATCH /themes/{theme_id} -> Theme
  Future<SDKResponse<Theme>> updateTheme(

      /// @param {int} theme_id Id of theme
      int themeId,

      /// @param {WriteTheme} body
      WriteTheme body) async {
    var pathThemeId = encodeParam(themeId);

    Theme responseHandler(dynamic json, String contentType) {
      return Theme.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/themes/$pathThemeId', null, body?.toJson());
  }

  /// ### Delete a specific theme by id
  ///
  /// This operation permanently deletes the identified theme from the database.
  ///
  /// Because multiple themes can have the same name (with different activation time spans) themes can only be deleted by ID.
  ///
  /// All IDs associated with a theme name can be retrieved by searching for the theme name with [Theme Search](#!/Theme/search).
  ///
  /// **Note**: Custom themes needs to be enabled by Looker. Unless custom themes are enabled, only the automatically generated default theme can be used. Please contact your Account Manager or help.looker.com to update your license for this feature.
  ///
  /// DELETE /themes/{theme_id} -> String
  Future<SDKResponse<String>> deleteTheme(

      /// @param {String} theme_id Id of theme
      String themeId) async {
    var pathThemeId = encodeParam(themeId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/themes/$pathThemeId');
  }

  // #endregion Theme: Manage Themes

  // #region User: Manage Users

  /// ### Search email credentials
  ///
  /// Returns all credentials_email records that match the given search criteria.
  ///
  /// If multiple search params are given and `filter_or` is FALSE or not specified,
  /// search params are combined in a logical AND operation.
  /// Only rows that match *all* search param criteria will be returned.
  ///
  /// If `filter_or` is TRUE, multiple search params are combined in a logical OR operation.
  /// Results will include rows that match **any** of the search criteria.
  ///
  /// String search params use case-insensitive matching.
  /// String search params can contain `%` and '_' as SQL LIKE pattern match wildcard expressions.
  /// example="dan%" will match "danger" and "Danzig" but not "David"
  /// example="D_m%" will match "Damage" and "dump"
  ///
  /// Integer search params can accept a single value or a comma separated list of values. The multiple
  /// values will be combined under a logical OR operation - results will match at least one of
  /// the given values.
  ///
  /// Most search params can accept "IS NULL" and "NOT NULL" as special expressions to match
  /// or exclude (respectively) rows where the column is null.
  ///
  /// Boolean search params accept only "true" and "false" as values.
  ///
  /// GET /credentials_email/search -> List<CredentialsEmailSearch>
  Future<SDKResponse<List<CredentialsEmailSearch>>> searchCredentialsEmail(
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {int} limit Number of results to return (used with `offset`).
      int limit,

      /// @param {int} offset Number of results to skip before returning any (used with `limit`).
      int offset,

      /// @param {String} sorts Fields to sort by.
      String sorts,

      /// @param {int} id Match credentials_email id.
      int id,

      /// @param {String} email Match credentials_email email.
      String email,

      /// @param {String} emails Find credentials_email that match given emails.
      String emails,

      /// @param {bool} filter_or Combine given search criteria in a boolean OR expression.
      bool filterOr}) async {
    List<CredentialsEmailSearch> responseHandler(
        dynamic json, String contentType) {
      return json
          .map<CredentialsEmailSearch>(
              (i) => CredentialsEmailSearch.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/credentials_email/search', {
      'fields': fields,
      'limit': limit,
      'offset': offset,
      'sorts': sorts,
      'id': id,
      'email': email,
      'emails': emails,
      'filter_or': filterOr
    });
  }

  /// ### Get information about the current user; i.e. the user account currently calling the API.
  ///
  /// GET /user -> User
  Future<SDKResponse<User>> me(
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    User responseHandler(dynamic json, String contentType) {
      return User.fromResponse(json, contentType);
    }

    return get(responseHandler, '/user', {'fields': fields});
  }

  /// ### Get information about all users.
  ///
  /// GET /users -> List<User>
  Future<SDKResponse<List<User>>> allUsers(
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {int} page DEPRECATED. Use limit and offset instead. Return only page N of paginated results
      int page,

      /// @param {int} per_page DEPRECATED. Use limit and offset instead. Return N rows of data per page
      int perPage,

      /// @param {int} limit Number of results to return. (used with offset and takes priority over page and per_page)
      int limit,

      /// @param {int} offset Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
      int offset,

      /// @param {String} sorts Fields to sort by.
      String sorts,

      /// @param {DelimList<int>} ids Optional list of ids to get specific users.
      DelimList<int> ids}) async {
    List<User> responseHandler(dynamic json, String contentType) {
      return json.map<User>((i) => User.fromResponse(i, contentType)).toList();
    }

    return get(responseHandler, '/users', {
      'fields': fields,
      'page': page,
      'per_page': perPage,
      'limit': limit,
      'offset': offset,
      'sorts': sorts,
      'ids': ids
    });
  }

  /// ### Create a user with the specified information.
  ///
  /// POST /users -> User
  Future<SDKResponse<User>> createUser(
      {

      /// @param {WriteUser} body
      WriteUser body,

      /// @param {String} fields Requested fields.
      String fields}) async {
    User responseHandler(dynamic json, String contentType) {
      return User.fromResponse(json, contentType);
    }

    return post(responseHandler, '/users', {'fields': fields}, body?.toJson());
  }

  /// ### Search users
  ///
  /// Returns all<sup>*</sup> user records that match the given search criteria.
  ///
  /// If multiple search params are given and `filter_or` is FALSE or not specified,
  /// search params are combined in a logical AND operation.
  /// Only rows that match *all* search param criteria will be returned.
  ///
  /// If `filter_or` is TRUE, multiple search params are combined in a logical OR operation.
  /// Results will include rows that match **any** of the search criteria.
  ///
  /// String search params use case-insensitive matching.
  /// String search params can contain `%` and '_' as SQL LIKE pattern match wildcard expressions.
  /// example="dan%" will match "danger" and "Danzig" but not "David"
  /// example="D_m%" will match "Damage" and "dump"
  ///
  /// Integer search params can accept a single value or a comma separated list of values. The multiple
  /// values will be combined under a logical OR operation - results will match at least one of
  /// the given values.
  ///
  /// Most search params can accept "IS NULL" and "NOT NULL" as special expressions to match
  /// or exclude (respectively) rows where the column is null.
  ///
  /// Boolean search params accept only "true" and "false" as values.
  ///
  ///
  /// (<sup>*</sup>) Results are always filtered to the level of information the caller is permitted to view.
  /// Looker admins can see all user details; normal users in an open system can see
  /// names of other users but no details; normal users in a closed system can only see
  /// names of other users who are members of the same group as the user.
  ///
  /// GET /users/search -> List<User>
  Future<SDKResponse<List<User>>> searchUsers(
      {

      /// @param {String} fields Include only these fields in the response
      String fields,

      /// @param {int} page DEPRECATED. Use limit and offset instead. Return only page N of paginated results
      int page,

      /// @param {int} per_page DEPRECATED. Use limit and offset instead. Return N rows of data per page
      int perPage,

      /// @param {int} limit Number of results to return. (used with offset and takes priority over page and per_page)
      int limit,

      /// @param {int} offset Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
      int offset,

      /// @param {String} sorts Fields to sort by.
      String sorts,

      /// @param {String} id Match User Id.
      String id,

      /// @param {String} first_name Match First name.
      String firstName,

      /// @param {String} last_name Match Last name.
      String lastName,

      /// @param {bool} verified_looker_employee Search for user accounts associated with Looker employees
      bool verifiedLookerEmployee,

      /// @param {bool} embed_user Search for only embed users
      bool embedUser,

      /// @param {String} email Search for the user with this email address
      String email,

      /// @param {bool} is_disabled Search for disabled user accounts
      bool isDisabled,

      /// @param {bool} filter_or Combine given search criteria in a boolean OR expression
      bool filterOr,

      /// @param {String} content_metadata_id Search for users who have access to this content_metadata item
      String contentMetadataId,

      /// @param {String} group_id Search for users who are direct members of this group
      String groupId}) async {
    List<User> responseHandler(dynamic json, String contentType) {
      return json.map<User>((i) => User.fromResponse(i, contentType)).toList();
    }

    return get(responseHandler, '/users/search', {
      'fields': fields,
      'page': page,
      'per_page': perPage,
      'limit': limit,
      'offset': offset,
      'sorts': sorts,
      'id': id,
      'first_name': firstName,
      'last_name': lastName,
      'verified_looker_employee': verifiedLookerEmployee,
      'embed_user': embedUser,
      'email': email,
      'is_disabled': isDisabled,
      'filter_or': filterOr,
      'content_metadata_id': contentMetadataId,
      'group_id': groupId
    });
  }

  /// ### Search for user accounts by name
  ///
  /// Returns all user accounts where `first_name` OR `last_name` OR `email` field values match a pattern.
  /// The pattern can contain `%` and `_` wildcards as in SQL LIKE expressions.
  ///
  /// Any additional search params will be combined into a logical AND expression.
  ///
  /// GET /users/search/names/{pattern} -> List<User>
  Future<SDKResponse<List<User>>> searchUsersNames(

      /// @param {String} pattern Pattern to match
      String pattern,
      {

      /// @param {String} fields Include only these fields in the response
      String fields,

      /// @param {int} page DEPRECATED. Use limit and offset instead. Return only page N of paginated results
      int page,

      /// @param {int} per_page DEPRECATED. Use limit and offset instead. Return N rows of data per page
      int perPage,

      /// @param {int} limit Number of results to return. (used with offset and takes priority over page and per_page)
      int limit,

      /// @param {int} offset Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
      int offset,

      /// @param {String} sorts Fields to sort by
      String sorts,

      /// @param {int} id Match User Id
      int id,

      /// @param {String} first_name Match First name
      String firstName,

      /// @param {String} last_name Match Last name
      String lastName,

      /// @param {bool} verified_looker_employee Match Verified Looker employee
      bool verifiedLookerEmployee,

      /// @param {String} email Match Email Address
      String email,

      /// @param {bool} is_disabled Include or exclude disabled accounts in the results
      bool isDisabled}) async {
    var pathPattern = encodeParam(pattern);

    List<User> responseHandler(dynamic json, String contentType) {
      return json.map<User>((i) => User.fromResponse(i, contentType)).toList();
    }

    return get(responseHandler, '/users/search/names/$pathPattern', {
      'fields': fields,
      'page': page,
      'per_page': perPage,
      'limit': limit,
      'offset': offset,
      'sorts': sorts,
      'id': id,
      'first_name': firstName,
      'last_name': lastName,
      'verified_looker_employee': verifiedLookerEmployee,
      'email': email,
      'is_disabled': isDisabled
    });
  }

  /// ### Get information about the user with a specific id.
  ///
  /// If the caller is an admin or the caller is the user being specified, then full user information will
  /// be returned. Otherwise, a minimal 'public' variant of the user information will be returned. This contains
  /// The user name and avatar url, but no sensitive information.
  ///
  /// GET /users/{user_id} -> User
  Future<SDKResponse<User>> user(

      /// @param {int} user_id Id of user
      int userId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    User responseHandler(dynamic json, String contentType) {
      return User.fromResponse(json, contentType);
    }

    return get(responseHandler, '/users/$pathUserId', {'fields': fields});
  }

  /// ### Update information about the user with a specific id.
  ///
  /// PATCH /users/{user_id} -> User
  Future<SDKResponse<User>> updateUser(

      /// @param {int} user_id Id of user
      int userId,

      /// @param {WriteUser} body
      WriteUser body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    User responseHandler(dynamic json, String contentType) {
      return User.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/users/$pathUserId', {'fields': fields},
        body?.toJson());
  }

  /// ### Delete the user with a specific id.
  ///
  /// **DANGER** this will delete the user and all looks and other information owned by the user.
  ///
  /// DELETE /users/{user_id} -> String
  Future<SDKResponse<String>> deleteUser(

      /// @param {int} user_id Id of user
      int userId) async {
    var pathUserId = encodeParam(userId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/users/$pathUserId');
  }

  /// ### Get information about the user with a credential of given type with specific id.
  ///
  /// This is used to do things like find users by their embed external_user_id. Or, find the user with
  /// a given api3 client_id, etc. The 'credential_type' matches the 'type' name of the various credential
  /// types. It must be one of the values listed in the table below. The 'credential_id' is your unique Id
  /// for the user and is specific to each type of credential.
  ///
  /// An example using the Ruby sdk might look like:
  ///
  /// `sdk.user_for_credential('embed', 'customer-4959425')`
  ///
  /// This table shows the supported 'Credential Type' strings. The right column is for reference; it shows
  /// which field in the given credential type is actually searched when finding a user with the supplied
  /// 'credential_id'.
  ///
  /// | Credential Types | Id Field Matched |
  /// | ---------------- | ---------------- |
  /// | email            | email            |
  /// | google           | google_user_id   |
  /// | saml             | saml_user_id     |
  /// | oidc             | oidc_user_id     |
  /// | ldap             | ldap_id          |
  /// | api              | token            |
  /// | api3             | client_id        |
  /// | embed            | external_user_id |
  /// | looker_openid    | email            |
  ///
  /// **NOTE**: The 'api' credential type was only used with the legacy Looker query API and is no longer supported. The credential type for API you are currently looking at is 'api3'.
  ///
  /// GET /users/credential/{credential_type}/{credential_id} -> User
  Future<SDKResponse<User>> userForCredential(

      /// @param {String} credential_type Type name of credential
      String credentialType,

      /// @param {String} credential_id Id of credential
      String credentialId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathCredentialType = encodeParam(credentialType);
    var pathCredentialId = encodeParam(credentialId);

    User responseHandler(dynamic json, String contentType) {
      return User.fromResponse(json, contentType);
    }

    return get(
        responseHandler,
        '/users/credential/$pathCredentialType/$pathCredentialId',
        {'fields': fields});
  }

  /// ### Email/password login information for the specified user.
  ///
  /// GET /users/{user_id}/credentials_email -> CredentialsEmail
  Future<SDKResponse<CredentialsEmail>> userCredentialsEmail(

      /// @param {int} user_id id of user
      int userId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    CredentialsEmail responseHandler(dynamic json, String contentType) {
      return CredentialsEmail.fromResponse(json, contentType);
    }

    return get(responseHandler, '/users/$pathUserId/credentials_email',
        {'fields': fields});
  }

  /// ### Email/password login information for the specified user.
  ///
  /// POST /users/{user_id}/credentials_email -> CredentialsEmail
  Future<SDKResponse<CredentialsEmail>> createUserCredentialsEmail(

      /// @param {int} user_id id of user
      int userId,

      /// @param {WriteCredentialsEmail} body
      WriteCredentialsEmail body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    CredentialsEmail responseHandler(dynamic json, String contentType) {
      return CredentialsEmail.fromResponse(json, contentType);
    }

    return post(responseHandler, '/users/$pathUserId/credentials_email',
        {'fields': fields}, body?.toJson());
  }

  /// ### Email/password login information for the specified user.
  ///
  /// PATCH /users/{user_id}/credentials_email -> CredentialsEmail
  Future<SDKResponse<CredentialsEmail>> updateUserCredentialsEmail(

      /// @param {int} user_id id of user
      int userId,

      /// @param {WriteCredentialsEmail} body
      WriteCredentialsEmail body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    CredentialsEmail responseHandler(dynamic json, String contentType) {
      return CredentialsEmail.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/users/$pathUserId/credentials_email',
        {'fields': fields}, body?.toJson());
  }

  /// ### Email/password login information for the specified user.
  ///
  /// DELETE /users/{user_id}/credentials_email -> String
  Future<SDKResponse<String>> deleteUserCredentialsEmail(

      /// @param {int} user_id id of user
      int userId) async {
    var pathUserId = encodeParam(userId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/users/$pathUserId/credentials_email');
  }

  /// ### Two-factor login information for the specified user.
  ///
  /// GET /users/{user_id}/credentials_totp -> CredentialsTotp
  Future<SDKResponse<CredentialsTotp>> userCredentialsTotp(

      /// @param {int} user_id id of user
      int userId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    CredentialsTotp responseHandler(dynamic json, String contentType) {
      return CredentialsTotp.fromResponse(json, contentType);
    }

    return get(responseHandler, '/users/$pathUserId/credentials_totp',
        {'fields': fields});
  }

  /// ### Two-factor login information for the specified user.
  ///
  /// POST /users/{user_id}/credentials_totp -> CredentialsTotp
  Future<SDKResponse<CredentialsTotp>> createUserCredentialsTotp(

      /// @param {int} user_id id of user
      int userId,
      {

      /// @param {CredentialsTotp} body
      CredentialsTotp body,

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    CredentialsTotp responseHandler(dynamic json, String contentType) {
      return CredentialsTotp.fromResponse(json, contentType);
    }

    return post(responseHandler, '/users/$pathUserId/credentials_totp',
        {'fields': fields}, body?.toJson());
  }

  /// ### Two-factor login information for the specified user.
  ///
  /// DELETE /users/{user_id}/credentials_totp -> String
  Future<SDKResponse<String>> deleteUserCredentialsTotp(

      /// @param {int} user_id id of user
      int userId) async {
    var pathUserId = encodeParam(userId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/users/$pathUserId/credentials_totp');
  }

  /// ### LDAP login information for the specified user.
  ///
  /// GET /users/{user_id}/credentials_ldap -> CredentialsLDAP
  Future<SDKResponse<CredentialsLDAP>> userCredentialsLdap(

      /// @param {int} user_id id of user
      int userId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    CredentialsLDAP responseHandler(dynamic json, String contentType) {
      return CredentialsLDAP.fromResponse(json, contentType);
    }

    return get(responseHandler, '/users/$pathUserId/credentials_ldap',
        {'fields': fields});
  }

  /// ### LDAP login information for the specified user.
  ///
  /// DELETE /users/{user_id}/credentials_ldap -> String
  Future<SDKResponse<String>> deleteUserCredentialsLdap(

      /// @param {int} user_id id of user
      int userId) async {
    var pathUserId = encodeParam(userId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/users/$pathUserId/credentials_ldap');
  }

  /// ### Google authentication login information for the specified user.
  ///
  /// GET /users/{user_id}/credentials_google -> CredentialsGoogle
  Future<SDKResponse<CredentialsGoogle>> userCredentialsGoogle(

      /// @param {int} user_id id of user
      int userId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    CredentialsGoogle responseHandler(dynamic json, String contentType) {
      return CredentialsGoogle.fromResponse(json, contentType);
    }

    return get(responseHandler, '/users/$pathUserId/credentials_google',
        {'fields': fields});
  }

  /// ### Google authentication login information for the specified user.
  ///
  /// DELETE /users/{user_id}/credentials_google -> String
  Future<SDKResponse<String>> deleteUserCredentialsGoogle(

      /// @param {int} user_id id of user
      int userId) async {
    var pathUserId = encodeParam(userId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/users/$pathUserId/credentials_google');
  }

  /// ### Saml authentication login information for the specified user.
  ///
  /// GET /users/{user_id}/credentials_saml -> CredentialsSaml
  Future<SDKResponse<CredentialsSaml>> userCredentialsSaml(

      /// @param {int} user_id id of user
      int userId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    CredentialsSaml responseHandler(dynamic json, String contentType) {
      return CredentialsSaml.fromResponse(json, contentType);
    }

    return get(responseHandler, '/users/$pathUserId/credentials_saml',
        {'fields': fields});
  }

  /// ### Saml authentication login information for the specified user.
  ///
  /// DELETE /users/{user_id}/credentials_saml -> String
  Future<SDKResponse<String>> deleteUserCredentialsSaml(

      /// @param {int} user_id id of user
      int userId) async {
    var pathUserId = encodeParam(userId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/users/$pathUserId/credentials_saml');
  }

  /// ### OpenID Connect (OIDC) authentication login information for the specified user.
  ///
  /// GET /users/{user_id}/credentials_oidc -> CredentialsOIDC
  Future<SDKResponse<CredentialsOIDC>> userCredentialsOidc(

      /// @param {int} user_id id of user
      int userId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    CredentialsOIDC responseHandler(dynamic json, String contentType) {
      return CredentialsOIDC.fromResponse(json, contentType);
    }

    return get(responseHandler, '/users/$pathUserId/credentials_oidc',
        {'fields': fields});
  }

  /// ### OpenID Connect (OIDC) authentication login information for the specified user.
  ///
  /// DELETE /users/{user_id}/credentials_oidc -> String
  Future<SDKResponse<String>> deleteUserCredentialsOidc(

      /// @param {int} user_id id of user
      int userId) async {
    var pathUserId = encodeParam(userId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/users/$pathUserId/credentials_oidc');
  }

  /// ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.
  ///
  /// GET /users/{user_id}/credentials_api3/{credentials_api3_id} -> CredentialsApi3
  Future<SDKResponse<CredentialsApi3>> userCredentialsApi3(

      /// @param {int} user_id Id of user
      int userId,

      /// @param {int} credentials_api3_id Id of API 3 Credential
      int credentialsApi3Id,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);
    var pathCredentialsApi3Id = encodeParam(credentialsApi3Id);

    CredentialsApi3 responseHandler(dynamic json, String contentType) {
      return CredentialsApi3.fromResponse(json, contentType);
    }

    return get(
        responseHandler,
        '/users/$pathUserId/credentials_api3/$pathCredentialsApi3Id',
        {'fields': fields});
  }

  /// ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.
  ///
  /// DELETE /users/{user_id}/credentials_api3/{credentials_api3_id} -> String
  Future<SDKResponse<String>> deleteUserCredentialsApi3(

      /// @param {int} user_id id of user
      int userId,

      /// @param {int} credentials_api3_id id of API 3 Credential
      int credentialsApi3Id) async {
    var pathUserId = encodeParam(userId);
    var pathCredentialsApi3Id = encodeParam(credentialsApi3Id);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler,
        '/users/$pathUserId/credentials_api3/$pathCredentialsApi3Id');
  }

  /// ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.
  ///
  /// GET /users/{user_id}/credentials_api3 -> List<CredentialsApi3>
  Future<SDKResponse<List<CredentialsApi3>>> allUserCredentialsApi3s(

      /// @param {int} user_id id of user
      int userId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    List<CredentialsApi3> responseHandler(dynamic json, String contentType) {
      return json
          .map<CredentialsApi3>(
              (i) => CredentialsApi3.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/users/$pathUserId/credentials_api3',
        {'fields': fields});
  }

  /// ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.
  ///
  /// POST /users/{user_id}/credentials_api3 -> CreateCredentialsApi3
  Future<SDKResponse<CreateCredentialsApi3>> createUserCredentialsApi3(

      /// @param {int} user_id id of user
      int userId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    CreateCredentialsApi3 responseHandler(dynamic json, String contentType) {
      return CreateCredentialsApi3.fromResponse(json, contentType);
    }

    return post(responseHandler, '/users/$pathUserId/credentials_api3',
        {'fields': fields});
  }

  /// ### Embed login information for the specified user.
  ///
  /// GET /users/{user_id}/credentials_embed/{credentials_embed_id} -> CredentialsEmbed
  Future<SDKResponse<CredentialsEmbed>> userCredentialsEmbed(

      /// @param {int} user_id Id of user
      int userId,

      /// @param {int} credentials_embed_id Id of Embedding Credential
      int credentialsEmbedId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);
    var pathCredentialsEmbedId = encodeParam(credentialsEmbedId);

    CredentialsEmbed responseHandler(dynamic json, String contentType) {
      return CredentialsEmbed.fromResponse(json, contentType);
    }

    return get(
        responseHandler,
        '/users/$pathUserId/credentials_embed/$pathCredentialsEmbedId',
        {'fields': fields});
  }

  /// ### Embed login information for the specified user.
  ///
  /// DELETE /users/{user_id}/credentials_embed/{credentials_embed_id} -> String
  Future<SDKResponse<String>> deleteUserCredentialsEmbed(

      /// @param {int} user_id id of user
      int userId,

      /// @param {int} credentials_embed_id id of Embedding Credential
      int credentialsEmbedId) async {
    var pathUserId = encodeParam(userId);
    var pathCredentialsEmbedId = encodeParam(credentialsEmbedId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler,
        '/users/$pathUserId/credentials_embed/$pathCredentialsEmbedId');
  }

  /// ### Embed login information for the specified user.
  ///
  /// GET /users/{user_id}/credentials_embed -> List<CredentialsEmbed>
  Future<SDKResponse<List<CredentialsEmbed>>> allUserCredentialsEmbeds(

      /// @param {int} user_id id of user
      int userId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    List<CredentialsEmbed> responseHandler(dynamic json, String contentType) {
      return json
          .map<CredentialsEmbed>(
              (i) => CredentialsEmbed.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/users/$pathUserId/credentials_embed',
        {'fields': fields});
  }

  /// ### Looker Openid login information for the specified user. Used by Looker Analysts.
  ///
  /// GET /users/{user_id}/credentials_looker_openid -> CredentialsLookerOpenid
  Future<SDKResponse<CredentialsLookerOpenid>> userCredentialsLookerOpenid(

      /// @param {int} user_id id of user
      int userId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    CredentialsLookerOpenid responseHandler(dynamic json, String contentType) {
      return CredentialsLookerOpenid.fromResponse(json, contentType);
    }

    return get(responseHandler, '/users/$pathUserId/credentials_looker_openid',
        {'fields': fields});
  }

  /// ### Looker Openid login information for the specified user. Used by Looker Analysts.
  ///
  /// DELETE /users/{user_id}/credentials_looker_openid -> String
  Future<SDKResponse<String>> deleteUserCredentialsLookerOpenid(

      /// @param {int} user_id id of user
      int userId) async {
    var pathUserId = encodeParam(userId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(
        responseHandler, '/users/$pathUserId/credentials_looker_openid');
  }

  /// ### Web login session for the specified user.
  ///
  /// GET /users/{user_id}/sessions/{session_id} -> Session
  Future<SDKResponse<Session>> userSession(

      /// @param {int} user_id Id of user
      int userId,

      /// @param {int} session_id Id of Web Login Session
      int sessionId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);
    var pathSessionId = encodeParam(sessionId);

    Session responseHandler(dynamic json, String contentType) {
      return Session.fromResponse(json, contentType);
    }

    return get(responseHandler, '/users/$pathUserId/sessions/$pathSessionId',
        {'fields': fields});
  }

  /// ### Web login session for the specified user.
  ///
  /// DELETE /users/{user_id}/sessions/{session_id} -> String
  Future<SDKResponse<String>> deleteUserSession(

      /// @param {int} user_id id of user
      int userId,

      /// @param {int} session_id id of Web Login Session
      int sessionId) async {
    var pathUserId = encodeParam(userId);
    var pathSessionId = encodeParam(sessionId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(
        responseHandler, '/users/$pathUserId/sessions/$pathSessionId');
  }

  /// ### Web login session for the specified user.
  ///
  /// GET /users/{user_id}/sessions -> List<Session>
  Future<SDKResponse<List<Session>>> allUserSessions(

      /// @param {int} user_id id of user
      int userId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    List<Session> responseHandler(dynamic json, String contentType) {
      return json
          .map<Session>((i) => Session.fromResponse(i, contentType))
          .toList();
    }

    return get(
        responseHandler, '/users/$pathUserId/sessions', {'fields': fields});
  }

  /// ### Create a password reset token.
  /// This will create a cryptographically secure random password reset token for the user.
  /// If the user already has a password reset token then this invalidates the old token and creates a new one.
  /// The token is expressed as the 'password_reset_url' of the user's email/password credential object.
  /// This takes an optional 'expires' param to indicate if the new token should be an expiring token.
  /// Tokens that expire are typically used for self-service password resets for existing users.
  /// Invitation emails for new users typically are not set to expire.
  /// The expire period is always 60 minutes when expires is enabled.
  /// This method can be called with an empty body.
  ///
  /// POST /users/{user_id}/credentials_email/password_reset -> CredentialsEmail
  Future<SDKResponse<CredentialsEmail>> createUserCredentialsEmailPasswordReset(

      /// @param {int} user_id Id of user
      int userId,
      {

      /// @param {bool} expires Expiring token.
      bool expires,

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    CredentialsEmail responseHandler(dynamic json, String contentType) {
      return CredentialsEmail.fromResponse(json, contentType);
    }

    return post(
        responseHandler,
        '/users/$pathUserId/credentials_email/password_reset',
        {'expires': expires, 'fields': fields});
  }

  /// ### Get information about roles of a given user
  ///
  /// GET /users/{user_id}/roles -> List<Role>
  Future<SDKResponse<List<Role>>> userRoles(

      /// @param {int} user_id id of user
      int userId,
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {bool} direct_association_only Get only roles associated directly with the user: exclude those only associated through groups.
      bool directAssociationOnly}) async {
    var pathUserId = encodeParam(userId);

    List<Role> responseHandler(dynamic json, String contentType) {
      return json.map<Role>((i) => Role.fromResponse(i, contentType)).toList();
    }

    return get(responseHandler, '/users/$pathUserId/roles',
        {'fields': fields, 'direct_association_only': directAssociationOnly});
  }

  /// ### Set roles of the user with a specific id.
  ///
  /// PUT /users/{user_id}/roles -> List<Role>
  Future<SDKResponse<List<Role>>> setUserRoles(

      /// @param {int} user_id id of user
      int userId,

      /// @param {List<int>} body
      List<int> body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    List<Role> responseHandler(dynamic json, String contentType) {
      return json.map<Role>((i) => Role.fromResponse(i, contentType)).toList();
    }

    return put(
        responseHandler, '/users/$pathUserId/roles', {'fields': fields}, body);
  }

  /// ### Get user attribute values for a given user.
  ///
  /// Returns the values of specified user attributes (or all user attributes) for a certain user.
  ///
  /// A value for each user attribute is searched for in the following locations, in this order:
  ///
  /// 1. in the user's account information
  /// 1. in groups that the user is a member of
  /// 1. the default value of the user attribute
  ///
  /// If more than one group has a value defined for a user attribute, the group with the lowest rank wins.
  ///
  /// The response will only include user attributes for which values were found. Use `include_unset=true` to include
  /// empty records for user attributes with no value.
  ///
  /// The value of all hidden user attributes will be blank.
  ///
  /// GET /users/{user_id}/attribute_values -> List<UserAttributeWithValue>
  Future<SDKResponse<List<UserAttributeWithValue>>> userAttributeUserValues(

      /// @param {int} user_id Id of user
      int userId,
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {DelimList<int>} user_attribute_ids Specific user attributes to request. Omit or leave blank to request all user attributes.
      DelimList<int> userAttributeIds,

      /// @param {bool} all_values If true, returns all values in the search path instead of just the first value found. Useful for debugging group precedence.
      bool allValues,

      /// @param {bool} include_unset If true, returns an empty record for each requested attribute that has no user, group, or default value.
      bool includeUnset}) async {
    var pathUserId = encodeParam(userId);

    List<UserAttributeWithValue> responseHandler(
        dynamic json, String contentType) {
      return json
          .map<UserAttributeWithValue>(
              (i) => UserAttributeWithValue.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/users/$pathUserId/attribute_values', {
      'fields': fields,
      'user_attribute_ids': userAttributeIds,
      'all_values': allValues,
      'include_unset': includeUnset
    });
  }

  /// ### Store a custom value for a user attribute in a user's account settings.
  ///
  /// Per-user user attribute values take precedence over group or default values.
  ///
  /// PATCH /users/{user_id}/attribute_values/{user_attribute_id} -> UserAttributeWithValue
  Future<SDKResponse<UserAttributeWithValue>> setUserAttributeUserValue(

      /// @param {int} user_id Id of user
      int userId,

      /// @param {int} user_attribute_id Id of user attribute
      int userAttributeId,

      /// @param {WriteUserAttributeWithValue} body
      WriteUserAttributeWithValue body) async {
    var pathUserId = encodeParam(userId);
    var pathUserAttributeId = encodeParam(userAttributeId);

    UserAttributeWithValue responseHandler(dynamic json, String contentType) {
      return UserAttributeWithValue.fromResponse(json, contentType);
    }

    return patch(
        responseHandler,
        '/users/$pathUserId/attribute_values/$pathUserAttributeId',
        null,
        body?.toJson());
  }

  /// ### Delete a user attribute value from a user's account settings.
  ///
  /// After the user attribute value is deleted from the user's account settings, subsequent requests
  /// for the user attribute value for this user will draw from the user's groups or the default
  /// value of the user attribute. See [Get User Attribute Values](#!/User/user_attribute_user_values) for more
  /// information about how user attribute values are resolved.
  ///
  /// DELETE /users/{user_id}/attribute_values/{user_attribute_id} -> void
  Future<SDKResponse<void>> deleteUserAttributeUserValue(

      /// @param {int} user_id Id of user
      int userId,

      /// @param {int} user_attribute_id Id of user attribute
      int userAttributeId) async {
    var pathUserId = encodeParam(userId);
    var pathUserAttributeId = encodeParam(userAttributeId);

    void responseHandler(dynamic json, String contentType) {}
    return delete(responseHandler,
        '/users/$pathUserId/attribute_values/$pathUserAttributeId');
  }

  /// ### Send a password reset token.
  /// This will send a password reset email to the user. If a password reset token does not already exist
  /// for this user, it will create one and then send it.
  /// If the user has not yet set up their account, it will send a setup email to the user.
  /// The URL sent in the email is expressed as the 'password_reset_url' of the user's email/password credential object.
  /// Password reset URLs will expire in 60 minutes.
  /// This method can be called with an empty body.
  ///
  /// POST /users/{user_id}/credentials_email/send_password_reset -> CredentialsEmail
  Future<SDKResponse<CredentialsEmail>> sendUserCredentialsEmailPasswordReset(

      /// @param {int} user_id Id of user
      int userId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    CredentialsEmail responseHandler(dynamic json, String contentType) {
      return CredentialsEmail.fromResponse(json, contentType);
    }

    return post(
        responseHandler,
        '/users/$pathUserId/credentials_email/send_password_reset',
        {'fields': fields});
  }

  /// ### Change a disabled user's email addresses
  ///
  /// Allows the admin to change the email addresses for all the user's
  /// associated credentials.  Will overwrite all associated email addresses with
  /// the value supplied in the 'email' body param.
  /// The user's 'is_disabled' status must be true.
  ///
  /// POST /users/{user_id}/update_emails -> User
  Future<SDKResponse<User>> wipeoutUserEmails(

      /// @param {int} user_id Id of user
      int userId,

      /// @param {UserEmailOnly} body
      UserEmailOnly body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserId = encodeParam(userId);

    User responseHandler(dynamic json, String contentType) {
      return User.fromResponse(json, contentType);
    }

    return post(responseHandler, '/users/$pathUserId/update_emails',
        {'fields': fields}, body?.toJson());
  }

  /// Create an embed user from an external user ID
  ///
  /// POST /users/embed_user -> UserPublic
  Future<SDKResponse<UserPublic>> createEmbedUser(

      /// @param {CreateEmbedUserRequest} body
      CreateEmbedUserRequest body) async {
    UserPublic responseHandler(dynamic json, String contentType) {
      return UserPublic.fromResponse(json, contentType);
    }

    return post(responseHandler, '/users/embed_user', null, body?.toJson());
  }

  // #endregion User: Manage Users

  // #region UserAttribute: Manage User Attributes

  /// ### Get information about all user attributes.
  ///
  /// GET /user_attributes -> List<UserAttribute>
  Future<SDKResponse<List<UserAttribute>>> allUserAttributes(
      {

      /// @param {String} fields Requested fields.
      String fields,

      /// @param {String} sorts Fields to order the results by. Sortable fields include: name, label
      String sorts}) async {
    List<UserAttribute> responseHandler(dynamic json, String contentType) {
      return json
          .map<UserAttribute>((i) => UserAttribute.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/user_attributes',
        {'fields': fields, 'sorts': sorts});
  }

  /// ### Create a new user attribute
  ///
  /// Permission information for a user attribute is conveyed through the `can` and `user_can_edit` fields.
  /// The `user_can_edit` field indicates whether an attribute is user-editable _anywhere_ in the application.
  /// The `can` field gives more granular access information, with the `set_value` child field indicating whether
  /// an attribute's value can be set by [Setting the User Attribute User Value](#!/User/set_user_attribute_user_value).
  ///
  /// Note: `name` and `label` fields must be unique across all user attributes in the Looker instance.
  /// Attempting to create a new user attribute with a name or label that duplicates an existing
  /// user attribute will fail with a 422 error.
  ///
  /// POST /user_attributes -> UserAttribute
  Future<SDKResponse<UserAttribute>> createUserAttribute(

      /// @param {WriteUserAttribute} body
      WriteUserAttribute body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    UserAttribute responseHandler(dynamic json, String contentType) {
      return UserAttribute.fromResponse(json, contentType);
    }

    return post(responseHandler, '/user_attributes', {'fields': fields},
        body?.toJson());
  }

  /// ### Get information about a user attribute.
  ///
  /// GET /user_attributes/{user_attribute_id} -> UserAttribute
  Future<SDKResponse<UserAttribute>> userAttribute(

      /// @param {int} user_attribute_id Id of user attribute
      int userAttributeId,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserAttributeId = encodeParam(userAttributeId);

    UserAttribute responseHandler(dynamic json, String contentType) {
      return UserAttribute.fromResponse(json, contentType);
    }

    return get(responseHandler, '/user_attributes/$pathUserAttributeId',
        {'fields': fields});
  }

  /// ### Update a user attribute definition.
  ///
  /// PATCH /user_attributes/{user_attribute_id} -> UserAttribute
  Future<SDKResponse<UserAttribute>> updateUserAttribute(

      /// @param {int} user_attribute_id Id of user attribute
      int userAttributeId,

      /// @param {WriteUserAttribute} body
      WriteUserAttribute body,
      {

      /// @param {String} fields Requested fields.
      String fields}) async {
    var pathUserAttributeId = encodeParam(userAttributeId);

    UserAttribute responseHandler(dynamic json, String contentType) {
      return UserAttribute.fromResponse(json, contentType);
    }

    return patch(responseHandler, '/user_attributes/$pathUserAttributeId',
        {'fields': fields}, body?.toJson());
  }

  /// ### Delete a user attribute (admin only).
  ///
  /// DELETE /user_attributes/{user_attribute_id} -> String
  Future<SDKResponse<String>> deleteUserAttribute(

      /// @param {int} user_attribute_id Id of user_attribute
      int userAttributeId) async {
    var pathUserAttributeId = encodeParam(userAttributeId);

    String responseHandler(dynamic json, String contentType) {
      return json;
    }

    return delete(responseHandler, '/user_attributes/$pathUserAttributeId');
  }

  /// ### Returns all values of a user attribute defined by user groups, in precedence order.
  ///
  /// A user may be a member of multiple groups which define different values for a given user attribute.
  /// The order of group-values in the response determines precedence for selecting which group-value applies
  /// to a given user.  For more information, see [Set User Attribute Group Values](#!/UserAttribute/set_user_attribute_group_values).
  ///
  /// Results will only include groups that the caller's user account has permission to see.
  ///
  /// GET /user_attributes/{user_attribute_id}/group_values -> List<UserAttributeGroupValue>
  Future<SDKResponse<List<UserAttributeGroupValue>>>
      allUserAttributeGroupValues(

          /// @param {int} user_attribute_id Id of user attribute
          int userAttributeId,
          {

          /// @param {String} fields Requested fields.
          String fields}) async {
    var pathUserAttributeId = encodeParam(userAttributeId);

    List<UserAttributeGroupValue> responseHandler(
        dynamic json, String contentType) {
      return json
          .map<UserAttributeGroupValue>(
              (i) => UserAttributeGroupValue.fromResponse(i, contentType))
          .toList();
    }

    return get(
        responseHandler,
        '/user_attributes/$pathUserAttributeId/group_values',
        {'fields': fields});
  }

  /// ### Define values for a user attribute across a set of groups, in priority order.
  ///
  /// This function defines all values for a user attribute defined by user groups. This is a global setting, potentially affecting
  /// all users in the system. This function replaces any existing group value definitions for the indicated user attribute.
  ///
  /// The value of a user attribute for a given user is determined by searching the following locations, in this order:
  ///
  /// 1. the user's account settings
  /// 2. the groups that the user is a member of
  /// 3. the default value of the user attribute, if any
  ///
  /// The user may be a member of multiple groups which define different values for that user attribute. The order of items in the group_values parameter
  /// determines which group takes priority for that user. Lowest array index wins.
  ///
  /// An alternate method to indicate the selection precedence of group-values is to assign numbers to the 'rank' property of each
  /// group-value object in the array. Lowest 'rank' value wins. If you use this technique, you must assign a
  /// rank value to every group-value object in the array.
  ///
  ///   To set a user attribute value for a single user, see [Set User Attribute User Value](#!/User/set_user_attribute_user_value).
  /// To set a user attribute value for all members of a group, see [Set User Attribute Group Value](#!/Group/update_user_attribute_group_value).
  ///
  /// POST /user_attributes/{user_attribute_id}/group_values -> List<UserAttributeGroupValue>
  Future<SDKResponse<List<UserAttributeGroupValue>>>
      setUserAttributeGroupValues(

          /// @param {int} user_attribute_id Id of user attribute
          int userAttributeId,

          /// @param {List<UserAttributeGroupValue>} body
          List<UserAttributeGroupValue> body) async {
    var pathUserAttributeId = encodeParam(userAttributeId);

    List<UserAttributeGroupValue> responseHandler(
        dynamic json, String contentType) {
      return json
          .map<UserAttributeGroupValue>(
              (i) => UserAttributeGroupValue.fromResponse(i, contentType))
          .toList();
    }

    return post(responseHandler,
        '/user_attributes/$pathUserAttributeId/group_values', null, body);
  }

  // #endregion UserAttribute: Manage User Attributes

  // #region Workspace: Manage Workspaces

  /// ### Get All Workspaces
  ///
  /// Returns all workspaces available to the calling user.
  ///
  /// GET /workspaces -> List<Workspace>
  Future<SDKResponse<List<Workspace>>> allWorkspaces() async {
    List<Workspace> responseHandler(dynamic json, String contentType) {
      return json
          .map<Workspace>((i) => Workspace.fromResponse(i, contentType))
          .toList();
    }

    return get(responseHandler, '/workspaces');
  }

  /// ### Get A Workspace
  ///
  /// Returns information about a workspace such as the git status and selected branches
  /// of all projects available to the caller's user account.
  ///
  /// A workspace defines which versions of project files will be used to evaluate expressions
  /// and operations that use model definitions - operations such as running queries or rendering dashboards.
  /// Each project has its own git repository, and each project in a workspace may be configured to reference
  /// particular branch or revision within their respective repositories.
  ///
  /// There are two predefined workspaces available: "production" and "dev".
  ///
  /// The production workspace is shared across all Looker users. Models in the production workspace are read-only.
  /// Changing files in production is accomplished by modifying files in a git branch and using Pull Requests
  /// to merge the changes from the dev branch into the production branch, and then telling
  /// Looker to sync with production.
  ///
  /// The dev workspace is local to each Looker user. Changes made to project/model files in the dev workspace only affect
  /// that user, and only when the dev workspace is selected as the active workspace for the API session.
  /// (See set_session_workspace()).
  ///
  /// The dev workspace is NOT unique to an API session. Two applications accessing the Looker API using
  /// the same user account will see the same files in the dev workspace. To avoid collisions between
  /// API clients it's best to have each client login with API3 credentials for a different user account.
  ///
  /// Changes made to files in a dev workspace are persistent across API sessions. It's a good
  /// idea to commit any changes you've made to the git repository, but not strictly required. Your modified files
  /// reside in a special user-specific directory on the Looker server and will still be there when you login in again
  /// later and use update_session(workspace_id: "dev") to select the dev workspace for the new API session.
  ///
  /// GET /workspaces/{workspace_id} -> Workspace
  Future<SDKResponse<Workspace>> workspace(

      /// @param {String} workspace_id Id of the workspace
      String workspaceId) async {
    var pathWorkspaceId = encodeParam(workspaceId);

    Workspace responseHandler(dynamic json, String contentType) {
      return Workspace.fromResponse(json, contentType);
    }

    return get(responseHandler, '/workspaces/$pathWorkspaceId');
  }

  // #endregion Workspace: Manage Workspaces
}
