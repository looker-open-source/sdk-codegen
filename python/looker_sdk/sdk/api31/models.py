# 230 API models: 178 Spec, 0 Request, 52 Write

# NOTE: Do not edit this file generated by Looker SDK Codegen for Looker 7.2 API 3.1
import datetime
from typing import MutableMapping, Optional, Sequence

import attr

from looker_sdk.rtl import model
from looker_sdk.rtl import serialize as sr

EXPLICIT_NULL = model.EXPLICIT_NULL  # type: ignore
DelimSequence = model.DelimSequence


@attr.s(auto_attribs=True, kw_only=True)
class AccessToken(model.Model):
    """
    Attributes:
        access_token: Access Token used for API calls
        token_type: Type of Token
        expires_in: Number of seconds before the token expires
    """

    access_token: Optional[str] = None
    token_type: Optional[str] = None
    expires_in: Optional[int] = None


@attr.s(auto_attribs=True, kw_only=True)
class ApiSession(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        workspace_id: The id of active workspace for this session
        sudo_user_id: The id of the actual user in the case when this session represents one user sudo'ing as another
    """

    can: Optional[MutableMapping[str, bool]] = None
    workspace_id: Optional[str] = None
    sudo_user_id: Optional[int] = None


@attr.s(auto_attribs=True, kw_only=True)
class ApiVersion(model.Model):
    """
    Attributes:
        looker_release_version: Current Looker release version number
        current_version:
        supported_versions: Array of versions supported by this Looker instance
    """

    looker_release_version: Optional[str] = None
    current_version: Optional["ApiVersionElement"] = None
    supported_versions: Optional[Sequence["ApiVersionElement"]] = None


@attr.s(auto_attribs=True, kw_only=True)
class ApiVersionElement(model.Model):
    """
    Attributes:
        version: Version number as it appears in '/api/xxx/' urls
        full_version: Full version number including minor version
        status: Status of this version
        swagger_url: Url for swagger.json for this version
    """

    version: Optional[str] = None
    full_version: Optional[str] = None
    status: Optional[str] = None
    swagger_url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class BackupConfiguration(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        type: Type of backup: looker-s3 or custom-s3
        custom_s3_bucket: Name of bucket for custom-s3 backups
        custom_s3_bucket_region: Name of region where the bucket is located
        custom_s3_key: (Write-Only) AWS S3 key used for custom-s3 backups
        custom_s3_secret: (Write-Only) AWS S3 secret used for custom-s3 backups
        url: Link to get this item
    """

    can: Optional[MutableMapping[str, bool]] = None
    type: Optional[str] = None
    custom_s3_bucket: Optional[str] = None
    custom_s3_bucket_region: Optional[str] = None
    custom_s3_key: Optional[str] = None
    custom_s3_secret: Optional[str] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class ColorCollection(model.Model):
    """
    Attributes:
        id: Unique Id
        label: Label of color collection
        categoricalPalettes: Array of categorical palette definitions
        sequentialPalettes: Array of discrete palette definitions
        divergingPalettes: Array of diverging palette definitions
    """

    id: Optional[str] = None
    label: Optional[str] = None
    categoricalPalettes: Optional[Sequence["DiscretePalette"]] = None
    sequentialPalettes: Optional[Sequence["ContinuousPalette"]] = None
    divergingPalettes: Optional[Sequence["ContinuousPalette"]] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class ColorStop(model.Model):
    """
    Attributes:
        color: CSS color string
        offset: Offset in continuous palette (0 to 100)
    """

    color: Optional[str] = None
    offset: Optional[int] = None

    def __init__(self, *, color: Optional[str] = None, offset: Optional[int] = None):
        self.color = color
        self.offset = offset


@attr.s(auto_attribs=True, kw_only=True)
class ContentFavorite(model.Model):
    """
    Attributes:
        id: Unique Id
        user_id: User Id which owns this ContentFavorite
        content_metadata_id: Content Metadata Id associated with this ContentFavorite
        look_id: Id of a look
        dashboard_id: Id of a dashboard
        look:
        dashboard:
    """

    id: Optional[int] = None
    user_id: Optional[int] = None
    content_metadata_id: Optional[int] = None
    look_id: Optional[int] = None
    dashboard_id: Optional[int] = None
    look: Optional["LookBasic"] = None
    dashboard: Optional["DashboardBase"] = None


@attr.s(auto_attribs=True, kw_only=True)
class ContentMeta(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: Unique Id
        name: Name or title of underlying content
        parent_id: Id of Parent Content
        space_id: Id of associated space when content_type is "space"
        folder_id: Id of associated folder when content_type is "space"
        dashboard_id: Id of associated dashboard when content_type is "dashboard"
        look_id: Id of associated look when content_type is "look"
        content_type: Content Type ("dashboard", "look", or "space")
        inherits: Whether content inherits its access levels from parent
        inheriting_id: Id of Inherited Content
        slug: Content Slug
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[int] = None
    name: Optional[str] = None
    parent_id: Optional[int] = None
    space_id: Optional[str] = None
    folder_id: Optional[str] = None
    dashboard_id: Optional[str] = None
    look_id: Optional[int] = None
    content_type: Optional[str] = None
    inherits: Optional[bool] = None
    inheriting_id: Optional[int] = None
    slug: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class ContentMetaGroupUser(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: Unique Id
        content_metadata_id: Id of associated Content Metadata
        permission_type: Type of permission: "view" or "edit" Valid values are: "view", "edit".
        group_id: ID of associated group
        user_id: ID of associated user
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[str] = None
    content_metadata_id: Optional[str] = None
    permission_type: Optional[str] = None
    group_id: Optional[int] = None
    user_id: Optional[int] = None

    def __init__(
        self,
        *,
        can: Optional[MutableMapping[str, bool]] = None,
        id: Optional[str] = None,
        content_metadata_id: Optional[str] = None,
        permission_type: Optional[str] = None,
        group_id: Optional[int] = None,
        user_id: Optional[int] = None
    ):
        self.can = can
        self.id = id
        self.content_metadata_id = content_metadata_id
        self.permission_type = permission_type
        self.group_id = group_id
        self.user_id = user_id


@attr.s(auto_attribs=True, kw_only=True)
class ContentValidation(model.Model):
    """
    Attributes:
        content_with_errors: A list of content errors
        computation_time: Duration of content validation in seconds
        total_looks_validated: The number of looks validated
        total_dashboard_elements_validated: The number of dashboard elements validated
        total_explores_validated: The number of explores used across all content validated
    """

    content_with_errors: Optional[Sequence["ContentValidatorError"]] = None
    computation_time: Optional[float] = None
    total_looks_validated: Optional[int] = None
    total_dashboard_elements_validated: Optional[int] = None
    total_explores_validated: Optional[int] = None


@attr.s(auto_attribs=True, kw_only=True)
class ContentValidationDashboard(model.Model):
    """
    Attributes:
        description: Description
        id: Unique Id
        space:
        folder:
        title: Dashboard Title
    """

    description: Optional[str] = None
    id: Optional[str] = None
    space: Optional["ContentValidationSpace"] = None
    folder: Optional["ContentValidationFolder"] = None
    title: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class ContentValidationDashboardElement(model.Model):
    """
    Attributes:
        body_text: Text tile body text
        dashboard_id: Id of Dashboard
        id: Unique Id
        look_id: Id Of Look
        note_display: Note Display
        note_state: Note State
        note_text: Note Text
        note_text_as_html: Note Text as Html
        query_id: Id Of Query
        subtitle_text: Text tile subtitle text
        title: Title of dashboard element
        title_hidden: Whether title is hidden
        title_text: Text tile title
        type: Type
    """

    body_text: Optional[str] = None
    dashboard_id: Optional[str] = None
    id: Optional[str] = None
    look_id: Optional[str] = None
    note_display: Optional[str] = None
    note_state: Optional[str] = None
    note_text: Optional[str] = None
    note_text_as_html: Optional[str] = None
    query_id: Optional[int] = None
    subtitle_text: Optional[str] = None
    title: Optional[str] = None
    title_hidden: Optional[bool] = None
    title_text: Optional[str] = None
    type: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class ContentValidationDashboardFilter(model.Model):
    """
    Attributes:
        id: Unique Id
        dashboard_id: Id of Dashboard
        name: Name of filter
        title: Title of filter
        type: Type of filter: one of date, number, string, or field
        default_value: Default value of filter
        model: Model of filter (required if type = field)
        explore: Explore of filter (required if type = field)
        dimension: Dimension of filter (required if type = field)
    """

    id: Optional[str] = None
    dashboard_id: Optional[str] = None
    name: Optional[str] = None
    title: Optional[str] = None
    type: Optional[str] = None
    default_value: Optional[str] = None
    model: Optional[str] = None
    explore: Optional[str] = None
    dimension: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class ContentValidationError(model.Model):
    """
    Attributes:
        message: Error message
        field_name: Name of the field involved in the error
        model_name: Name of the model involved in the error
        explore_name: Name of the explore involved in the error
        removable: Whether this validation error is removable
    """

    message: Optional[str] = None
    field_name: Optional[str] = None
    model_name: Optional[str] = None
    explore_name: Optional[str] = None
    removable: Optional[bool] = None


@attr.s(auto_attribs=True, kw_only=True)
class ContentValidationFolder(model.Model):
    """
    Attributes:
        name: Unique Name
        id: Unique Id
    """

    name: str
    id: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class ContentValidationLook(model.Model):
    """
    Attributes:
        id: Unique Id
        title: Look Title
        space:
        folder:
    """

    id: Optional[int] = None
    title: Optional[str] = None
    space: Optional["ContentValidationSpace"] = None
    folder: Optional["ContentValidationFolder"] = None


@attr.s(auto_attribs=True, kw_only=True)
class ContentValidationSpace(model.Model):
    """
    Attributes:
        name: Unique Name
        id: Unique Id
    """

    name: str
    id: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class ContentValidatorError(model.Model):
    """
    Attributes:
        look:
        dashboard:
        dashboard_element:
        dashboard_filter:
        errors: A list of errors found for this piece of content
        id: An id unique to this piece of content for this validation run
    """

    look: Optional["ContentValidationLook"] = None
    dashboard: Optional["ContentValidationDashboard"] = None
    dashboard_element: Optional["ContentValidationDashboardElement"] = None
    dashboard_filter: Optional["ContentValidationDashboardFilter"] = None
    errors: Optional[Sequence["ContentValidationError"]] = None
    id: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class ContentView(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: Unique Id
        look_id: Id of viewed Look
        dashboard_id: Id of the viewed Dashboard
        content_metadata_id: Content metadata id of the Look or Dashboard
        user_id: Id of user content was viewed by
        group_id: Id of group content was viewed by
        view_count: Number of times piece of content was viewed
        favorite_count: Number of times piece of content was favorited
        last_viewed_at: Date the piece of content was last viewed
        start_of_week_date: Week start date for the view and favorite count during that given week
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[int] = None
    look_id: Optional[int] = None
    dashboard_id: Optional[int] = None
    content_metadata_id: Optional[int] = None
    user_id: Optional[int] = None
    group_id: Optional[int] = None
    view_count: Optional[int] = None
    favorite_count: Optional[int] = None
    last_viewed_at: Optional[str] = None
    start_of_week_date: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class ContinuousPalette(model.Model):
    """
    Attributes:
        id: Unique identity string
        label: Label for palette
        type: Type of palette
        stops: Array of ColorStops in the palette
    """

    id: Optional[str] = None
    label: Optional[str] = None
    type: Optional[str] = None
    stops: Optional[Sequence["ColorStop"]] = None

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        label: Optional[str] = None,
        type: Optional[str] = None,
        stops: Optional[Sequence["ColorStop"]] = None
    ):
        self.id = id
        self.label = label
        self.type = type
        self.stops = stops


@attr.s(auto_attribs=True, kw_only=True)
class CreateDashboardFilter(model.Model):
    """
    Attributes:
        id: Unique Id
        dashboard_id: Id of Dashboard
        name: Name of filter
        title: Title of filter
        type: Type of filter: one of date, number, string, or field
        default_value: Default value of filter
        model: Model of filter (required if type = field)
        explore: Explore of filter (required if type = field)
        dimension: Dimension of filter (required if type = field)
        field: Field information
        row: Display order of this filter relative to other filters
        listens_to_filters: Array of listeners for faceted filters
        allow_multiple_values: Whether the filter allows multiple filter values
        required: Whether the filter requires a value to run the dashboard
        ui_config: The visual configuration for this filter. Used to set up how the UI for this filter should appear.
    """

    id: Optional[str] = None
    dashboard_id: str
    name: str
    title: str
    type: str
    default_value: Optional[str] = None
    model: Optional[str] = None
    explore: Optional[str] = None
    dimension: Optional[str] = None
    field: Optional[MutableMapping[str, str]] = None
    row: Optional[int] = None
    listens_to_filters: Optional[Sequence[str]] = None
    allow_multiple_values: Optional[bool] = None
    required: Optional[bool] = None
    ui_config: Optional[MutableMapping[str, str]] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class CreateDashboardRenderTask(model.Model):
    """
    Attributes:
        dashboard_filters: Filter values to apply to the dashboard queries, in URL query format
        dashboard_style: Dashboard layout style: single_column or tiled
    """

    dashboard_filters: Optional[str] = None
    dashboard_style: Optional[str] = None

    def __init__(
        self,
        *,
        dashboard_filters: Optional[str] = None,
        dashboard_style: Optional[str] = None
    ):
        self.dashboard_filters = dashboard_filters
        self.dashboard_style = dashboard_style


@attr.s(auto_attribs=True, kw_only=True, init=False)
class CreateFolder(model.Model):
    """
    Attributes:
        name: Unique Name
        parent_id: Id of Parent. If the parent id is null, this is a root-level entry
    """

    name: str
    parent_id: str

    def __init__(self, *, name: str, parent_id: str):
        self.name = name
        self.parent_id = parent_id


@attr.s(auto_attribs=True, kw_only=True)
class CreateQueryTask(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        query_id: Id of query to run
        result_format: Desired async query result format. Valid values are: "json", "json_detail", "json_fe", "csv", "html", "md", "txt", "xlsx", "gsxml".
        source: Source of query task
        deferred: Create the task but defer execution
        look_id: Id of look associated with query.
        dashboard_id: Id of dashboard associated with query.
    """

    can: Optional[MutableMapping[str, bool]] = None
    query_id: int
    result_format: str
    source: Optional[str] = None
    deferred: Optional[bool] = None
    look_id: Optional[int] = None
    dashboard_id: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class CreateSpace(model.Model):
    """
    Attributes:
        name: Unique Name
        parent_id: Id of Parent. If the parent id is null, this is a root-level entry
    """

    name: str
    parent_id: str

    def __init__(self, *, name: str, parent_id: str):
        self.name = name
        self.parent_id = parent_id


@attr.s(auto_attribs=True, kw_only=True, init=False)
class CredentialsApi3(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: Unique Id
        client_id: API key client_id
        created_at: Timestamp for the creation of this credential
        is_disabled: Has this credential been disabled?
        type: Short name for the type of this kind of credential
        url: Link to get this item
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[int] = None
    client_id: Optional[str] = None
    created_at: Optional[str] = None
    is_disabled: Optional[bool] = None
    type: Optional[str] = None
    url: Optional[str] = None

    def __init__(
        self,
        *,
        can: Optional[MutableMapping[str, bool]] = None,
        id: Optional[int] = None,
        client_id: Optional[str] = None,
        created_at: Optional[str] = None,
        is_disabled: Optional[bool] = None,
        type: Optional[str] = None,
        url: Optional[str] = None
    ):
        self.can = can
        self.id = id
        self.client_id = client_id
        self.created_at = created_at
        self.is_disabled = is_disabled
        self.type = type
        self.url = url


@attr.s(auto_attribs=True, kw_only=True)
class CredentialsEmail(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        created_at: Timestamp for the creation of this credential
        email: EMail address used for user login
        forced_password_reset_at_next_login: Force the user to change their password upon their next login
        is_disabled: Has this credential been disabled?
        logged_in_at: Timestamp for most recent login using credential
        password_reset_url: Url with one-time use secret token that the user can use to reset password
        type: Short name for the type of this kind of credential
        url: Link to get this item
        user_url: Link to get this user
    """

    can: Optional[MutableMapping[str, bool]] = None
    created_at: Optional[str] = None
    email: Optional[str] = None
    forced_password_reset_at_next_login: Optional[bool] = None
    is_disabled: Optional[bool] = None
    logged_in_at: Optional[str] = None
    password_reset_url: Optional[str] = None
    type: Optional[str] = None
    url: Optional[str] = None
    user_url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class CredentialsEmbed(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        created_at: Timestamp for the creation of this credential
        external_group_id: Embedder's id for a group to which this user was added during the most recent login
        external_user_id: Embedder's unique id for the user
        id: Unique Id
        is_disabled: Has this credential been disabled?
        logged_in_at: Timestamp for most recent login using credential
        type: Short name for the type of this kind of credential
        url: Link to get this item
    """

    can: Optional[MutableMapping[str, bool]] = None
    created_at: Optional[str] = None
    external_group_id: Optional[str] = None
    external_user_id: Optional[str] = None
    id: Optional[int] = None
    is_disabled: Optional[bool] = None
    logged_in_at: Optional[str] = None
    type: Optional[str] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class CredentialsGoogle(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        created_at: Timestamp for the creation of this credential
        domain: Google domain
        email: EMail address
        google_user_id: Google's Unique ID for this user
        is_disabled: Has this credential been disabled?
        logged_in_at: Timestamp for most recent login using credential
        type: Short name for the type of this kind of credential
        url: Link to get this item
    """

    can: Optional[MutableMapping[str, bool]] = None
    created_at: Optional[str] = None
    domain: Optional[str] = None
    email: Optional[str] = None
    google_user_id: Optional[str] = None
    is_disabled: Optional[bool] = None
    logged_in_at: Optional[str] = None
    type: Optional[str] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class CredentialsLDAP(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        created_at: Timestamp for the creation of this credential
        email: EMail address
        is_disabled: Has this credential been disabled?
        ldap_dn: LDAP Distinguished name for this user (as-of the last login)
        ldap_id: LDAP Unique ID for this user
        logged_in_at: Timestamp for most recent login using credential
        type: Short name for the type of this kind of credential
        url: Link to get this item
    """

    can: Optional[MutableMapping[str, bool]] = None
    created_at: Optional[str] = None
    email: Optional[str] = None
    is_disabled: Optional[bool] = None
    ldap_dn: Optional[str] = None
    ldap_id: Optional[str] = None
    logged_in_at: Optional[str] = None
    type: Optional[str] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class CredentialsLookerOpenid(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        created_at: Timestamp for the creation of this credential
        email: EMail address used for user login
        is_disabled: Has this credential been disabled?
        logged_in_at: Timestamp for most recent login using credential
        logged_in_ip: IP address of client for most recent login using credential
        type: Short name for the type of this kind of credential
        url: Link to get this item
        user_url: Link to get this user
    """

    can: Optional[MutableMapping[str, bool]] = None
    created_at: Optional[str] = None
    email: Optional[str] = None
    is_disabled: Optional[bool] = None
    logged_in_at: Optional[str] = None
    logged_in_ip: Optional[str] = None
    type: Optional[str] = None
    url: Optional[str] = None
    user_url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class CredentialsOIDC(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        created_at: Timestamp for the creation of this credential
        email: EMail address
        is_disabled: Has this credential been disabled?
        logged_in_at: Timestamp for most recent login using credential
        oidc_user_id: OIDC OP's Unique ID for this user
        type: Short name for the type of this kind of credential
        url: Link to get this item
    """

    can: Optional[MutableMapping[str, bool]] = None
    created_at: Optional[str] = None
    email: Optional[str] = None
    is_disabled: Optional[bool] = None
    logged_in_at: Optional[str] = None
    oidc_user_id: Optional[str] = None
    type: Optional[str] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class CredentialsSaml(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        created_at: Timestamp for the creation of this credential
        email: EMail address
        is_disabled: Has this credential been disabled?
        logged_in_at: Timestamp for most recent login using credential
        saml_user_id: Saml IdP's Unique ID for this user
        type: Short name for the type of this kind of credential
        url: Link to get this item
    """

    can: Optional[MutableMapping[str, bool]] = None
    created_at: Optional[str] = None
    email: Optional[str] = None
    is_disabled: Optional[bool] = None
    logged_in_at: Optional[str] = None
    saml_user_id: Optional[str] = None
    type: Optional[str] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class CredentialsTotp(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        created_at: Timestamp for the creation of this credential
        is_disabled: Has this credential been disabled?
        type: Short name for the type of this kind of credential
        verified: User has verified
        url: Link to get this item
    """

    can: Optional[MutableMapping[str, bool]] = None
    created_at: Optional[str] = None
    is_disabled: Optional[bool] = None
    type: Optional[str] = None
    verified: Optional[bool] = None
    url: Optional[str] = None

    def __init__(
        self,
        *,
        can: Optional[MutableMapping[str, bool]] = None,
        created_at: Optional[str] = None,
        is_disabled: Optional[bool] = None,
        type: Optional[str] = None,
        verified: Optional[bool] = None,
        url: Optional[str] = None
    ):
        self.can = can
        self.created_at = created_at
        self.is_disabled = is_disabled
        self.type = type
        self.verified = verified
        self.url = url


@attr.s(auto_attribs=True, kw_only=True)
class CustomWelcomeEmail(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        enabled: If true, custom email content will replace the default body of welcome emails
        content: The HTML to use as custom content for welcome emails. Script elements and other potentially dangerous markup will be removed.
    """

    can: Optional[MutableMapping[str, bool]] = None
    enabled: Optional[bool] = None
    content: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class Dashboard(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        content_favorite_id: Content Favorite Id
        content_metadata_id: Id of content metadata
        description: Description
        hidden: Is Hidden
        id: Unique Id
        model:
        query_timezone: Timezone in which the Dashboard will run by default.
        readonly: Is Read-only
        refresh_interval: Refresh Interval, as a time duration phrase like "2 hours 30 minutes". A number with no time units will be interpreted as whole seconds.
        refresh_interval_to_i: Refresh Interval in milliseconds
        space:
        folder:
        title: Dashboard Title
        user_id: Id of User
        background_color: Background color
        created_at: Time that the Dashboard was created.
        dashboard_elements: Elements
        dashboard_filters: Filters
        dashboard_layouts: Layouts
        deleted: Whether or not a dashboard is 'soft' deleted.
        deleted_at: Time that the Dashboard was 'soft' deleted.
        deleter_id: Id of User that 'soft' deleted the dashboard.
        edit_uri: Relative path of URI of LookML file to edit the dashboard (LookML dashboard only).
        favorite_count: Number of times favorited
        last_accessed_at: Time the dashboard was last accessed
        last_viewed_at: Time last viewed in the Looker web UI
        load_configuration: configuration option that governs how dashboard loading will happen.
        lookml_link_id: Links this dashboard to a particular LookML dashboard such that calling a **sync** operation on that LookML dashboard will update this dashboard to match.
        show_filters_bar: Show filters bar.  **Security Note:** This property only affects the *cosmetic* appearance of the dashboard, not a user's ability to access data. Hiding the filters bar does **NOT** prevent users from changing filters by other means. For information on how to set up secure data access control policies, see [Control User Access to Data](https://looker.com/docs/r/api/control-access)
        show_title: Show title
        slug: Content Metadata Slug
        space_id: Id of Space
        folder_id: Id of folder
        text_tile_text_color: Color of text on text tiles
        tile_background_color: Tile background color
        tile_text_color: Tile text color
        title_color: Title color
        view_count: Number of times viewed in the Looker web UI
        settings:
        preferred_viewer: The preferred route for viewing this dashboard (ie: dashboards or dashboards-next)
    """

    can: Optional[MutableMapping[str, bool]] = None
    content_favorite_id: Optional[int] = None
    content_metadata_id: Optional[int] = None
    description: Optional[str] = None
    hidden: Optional[bool] = None
    id: Optional[str] = None
    model: Optional["LookModel"] = None
    query_timezone: Optional[str] = None
    readonly: Optional[bool] = None
    refresh_interval: Optional[str] = None
    refresh_interval_to_i: Optional[int] = None
    space: Optional["SpaceBase"] = None
    folder: Optional["FolderBase"] = None
    title: Optional[str] = None
    user_id: Optional[int] = None
    background_color: Optional[str] = None
    created_at: Optional[datetime.datetime] = None
    dashboard_elements: Optional[Sequence["DashboardElement"]] = None
    dashboard_filters: Optional[Sequence["DashboardFilter"]] = None
    dashboard_layouts: Optional[Sequence["DashboardLayout"]] = None
    deleted: Optional[bool] = None
    deleted_at: Optional[datetime.datetime] = None
    deleter_id: Optional[int] = None
    edit_uri: Optional[str] = None
    favorite_count: Optional[int] = None
    last_accessed_at: Optional[datetime.datetime] = None
    last_viewed_at: Optional[datetime.datetime] = None
    load_configuration: Optional[str] = None
    lookml_link_id: Optional[str] = None
    show_filters_bar: Optional[bool] = None
    show_title: Optional[bool] = None
    slug: Optional[str] = None
    space_id: Optional[str] = None
    folder_id: Optional[str] = None
    text_tile_text_color: Optional[str] = None
    tile_background_color: Optional[str] = None
    tile_text_color: Optional[str] = None
    title_color: Optional[str] = None
    view_count: Optional[int] = None
    settings: Optional["DashboardSettings"] = None
    preferred_viewer: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class DashboardBase(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        content_favorite_id: Content Favorite Id
        content_metadata_id: Id of content metadata
        description: Description
        hidden: Is Hidden
        id: Unique Id
        model:
        query_timezone: Timezone in which the Dashboard will run by default.
        readonly: Is Read-only
        refresh_interval: Refresh Interval, as a time duration phrase like "2 hours 30 minutes". A number with no time units will be interpreted as whole seconds.
        refresh_interval_to_i: Refresh Interval in milliseconds
        space:
        folder:
        title: Dashboard Title
        user_id: Id of User
    """

    can: Optional[MutableMapping[str, bool]] = None
    content_favorite_id: Optional[int] = None
    content_metadata_id: Optional[int] = None
    description: Optional[str] = None
    hidden: Optional[bool] = None
    id: Optional[str] = None
    model: Optional["LookModel"] = None
    query_timezone: Optional[str] = None
    readonly: Optional[bool] = None
    refresh_interval: Optional[str] = None
    refresh_interval_to_i: Optional[int] = None
    space: Optional["SpaceBase"] = None
    folder: Optional["FolderBase"] = None
    title: Optional[str] = None
    user_id: Optional[int] = None


@attr.s(auto_attribs=True, kw_only=True)
class DashboardElement(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        body_text: Text tile body text
        body_text_as_html: Text tile body text as Html
        dashboard_id: Id of Dashboard
        edit_uri: Relative path of URI of LookML file to edit the dashboard element (LookML dashboard only).
        id: Unique Id
        look:
        look_id: Id Of Look
        lookml_link_id: LookML link ID
        merge_result_id: ID of merge result
        note_display: Note Display
        note_state: Note State
        note_text: Note Text
        note_text_as_html: Note Text as Html
        query:
        query_id: Id Of Query
        refresh_interval: Refresh Interval
        refresh_interval_to_i: Refresh Interval as integer
        result_maker:
        result_maker_id: ID of the ResultMakerLookup entry.
        subtitle_text: Text tile subtitle text
        title: Title of dashboard element
        title_hidden: Whether title is hidden
        title_text: Text tile title
        type: Type
        alert_count: Count of Alerts associated to a dashboard element
    """

    can: Optional[MutableMapping[str, bool]] = None
    body_text: Optional[str] = None
    body_text_as_html: Optional[str] = None
    dashboard_id: Optional[str] = None
    edit_uri: Optional[str] = None
    id: Optional[str] = None
    look: Optional["LookWithQuery"] = None
    look_id: Optional[str] = None
    lookml_link_id: Optional[str] = None
    merge_result_id: Optional[str] = None
    note_display: Optional[str] = None
    note_state: Optional[str] = None
    note_text: Optional[str] = None
    note_text_as_html: Optional[str] = None
    query: Optional["Query"] = None
    query_id: Optional[int] = None
    refresh_interval: Optional[str] = None
    refresh_interval_to_i: Optional[int] = None
    result_maker: Optional["ResultMakerWithIdVisConfigAndDynamicFields"] = None
    result_maker_id: Optional[int] = None
    subtitle_text: Optional[str] = None
    title: Optional[str] = None
    title_hidden: Optional[bool] = None
    title_text: Optional[str] = None
    type: Optional[str] = None
    alert_count: Optional[int] = None


@attr.s(auto_attribs=True, kw_only=True)
class DashboardFilter(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: Unique Id
        dashboard_id: Id of Dashboard
        name: Name of filter
        title: Title of filter
        type: Type of filter: one of date, number, string, or field
        default_value: Default value of filter
        model: Model of filter (required if type = field)
        explore: Explore of filter (required if type = field)
        dimension: Dimension of filter (required if type = field)
        field: Field information
        row: Display order of this filter relative to other filters
        listens_to_filters: Array of listeners for faceted filters
        allow_multiple_values: Whether the filter allows multiple filter values
        required: Whether the filter requires a value to run the dashboard
        ui_config: The visual configuration for this filter. Used to set up how the UI for this filter should appear.
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[str] = None
    dashboard_id: Optional[str] = None
    name: Optional[str] = None
    title: Optional[str] = None
    type: Optional[str] = None
    default_value: Optional[str] = None
    model: Optional[str] = None
    explore: Optional[str] = None
    dimension: Optional[str] = None
    field: Optional[MutableMapping[str, str]] = None
    row: Optional[int] = None
    listens_to_filters: Optional[Sequence[str]] = None
    allow_multiple_values: Optional[bool] = None
    required: Optional[bool] = None
    ui_config: Optional[MutableMapping[str, str]] = None


@attr.s(auto_attribs=True, kw_only=True)
class DashboardLayout(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: Unique Id
        dashboard_id: Id of Dashboard
        type: Type
        active: Is Active
        column_width: Column Width
        width: Width
        deleted: Whether or not the dashboard layout is deleted.
        dashboard_title: Title extracted from the dashboard this layout represents.
        dashboard_layout_components: Components
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[str] = None
    dashboard_id: Optional[str] = None
    type: Optional[str] = None
    active: Optional[bool] = None
    column_width: Optional[int] = None
    width: Optional[int] = None
    deleted: Optional[bool] = None
    dashboard_title: Optional[str] = None
    dashboard_layout_components: Optional[Sequence["DashboardLayoutComponent"]] = None


@attr.s(auto_attribs=True, kw_only=True)
class DashboardLayoutComponent(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: Unique Id
        dashboard_layout_id: Id of Dashboard Layout
        dashboard_element_id: Id Of Dashboard Element
        row: Row
        column: Column
        width: Width
        height: Height
        deleted: Whether or not the dashboard layout component is deleted
        element_title: Dashboard element title, extracted from the Dashboard Element.
        element_title_hidden: Whether or not the dashboard element title is displayed.
        vis_type: Visualization type, extracted from a query's vis_config
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[str] = None
    dashboard_layout_id: Optional[str] = None
    dashboard_element_id: Optional[str] = None
    row: Optional[int] = None
    column: Optional[int] = None
    width: Optional[int] = None
    height: Optional[int] = None
    deleted: Optional[bool] = None
    element_title: Optional[str] = None
    element_title_hidden: Optional[bool] = None
    vis_type: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class DashboardLookml(model.Model):
    """
    Attributes:
        dashboard_id: Id of Dashboard
        lookml: lookml of UDD
    """

    dashboard_id: Optional[str] = None
    lookml: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class DashboardSettings(model.Model):
    """
    Attributes:
        page_side_margins: Page margin (side) width
        page_background_color: Background color for the dashboard
        tile_title_alignment: Title alignment on dashboard tiles
        tile_space_between: Space between tiles
        tile_background_color: Background color for tiles
        tile_shadow: Tile shadow on/off
        key_color: Key color
    """

    page_side_margins: Optional[int] = None
    page_background_color: Optional[str] = None
    tile_title_alignment: Optional[str] = None
    tile_space_between: Optional[int] = None
    tile_background_color: Optional[str] = None
    tile_shadow: Optional[bool] = None
    key_color: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class DataActionForm(model.Model):
    """
    Attributes:
        state:
        fields: Array of form fields.
    """

    state: Optional["DataActionUserState"] = None
    fields: Optional[Sequence["DataActionFormField"]] = None


@attr.s(auto_attribs=True, kw_only=True)
class DataActionFormField(model.Model):
    """
    Attributes:
        name: Name
        label: Human-readable label
        description: Description of field
        type: Type of field.
        default: Default value of the field.
        oauth_url: The URL for an oauth link, if type is 'oauth_link'.
        interactive: Whether or not a field supports interactive forms.
        required: Whether or not the field is required. This is a user-interface hint. A user interface displaying this form should not submit it without a value for this field. The action server must also perform this validation.
        options: If the form type is 'select', a list of options to be selected from.
    """

    name: Optional[str] = None
    label: Optional[str] = None
    description: Optional[str] = None
    type: Optional[str] = None
    default: Optional[str] = None
    oauth_url: Optional[str] = None
    interactive: Optional[bool] = None
    required: Optional[bool] = None
    options: Optional[Sequence["DataActionFormSelectOption"]] = None


@attr.s(auto_attribs=True, kw_only=True)
class DataActionFormSelectOption(model.Model):
    """
    Attributes:
        name: Name
        label: Human-readable label
    """

    name: Optional[str] = None
    label: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class DataActionRequest(model.Model):
    """
    Attributes:
        action: The JSON describing the data action. This JSON should be considered opaque and should be passed through unmodified from the query result it came from.
        form_values: User input for any form values the data action might use.
    """

    action: Optional[MutableMapping[str, str]] = None
    form_values: Optional[MutableMapping[str, str]] = None

    def __init__(
        self,
        *,
        action: Optional[MutableMapping[str, str]] = None,
        form_values: Optional[MutableMapping[str, str]] = None
    ):
        self.action = action
        self.form_values = form_values


@attr.s(auto_attribs=True, kw_only=True)
class DataActionResponse(model.Model):
    """
    Attributes:
        webhook_id: ID of the webhook event that sent this data action. In some error conditions, this may be null.
        success: Whether the data action was successful.
        refresh_query: When true, indicates that the client should refresh (rerun) the source query because the data may have been changed by the action.
        validation_errors:
        message: Optional message returned by the data action server describing the state of the action that took place. This can be used to implement custom failure messages. If a failure is related to a particular form field, the server should send back a validation error instead. The Looker web UI does not currently display any message if the action indicates 'success', but may do so in the future.
    """

    webhook_id: Optional[str] = None
    success: Optional[bool] = None
    refresh_query: Optional[bool] = None
    validation_errors: Optional["ValidationError"] = None
    message: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class DataActionUserState(model.Model):
    """
    Attributes:
        data: User state data
        refresh_time: Time in seconds until the state needs to be refreshed
    """

    data: Optional[str] = None
    refresh_time: Optional[int] = None


@attr.s(auto_attribs=True, kw_only=True)
class Datagroup(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        created_at: UNIX timestamp at which this entry was created.
        id: Unique ID of the datagroup
        model_name: Name of the model containing the datagroup. Unique when combined with name.
        name: Name of the datagroup. Unique when combined with model_name.
        stale_before: UNIX timestamp before which cache entries are considered stale. Cannot be in the future.
        trigger_check_at: UNIX timestamp at which this entry trigger was last checked.
        trigger_error: The message returned with the error of the last trigger check.
        trigger_value: The value of the trigger when last checked.
        triggered_at: UNIX timestamp at which this entry became triggered. Cannot be in the future.
    """

    can: Optional[MutableMapping[str, bool]] = None
    created_at: Optional[int] = None
    id: Optional[str] = None
    model_name: Optional[str] = None
    name: Optional[str] = None
    stale_before: Optional[int] = None
    trigger_check_at: Optional[int] = None
    trigger_error: Optional[str] = None
    trigger_value: Optional[str] = None
    triggered_at: Optional[int] = None


@attr.s(auto_attribs=True, kw_only=True)
class DBConnection(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        name: Name of the connection. Also used as the unique identifier
        dialect:
        snippets: SQL Runner snippets for this connection
        host: Host name/address of server
        port: Port number on server
        username: Username for server authentication
        password: (Write-Only) Password for server authentication
        uses_oauth: Whether the connection uses OAuth for authentication.
        certificate: (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
        file_type: (Write-Only) Certificate keyfile type - .json or .p12
        database: Database name
        db_timezone: Time zone of database
        query_timezone: Timezone to use in queries
        schema: Scheme name
        max_connections: Maximum number of concurrent connection to use
        max_billing_gigabytes: Maximum size of query in GBs (BigQuery only, can be a user_attribute name)
        ssl: Use SSL/TLS when connecting to server
        verify_ssl: Verify the SSL
        tmp_db_name: Name of temporary database (if used)
        jdbc_additional_params: Additional params to add to JDBC connection string
        pool_timeout: Connection Pool Timeout, in seconds
        dialect_name: (Read/Write) SQL Dialect name
        created_at: Creation date for this connection
        user_id: Id of user who last modified this connection configuration
        example: Is this an example connection?
        user_db_credentials: (Limited access feature) Are per user db credentials enabled. Enabling will remove previously set username and password
        user_attribute_fields: Fields whose values map to user attribute names
        maintenance_cron: Cron string specifying when maintenance such as PDT trigger checks and drops should be performed
        last_regen_at: Unix timestamp at start of last completed PDT trigger check process
        last_reap_at: Unix timestamp at start of last completed PDT reap process
        sql_runner_precache_tables: Precache tables in the SQL Runner
        after_connect_statements: SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
        pdt_context_override:
        managed: Is this connection created and managed by Looker
    """

    can: Optional[MutableMapping[str, bool]] = None
    name: Optional[str] = None
    dialect: Optional["Dialect"] = None
    snippets: Optional[Sequence["Snippet"]] = None
    host: Optional[str] = None
    port: Optional[str] = None
    username: Optional[str] = None
    password: Optional[str] = None
    uses_oauth: Optional[bool] = None
    certificate: Optional[str] = None
    file_type: Optional[str] = None
    database: Optional[str] = None
    db_timezone: Optional[str] = None
    query_timezone: Optional[str] = None
    schema: Optional[str] = None
    max_connections: Optional[int] = None
    max_billing_gigabytes: Optional[str] = None
    ssl: Optional[bool] = None
    verify_ssl: Optional[bool] = None
    tmp_db_name: Optional[str] = None
    jdbc_additional_params: Optional[str] = None
    pool_timeout: Optional[int] = None
    dialect_name: Optional[str] = None
    created_at: Optional[str] = None
    user_id: Optional[str] = None
    example: Optional[bool] = None
    user_db_credentials: Optional[bool] = None
    user_attribute_fields: Optional[Sequence[str]] = None
    maintenance_cron: Optional[str] = None
    last_regen_at: Optional[str] = None
    last_reap_at: Optional[str] = None
    sql_runner_precache_tables: Optional[bool] = None
    after_connect_statements: Optional[str] = None
    pdt_context_override: Optional["DBConnectionOverride"] = None
    managed: Optional[bool] = None


@attr.s(auto_attribs=True, kw_only=True)
class DBConnectionBase(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        name: Name of the connection. Also used as the unique identifier
        dialect:
        snippets: SQL Runner snippets for this connection
    """

    can: Optional[MutableMapping[str, bool]] = None
    name: Optional[str] = None
    dialect: Optional["Dialect"] = None
    snippets: Optional[Sequence["Snippet"]] = None


@attr.s(auto_attribs=True, kw_only=True)
class DBConnectionOverride(model.Model):
    """
    Attributes:
        context: Context in which to override (`pdt` is the only allowed value)
        host: Host name/address of server
        port: Port number on server
        username: Username for server authentication
        password: (Write-Only) Password for server authentication
        has_password: Whether or not the password is overridden in this context
        certificate: (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
        file_type: (Write-Only) Certificate keyfile type - .json or .p12
        database: Database name
        schema: Scheme name
        jdbc_additional_params: Additional params to add to JDBC connection string
        after_connect_statements: SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
    """

    context: Optional[str] = None
    host: Optional[str] = None
    port: Optional[str] = None
    username: Optional[str] = None
    password: Optional[str] = None
    has_password: Optional[bool] = None
    certificate: Optional[str] = None
    file_type: Optional[str] = None
    database: Optional[str] = None
    schema: Optional[str] = None
    jdbc_additional_params: Optional[str] = None
    after_connect_statements: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class DBConnectionTestResult(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        connection_string: JDBC connection string. (only populated in the 'connect' test)
        message: Result message of test
        name: Name of test
        status: Result code of test
    """

    can: Optional[MutableMapping[str, bool]] = None
    connection_string: Optional[str] = None
    message: Optional[str] = None
    name: Optional[str] = None
    status: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class Dialect(model.Model):
    """
    Attributes:
        name: The name of the dialect
        label: The human-readable label of the connection
        supports_cost_estimate: Whether the dialect supports query cost estimates
        persistent_table_indexes: PDT index columns
        persistent_table_sortkeys: PDT sortkey columns
        persistent_table_distkey: PDT distkey column
        supports_streaming: Suports streaming results
        automatically_run_sql_runner_snippets: Should SQL Runner snippets automatically be run
        connection_tests: Array of names of the tests that can be run on a connection using this dialect
        supports_inducer: Is supported with the inducer (i.e. generate from sql)
        supports_multiple_databases: Can multiple databases be accessed from a connection using this dialect
        supports_persistent_derived_tables: Whether the dialect supports allowing Looker to build persistent derived tables
        has_ssl_support: Does the database have client SSL support settable through the JDBC string explicitly?
    """

    name: Optional[str] = None
    label: Optional[str] = None
    supports_cost_estimate: Optional[bool] = None
    persistent_table_indexes: Optional[str] = None
    persistent_table_sortkeys: Optional[str] = None
    persistent_table_distkey: Optional[str] = None
    supports_streaming: Optional[bool] = None
    automatically_run_sql_runner_snippets: Optional[bool] = None
    connection_tests: Optional[Sequence[str]] = None
    supports_inducer: Optional[bool] = None
    supports_multiple_databases: Optional[bool] = None
    supports_persistent_derived_tables: Optional[bool] = None
    has_ssl_support: Optional[bool] = None


@attr.s(auto_attribs=True, kw_only=True)
class DialectInfo(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        default_max_connections: Default number max connections
        default_port: Default port number
        installed: Is the supporting driver installed
        label: The human-readable label of the connection
        label_for_database_equivalent: What the dialect calls the equivalent of a normal SQL table
        name: The name of the dialect
        supported_options:
    """

    can: Optional[MutableMapping[str, bool]] = None
    default_max_connections: Optional[str] = None
    default_port: Optional[str] = None
    installed: Optional[bool] = None
    label: Optional[str] = None
    label_for_database_equivalent: Optional[str] = None
    name: Optional[str] = None
    supported_options: Optional["DialectInfoOptions"] = None


@attr.s(auto_attribs=True, kw_only=True)
class DialectInfoOptions(model.Model):
    """
    Attributes:
        additional_params: Has additional params support
        auth: Has auth support
        host: Has host support
        oauth_credentials: Has support for a service account
        project_name: Has project name support
        schema: Has schema support
        ssl: Has SSL support
        timezone: Has timezone support
        tmp_table: Has tmp table support
        username_required: Username is required
        can: Operations the current user is able to perform on this object
    """

    additional_params: Optional[bool] = None
    auth: Optional[bool] = None
    host: Optional[bool] = None
    oauth_credentials: Optional[bool] = None
    project_name: Optional[bool] = None
    schema: Optional[bool] = None
    ssl: Optional[bool] = None
    timezone: Optional[bool] = None
    tmp_table: Optional[bool] = None
    username_required: Optional[bool] = None
    can: Optional[MutableMapping[str, bool]] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class DiscretePalette(model.Model):
    """
    Attributes:
        id: Unique identity string
        label: Label for palette
        type: Type of palette
        colors: Array of colors in the palette
    """

    id: Optional[str] = None
    label: Optional[str] = None
    type: Optional[str] = None
    colors: Optional[Sequence[str]] = None

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        label: Optional[str] = None,
        type: Optional[str] = None,
        colors: Optional[Sequence[str]] = None
    ):
        self.id = id
        self.label = label
        self.type = type
        self.colors = colors


@attr.s(auto_attribs=True, kw_only=True)
class EmbedSsoUrl(model.Model):
    """
    Attributes:
        url: The signed embed URL. Any modification to this string will invalidate the signature and make the URL unusable.
    """

    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class EmbedSsoUrlParams(model.Model):
    """
    Attributes:
        target_url: The complete URL of the Looker UI page to display in the embed context. For example, to display the dashboard with id 34, `target_url` would look like: `https://mycompany.looker.com:9999/dashboards/34`. `target_uri` MUST contain a scheme (HTTPS), domain name, and URL path. Port must be included if it is required to reach the Looker server from browser clients. If the Looker instance is behind a load balancer or other proxy, `target_uri` must be the public-facing domain name and port required to reach the Looker instance, not the actual internal network machine name of the Looker instance.
        session_length: Number of seconds the SSO embed session will be valid after the embed session is started. Defaults to 300 seconds. Maximum session length accepted is 2592000 seconds (30 days).
        external_user_id: A value from an external system that uniquely identifies the embed user. Since the user_ids of Looker embed users may change with every embed session, external_user_id provides a way to assign a known, stable user identifier across multiple embed sessions.
        force_logout_login: When true, the embed session will purge any residual Looker login state (such as in browser cookies) before creating a new login state with the given embed user info. Defaults to true.
        first_name: First name of the embed user. Defaults to 'Embed' if not specified
        last_name: Last name of the embed user. Defaults to 'User' if not specified
        user_timezone: Sets the user timezone for the embed user session, if the User Specific Timezones setting is enabled in the Looker admin settings. A value of `null` forces the embed user to use the Looker Application Default Timezone. You MUST omit this property from the request if the User Specific Timezones setting is disabled. Timezone values are validated against the IANA Timezone standard and can be seen in the Application Time Zone dropdown list on the Looker General Settings admin page.
        permissions: List of Looker permission names to grant to the embed user. Requested permissions will be filtered to permissions allowed for embed sessions.
        models: List of model names that the embed user may access
        group_ids: List of Looker group ids in which to enroll the embed user
        external_group_id: A unique value identifying an embed-exclusive group. Multiple embed users using the same `external_group_id` value will be able to share Looker content with each other. Content and embed users associated with the `external_group_id` will not be accessible to normal Looker users or embed users not associated with this `external_group_id`.
        user_attributes: A dictionary of name-value pairs associating a Looker user attribute name with a value.
        secret_id: Id of the embed secret to use to sign this SSO url. If specified, the value must be an id of a valid (active) secret defined in the Looker instance. If not specified, the URL will be signed with the newest active embed secret defined in the Looker instance.
    """

    target_url: str
    session_length: Optional[int] = None
    external_user_id: Optional[str] = None
    force_logout_login: Optional[bool] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    user_timezone: Optional[str] = None
    permissions: Optional[Sequence[str]] = None
    models: Optional[Sequence[str]] = None
    group_ids: Optional[Sequence[int]] = None
    external_group_id: Optional[int] = None
    user_attributes: Optional[MutableMapping[str, str]] = None
    secret_id: Optional[int] = None

    def __init__(
        self,
        *,
        target_url: str,
        session_length: Optional[int] = None,
        external_user_id: Optional[str] = None,
        force_logout_login: Optional[bool] = None,
        first_name: Optional[str] = None,
        last_name: Optional[str] = None,
        user_timezone: Optional[str] = None,
        permissions: Optional[Sequence[str]] = None,
        models: Optional[Sequence[str]] = None,
        group_ids: Optional[Sequence[int]] = None,
        external_group_id: Optional[int] = None,
        user_attributes: Optional[MutableMapping[str, str]] = None,
        secret_id: Optional[int] = None
    ):
        self.target_url = target_url
        self.session_length = session_length
        self.external_user_id = external_user_id
        self.force_logout_login = force_logout_login
        self.first_name = first_name
        self.last_name = last_name
        self.user_timezone = user_timezone
        self.permissions = permissions
        self.models = models
        self.group_ids = group_ids
        self.external_group_id = external_group_id
        self.user_attributes = user_attributes
        self.secret_id = secret_id


@attr.s(auto_attribs=True, kw_only=True)
class Error(model.Model):
    """
    Attributes:
        message: Error details
        documentation_url: Documentation link
    """

    message: str
    documentation_url: str


@attr.s(auto_attribs=True, kw_only=True)
class Folder(model.Model):
    """
    Attributes:
        name: Unique Name
        parent_id: Id of Parent. If the parent id is null, this is a root-level entry
        id: Unique Id
        content_metadata_id: Id of content metadata
        created_at: Time the space was created
        creator_id: User Id of Creator
        child_count: Children Count
        external_id: Embedder's Id if this folder was autogenerated as an embedding shared folder via 'external_group_id' in an SSO embed login
        is_embed: Folder is an embed folder
        is_embed_shared_root: Folder is the root embed shared folder
        is_embed_users_root: Folder is the root embed users folder
        is_personal: Folder is a user's personal folder
        is_personal_descendant: Folder is descendant of a user's personal folder
        is_shared_root: Folder is the root shared folder
        is_users_root: Folder is the root user folder
        can: Operations the current user is able to perform on this object
        dashboards: Dashboards
        looks: Looks
    """

    name: str
    parent_id: Optional[str] = None
    id: Optional[str] = None
    content_metadata_id: Optional[int] = None
    created_at: Optional[datetime.datetime] = None
    creator_id: Optional[int] = None
    child_count: Optional[int] = None
    external_id: Optional[str] = None
    is_embed: Optional[bool] = None
    is_embed_shared_root: Optional[bool] = None
    is_embed_users_root: Optional[bool] = None
    is_personal: Optional[bool] = None
    is_personal_descendant: Optional[bool] = None
    is_shared_root: Optional[bool] = None
    is_users_root: Optional[bool] = None
    can: Optional[MutableMapping[str, bool]] = None
    dashboards: Optional[Sequence["DashboardBase"]] = None
    looks: Optional[Sequence["LookWithDashboards"]] = None


@attr.s(auto_attribs=True, kw_only=True)
class FolderBase(model.Model):
    """
    Attributes:
        name: Unique Name
        parent_id: Id of Parent. If the parent id is null, this is a root-level entry
        id: Unique Id
        content_metadata_id: Id of content metadata
        created_at: Time the folder was created
        creator_id: User Id of Creator
        child_count: Children Count
        external_id: Embedder's Id if this folder was autogenerated as an embedding shared folder via 'external_group_id' in an SSO embed login
        is_embed: Folder is an embed folder
        is_embed_shared_root: Folder is the root embed shared folder
        is_embed_users_root: Folder is the root embed users folder
        is_personal: Folder is a user's personal folder
        is_personal_descendant: Folder is descendant of a user's personal folder
        is_shared_root: Folder is the root shared folder
        is_users_root: Folder is the root user folder
        can: Operations the current user is able to perform on this object
    """

    name: str
    parent_id: Optional[str] = None
    id: Optional[str] = None
    content_metadata_id: Optional[int] = None
    created_at: Optional[datetime.datetime] = None
    creator_id: Optional[int] = None
    child_count: Optional[int] = None
    external_id: Optional[str] = None
    is_embed: Optional[bool] = None
    is_embed_shared_root: Optional[bool] = None
    is_embed_users_root: Optional[bool] = None
    is_personal: Optional[bool] = None
    is_personal_descendant: Optional[bool] = None
    is_shared_root: Optional[bool] = None
    is_users_root: Optional[bool] = None
    can: Optional[MutableMapping[str, bool]] = None


@attr.s(auto_attribs=True, kw_only=True)
class GitBranch(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        name: The short name on the local. Updating `name` results in `git checkout <new_name>`
        remote: The name of the remote
        remote_name: The short name on the remote
        error: Name of error
        message: Message describing an error if present
        owner_name: Name of the owner of a personal branch
        readonly: Whether or not this branch is readonly
        personal: Whether or not this branch is a personal branch - readonly for all developers except the owner
        is_local: Whether or not a local ref exists for the branch
        is_remote: Whether or not a remote ref exists for the branch
        is_production: Whether or not this is the production branch
        ahead_count: Number of commits the local branch is ahead of the remote
        behind_count: Number of commits the local branch is behind the remote
        commit_at: UNIX timestamp at which this branch was last committed.
        ref: The resolved ref of this branch. Updating `ref` results in `git reset --hard <new_ref>``.
        remote_ref: The resolved ref of this branch remote.
    """

    can: Optional[MutableMapping[str, bool]] = None
    name: Optional[str] = None
    remote: Optional[str] = None
    remote_name: Optional[str] = None
    error: Optional[str] = None
    message: Optional[str] = None
    owner_name: Optional[str] = None
    readonly: Optional[bool] = None
    personal: Optional[bool] = None
    is_local: Optional[bool] = None
    is_remote: Optional[bool] = None
    is_production: Optional[bool] = None
    ahead_count: Optional[int] = None
    behind_count: Optional[int] = None
    commit_at: Optional[int] = None
    ref: Optional[str] = None
    remote_ref: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class GitConnectionTest(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        description: Human readable string describing the test
        id: A short string, uniquely naming this test
    """

    can: Optional[MutableMapping[str, bool]] = None
    description: Optional[str] = None
    id: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class GitConnectionTestResult(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: A short string, uniquely naming this test
        message: Additional data from the test
        status: Either 'pass' or 'fail'
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[str] = None
    message: Optional[str] = None
    status: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class GitStatus(model.Model):
    """
    Attributes:
        action: Git action: add, delete, etc
        conflict: When true, changes to the local file conflict with the remote repository
        revertable: When true, the file can be reverted to an earlier state
        text: Git description of the action
        can: Operations the current user is able to perform on this object
    """

    action: Optional[str] = None
    conflict: Optional[bool] = None
    revertable: Optional[bool] = None
    text: Optional[str] = None
    can: Optional[MutableMapping[str, bool]] = None


@attr.s(auto_attribs=True, kw_only=True)
class Group(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        can_add_to_content_metadata: Group can be used in content access controls
        contains_current_user: Currently logged in user is group member
        external_group_id: External Id group if embed group
        externally_managed: Group membership controlled outside of Looker
        id: Unique Id
        include_by_default: New users are added to this group by default
        name: Name of group
        user_count: Number of users included in this group
    """

    can: Optional[MutableMapping[str, bool]] = None
    can_add_to_content_metadata: Optional[bool] = None
    contains_current_user: Optional[bool] = None
    external_group_id: Optional[str] = None
    externally_managed: Optional[bool] = None
    id: Optional[int] = None
    include_by_default: Optional[bool] = None
    name: Optional[str] = None
    user_count: Optional[int] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class GroupIdForGroupInclusion(model.Model):
    """
    Attributes:
        group_id: Id of group
    """

    group_id: Optional[int] = None

    def __init__(self, *, group_id: Optional[int] = None):
        self.group_id = group_id


@attr.s(auto_attribs=True, kw_only=True, init=False)
class GroupIdForGroupUserInclusion(model.Model):
    """
    Attributes:
        user_id: Id of user
    """

    user_id: Optional[int] = None

    def __init__(self, *, user_id: Optional[int] = None):
        self.user_id = user_id


@attr.s(auto_attribs=True, kw_only=True)
class Homepage(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        content_metadata_id: Id of associated content_metadata record
        created_at: Date of homepage creatopm
        deleted_at: Date of homepage deletion
        description: Description of homepage
        homepage_sections: Sections of the homepage
        id: Unique Id
        section_order: ids of the homepage sections in the order they should be displayed
        title: Title of homepage
        updated_at: Date of last homepage update
        user_id: User id of homepage creator
        primary_homepage: Whether the homepage is the primary homepage or not
    """

    can: Optional[MutableMapping[str, bool]] = None
    content_metadata_id: Optional[int] = None
    created_at: Optional[datetime.datetime] = None
    deleted_at: Optional[datetime.datetime] = None
    description: Optional[str] = None
    homepage_sections: Optional[Sequence["HomepageSection"]] = None
    id: Optional[str] = None
    section_order: Optional[Sequence[int]] = None
    title: Optional[str] = None
    updated_at: Optional[datetime.datetime] = None
    user_id: Optional[int] = None
    primary_homepage: Optional[bool] = None


@attr.s(auto_attribs=True, kw_only=True)
class HomepageItem(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        content_created_by: Name of user who created the content this item is based on
        content_favorite_id: Content favorite id associated with the item this content is based on
        content_metadata_id: Content metadata id associated with the item this content is based on
        content_updated_at: Last time the content that this item is based on was updated
        custom_description: Custom description entered by the user, if present
        custom_image_data_base64: (Write-Only) base64 encoded image data
        custom_image_url: Custom image_url entered by the user, if present
        custom_title: Custom title entered by the user, if present
        custom_url: Custom url entered by the user, if present
        dashboard_id: Dashboard to base this item on
        description: The actual description for display
        favorite_count: Number of times content has been favorited, if present
        homepage_section_id: Associated Homepage Section
        id: Unique Id
        image_url: The actual image_url for display
        location: The container folder name of the content
        look_id: Look to base this item on
        lookml_dashboard_id: LookML Dashboard to base this item on
        order: An arbitrary integer representing the sort order within the section
        section_fetch_time: Number of seconds it took to fetch the section this item is in
        title: The actual title for display
        url: The actual url for display
        use_custom_description: Whether the custom description should be used instead of the content description, if the item is associated with content
        use_custom_image: Whether the custom image should be used instead of the content image, if the item is associated with content
        use_custom_title: Whether the custom title should be used instead of the content title, if the item is associated with content
        use_custom_url: Whether the custom url should be used instead of the content url, if the item is associated with content
        view_count: Number of times content has been viewed, if present
    """

    can: Optional[MutableMapping[str, bool]] = None
    content_created_by: Optional[str] = None
    content_favorite_id: Optional[int] = None
    content_metadata_id: Optional[int] = None
    content_updated_at: Optional[str] = None
    custom_description: Optional[str] = None
    custom_image_data_base64: Optional[str] = None
    custom_image_url: Optional[str] = None
    custom_title: Optional[str] = None
    custom_url: Optional[str] = None
    dashboard_id: Optional[int] = None
    description: Optional[str] = None
    favorite_count: Optional[int] = None
    homepage_section_id: Optional[str] = None
    id: Optional[str] = None
    image_url: Optional[str] = None
    location: Optional[str] = None
    look_id: Optional[int] = None
    lookml_dashboard_id: Optional[str] = None
    order: Optional[int] = None
    section_fetch_time: Optional[float] = None
    title: Optional[str] = None
    url: Optional[str] = None
    use_custom_description: Optional[bool] = None
    use_custom_image: Optional[bool] = None
    use_custom_title: Optional[bool] = None
    use_custom_url: Optional[bool] = None
    view_count: Optional[int] = None


@attr.s(auto_attribs=True, kw_only=True)
class HomepageSection(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        created_at: Time at which this section was created.
        deleted_at: Time at which this section was deleted.
        detail_url: A URL pointing to a page showing further information about the content in the section.
        homepage_id: Id reference to parent homepage
        homepage_items: Items in the homepage section
        id: Unique Id
        is_header: Is this a header section (has no items)
        item_order: ids of the homepage items in the order they should be displayed
        title: Name of row
        updated_at: Time at which this section was last updated.
        description: Description of the content found in this section.
    """

    can: Optional[MutableMapping[str, bool]] = None
    created_at: Optional[datetime.datetime] = None
    deleted_at: Optional[datetime.datetime] = None
    detail_url: Optional[str] = None
    homepage_id: Optional[int] = None
    homepage_items: Optional[Sequence["HomepageItem"]] = None
    id: Optional[str] = None
    is_header: Optional[bool] = None
    item_order: Optional[Sequence[int]] = None
    title: Optional[str] = None
    updated_at: Optional[datetime.datetime] = None
    description: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class ImportedProject(model.Model):
    """
    Attributes:
        name: Dependency name
        url: Url for a remote dependency
        ref: Ref for a remote dependency
        is_remote: Flag signifying if a dependency is remote or local
        can: Operations the current user is able to perform on this object
    """

    name: Optional[str] = None
    url: Optional[str] = None
    ref: Optional[str] = None
    is_remote: Optional[bool] = None
    can: Optional[MutableMapping[str, bool]] = None


@attr.s(auto_attribs=True, kw_only=True)
class Integration(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: ID of the integration.
        integration_hub_id: ID of the integration hub.
        label: Label for the integration.
        description: Description of the integration.
        enabled: Whether the integration is available to users.
        params: Array of params for the integration.
        supported_formats: A list of data formats the integration supports. If unspecified, the default is all data formats. Valid values are: "txt", "csv", "inline_json", "json", "json_label", "json_detail", "json_detail_lite_stream", "xlsx", "html", "wysiwyg_pdf", "assembled_pdf", "wysiwyg_png", "csv_zip".
        supported_action_types: A list of action types the integration supports. Valid values are: "cell", "query", "dashboard".
        supported_formattings: A list of formatting options the integration supports. If unspecified, defaults to all formats. Valid values are: "formatted", "unformatted".
        supported_visualization_formattings: A list of visualization formatting options the integration supports. If unspecified, defaults to all formats. Valid values are: "apply", "noapply".
        supported_download_settings: A list of all the download mechanisms the integration supports. The order of values is not significant: Looker will select the most appropriate supported download mechanism for a given query. The integration must ensure it can handle any of the mechanisms it claims to support. If unspecified, this defaults to all download setting values. Valid values are: "push", "url".
        icon_url: URL to an icon for the integration.
        uses_oauth: Whether the integration uses oauth.
        required_fields: A list of descriptions of required fields that this integration is compatible with. If there are multiple entries in this list, the integration requires more than one field. If unspecified, no fields will be required.
        delegate_oauth: Whether the integration uses delegate oauth, which allows federation between an integration installation scope specific entity (like org, group, and team, etc.) and Looker.
        installed_delegate_oauth_targets: Whether the integration is available to users.
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[str] = None
    integration_hub_id: Optional[int] = None
    label: Optional[str] = None
    description: Optional[str] = None
    enabled: Optional[bool] = None
    params: Optional[Sequence["IntegrationParam"]] = None
    supported_formats: Optional[Sequence[str]] = None
    supported_action_types: Optional[Sequence[str]] = None
    supported_formattings: Optional[Sequence[str]] = None
    supported_visualization_formattings: Optional[Sequence[str]] = None
    supported_download_settings: Optional[Sequence[str]] = None
    icon_url: Optional[str] = None
    uses_oauth: Optional[bool] = None
    required_fields: Optional[Sequence["IntegrationRequiredField"]] = None
    delegate_oauth: Optional[bool] = None
    installed_delegate_oauth_targets: Optional[Sequence[str]] = None


@attr.s(auto_attribs=True, kw_only=True)
class IntegrationHub(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: ID of the hub.
        url: URL of the hub.
        label: Label of the hub.
        official: Whether this hub is a first-party integration hub operated by Looker.
        fetch_error_message: An error message, present if the integration hub metadata could not be fetched. If this is present, the integration hub is unusable.
        authorization_token: (Write-Only) An authorization key that will be sent to the integration hub on every request.
        has_authorization_token: Whether the authorization_token is set for the hub.
        legal_agreement_signed: Whether the legal agreement message has been signed by the user. This only matters if legal_agreement_required is true.
        legal_agreement_required: Whether the legal terms for the integration hub are required before use.
        legal_agreement_text: The legal agreement text for this integration hub.
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[int] = None
    url: Optional[str] = None
    label: Optional[str] = None
    official: Optional[bool] = None
    fetch_error_message: Optional[str] = None
    authorization_token: Optional[str] = None
    has_authorization_token: Optional[bool] = None
    legal_agreement_signed: Optional[bool] = None
    legal_agreement_required: Optional[bool] = None
    legal_agreement_text: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class IntegrationParam(model.Model):
    """
    Attributes:
        name: Name of the parameter.
        label: Label of the parameter.
        description: Short description of the parameter.
        required: Whether the parameter is required to be set to use the destination. If unspecified, this defaults to false.
        has_value: Whether the parameter has a value set.
        value: The current value of the parameter. Always null if the value is sensitive. When writing, null values will be ignored. Set the value to an empty string to clear it.
        user_attribute_name: When present, the param's value comes from this user attribute instead of the 'value' parameter. Set to null to use the 'value'.
        sensitive: Whether the parameter contains sensitive data like API credentials. If unspecified, this defaults to true.
        per_user: When true, this parameter must be assigned to a user attribute in the admin panel (instead of a constant value), and that value may be updated by the user as part of the integration flow.
        delegate_oauth_url: When present, the param represents the oauth url the user will be taken to.
    """

    name: Optional[str] = None
    label: Optional[str] = None
    description: Optional[str] = None
    required: Optional[bool] = None
    has_value: Optional[bool] = None
    value: Optional[str] = None
    user_attribute_name: Optional[str] = None
    sensitive: Optional[bool] = None
    per_user: Optional[bool] = None
    delegate_oauth_url: Optional[str] = None

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        label: Optional[str] = None,
        description: Optional[str] = None,
        required: Optional[bool] = None,
        has_value: Optional[bool] = None,
        value: Optional[str] = None,
        user_attribute_name: Optional[str] = None,
        sensitive: Optional[bool] = None,
        per_user: Optional[bool] = None,
        delegate_oauth_url: Optional[str] = None
    ):
        self.name = name
        self.label = label
        self.description = description
        self.required = required
        self.has_value = has_value
        self.value = value
        self.user_attribute_name = user_attribute_name
        self.sensitive = sensitive
        self.per_user = per_user
        self.delegate_oauth_url = delegate_oauth_url


@attr.s(auto_attribs=True, kw_only=True)
class IntegrationRequiredField(model.Model):
    """
    Attributes:
        tag: Matches a field that has this tag.
        any_tag: If present, supercedes 'tag' and matches a field that has any of the provided tags.
        all_tags: If present, supercedes 'tag' and matches a field that has all of the provided tags.
    """

    tag: Optional[str] = None
    any_tag: Optional[Sequence[str]] = None
    all_tags: Optional[Sequence[str]] = None


@attr.s(auto_attribs=True, kw_only=True)
class IntegrationTestResult(model.Model):
    """
    Attributes:
        success: Whether or not the test was successful
        message: A message representing the results of the test.
    """

    success: Optional[bool] = None
    message: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class InternalHelpResources(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        enabled: If true and internal help resources content is not blank then the link for internal help resources will be shown in the help menu and the content displayed within Looker
    """

    can: Optional[MutableMapping[str, bool]] = None
    enabled: Optional[bool] = None


@attr.s(auto_attribs=True, kw_only=True)
class InternalHelpResourcesContent(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        organization_name: Text to display in the help menu item which will display the internal help resources
        markdown_content: Content to be displayed in the internal help resources page/modal
    """

    can: Optional[MutableMapping[str, bool]] = None
    organization_name: Optional[str] = None
    markdown_content: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class LDAPConfig(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        alternate_email_login_allowed: Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
        auth_password: (Write-Only)  Password for the LDAP account used to access the LDAP server
        auth_requires_role: Users will not be allowed to login at all unless a role for them is found in LDAP if set to true
        auth_username: Distinguished name of LDAP account used to access the LDAP server
        connection_host: LDAP server hostname
        connection_port: LDAP host port
        connection_tls: Use Transport Layer Security
        connection_tls_no_verify: Do not verify peer when using TLS
        default_new_user_group_ids: (Write-Only)  Array of ids of groups that will be applied to new users the first time they login via LDAP
        default_new_user_groups: (Read-only) Groups that will be applied to new users the first time they login via LDAP
        default_new_user_role_ids: (Write-Only)  Array of ids of roles that will be applied to new users the first time they login via LDAP
        default_new_user_roles: (Read-only) Roles that will be applied to new users the first time they login via LDAP
        enabled: Enable/Disable LDAP authentication for the server
        force_no_page: Don't attempt to do LDAP search result paging (RFC 2696) even if the LDAP server claims to support it.
        groups: (Read-only) Array of mappings between LDAP Groups and Looker Roles
        groups_base_dn: Base dn for finding groups in LDAP searches
        groups_finder_type: Identifier for a strategy for how Looker will search for groups in the LDAP server
        groups_member_attribute: LDAP Group attribute that signifies the members of the groups. Most commonly 'member'
        groups_objectclasses: Optional comma-separated list of supported LDAP objectclass for groups when doing groups searches
        groups_user_attribute: LDAP Group attribute that signifies the user in a group. Most commonly 'dn'
        groups_with_role_ids: (Read/Write) Array of mappings between LDAP Groups and arrays of Looker Role ids
        has_auth_password: (Read-only) Has the password been set for the LDAP account used to access the LDAP server
        merge_new_users_by_email: Merge first-time ldap login to existing user account by email addresses. When a user logs in for the first time via ldap this option will connect this user into their existing account by finding the account with a matching email address. Otherwise a new user account will be created for the user.
        modified_at: When this config was last modified
        modified_by: User id of user who last modified this config
        set_roles_from_groups: Set user roles in Looker based on groups from LDAP
        test_ldap_password: (Write-Only)  Test LDAP user password. For ldap tests only.
        test_ldap_user: (Write-Only)  Test LDAP user login id. For ldap tests only.
        user_attribute_map_email: Name of user record attributes used to indicate email address field
        user_attribute_map_first_name: Name of user record attributes used to indicate first name
        user_attribute_map_last_name: Name of user record attributes used to indicate last name
        user_attribute_map_ldap_id: Name of user record attributes used to indicate unique record id
        user_attributes: (Read-only) Array of mappings between LDAP User Attributes and Looker User Attributes
        user_attributes_with_ids: (Read/Write) Array of mappings between LDAP User Attributes and arrays of Looker User Attribute ids
        user_bind_base_dn: Distinguished name of LDAP node used as the base for user searches
        user_custom_filter: (Optional) Custom RFC-2254 filter clause for use in finding user during login. Combined via 'and' with the other generated filter clauses.
        user_id_attribute_names: Name(s) of user record attributes used for matching user login id (comma separated list)
        user_objectclass: (Optional) Name of user record objectclass used for finding user during login id
        url: Link to get this item
    """

    can: Optional[MutableMapping[str, bool]] = None
    alternate_email_login_allowed: Optional[bool] = None
    auth_password: Optional[str] = None
    auth_requires_role: Optional[bool] = None
    auth_username: Optional[str] = None
    connection_host: Optional[str] = None
    connection_port: Optional[str] = None
    connection_tls: Optional[bool] = None
    connection_tls_no_verify: Optional[bool] = None
    default_new_user_group_ids: Optional[Sequence[int]] = None
    default_new_user_groups: Optional[Sequence["Group"]] = None
    default_new_user_role_ids: Optional[Sequence[int]] = None
    default_new_user_roles: Optional[Sequence["Role"]] = None
    enabled: Optional[bool] = None
    force_no_page: Optional[bool] = None
    groups: Optional[Sequence["LDAPGroupRead"]] = None
    groups_base_dn: Optional[str] = None
    groups_finder_type: Optional[str] = None
    groups_member_attribute: Optional[str] = None
    groups_objectclasses: Optional[str] = None
    groups_user_attribute: Optional[str] = None
    groups_with_role_ids: Optional[Sequence["LDAPGroupWrite"]] = None
    has_auth_password: Optional[bool] = None
    merge_new_users_by_email: Optional[bool] = None
    modified_at: Optional[str] = None
    modified_by: Optional[str] = None
    set_roles_from_groups: Optional[bool] = None
    test_ldap_password: Optional[str] = None
    test_ldap_user: Optional[str] = None
    user_attribute_map_email: Optional[str] = None
    user_attribute_map_first_name: Optional[str] = None
    user_attribute_map_last_name: Optional[str] = None
    user_attribute_map_ldap_id: Optional[str] = None
    user_attributes: Optional[Sequence["LDAPUserAttributeRead"]] = None
    user_attributes_with_ids: Optional[Sequence["LDAPUserAttributeWrite"]] = None
    user_bind_base_dn: Optional[str] = None
    user_custom_filter: Optional[str] = None
    user_id_attribute_names: Optional[str] = None
    user_objectclass: Optional[str] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class LDAPConfigTestIssue(model.Model):
    """
    Attributes:
        severity: Severity of the issue. Error or Warning
        message: Message describing the issue
        can: Operations the current user is able to perform on this object
    """

    severity: Optional[str] = None
    message: Optional[str] = None
    can: Optional[MutableMapping[str, bool]] = None


@attr.s(auto_attribs=True, kw_only=True)
class LDAPConfigTestResult(model.Model):
    """
    Attributes:
        details: Additional details for error cases
        issues: Array of issues/considerations about the result
        message: Short human readable test about the result
        status: Test status code: always 'success' or 'error'
        trace: A more detailed trace of incremental results during auth tests
        user:
        url: Link to ldap config
    """

    details: Optional[str] = None
    issues: Optional[Sequence["LDAPConfigTestIssue"]] = None
    message: Optional[str] = None
    status: Optional[str] = None
    trace: Optional[str] = None
    user: Optional["LDAPUser"] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class LDAPGroupRead(model.Model):
    """
    Attributes:
        name: Name of group in LDAP
        roles: Looker Roles
        url: Link to ldap config
    """

    name: Optional[str] = None
    roles: Optional[Sequence["Role"]] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class LDAPGroupWrite(model.Model):
    """
    Attributes:
        name: Name of group in LDAP
        role_ids: Looker Role Ids
        url: Link to ldap config
    """

    name: Optional[str] = None
    role_ids: Optional[Sequence[int]] = None
    url: Optional[str] = None

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        role_ids: Optional[Sequence[int]] = None,
        url: Optional[str] = None
    ):
        self.name = name
        self.role_ids = role_ids
        self.url = url


@attr.s(auto_attribs=True, kw_only=True)
class LDAPUser(model.Model):
    """
    Attributes:
        all_emails: Array of user's email addresses and aliases for use in migration
        attributes: Dictionary of user's attributes (name/value)
        email: Primary email address
        first_name: First name
        groups: Array of user's groups (group names only)
        last_name: Last Name
        ldap_dn: LDAP's distinguished name for the user record
        ldap_id: LDAP's Unique ID for the user
        roles: Array of user's roles (role names only)
        can: Operations the current user is able to perform on this object
        url: Link to ldap config
    """

    all_emails: Optional[Sequence[str]] = None
    attributes: Optional[MutableMapping[str, str]] = None
    email: Optional[str] = None
    first_name: Optional[str] = None
    groups: Optional[Sequence[str]] = None
    last_name: Optional[str] = None
    ldap_dn: Optional[str] = None
    ldap_id: Optional[str] = None
    roles: Optional[Sequence[str]] = None
    can: Optional[MutableMapping[str, bool]] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class LDAPUserAttributeRead(model.Model):
    """
    Attributes:
        name: Name of User Attribute in LDAP
        required: Required to be in LDAP assertion for login to be allowed to succeed
        user_attributes: Looker User Attributes
        url: Link to ldap config
    """

    name: Optional[str] = None
    required: Optional[bool] = None
    user_attributes: Optional[Sequence["UserAttribute"]] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class LDAPUserAttributeWrite(model.Model):
    """
    Attributes:
        name: Name of User Attribute in LDAP
        required: Required to be in LDAP assertion for login to be allowed to succeed
        user_attribute_ids: Looker User Attribute Ids
        url: Link to ldap config
    """

    name: Optional[str] = None
    required: Optional[bool] = None
    user_attribute_ids: Optional[Sequence[int]] = None
    url: Optional[str] = None

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        required: Optional[bool] = None,
        user_attribute_ids: Optional[Sequence[int]] = None,
        url: Optional[str] = None
    ):
        self.name = name
        self.required = required
        self.user_attribute_ids = user_attribute_ids
        self.url = url


@attr.s(auto_attribs=True, kw_only=True)
class LegacyFeature(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: Unique Id
        name: Name
        description: Description
        enabled_locally: Whether this feature has been enabled by a user
        enabled: Whether this feature is currently enabled
        disallowed_as_of_version: Looker version where this feature became a legacy feature
        disable_on_upgrade_to_version: Looker version where this feature will be automatically disabled
        end_of_life_version: Future Looker version where this feature will be removed
        documentation_url: URL for documentation about this feature
        approximate_disable_date: Approximate date that this feature will be automatically disabled.
        approximate_end_of_life_date: Approximate date that this feature will be removed.
        has_disabled_on_upgrade: Whether this legacy feature may have been automatically disabled when upgrading to the current version.
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    enabled_locally: Optional[bool] = None
    enabled: Optional[bool] = None
    disallowed_as_of_version: Optional[str] = None
    disable_on_upgrade_to_version: Optional[str] = None
    end_of_life_version: Optional[str] = None
    documentation_url: Optional[str] = None
    approximate_disable_date: Optional[datetime.datetime] = None
    approximate_end_of_life_date: Optional[datetime.datetime] = None
    has_disabled_on_upgrade: Optional[bool] = None


@attr.s(auto_attribs=True, kw_only=True)
class Locale(model.Model):
    """
    Attributes:
        code: Code for Locale
        native_name: Name of Locale in its own language
        english_name: Name of Locale in English
    """

    code: Optional[str] = None
    native_name: Optional[str] = None
    english_name: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class LocalizationSettings(model.Model):
    """
    Attributes:
        default_locale: Default locale for localization
        localization_level: Localization level - strict or permissive
        can: Operations the current user is able to perform on this object
    """

    default_locale: Optional[str] = None
    localization_level: Optional[str] = None
    can: Optional[MutableMapping[str, bool]] = None


@attr.s(auto_attribs=True, kw_only=True)
class Look(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        content_metadata_id: Id of content metadata
        id: Unique Id
        title: Look Title
        content_favorite_id: Content Favorite Id
        created_at: Time that the Look was created.
        deleted: Whether or not a look is 'soft' deleted.
        deleted_at: Time that the Look was deleted.
        deleter_id: Id of User that deleted the look.
        description: Description
        embed_url: Embed Url
        excel_file_url: Excel File Url
        favorite_count: Number of times favorited
        google_spreadsheet_formula: Google Spreadsheet Formula
        image_embed_url: Image Embed Url
        is_run_on_load: auto-run query when Look viewed
        last_accessed_at: Time that the Look was last accessed by any user
        last_updater_id: Id of User that last updated the look.
        last_viewed_at: Time last viewed in the Looker web UI
        model:
        public: Is Public
        public_slug: Public Slug
        public_url: Public Url
        query_id: Query Id
        short_url: Short Url
        space:
        folder:
        space_id: Space Id
        folder_id: Folder Id
        updated_at: Time that the Look was updated.
        user_id: User Id
        view_count: Number of times viewed in the Looker web UI
        user:
    """

    can: Optional[MutableMapping[str, bool]] = None
    content_metadata_id: Optional[int] = None
    id: Optional[int] = None
    title: Optional[str] = None
    content_favorite_id: Optional[int] = None
    created_at: Optional[datetime.datetime] = None
    deleted: Optional[bool] = None
    deleted_at: Optional[datetime.datetime] = None
    deleter_id: Optional[int] = None
    description: Optional[str] = None
    embed_url: Optional[str] = None
    excel_file_url: Optional[str] = None
    favorite_count: Optional[int] = None
    google_spreadsheet_formula: Optional[str] = None
    image_embed_url: Optional[str] = None
    is_run_on_load: Optional[bool] = None
    last_accessed_at: Optional[datetime.datetime] = None
    last_updater_id: Optional[int] = None
    last_viewed_at: Optional[datetime.datetime] = None
    model: Optional["LookModel"] = None
    public: Optional[bool] = None
    public_slug: Optional[str] = None
    public_url: Optional[str] = None
    query_id: Optional[int] = None
    short_url: Optional[str] = None
    space: Optional["SpaceBase"] = None
    folder: Optional["FolderBase"] = None
    space_id: Optional[str] = None
    folder_id: Optional[str] = None
    updated_at: Optional[datetime.datetime] = None
    user_id: Optional[int] = None
    view_count: Optional[int] = None
    user: Optional["UserIdOnly"] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookBasic(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        content_metadata_id: Id of content metadata
        id: Unique Id
        title: Look Title
    """

    can: Optional[MutableMapping[str, bool]] = None
    content_metadata_id: Optional[int] = None
    id: Optional[int] = None
    title: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookmlModel(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        allowed_db_connection_names: Array of names of connections this model is allowed to use
        explores: Array of explores (if has_content)
        has_content: Does this model declaration have have lookml content?
        label: UI-friendly name for this model
        name: Name of the model. Also used as the unique identifier
        project_name: Name of project containing the model
        unlimited_db_connections: Is this model allowed to use all current and future connections
    """

    can: Optional[MutableMapping[str, bool]] = None
    allowed_db_connection_names: Optional[Sequence[str]] = None
    explores: Optional[Sequence["LookmlModelNavExplore"]] = None
    has_content: Optional[bool] = None
    label: Optional[str] = None
    name: Optional[str] = None
    project_name: Optional[str] = None
    unlimited_db_connections: Optional[bool] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookmlModelExplore(model.Model):
    """
    Attributes:
        id: Fully qualified name model plus explore name
        name: Explore name
        description: Description
        label: Label
        scopes: Scopes
        can_total: Can Total
        can_save: Can Save
        can_explain: Can Explain
        can_pivot_in_db: Can pivot in the DB
        can_subtotal: Can use subtotals
        has_timezone_support: Has timezone support
        supports_cost_estimate: Cost estimates supported
        connection_name: Connection name
        null_sort_treatment: How nulls are sorted, possible values are "low", "high", "first" and "last"
        files: List of model source files
        source_file: Primary source_file file
        project_name: Name of project
        model_name: Name of model
        view_name: Name of view
        hidden: Is hidden
        sql_table_name: A sql_table_name expression that defines what sql table the view/explore maps onto. Example: "prod_orders2 AS orders" in a view named orders.
        access_filter_fields: (DEPRECATED) Array of access filter field names
        access_filters: Access filters
        aliases: Aliases
        always_filter: Always filter
        conditionally_filter: Conditionally filter
        index_fields: Array of index fields
        sets: Sets
        tags: An array of arbitrary string tags provided in the model for this explore.
        errors: Errors
        fields:
        joins: Views joined into this explore
        group_label: Label used to group explores in the navigation menus
        supported_measure_types: An array of items describing which custom measure types are supported for creating a custom measure 'baed_on' each possible dimension type.
    """

    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    label: Optional[str] = None
    scopes: Optional[Sequence[str]] = None
    can_total: Optional[bool] = None
    can_save: Optional[bool] = None
    can_explain: Optional[bool] = None
    can_pivot_in_db: Optional[bool] = None
    can_subtotal: Optional[bool] = None
    has_timezone_support: Optional[bool] = None
    supports_cost_estimate: Optional[bool] = None
    connection_name: Optional[str] = None
    null_sort_treatment: Optional[str] = None
    files: Optional[Sequence[str]] = None
    source_file: Optional[str] = None
    project_name: Optional[str] = None
    model_name: Optional[str] = None
    view_name: Optional[str] = None
    hidden: Optional[bool] = None
    sql_table_name: Optional[str] = None
    access_filter_fields: Optional[Sequence[str]] = None
    access_filters: Optional[Sequence["LookmlModelExploreAccessFilter"]] = None
    aliases: Optional[Sequence["LookmlModelExploreAlias"]] = None
    always_filter: Optional[Sequence["LookmlModelExploreAlwaysFilter"]] = None
    conditionally_filter: Optional[
        Sequence["LookmlModelExploreConditionallyFilter"]
    ] = None
    index_fields: Optional[Sequence[str]] = None
    sets: Optional[Sequence["LookmlModelExploreSet"]] = None
    tags: Optional[Sequence[str]] = None
    errors: Optional[Sequence["LookmlModelExploreError"]] = None
    fields: Optional["LookmlModelExploreFieldset"] = None
    joins: Optional[Sequence["LookmlModelExploreJoins"]] = None
    group_label: Optional[str] = None
    supported_measure_types: Optional[
        Sequence["LookmlModelExploreSupportedMeasureType"]
    ] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookmlModelExploreAccessFilter(model.Model):
    """
    Attributes:
        field: Field to be filtered
        user_attribute: User attribute name
    """

    field: Optional[str] = None
    user_attribute: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookmlModelExploreAlias(model.Model):
    """
    Attributes:
        name: Name
        value: Value
    """

    name: Optional[str] = None
    value: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookmlModelExploreAlwaysFilter(model.Model):
    """
    Attributes:
        name: Name
        value: Value
    """

    name: Optional[str] = None
    value: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookmlModelExploreConditionallyFilter(model.Model):
    """
    Attributes:
        name: Name
        value: Value
    """

    name: Optional[str] = None
    value: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookmlModelExploreError(model.Model):
    """
    Attributes:
        message: Error Message
        details: Details
        error_pos: Error source location
        field_error: Is this a field error
    """

    message: Optional[str] = None
    details: Optional[str] = None
    error_pos: Optional[str] = None
    field_error: Optional[bool] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookmlModelExploreField(model.Model):
    """
    Attributes:
        align: The appropriate horizontal text alignment the values of this field shoud be displayed in. Valid values are: "left", "right".
        can_filter: Whether it's possible to filter on this field.
        category: Field category Valid values are: "parameter", "filter", "measure", "dimension".
        default_filter_value: The default value that this field uses when filtering. Null if there is no default value.
        description: Description
        enumerations: An array enumerating all the possible values that this field can contain. When null, there is no limit to the set of possible values this field can contain.
        error: An error message indicating a problem with the definition of this field. If there are no errors, this will be null.
        field_group_label: A label creating a grouping of fields. All fields with this label should be presented together when displayed in a UI.
        field_group_variant: When presented in a field group via field_group_label, a shorter name of the field to be displayed in that context.
        fill_style: The style of dimension fill that is possible for this field. Null if no dimension fill is possible. Valid values are: "enumeration", "range".
        fiscal_month_offset: An offset (in months) from the calendar start month to the fiscal start month defined in the LookML model this field belongs to.
        has_allowed_values: Whether this field has a set of allowed_values specified in LookML.
        hidden: Whether this field should be hidden from the user interface.
        is_filter: Whether this field is a filter.
        is_fiscal: Whether this field represents a fiscal time value.
        is_numeric: Whether this field is of a type that represents a numeric value.
        is_timeframe: Whether this field is of a type that represents a time value.
        can_time_filter: Whether this field can be time filtered.
        time_interval:
        label: Fully-qualified human-readable label of the field.
        label_from_parameter: The name of the parameter that will provide a parameterized label for this field, if available in the current context.
        label_short: The human-readable label of the field, without the view label.
        lookml_link: A URL linking to the definition of this field in the LookML IDE.
        map_layer:
        measure: Whether this field is a measure.
        name: Fully-qualified name of the field.
        strict_value_format: If yes, the field will not be localized with the user attribute number_format. Defaults to no
        parameter: Whether this field is a parameter.
        permanent: Whether this field can be removed from a query.
        primary_key: Whether or not the field represents a primary key.
        project_name: The name of the project this field is defined in.
        requires_refresh_on_sort: When true, it's not possible to re-sort this field's values without re-running the SQL query, due to database logic that affects the sort.
        scope: The LookML scope this field belongs to. The scope is typically the field's view.
        sortable: Whether this field can be sorted.
        source_file: The path portion of source_file_path.
        source_file_path: The fully-qualified path of the project file this field is defined in.
        sql: SQL expression as defined in the LookML model. The SQL syntax shown here is a representation intended for auditability, and is not neccessarily an exact match for what will ultimately be run in the database. It may contain special LookML syntax or annotations that are not valid SQL. This will be null if the current user does not have the see_lookml permission for the field's model.
        sql_case: An array of conditions and values that make up a SQL Case expression, as defined in the LookML model. The SQL syntax shown here is a representation intended for auditability, and is not neccessarily an exact match for what will ultimately be run in the database. It may contain special LookML syntax or annotations that are not valid SQL. This will be null if the current user does not have the see_lookml permission for the field's model.
        suggest_dimension: The name of the dimension to base suggest queries from.
        suggest_explore: The name of the explore to base suggest queries from.
        suggestable: Whether or not suggestions are possible for this field.
        suggestions: If available, a list of suggestions for this field. For most fields, a suggest query is a more appropriate way to get an up-to-date list of suggestions. Or use enumerations to list all the possible values.
        tags: An array of arbitrary string tags provided in the model for this field.
        type: The LookML type of the field.
        user_attribute_filter_types: An array of user attribute types that are allowed to be used in filters on this field. Valid values are: "advanced_filter_string", "advanced_filter_number", "advanced_filter_datetime", "string", "number", "datetime", "relative_url", "yesno", "zipcode".
        value_format: If specified, the LookML value format string for formatting values of this field.
        view: The name of the view this field belongs to.
        view_label: The human-readable label of the view the field belongs to.
        dynamic: Whether this field was specified in "dynamic_fields" and is not part of the model.
        week_start_day: The name of the starting day of the week. Valid values are: "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday".
    """

    align: Optional[str] = None
    can_filter: Optional[bool] = None
    category: Optional[str] = None
    default_filter_value: Optional[str] = None
    description: Optional[str] = None
    enumerations: Optional[Sequence["LookmlModelExploreFieldEnumeration"]] = None
    error: Optional[str] = None
    field_group_label: Optional[str] = None
    field_group_variant: Optional[str] = None
    fill_style: Optional[str] = None
    fiscal_month_offset: Optional[int] = None
    has_allowed_values: Optional[bool] = None
    hidden: Optional[bool] = None
    is_filter: Optional[bool] = None
    is_fiscal: Optional[bool] = None
    is_numeric: Optional[bool] = None
    is_timeframe: Optional[bool] = None
    can_time_filter: Optional[bool] = None
    time_interval: Optional["LookmlModelExploreFieldTimeInterval"] = None
    label: Optional[str] = None
    label_from_parameter: Optional[str] = None
    label_short: Optional[str] = None
    lookml_link: Optional[str] = None
    map_layer: Optional["LookmlModelExploreFieldMapLayer"] = None
    measure: Optional[bool] = None
    name: Optional[str] = None
    strict_value_format: Optional[bool] = None
    parameter: Optional[bool] = None
    permanent: Optional[bool] = None
    primary_key: Optional[bool] = None
    project_name: Optional[str] = None
    requires_refresh_on_sort: Optional[bool] = None
    scope: Optional[str] = None
    sortable: Optional[bool] = None
    source_file: Optional[str] = None
    source_file_path: Optional[str] = None
    sql: Optional[str] = None
    sql_case: Optional[Sequence["LookmlModelExploreFieldSqlCase"]] = None
    suggest_dimension: Optional[str] = None
    suggest_explore: Optional[str] = None
    suggestable: Optional[bool] = None
    suggestions: Optional[Sequence[str]] = None
    tags: Optional[Sequence[str]] = None
    type: Optional[str] = None
    user_attribute_filter_types: Optional[Sequence[str]] = None
    value_format: Optional[str] = None
    view: Optional[str] = None
    view_label: Optional[str] = None
    dynamic: Optional[bool] = None
    week_start_day: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookmlModelExploreFieldEnumeration(model.Model):
    """
    Attributes:
        label: Label
        value: Value
    """

    label: Optional[str] = None
    value: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookmlModelExploreFieldMapLayer(model.Model):
    """
    Attributes:
        url: URL to the map layer resource.
        name: Name of the map layer, as defined in LookML.
        feature_key: Specifies the name of the TopoJSON object that the map layer references. If not specified, use the first object..
        property_key: Selects which property from the TopoJSON data to plot against. TopoJSON supports arbitrary metadata for each region. When null, the first matching property should be used.
        property_label_key: Which property from the TopoJSON data to use to label the region. When null, property_key should be used.
        projection: The preferred geographic projection of the map layer when displayed in a visualization that supports multiple geographic projections.
        format: Specifies the data format of the region information. Valid values are: "topojson", "vector_tile_region".
        extents_json_url: Specifies the URL to a JSON file that defines the geographic extents of each region available in the map layer. This data is used to automatically center the map on the available data for visualization purposes. The JSON file must be a JSON object where the keys are the mapping value of the feature (as specified by property_key) and the values are arrays of four numbers representing the west longitude, south latitude, east longitude, and north latitude extents of the region. The object must include a key for every possible value of property_key.
        max_zoom_level: The minimum zoom level that the map layer may be displayed at, for visualizations that support zooming.
        min_zoom_level: The maximum zoom level that the map layer may be displayed at, for visualizations that support zooming.
    """

    url: Optional[str] = None
    name: Optional[str] = None
    feature_key: Optional[str] = None
    property_key: Optional[str] = None
    property_label_key: Optional[str] = None
    projection: Optional[str] = None
    format: Optional[str] = None
    extents_json_url: Optional[str] = None
    max_zoom_level: Optional[int] = None
    min_zoom_level: Optional[int] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookmlModelExploreFieldset(model.Model):
    """
    Attributes:
        dimensions: Array of dimensions
        measures: Array of measures
        filters: Array of filters
        parameters: Array of parameters
    """

    dimensions: Optional[Sequence["LookmlModelExploreField"]] = None
    measures: Optional[Sequence["LookmlModelExploreField"]] = None
    filters: Optional[Sequence["LookmlModelExploreField"]] = None
    parameters: Optional[Sequence["LookmlModelExploreField"]] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookmlModelExploreFieldSqlCase(model.Model):
    """
    Attributes:
        value: SQL Case label value
        condition: SQL Case condition expression
    """

    value: Optional[str] = None
    condition: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookmlModelExploreFieldTimeInterval(model.Model):
    """
    Attributes:
        name: The type of time interval this field represents a grouping of. Valid values are: "day", "hour", "minute", "second", "millisecond", "microsecond", "month", "year".
        count: The number of intervals this field represents a grouping of.
    """

    name: Optional[str] = None
    count: Optional[int] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookmlModelExploreJoins(model.Model):
    """
    Attributes:
        name: Name of this join (and name of the view to join)
        dependent_fields: Fields referenced by the join
        fields: Fields of the joined view to pull into this explore
        foreign_key: Name of the dimension in this explore whose value is in the primary key of the joined view
        from_: Name of view to join
        outer_only: Specifies whether all queries must use an outer join
        relationship: many_to_one, one_to_one, one_to_many, many_to_many
        required_joins: Names of joins that must always be included in SQL queries
        sql_foreign_key: SQL expression that produces a foreign key
        sql_on: SQL ON expression describing the join condition
        sql_table_name: SQL table name to join
        type: The join type: left_outer, full_outer, inner, or cross
        view_label: Label to display in UI selectors
    """

    name: Optional[str] = None
    dependent_fields: Optional[Sequence[str]] = None
    fields: Optional[Sequence[str]] = None
    foreign_key: Optional[str] = None
    from_: Optional[str] = None
    outer_only: Optional[bool] = None
    relationship: Optional[str] = None
    required_joins: Optional[Sequence[str]] = None
    sql_foreign_key: Optional[str] = None
    sql_on: Optional[str] = None
    sql_table_name: Optional[str] = None
    type: Optional[str] = None
    view_label: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookmlModelExploreSet(model.Model):
    """
    Attributes:
        name: Name
        value: Value set
    """

    name: Optional[str] = None
    value: Optional[Sequence[str]] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookmlModelExploreSupportedMeasureType(model.Model):
    """
    Attributes:
        dimension_type:
        measure_types:
    """

    dimension_type: Optional[str] = None
    measure_types: Optional[Sequence[str]] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookmlModelNavExplore(model.Model):
    """
    Attributes:
        name: Name of the explore
        description: Description for the explore
        label: Label for the explore
        hidden: Is this explore marked as hidden
        group_label: Label used to group explores in the navigation menus
        can: Operations the current user is able to perform on this object
    """

    name: Optional[str] = None
    description: Optional[str] = None
    label: Optional[str] = None
    hidden: Optional[bool] = None
    group_label: Optional[str] = None
    can: Optional[MutableMapping[str, bool]] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookmlTest(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        model_name: Name of model containing this test.
        name: Name of this test.
        explore_name: Name of the explore this test runs a query against
        query_url_params: The url parameters that can be used to reproduce this test's query on an explore.
        file: Name of the LookML file containing this test.
        line: Line number of this test in LookML.
    """

    can: Optional[MutableMapping[str, bool]] = None
    model_name: Optional[str] = None
    name: Optional[str] = None
    explore_name: Optional[str] = None
    query_url_params: Optional[str] = None
    file: Optional[str] = None
    line: Optional[int] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookmlTestResult(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        model_name: Name of model containing this test.
        test_name: Name of this test.
        assertions_count: Number of assertions in this test
        assertions_failed: Number of assertions passed in this test
        errors: A list of any errors encountered by the test.
        warnings: A list of any warnings encountered by the test.
        success: True if this test passsed without errors.
    """

    can: Optional[MutableMapping[str, bool]] = None
    model_name: Optional[str] = None
    test_name: Optional[str] = None
    assertions_count: Optional[int] = None
    assertions_failed: Optional[int] = None
    errors: Optional[Sequence["ProjectError"]] = None
    warnings: Optional[Sequence["ProjectError"]] = None
    success: Optional[bool] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookModel(model.Model):
    """
    Attributes:
        id: Model Id
        label: Model Label
    """

    id: Optional[str] = None
    label: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookWithDashboards(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        content_metadata_id: Id of content metadata
        id: Unique Id
        title: Look Title
        content_favorite_id: Content Favorite Id
        created_at: Time that the Look was created.
        deleted: Whether or not a look is 'soft' deleted.
        deleted_at: Time that the Look was deleted.
        deleter_id: Id of User that deleted the look.
        description: Description
        embed_url: Embed Url
        excel_file_url: Excel File Url
        favorite_count: Number of times favorited
        google_spreadsheet_formula: Google Spreadsheet Formula
        image_embed_url: Image Embed Url
        is_run_on_load: auto-run query when Look viewed
        last_accessed_at: Time that the Look was last accessed by any user
        last_updater_id: Id of User that last updated the look.
        last_viewed_at: Time last viewed in the Looker web UI
        model:
        public: Is Public
        public_slug: Public Slug
        public_url: Public Url
        query_id: Query Id
        short_url: Short Url
        space:
        folder:
        space_id: Space Id
        folder_id: Folder Id
        updated_at: Time that the Look was updated.
        user_id: User Id
        view_count: Number of times viewed in the Looker web UI
        user:
        dashboards: Dashboards
    """

    can: Optional[MutableMapping[str, bool]] = None
    content_metadata_id: Optional[int] = None
    id: Optional[int] = None
    title: Optional[str] = None
    content_favorite_id: Optional[int] = None
    created_at: Optional[datetime.datetime] = None
    deleted: Optional[bool] = None
    deleted_at: Optional[datetime.datetime] = None
    deleter_id: Optional[int] = None
    description: Optional[str] = None
    embed_url: Optional[str] = None
    excel_file_url: Optional[str] = None
    favorite_count: Optional[int] = None
    google_spreadsheet_formula: Optional[str] = None
    image_embed_url: Optional[str] = None
    is_run_on_load: Optional[bool] = None
    last_accessed_at: Optional[datetime.datetime] = None
    last_updater_id: Optional[int] = None
    last_viewed_at: Optional[datetime.datetime] = None
    model: Optional["LookModel"] = None
    public: Optional[bool] = None
    public_slug: Optional[str] = None
    public_url: Optional[str] = None
    query_id: Optional[int] = None
    short_url: Optional[str] = None
    space: Optional["SpaceBase"] = None
    folder: Optional["FolderBase"] = None
    space_id: Optional[str] = None
    folder_id: Optional[str] = None
    updated_at: Optional[datetime.datetime] = None
    user_id: Optional[int] = None
    view_count: Optional[int] = None
    user: Optional["UserIdOnly"] = None
    dashboards: Optional[Sequence["DashboardBase"]] = None


@attr.s(auto_attribs=True, kw_only=True)
class LookWithQuery(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        content_metadata_id: Id of content metadata
        id: Unique Id
        title: Look Title
        content_favorite_id: Content Favorite Id
        created_at: Time that the Look was created.
        deleted: Whether or not a look is 'soft' deleted.
        deleted_at: Time that the Look was deleted.
        deleter_id: Id of User that deleted the look.
        description: Description
        embed_url: Embed Url
        excel_file_url: Excel File Url
        favorite_count: Number of times favorited
        google_spreadsheet_formula: Google Spreadsheet Formula
        image_embed_url: Image Embed Url
        is_run_on_load: auto-run query when Look viewed
        last_accessed_at: Time that the Look was last accessed by any user
        last_updater_id: Id of User that last updated the look.
        last_viewed_at: Time last viewed in the Looker web UI
        model:
        public: Is Public
        public_slug: Public Slug
        public_url: Public Url
        query_id: Query Id
        short_url: Short Url
        space:
        folder:
        space_id: Space Id
        folder_id: Folder Id
        updated_at: Time that the Look was updated.
        user_id: User Id
        view_count: Number of times viewed in the Looker web UI
        user:
        query:
        url: Url
    """

    can: Optional[MutableMapping[str, bool]] = None
    content_metadata_id: Optional[int] = None
    id: Optional[int] = None
    title: Optional[str] = None
    content_favorite_id: Optional[int] = None
    created_at: Optional[datetime.datetime] = None
    deleted: Optional[bool] = None
    deleted_at: Optional[datetime.datetime] = None
    deleter_id: Optional[int] = None
    description: Optional[str] = None
    embed_url: Optional[str] = None
    excel_file_url: Optional[str] = None
    favorite_count: Optional[int] = None
    google_spreadsheet_formula: Optional[str] = None
    image_embed_url: Optional[str] = None
    is_run_on_load: Optional[bool] = None
    last_accessed_at: Optional[datetime.datetime] = None
    last_updater_id: Optional[int] = None
    last_viewed_at: Optional[datetime.datetime] = None
    model: Optional["LookModel"] = None
    public: Optional[bool] = None
    public_slug: Optional[str] = None
    public_url: Optional[str] = None
    query_id: Optional[int] = None
    short_url: Optional[str] = None
    space: Optional["SpaceBase"] = None
    folder: Optional["FolderBase"] = None
    space_id: Optional[str] = None
    folder_id: Optional[str] = None
    updated_at: Optional[datetime.datetime] = None
    user_id: Optional[int] = None
    view_count: Optional[int] = None
    user: Optional["UserIdOnly"] = None
    query: Optional["Query"] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class Manifest(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        name: Manifest project name
        imports: Imports for a project
        localization_settings:
    """

    can: Optional[MutableMapping[str, bool]] = None
    name: Optional[str] = None
    imports: Optional[Sequence["ImportedProject"]] = None
    localization_settings: Optional["LocalizationSettings"] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class MergeFields(model.Model):
    """
    Attributes:
        field_name: Field name to map onto in the merged results
        source_field_name: Field name from the source query
    """

    field_name: Optional[str] = None
    source_field_name: Optional[str] = None

    def __init__(
        self,
        *,
        field_name: Optional[str] = None,
        source_field_name: Optional[str] = None
    ):
        self.field_name = field_name
        self.source_field_name = source_field_name


@attr.s(auto_attribs=True, kw_only=True)
class MergeQuery(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        column_limit: Column Limit
        dynamic_fields: Dynamic Fields
        id: Unique Id
        pivots: Pivots
        result_maker_id: Unique to get results
        sorts: Sorts
        source_queries: Source Queries defining the results to be merged.
        total: Total
        vis_config: Visualization Config
    """

    can: Optional[MutableMapping[str, bool]] = None
    column_limit: Optional[str] = None
    dynamic_fields: Optional[str] = None
    id: Optional[str] = None
    pivots: Optional[Sequence[str]] = None
    result_maker_id: Optional[int] = None
    sorts: Optional[Sequence[str]] = None
    source_queries: Optional[Sequence["MergeQuerySourceQuery"]] = None
    total: Optional[bool] = None
    vis_config: Optional[MutableMapping[str, str]] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class MergeQuerySourceQuery(model.Model):
    """
    Attributes:
        merge_fields: An array defining which fields of the source query are mapped onto fields of the merge query
        name: Display name
        query_id: Id of the query to merge
    """

    merge_fields: Optional[Sequence["MergeFields"]] = None
    name: Optional[str] = None
    query_id: Optional[int] = None

    def __init__(
        self,
        *,
        merge_fields: Optional[Sequence["MergeFields"]] = None,
        name: Optional[str] = None,
        query_id: Optional[int] = None
    ):
        self.merge_fields = merge_fields
        self.name = name
        self.query_id = query_id


@attr.s(auto_attribs=True, kw_only=True)
class ModelSet(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        all_access:
        built_in:
        id: Unique Id
        models:
        name: Name of ModelSet
        url: Link to get this item
    """

    can: Optional[MutableMapping[str, bool]] = None
    all_access: Optional[bool] = None
    built_in: Optional[bool] = None
    id: Optional[int] = None
    models: Optional[Sequence[str]] = None
    name: Optional[str] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class ModelsNotValidated(model.Model):
    """
    Attributes:
        name: Model name
        project_file_id: Project file
    """

    name: Optional[str] = None
    project_file_id: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class OIDCConfig(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        alternate_email_login_allowed: Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
        audience: OpenID Provider Audience
        auth_requires_role: Users will not be allowed to login at all unless a role for them is found in OIDC if set to true
        authorization_endpoint: OpenID Provider Authorization Url
        default_new_user_group_ids: (Write-Only) Array of ids of groups that will be applied to new users the first time they login via OIDC
        default_new_user_groups: (Read-only) Groups that will be applied to new users the first time they login via OIDC
        default_new_user_role_ids: (Write-Only) Array of ids of roles that will be applied to new users the first time they login via OIDC
        default_new_user_roles: (Read-only) Roles that will be applied to new users the first time they login via OIDC
        enabled: Enable/Disable OIDC authentication for the server
        groups: (Read-only) Array of mappings between OIDC Groups and Looker Roles
        groups_attribute: Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
        groups_with_role_ids: (Read/Write) Array of mappings between OIDC Groups and arrays of Looker Role ids
        identifier: Relying Party Identifier (provided by OpenID Provider)
        issuer: OpenID Provider Issuer
        modified_at: When this config was last modified
        modified_by: User id of user who last modified this config
        new_user_migration_types: Merge first-time oidc login to existing user account by email addresses. When a user logs in for the first time via oidc this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
        scopes: Array of scopes to request.
        secret: (Write-Only) Relying Party Secret (provided by OpenID Provider)
        set_roles_from_groups: Set user roles in Looker based on groups from OIDC
        test_slug: Slug to identify configurations that are created in order to run a OIDC config test
        token_endpoint: OpenID Provider Token Url
        user_attribute_map_email: Name of user record attributes used to indicate email address field
        user_attribute_map_first_name: Name of user record attributes used to indicate first name
        user_attribute_map_last_name: Name of user record attributes used to indicate last name
        user_attributes: (Read-only) Array of mappings between OIDC User Attributes and Looker User Attributes
        user_attributes_with_ids: (Read/Write) Array of mappings between OIDC User Attributes and arrays of Looker User Attribute ids
        userinfo_endpoint: OpenID Provider User Information Url
        url: Link to get this item
    """

    can: Optional[MutableMapping[str, bool]] = None
    alternate_email_login_allowed: Optional[bool] = None
    audience: Optional[str] = None
    auth_requires_role: Optional[bool] = None
    authorization_endpoint: Optional[str] = None
    default_new_user_group_ids: Optional[Sequence[int]] = None
    default_new_user_groups: Optional[Sequence["Group"]] = None
    default_new_user_role_ids: Optional[Sequence[int]] = None
    default_new_user_roles: Optional[Sequence["Role"]] = None
    enabled: Optional[bool] = None
    groups: Optional[Sequence["OIDCGroupRead"]] = None
    groups_attribute: Optional[str] = None
    groups_with_role_ids: Optional[Sequence["OIDCGroupWrite"]] = None
    identifier: Optional[str] = None
    issuer: Optional[str] = None
    modified_at: Optional[datetime.datetime] = None
    modified_by: Optional[int] = None
    new_user_migration_types: Optional[str] = None
    scopes: Optional[Sequence[str]] = None
    secret: Optional[str] = None
    set_roles_from_groups: Optional[bool] = None
    test_slug: Optional[str] = None
    token_endpoint: Optional[str] = None
    user_attribute_map_email: Optional[str] = None
    user_attribute_map_first_name: Optional[str] = None
    user_attribute_map_last_name: Optional[str] = None
    user_attributes: Optional[Sequence["OIDCUserAttributeRead"]] = None
    user_attributes_with_ids: Optional[Sequence["OIDCUserAttributeWrite"]] = None
    userinfo_endpoint: Optional[str] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class OIDCGroupRead(model.Model):
    """
    Attributes:
        name: Name of group in OIDC
        roles: Looker Roles
    """

    name: Optional[str] = None
    roles: Optional[Sequence["Role"]] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class OIDCGroupWrite(model.Model):
    """
    Attributes:
        name: Name of group in OIDC
        role_ids: Looker Role Ids
        can: Operations the current user is able to perform on this object
    """

    name: Optional[str] = None
    role_ids: Optional[Sequence[int]] = None
    can: Optional[MutableMapping[str, bool]] = None

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        role_ids: Optional[Sequence[int]] = None,
        can: Optional[MutableMapping[str, bool]] = None
    ):
        self.name = name
        self.role_ids = role_ids
        self.can = can


@attr.s(auto_attribs=True, kw_only=True)
class OIDCUserAttributeRead(model.Model):
    """
    Attributes:
        name: Name of User Attribute in OIDC
        required: Required to be in OIDC assertion for login to be allowed to succeed
        user_attributes: Looker User Attributes
    """

    name: Optional[str] = None
    required: Optional[bool] = None
    user_attributes: Optional[Sequence["UserAttribute"]] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class OIDCUserAttributeWrite(model.Model):
    """
    Attributes:
        name: Name of User Attribute in OIDC
        required: Required to be in OIDC assertion for login to be allowed to succeed
        user_attribute_ids: Looker User Attribute Ids
        can: Operations the current user is able to perform on this object
    """

    name: Optional[str] = None
    required: Optional[bool] = None
    user_attribute_ids: Optional[Sequence[int]] = None
    can: Optional[MutableMapping[str, bool]] = None

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        required: Optional[bool] = None,
        user_attribute_ids: Optional[Sequence[int]] = None,
        can: Optional[MutableMapping[str, bool]] = None
    ):
        self.name = name
        self.required = required
        self.user_attribute_ids = user_attribute_ids
        self.can = can


@attr.s(auto_attribs=True, kw_only=True)
class PasswordConfig(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        min_length: Minimum number of characters required for a new password.  Must be between 7 and 100
        require_numeric: Require at least one numeric character
        require_upperlower: Require at least one uppercase and one lowercase letter
        require_special: Require at least one special character
    """

    can: Optional[MutableMapping[str, bool]] = None
    min_length: Optional[int] = None
    require_numeric: Optional[bool] = None
    require_upperlower: Optional[bool] = None
    require_special: Optional[bool] = None


@attr.s(auto_attribs=True, kw_only=True)
class Permission(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        permission: Permission symbol
        parent: Dependency parent symbol
        description: Description
    """

    can: Optional[MutableMapping[str, bool]] = None
    permission: Optional[str] = None
    parent: Optional[str] = None
    description: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class PermissionSet(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        all_access:
        built_in:
        id: Unique Id
        name: Name of PermissionSet
        permissions:
        url: Link to get this item
    """

    can: Optional[MutableMapping[str, bool]] = None
    all_access: Optional[bool] = None
    built_in: Optional[bool] = None
    id: Optional[int] = None
    name: Optional[str] = None
    permissions: Optional[Sequence[str]] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class Project(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: Project Id
        name: Project display name
        uses_git: If true the project is configured with a git repository
        git_remote_url: Git remote repository url
        git_username: Git username for HTTPS authentication. (For production only, if using user attributes.)
        git_password: (Write-Only) Git password for HTTPS authentication. (For production only, if using user attributes.)
        git_username_user_attribute: User attribute name for username in per-user HTTPS authentication.
        git_password_user_attribute: User attribute name for password in per-user HTTPS authentication.
        git_service_name: Name of the git service provider
        deploy_secret: (Write-Only) Optional secret token with which to authenticate requests to the webhook deploy endpoint. If not set, endpoint is unauthenticated.
        unset_deploy_secret: (Write-Only) When true, unsets the deploy secret to allow unauthenticated access to the webhook deploy endpoint.
        pull_request_mode: The git pull request policy for this project. Valid values are: "off", "links", "recommended", "required".
        validation_required: Validation policy: If true, the project must pass validation checks before project changes can be committed to the git repository
        folders_enabled: If true, folders are enabled for this project
        allow_warnings: Validation policy: If true, the project can be committed with warnings when `validation_required` is true. (`allow_warnings` does nothing if `validation_required` is false).
        is_example: If true the project is an example project and cannot be modified
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[str] = None
    name: Optional[str] = None
    uses_git: Optional[bool] = None
    git_remote_url: Optional[str] = None
    git_username: Optional[str] = None
    git_password: Optional[str] = None
    git_username_user_attribute: Optional[str] = None
    git_password_user_attribute: Optional[str] = None
    git_service_name: Optional[str] = None
    deploy_secret: Optional[str] = None
    unset_deploy_secret: Optional[bool] = None
    pull_request_mode: Optional[str] = None
    validation_required: Optional[bool] = None
    folders_enabled: Optional[bool] = None
    allow_warnings: Optional[bool] = None
    is_example: Optional[bool] = None


@attr.s(auto_attribs=True, kw_only=True)
class ProjectError(model.Model):
    """
    Attributes:
        code: A stable token that uniquely identifies this class of error, ignoring parameter values. Error message text may vary due to parameters or localization, but error codes do not. For example, a "File not found" error will have the same error code regardless of the filename in question or the user's display language
        severity: Severity: fatal, error, warning, info, success
        kind: Error classification: syntax, deprecation, model_configuration, etc
        message: Error message which may contain information such as dashboard or model names that may be considered sensitive in some use cases. Avoid storing or sending this message outside of Looker
        field_name: The field associated with this error
        file_path: Name of the file containing this error
        line_number: Line number in the file of this error
        model_id: The model associated with this error
        explore: The explore associated with this error
        help_url: A link to Looker documentation about this error
        params: Error parameters
        sanitized_message: A version of the error message that does not contain potentially sensitive information. Suitable for situations in which messages are stored or sent to consumers outside of Looker, such as external logs. Sanitized messages will display "(?)" where sensitive information would appear in the corresponding non-sanitized message
    """

    code: Optional[str] = None
    severity: Optional[str] = None
    kind: Optional[str] = None
    message: Optional[str] = None
    field_name: Optional[str] = None
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    model_id: Optional[str] = None
    explore: Optional[str] = None
    help_url: Optional[str] = None
    params: Optional[MutableMapping[str, str]] = None
    sanitized_message: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class ProjectFile(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: An opaque token uniquely identifying a file within a project. Avoid parsing or decomposing the text of this token. This token is stable within a Looker release but may change between Looker releases
        path: Path, file name, and extension of the file relative to the project root directory
        title: Display name
        type: File type: model, view, etc
        extension: The extension of the file: .view.lkml, .model.lkml, etc
        mime_type: File mime type
        editable: State of editability for the file.
        git_status:
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[str] = None
    path: Optional[str] = None
    title: Optional[str] = None
    type: Optional[str] = None
    extension: Optional[str] = None
    mime_type: Optional[str] = None
    editable: Optional[bool] = None
    git_status: Optional["GitStatus"] = None


@attr.s(auto_attribs=True, kw_only=True)
class ProjectValidation(model.Model):
    """
    Attributes:
        errors: A list of project errors
        project_digest: A hash value computed from the project's current state
        models_not_validated: A list of models which were not fully validated
        computation_time: Duration of project validation in seconds
    """

    errors: Optional[Sequence["ProjectError"]] = None
    project_digest: Optional[str] = None
    models_not_validated: Optional[Sequence["ModelsNotValidated"]] = None
    computation_time: Optional[float] = None


@attr.s(auto_attribs=True, kw_only=True)
class ProjectValidationCache(model.Model):
    """
    Attributes:
        errors: A list of project errors
        project_digest: A hash value computed from the project's current state
        models_not_validated: A list of models which were not fully validated
        computation_time: Duration of project validation in seconds
        stale: If true, the cached project validation results are no longer accurate because the project has changed since the cached results were calculated
    """

    errors: Optional[Sequence["ProjectError"]] = None
    project_digest: Optional[str] = None
    models_not_validated: Optional[Sequence["ModelsNotValidated"]] = None
    computation_time: Optional[float] = None
    stale: Optional[bool] = None


@attr.s(auto_attribs=True, kw_only=True)
class ProjectWorkspace(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        project_id: The id of the project
        workspace_id: The id of the local workspace containing the project files
        git_status: The status of the local git directory
        git_head: Git head revision name
        git_branch:
        lookml_type: The lookml syntax used by all files in this project
    """

    can: Optional[MutableMapping[str, bool]] = None
    project_id: Optional[str] = None
    workspace_id: Optional[str] = None
    git_status: Optional[str] = None
    git_head: Optional[str] = None
    git_branch: Optional["GitBranch"] = None
    lookml_type: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class Query(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: Unique Id
        model: Model
        view: Explore Name
        fields: Fields
        pivots: Pivots
        fill_fields: Fill Fields
        filters: Filters
        filter_expression: Filter Expression
        sorts: Sorting for the query results. Use the format `["view.field", ...]` to sort on fields in ascending order. Use the format `["view.field desc", ...]` to sort on fields in descending order. Use `["__UNSORTED__"]` (2 underscores before and after) to disable sorting entirely. Empty sorts `[]` will trigger a default sort.
        limit: Limit
        column_limit: Column Limit
        total: Total
        row_total: Raw Total
        subtotals: Fields on which to run subtotals
        runtime: Runtime
        vis_config: Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
        filter_config: The filter_config represents the state of the filter UI on the explore page for a given query. When running a query via the Looker UI, this parameter takes precedence over "filters". When creating a query or modifying an existing query, "filter_config" should be set to null. Setting it to any other value could cause unexpected filtering behavior. The format should be considered opaque.
        visible_ui_sections: Visible UI Sections
        slug: Slug
        dynamic_fields: Dynamic Fields
        client_id: Client Id: used to generate shortened explore URLs. If set by client, must be a unique 22 character alphanumeric string. Otherwise one will be generated.
        share_url: Share Url
        expanded_share_url: Expanded Share Url
        url: Expanded Url
        query_timezone: Query Timezone
        has_table_calculations: Has Table Calculations
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[int] = None
    model: str
    view: str
    fields: Optional[Sequence[str]] = None
    pivots: Optional[Sequence[str]] = None
    fill_fields: Optional[Sequence[str]] = None
    filters: Optional[MutableMapping[str, str]] = None
    filter_expression: Optional[str] = None
    sorts: Optional[Sequence[str]] = None
    limit: Optional[str] = None
    column_limit: Optional[str] = None
    total: Optional[bool] = None
    row_total: Optional[str] = None
    subtotals: Optional[Sequence[str]] = None
    runtime: Optional[float] = None
    vis_config: Optional[MutableMapping[str, str]] = None
    filter_config: Optional[MutableMapping[str, str]] = None
    visible_ui_sections: Optional[str] = None
    slug: Optional[str] = None
    dynamic_fields: Optional[str] = None
    client_id: Optional[str] = None
    share_url: Optional[str] = None
    expanded_share_url: Optional[str] = None
    url: Optional[str] = None
    query_timezone: Optional[str] = None
    has_table_calculations: Optional[bool] = None


@attr.s(auto_attribs=True, kw_only=True)
class QueryTask(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: Unique Id
        query_id: Id of query
        query:
        generate_links: whether or not to generate links in the query response.
        force_production: Use production models to run query (even is user is in dev mode).
        path_prefix: Prefix to use for drill links.
        cache: Whether or not to use the cache
        server_table_calcs: Whether or not to run table calculations on the server
        cache_only: Retrieve any results from cache even if the results have expired.
        cache_key: cache key used to cache query.
        status: Status of query task.
        source: Source of query task.
        runtime: Runtime of prior queries.
        rebuild_pdts: Rebuild PDTS used in query.
        result_source: Source of the results of the query.
        look_id: Id of look associated with query.
        dashboard_id: Id of dashboard associated with query.
        result_format: The data format of the query results.
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[str] = None
    query_id: Optional[int] = None
    query: Optional["Query"] = None
    generate_links: Optional[bool] = None
    force_production: Optional[bool] = None
    path_prefix: Optional[str] = None
    cache: Optional[bool] = None
    server_table_calcs: Optional[bool] = None
    cache_only: Optional[bool] = None
    cache_key: Optional[str] = None
    status: Optional[str] = None
    source: Optional[str] = None
    runtime: Optional[float] = None
    rebuild_pdts: Optional[bool] = None
    result_source: Optional[str] = None
    look_id: Optional[int] = None
    dashboard_id: Optional[str] = None
    result_format: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class RenderTask(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        created_at: Date/Time render task was created
        dashboard_filters: Filter values to apply to the dashboard queries, in URL query format
        dashboard_id: Id of dashboard to render
        dashboard_style: Dashboard layout style: single_column or tiled
        finalized_at: Date/Time render task was completed
        height: Output height in pixels. Flowed layouts may ignore this value.
        id: Id of this render task
        look_id: Id of look to render
        lookml_dashboard_id: Id of lookml dashboard to render
        query_id: Id of query to render
        query_runtime: Number of seconds elapsed running queries
        render_runtime: Number of seconds elapsed rendering data
        result_format: Output format: pdf, png, or jpg
        runtime: Total seconds elapsed for render task
        status: Render task status: enqueued_for_query, querying, enqueued_for_render, rendering, success, failure
        status_detail: Additional information about the current status
        user_id: The user account permissions in which the render task will execute
        width: Output width in pixels
    """

    can: Optional[MutableMapping[str, bool]] = None
    created_at: Optional[str] = None
    dashboard_filters: Optional[str] = None
    dashboard_id: Optional[int] = None
    dashboard_style: Optional[str] = None
    finalized_at: Optional[str] = None
    height: Optional[int] = None
    id: Optional[str] = None
    look_id: Optional[int] = None
    lookml_dashboard_id: Optional[str] = None
    query_id: Optional[int] = None
    query_runtime: Optional[float] = None
    render_runtime: Optional[float] = None
    result_format: Optional[str] = None
    runtime: Optional[float] = None
    status: Optional[str] = None
    status_detail: Optional[str] = None
    user_id: Optional[int] = None
    width: Optional[int] = None


@attr.s(auto_attribs=True, kw_only=True)
class RepositoryCredential(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: Unique Id
        root_project_id: Root project Id
        remote_url: Git remote repository url
        git_username: Git username for HTTPS authentication.
        git_password: (Write-Only) Git password for HTTPS authentication.
        ssh_public_key: Public deploy key for SSH authentication.
        is_configured: Whether the credentials have been configured for the Git Repository.
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[str] = None
    root_project_id: Optional[str] = None
    remote_url: Optional[str] = None
    git_username: Optional[str] = None
    git_password: Optional[str] = None
    ssh_public_key: Optional[str] = None
    is_configured: Optional[bool] = None


@attr.s(auto_attribs=True, kw_only=True)
class ResultMakerFilterables(model.Model):
    """
    Attributes:
        model: The model this filterable comes from (used for field suggestions).
        view: The view this filterable comes from (used for field suggestions).
        name: The name of the filterable thing (Query or Merged Results).
        listen: array of dashboard_filter_name: and field: objects.
    """

    model: Optional[str] = None
    view: Optional[str] = None
    name: Optional[str] = None
    listen: Optional[Sequence["ResultMakerFilterablesListen"]] = None


@attr.s(auto_attribs=True, kw_only=True)
class ResultMakerFilterablesListen(model.Model):
    """
    Attributes:
        dashboard_filter_name: The name of a dashboard filter to listen to.
        field: The name of the field in the filterable to filter with the value of the dashboard filter.
    """

    dashboard_filter_name: Optional[str] = None
    field: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class ResultMakerWithIdVisConfigAndDynamicFields(model.Model):
    """
    Attributes:
        id: Unique Id.
        dynamic_fields: JSON string of dynamic field information.
        filterables: array of items that can be filtered and information about them.
        sorts: Sorts of the constituent Look, Query, or Merge Query
        merge_result_id: ID of merge result if this is a merge_result.
        total: Total of the constituent Look, Query, or Merge Query
        query_id: ID of query if this is a query.
        query:
        vis_config: Vis config of the constituent Query, or Merge Query.
    """

    id: Optional[int] = None
    dynamic_fields: Optional[str] = None
    filterables: Optional[Sequence["ResultMakerFilterables"]] = None
    sorts: Optional[Sequence[str]] = None
    merge_result_id: Optional[str] = None
    total: Optional[bool] = None
    query_id: Optional[int] = None
    query: Optional["Query"] = None
    vis_config: Optional[MutableMapping[str, str]] = None


@attr.s(auto_attribs=True, kw_only=True)
class Role(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: Unique Id
        name: Name of Role
        permission_set:
        permission_set_id: (Write-Only) Id of permission set
        model_set:
        model_set_id: (Write-Only) Id of model set
        url: Link to get this item
        users_url: Link to get list of users with this role
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[int] = None
    name: Optional[str] = None
    permission_set: Optional["PermissionSet"] = None
    permission_set_id: Optional[int] = None
    model_set: Optional["ModelSet"] = None
    model_set_id: Optional[int] = None
    url: Optional[str] = None
    users_url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class RunningQueries(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: Unique Id
        user:
        query:
        sql_query:
        look:
        created_at: Date/Time Query was initiated
        completed_at: Date/Time Query was completed
        query_id: Query Id
        source: Source (look, dashboard, queryrunner, explore, etc.)
        node_id: Node Id
        slug: Slug
        query_task_id: ID of a Query Task
        cache_key: Cache Key
        connection_name: Connection
        dialect: Dialect
        connection_id: Connection ID
        message: Additional Information(Error message or verbose status)
        status: Status description
        runtime: Number of seconds elapsed running the Query
        sql: SQL text of the query as run
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[int] = None
    user: Optional["UserPublic"] = None
    query: Optional["Query"] = None
    sql_query: Optional["SqlQuery"] = None
    look: Optional["LookBasic"] = None
    created_at: Optional[str] = None
    completed_at: Optional[str] = None
    query_id: Optional[str] = None
    source: Optional[str] = None
    node_id: Optional[str] = None
    slug: Optional[str] = None
    query_task_id: Optional[str] = None
    cache_key: Optional[str] = None
    connection_name: Optional[str] = None
    dialect: Optional[str] = None
    connection_id: Optional[str] = None
    message: Optional[str] = None
    status: Optional[str] = None
    runtime: Optional[float] = None
    sql: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class SamlConfig(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        enabled: Enable/Disable Saml authentication for the server
        idp_cert: Identity Provider Certificate (provided by IdP)
        idp_url: Identity Provider Url (provided by IdP)
        idp_issuer: Identity Provider Issuer (provided by IdP)
        idp_audience: Identity Provider Audience (set in IdP config). Optional in Looker. Set this only if you want Looker to validate the audience value returned by the IdP.
        allowed_clock_drift: Count of seconds of clock drift to allow when validating timestamps of assertions.
        user_attribute_map_email: Name of user record attributes used to indicate email address field
        user_attribute_map_first_name: Name of user record attributes used to indicate first name
        user_attribute_map_last_name: Name of user record attributes used to indicate last name
        new_user_migration_types: Merge first-time saml login to existing user account by email addresses. When a user logs in for the first time via saml this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
        alternate_email_login_allowed: Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
        test_slug: Slug to identify configurations that are created in order to run a Saml config test
        modified_at: When this config was last modified
        modified_by: User id of user who last modified this config
        default_new_user_roles: (Read-only) Roles that will be applied to new users the first time they login via Saml
        default_new_user_groups: (Read-only) Groups that will be applied to new users the first time they login via Saml
        default_new_user_role_ids: (Write-Only) Array of ids of roles that will be applied to new users the first time they login via Saml
        default_new_user_group_ids: (Write-Only) Array of ids of groups that will be applied to new users the first time they login via Saml
        set_roles_from_groups: Set user roles in Looker based on groups from Saml
        groups_attribute: Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
        groups: (Read-only) Array of mappings between Saml Groups and Looker Roles
        groups_with_role_ids: (Read/Write) Array of mappings between Saml Groups and arrays of Looker Role ids
        auth_requires_role: Users will not be allowed to login at all unless a role for them is found in Saml if set to true
        user_attributes: (Read-only) Array of mappings between Saml User Attributes and Looker User Attributes
        user_attributes_with_ids: (Read/Write) Array of mappings between Saml User Attributes and arrays of Looker User Attribute ids
        groups_finder_type: Identifier for a strategy for how Looker will find groups in the SAML response. One of ['grouped_attribute_values', 'individual_attributes']
        groups_member_value: Value for group attribute used to indicate membership. Used when 'groups_finder_type' is set to 'individual_attributes'
        bypass_login_page: Bypass the login page when user authentication is required. Redirect to IdP immediately instead.
        url: Link to get this item
    """

    can: Optional[MutableMapping[str, bool]] = None
    enabled: Optional[bool] = None
    idp_cert: Optional[str] = None
    idp_url: Optional[str] = None
    idp_issuer: Optional[str] = None
    idp_audience: Optional[str] = None
    allowed_clock_drift: Optional[int] = None
    user_attribute_map_email: Optional[str] = None
    user_attribute_map_first_name: Optional[str] = None
    user_attribute_map_last_name: Optional[str] = None
    new_user_migration_types: Optional[str] = None
    alternate_email_login_allowed: Optional[bool] = None
    test_slug: Optional[str] = None
    modified_at: Optional[str] = None
    modified_by: Optional[str] = None
    default_new_user_roles: Optional[Sequence["Role"]] = None
    default_new_user_groups: Optional[Sequence["Group"]] = None
    default_new_user_role_ids: Optional[Sequence[int]] = None
    default_new_user_group_ids: Optional[Sequence[int]] = None
    set_roles_from_groups: Optional[bool] = None
    groups_attribute: Optional[str] = None
    groups: Optional[Sequence["SamlGroupRead"]] = None
    groups_with_role_ids: Optional[Sequence["SamlGroupWrite"]] = None
    auth_requires_role: Optional[bool] = None
    user_attributes: Optional[Sequence["SamlUserAttributeRead"]] = None
    user_attributes_with_ids: Optional[Sequence["SamlUserAttributeWrite"]] = None
    groups_finder_type: Optional[str] = None
    groups_member_value: Optional[str] = None
    bypass_login_page: Optional[bool] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class SamlGroupRead(model.Model):
    """
    Attributes:
        name: Name of group in Saml
        roles: Looker Roles
        url: Link to saml config
    """

    name: Optional[str] = None
    roles: Optional[Sequence["Role"]] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class SamlGroupWrite(model.Model):
    """
    Attributes:
        name: Name of group in Saml
        role_ids: Looker Role Ids
        url: Link to saml config
    """

    name: Optional[str] = None
    role_ids: Optional[Sequence[int]] = None
    url: Optional[str] = None

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        role_ids: Optional[Sequence[int]] = None,
        url: Optional[str] = None
    ):
        self.name = name
        self.role_ids = role_ids
        self.url = url


@attr.s(auto_attribs=True, kw_only=True)
class SamlMetadataParseResult(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        idp_issuer: Identify Provider Issuer
        idp_url: Identify Provider Url
        idp_cert: Identify Provider Certificate
    """

    can: Optional[MutableMapping[str, bool]] = None
    idp_issuer: Optional[str] = None
    idp_url: Optional[str] = None
    idp_cert: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class SamlUserAttributeRead(model.Model):
    """
    Attributes:
        name: Name of User Attribute in Saml
        required: Required to be in Saml assertion for login to be allowed to succeed
        user_attributes: Looker User Attributes
        url: Link to saml config
    """

    name: Optional[str] = None
    required: Optional[bool] = None
    user_attributes: Optional[Sequence["UserAttribute"]] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class SamlUserAttributeWrite(model.Model):
    """
    Attributes:
        name: Name of User Attribute in Saml
        required: Required to be in Saml assertion for login to be allowed to succeed
        user_attribute_ids: Looker User Attribute Ids
        url: Link to saml config
    """

    name: Optional[str] = None
    required: Optional[bool] = None
    user_attribute_ids: Optional[Sequence[int]] = None
    url: Optional[str] = None

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        required: Optional[bool] = None,
        user_attribute_ids: Optional[Sequence[int]] = None,
        url: Optional[str] = None
    ):
        self.name = name
        self.required = required
        self.user_attribute_ids = user_attribute_ids
        self.url = url


@attr.s(auto_attribs=True, kw_only=True)
class ScheduledPlan(model.Model):
    """
    Attributes:
        name: Name of this scheduled plan
        user_id: User Id which owns this scheduled plan
        run_as_recipient: Whether schedule is run as recipient (only applicable for email recipients)
        enabled: Whether the ScheduledPlan is enabled
        look_id: Id of a look
        dashboard_id: Id of a dashboard
        lookml_dashboard_id: Id of a LookML dashboard
        filters_string: Query string to run look or dashboard with
        dashboard_filters: (DEPRECATED) Alias for filters_string field
        require_results: Delivery should occur if running the dashboard or look returns results
        require_no_results: Delivery should occur if the dashboard look does not return results
        require_change: Delivery should occur if data have changed since the last run
        send_all_results: Will run an unlimited query and send all results.
        crontab: Vixie-Style crontab specification when to run
        datagroup: Name of a datagroup; if specified will run when datagroup triggered (can't be used with cron string)
        timezone: Timezone for interpreting the specified crontab (default is Looker instance timezone)
        query_id: Query id
        scheduled_plan_destination: Scheduled plan destinations
        run_once: Whether the plan in question should only be run once (usually for testing)
        include_links: Whether links back to Looker should be included in this ScheduledPlan
        pdf_paper_size: The size of paper a PDF should be rendered for
        pdf_landscape: Whether the paper should be landscape
        embed: Whether this schedule is in an embed context or not
        color_theme: Color scheme of the dashboard if applicable
        long_tables: Whether or not to expand table vis to full length
        id: Unique Id
        created_at: Date and time when ScheduledPlan was created
        updated_at: Date and time when ScheduledPlan was last updated
        title: Title
        user:
        next_run_at: When the ScheduledPlan will next run (null if running once)
        last_run_at: When the ScheduledPlan was last run
        can: Operations the current user is able to perform on this object
    """

    name: Optional[str] = None
    user_id: Optional[int] = None
    run_as_recipient: Optional[bool] = None
    enabled: Optional[bool] = None
    look_id: Optional[int] = None
    dashboard_id: Optional[int] = None
    lookml_dashboard_id: Optional[str] = None
    filters_string: Optional[str] = None
    dashboard_filters: Optional[str] = None
    require_results: Optional[bool] = None
    require_no_results: Optional[bool] = None
    require_change: Optional[bool] = None
    send_all_results: Optional[bool] = None
    crontab: Optional[str] = None
    datagroup: Optional[str] = None
    timezone: Optional[str] = None
    query_id: Optional[str] = None
    scheduled_plan_destination: Optional[Sequence["ScheduledPlanDestination"]] = None
    run_once: Optional[bool] = None
    include_links: Optional[bool] = None
    pdf_paper_size: Optional[str] = None
    pdf_landscape: Optional[bool] = None
    embed: Optional[bool] = None
    color_theme: Optional[str] = None
    long_tables: Optional[bool] = None
    id: Optional[int] = None
    created_at: Optional[datetime.datetime] = None
    updated_at: Optional[datetime.datetime] = None
    title: Optional[str] = None
    user: Optional["UserPublic"] = None
    next_run_at: Optional[datetime.datetime] = None
    last_run_at: Optional[datetime.datetime] = None
    can: Optional[MutableMapping[str, bool]] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class ScheduledPlanDestination(model.Model):
    """
    Attributes:
        id: Unique Id
        scheduled_plan_id: Id of a scheduled plan you own
        format: The data format to send to the given destination. Supported formats vary by destination, but include: "txt", "csv", "inline_json", "json", "json_detail", "xlsx", "html", "wysiwyg_pdf", "assembled_pdf", "wysiwyg_png"
        apply_formatting: Are values formatted? (containing currency symbols, digit separators, etc.
        apply_vis: Whether visualization options are applied to the results.
        address: Address for recipient. For email e.g. 'user@example.com'. For webhooks e.g. 'https://domain/path'. For Amazon S3 e.g. 's3://bucket-name/path/'. For SFTP e.g. 'sftp://host-name/path/'. 
        looker_recipient: Whether the recipient is a Looker user on the current instance (only applicable for email recipients)
        type: Type of the address ('email', 'webhook', 's3', or 'sftp')
        parameters: JSON object containing parameters for external scheduling. For Amazon S3, this requires keys and values for access_key_id and region. For SFTP, this requires a key and value for username.
        secret_parameters: (Write-Only) JSON object containing secret parameters for external scheduling. For Amazon S3, this requires a key and value for secret_access_key. For SFTP, this requires a key and value for password.
        message: Optional message to be included in scheduled emails
    """

    id: Optional[int] = None
    scheduled_plan_id: Optional[int] = None
    format: Optional[str] = None
    apply_formatting: Optional[bool] = None
    apply_vis: Optional[bool] = None
    address: Optional[str] = None
    looker_recipient: Optional[bool] = None
    type: Optional[str] = None
    parameters: Optional[str] = None
    secret_parameters: Optional[str] = None
    message: Optional[str] = None

    def __init__(
        self,
        *,
        id: Optional[int] = None,
        scheduled_plan_id: Optional[int] = None,
        format: Optional[str] = None,
        apply_formatting: Optional[bool] = None,
        apply_vis: Optional[bool] = None,
        address: Optional[str] = None,
        looker_recipient: Optional[bool] = None,
        type: Optional[str] = None,
        parameters: Optional[str] = None,
        secret_parameters: Optional[str] = None,
        message: Optional[str] = None
    ):
        self.id = id
        self.scheduled_plan_id = scheduled_plan_id
        self.format = format
        self.apply_formatting = apply_formatting
        self.apply_vis = apply_vis
        self.address = address
        self.looker_recipient = looker_recipient
        self.type = type
        self.parameters = parameters
        self.secret_parameters = secret_parameters
        self.message = message


@attr.s(auto_attribs=True, kw_only=True)
class Session(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: Unique Id
        ip_address: IP address of user when this session was initiated
        browser: User's browser type
        operating_system: User's Operating System
        city: City component of user location (derived from IP address)
        state: State component of user location (derived from IP address)
        country: Country component of user location (derived from IP address)
        credentials_type: Type of credentials used for logging in this session
        extended_at: Time when this session was last extended by the user
        extended_count: Number of times this session was extended
        sudo_user_id: Actual user in the case when this session represents one user sudo'ing as another
        created_at: Time when this session was initiated
        expires_at: Time when this session will expire
        url: Link to get this item
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[int] = None
    ip_address: Optional[str] = None
    browser: Optional[str] = None
    operating_system: Optional[str] = None
    city: Optional[str] = None
    state: Optional[str] = None
    country: Optional[str] = None
    credentials_type: Optional[str] = None
    extended_at: Optional[str] = None
    extended_count: Optional[int] = None
    sudo_user_id: Optional[int] = None
    created_at: Optional[str] = None
    expires_at: Optional[str] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class SessionConfig(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        allow_persistent_sessions: Allow users to have persistent sessions when they login
        session_minutes: Number of minutes for user sessions.  Must be between 5 and 43200
        unlimited_sessions_per_user: Allow users to have an unbounded number of concurrent sessions (otherwise, users will be limited to only one session at a time).
        use_inactivity_based_logout: Enforce session logout for sessions that are inactive for 15 minutes.
        track_session_location: Track location of session when user logs in.
    """

    can: Optional[MutableMapping[str, bool]] = None
    allow_persistent_sessions: Optional[bool] = None
    session_minutes: Optional[int] = None
    unlimited_sessions_per_user: Optional[bool] = None
    use_inactivity_based_logout: Optional[bool] = None
    track_session_location: Optional[bool] = None


@attr.s(auto_attribs=True, kw_only=True)
class Snippet(model.Model):
    """
    Attributes:
        name: Name of the snippet
        label: Label of the snippet
        sql: SQL text of the snippet
        can: Operations the current user is able to perform on this object
    """

    name: Optional[str] = None
    label: Optional[str] = None
    sql: Optional[str] = None
    can: Optional[MutableMapping[str, bool]] = None


@attr.s(auto_attribs=True, kw_only=True)
class Space(model.Model):
    """
    Attributes:
        name: Unique Name
        parent_id: Id of Parent. If the parent id is null, this is a root-level entry
        id: Unique Id
        content_metadata_id: Id of content metadata
        created_at: Time the space was created
        creator_id: User Id of Creator
        child_count: Children Count
        external_id: Embedder's Id if this space was autogenerated as an embedding shared space via 'external_group_id' in an SSO embed login
        is_embed: Space is an embed space
        is_embed_shared_root: Space is the root embed shared space
        is_embed_users_root: Space is the root embed users space
        is_personal: Space is a user's personal space
        is_personal_descendant: Space is descendant of a user's personal space
        is_shared_root: Space is the root shared space
        is_users_root: Space is the root user space
        can: Operations the current user is able to perform on this object
        dashboards: Dashboards
        looks: Looks
    """

    name: str
    parent_id: Optional[str] = None
    id: Optional[str] = None
    content_metadata_id: Optional[int] = None
    created_at: Optional[datetime.datetime] = None
    creator_id: Optional[int] = None
    child_count: Optional[int] = None
    external_id: Optional[str] = None
    is_embed: Optional[bool] = None
    is_embed_shared_root: Optional[bool] = None
    is_embed_users_root: Optional[bool] = None
    is_personal: Optional[bool] = None
    is_personal_descendant: Optional[bool] = None
    is_shared_root: Optional[bool] = None
    is_users_root: Optional[bool] = None
    can: Optional[MutableMapping[str, bool]] = None
    dashboards: Optional[Sequence["DashboardBase"]] = None
    looks: Optional[Sequence["LookWithDashboards"]] = None


@attr.s(auto_attribs=True, kw_only=True)
class SpaceBase(model.Model):
    """
    Attributes:
        name: Unique Name
        parent_id: Id of Parent. If the parent id is null, this is a root-level entry
        id: Unique Id
        content_metadata_id: Id of content metadata
        created_at: Time the space was created
        creator_id: User Id of Creator
        child_count: Children Count
        external_id: Embedder's Id if this space was autogenerated as an embedding shared space via 'external_group_id' in an SSO embed login
        is_embed: Space is an embed space
        is_embed_shared_root: Space is the root embed shared space
        is_embed_users_root: Space is the root embed users space
        is_personal: Space is a user's personal space
        is_personal_descendant: Space is descendant of a user's personal space
        is_shared_root: Space is the root shared space
        is_users_root: Space is the root user space
        can: Operations the current user is able to perform on this object
    """

    name: str
    parent_id: Optional[str] = None
    id: Optional[str] = None
    content_metadata_id: Optional[int] = None
    created_at: Optional[datetime.datetime] = None
    creator_id: Optional[int] = None
    child_count: Optional[int] = None
    external_id: Optional[str] = None
    is_embed: Optional[bool] = None
    is_embed_shared_root: Optional[bool] = None
    is_embed_users_root: Optional[bool] = None
    is_personal: Optional[bool] = None
    is_personal_descendant: Optional[bool] = None
    is_shared_root: Optional[bool] = None
    is_users_root: Optional[bool] = None
    can: Optional[MutableMapping[str, bool]] = None


@attr.s(auto_attribs=True, kw_only=True)
class SqlQuery(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        slug: The identifier of the SQL query
        last_runtime: Number of seconds this query took to run the most recent time it was run
        run_count: Number of times this query has been run
        browser_limit: Maximum number of rows this query will display on the SQL Runner page
        sql: SQL query text
        last_run_at: The most recent time this query was run
        connection:
        model_name: Model name this query uses
        creator:
        explore_url: Explore page URL for this SQL query
        plaintext: Should this query be rendered as plain text
        vis_config: Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
    """

    can: Optional[MutableMapping[str, bool]] = None
    slug: Optional[str] = None
    last_runtime: Optional[float] = None
    run_count: Optional[int] = None
    browser_limit: Optional[int] = None
    sql: Optional[str] = None
    last_run_at: Optional[str] = None
    connection: Optional["DBConnectionBase"] = None
    model_name: Optional[str] = None
    creator: Optional["UserPublic"] = None
    explore_url: Optional[str] = None
    plaintext: Optional[bool] = None
    vis_config: Optional[MutableMapping[str, str]] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class SqlQueryCreate(model.Model):
    """
    Attributes:
        connection_name: Name of the db connection on which to run this query
        connection_id: (DEPRECATED) Use `connection_name` instead
        model_name: Name of LookML Model (this or `connection_id` required)
        sql: SQL query
        vis_config: Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
    """

    connection_name: Optional[str] = None
    connection_id: Optional[str] = None
    model_name: Optional[str] = None
    sql: Optional[str] = None
    vis_config: Optional[MutableMapping[str, str]] = None

    def __init__(
        self,
        *,
        connection_name: Optional[str] = None,
        connection_id: Optional[str] = None,
        model_name: Optional[str] = None,
        sql: Optional[str] = None,
        vis_config: Optional[MutableMapping[str, str]] = None
    ):
        self.connection_name = connection_name
        self.connection_id = connection_id
        self.model_name = model_name
        self.sql = sql
        self.vis_config = vis_config


@attr.s(auto_attribs=True, kw_only=True)
class Theme(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        begin_at: Timestamp for when this theme becomes active. Null=always
        end_at: Timestamp for when this theme expires. Null=never
        id: Unique Id
        name: Name of theme. Can only be alphanumeric and underscores.
        settings:
    """

    can: Optional[MutableMapping[str, bool]] = None
    begin_at: Optional[datetime.datetime] = None
    end_at: Optional[datetime.datetime] = None
    id: Optional[int] = None
    name: Optional[str] = None
    settings: Optional["ThemeSettings"] = None


@attr.s(auto_attribs=True, kw_only=True)
class ThemeSettings(model.Model):
    """
    Attributes:
        background_color: Default background color
        base_font_size: Base font size for scaling fonts
        color_collection_id: Optional. ID of color collection to use with the theme. Use an empty string for none.
        font_color: Default font color
        font_family: Primary font family
        font_source: Source specification for font
        info_button_color: Info button color
        primary_button_color: Primary button color
        show_filters_bar: Toggle to show filters. Defaults to true.
        show_title: Toggle to show the title. Defaults to true.
        text_tile_text_color: Text color for text tiles
        tile_background_color: Background color for tiles
        tile_text_color: Text color for tiles
        title_color: Color for titles
        warn_button_color: Warning button color
    """

    background_color: Optional[str] = None
    base_font_size: Optional[str] = None
    color_collection_id: Optional[str] = None
    font_color: Optional[str] = None
    font_family: Optional[str] = None
    font_source: Optional[str] = None
    info_button_color: Optional[str] = None
    primary_button_color: Optional[str] = None
    show_filters_bar: Optional[bool] = None
    show_title: Optional[bool] = None
    text_tile_text_color: Optional[str] = None
    tile_background_color: Optional[str] = None
    tile_text_color: Optional[str] = None
    title_color: Optional[str] = None
    warn_button_color: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class Timezone(model.Model):
    """
    Attributes:
        value: Timezone
        label: Description of timezone
        group: Timezone group (e.g Common, Other, etc.)
    """

    value: Optional[str] = None
    label: Optional[str] = None
    group: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class UpdateFolder(model.Model):
    """
    Attributes:
        name: Unique Name
        parent_id: Id of Parent. If the parent id is null, this is a root-level entry
    """

    name: Optional[str] = None
    parent_id: Optional[str] = None

    def __init__(self, *, name: Optional[str] = None, parent_id: Optional[str] = None):
        self.name = name
        self.parent_id = parent_id


@attr.s(auto_attribs=True, kw_only=True, init=False)
class UpdateSpace(model.Model):
    """
    Attributes:
        name: Unique Name
        parent_id: Id of Parent. If the parent id is null, this is a root-level entry
    """

    name: Optional[str] = None
    parent_id: Optional[str] = None

    def __init__(self, *, name: Optional[str] = None, parent_id: Optional[str] = None):
        self.name = name
        self.parent_id = parent_id


@attr.s(auto_attribs=True, kw_only=True)
class User(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        avatar_url: URL for the avatar image (may be generic)
        avatar_url_without_sizing: URL for the avatar image (may be generic), does not specify size
        credentials_api3: API 3 credentials
        credentials_email:
        credentials_embed: Embed credentials
        credentials_google:
        credentials_ldap:
        credentials_looker_openid:
        credentials_oidc:
        credentials_saml:
        credentials_totp:
        display_name: Full name for display (available only if both first_name and last_name are set)
        email: EMail address
        embed_group_space_id: (Embed only) ID of user's group space based on the external_group_id optionally specified during embed user login
        first_name: First name
        group_ids: Array of ids of the groups for this user
        home_space_id: ID string for user's home space
        home_folder_id: ID string for user's home folder
        id: Unique Id
        is_disabled: Account has been disabled
        last_name: Last name
        locale: User's preferred locale. User locale takes precedence over Looker's system-wide default locale. Locale determines language of display strings and date and numeric formatting in API responses. Locale string must be a 2 letter language code or a combination of language code and region code: 'en' or 'en-US', for example.
        looker_versions: Array of strings representing the Looker versions that this user has used (this only goes back as far as '3.54.0')
        models_dir_validated: User's dev workspace has been checked for presence of applicable production projects
        personal_space_id: ID of user's personal space
        personal_folder_id: ID of user's personal folder
        presumed_looker_employee: User is identified as an employee of Looker
        role_ids: Array of ids of the roles for this user
        sessions: Active sessions
        ui_state: Per user dictionary of undocumented state information owned by the Looker UI.
        verified_looker_employee: User is identified as an employee of Looker who has been verified via Looker corporate authentication
        roles_externally_managed: User's roles are managed by an external directory like SAML or LDAP and can not be changed directly.
        url: Link to get this item
    """

    can: Optional[MutableMapping[str, bool]] = None
    avatar_url: Optional[str] = None
    avatar_url_without_sizing: Optional[str] = None
    credentials_api3: Optional[Sequence["CredentialsApi3"]] = None
    credentials_email: Optional["CredentialsEmail"] = None
    credentials_embed: Optional[Sequence["CredentialsEmbed"]] = None
    credentials_google: Optional["CredentialsGoogle"] = None
    credentials_ldap: Optional["CredentialsLDAP"] = None
    credentials_looker_openid: Optional["CredentialsLookerOpenid"] = None
    credentials_oidc: Optional["CredentialsOIDC"] = None
    credentials_saml: Optional["CredentialsSaml"] = None
    credentials_totp: Optional["CredentialsTotp"] = None
    display_name: Optional[str] = None
    email: Optional[str] = None
    embed_group_space_id: Optional[int] = None
    first_name: Optional[str] = None
    group_ids: Optional[Sequence[int]] = None
    home_space_id: Optional[str] = None
    home_folder_id: Optional[str] = None
    id: Optional[int] = None
    is_disabled: Optional[bool] = None
    last_name: Optional[str] = None
    locale: Optional[str] = None
    looker_versions: Optional[Sequence[str]] = None
    models_dir_validated: Optional[bool] = None
    personal_space_id: Optional[int] = None
    personal_folder_id: Optional[int] = None
    presumed_looker_employee: Optional[bool] = None
    role_ids: Optional[Sequence[int]] = None
    sessions: Optional[Sequence["Session"]] = None
    ui_state: Optional[MutableMapping[str, str]] = None
    verified_looker_employee: Optional[bool] = None
    roles_externally_managed: Optional[bool] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class UserAttribute(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: Unique Id
        name: Name of user attribute
        label: Human-friendly label for user attribute
        type: Type of user attribute ("string", "number", "datetime", "yesno", "zipcode")
        default_value: Default value for when no value is set on the user
        is_system: Attribute is a system default
        is_permanent: Attribute is permanent and cannot be deleted
        value_is_hidden: If true, users will not be able to view values of this attribute
        user_can_view: Non-admin users can see the values of their attributes and use them in filters
        user_can_edit: Users can change the value of this attribute for themselves
        hidden_value_domain_whitelist: Destinations to which a hidden attribute may be sent. Once set, cannot be edited.
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[int] = None
    name: Optional[str] = None
    label: Optional[str] = None
    type: Optional[str] = None
    default_value: Optional[str] = None
    is_system: Optional[bool] = None
    is_permanent: Optional[bool] = None
    value_is_hidden: Optional[bool] = None
    user_can_view: Optional[bool] = None
    user_can_edit: Optional[bool] = None
    hidden_value_domain_whitelist: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class UserAttributeGroupValue(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: Unique Id of this group-attribute relation
        group_id: Id of group
        user_attribute_id: Id of user attribute
        value_is_hidden: If true, the "value" field will be null, because the attribute settings block access to this value
        rank: Precedence for resolving value for user
        value: Value of user attribute for group
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[int] = None
    group_id: Optional[int] = None
    user_attribute_id: Optional[int] = None
    value_is_hidden: Optional[bool] = None
    rank: Optional[int] = None
    value: Optional[str] = None

    def __init__(
        self,
        *,
        can: Optional[MutableMapping[str, bool]] = None,
        id: Optional[int] = None,
        group_id: Optional[int] = None,
        user_attribute_id: Optional[int] = None,
        value_is_hidden: Optional[bool] = None,
        rank: Optional[int] = None,
        value: Optional[str] = None
    ):
        self.can = can
        self.id = id
        self.group_id = group_id
        self.user_attribute_id = user_attribute_id
        self.value_is_hidden = value_is_hidden
        self.rank = rank
        self.value = value


@attr.s(auto_attribs=True, kw_only=True)
class UserAttributeWithValue(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        name: Name of user attribute
        label: Human-friendly label for user attribute
        rank: Precedence for setting value on user (lowest wins)
        value: Value of attribute for user
        user_id: Id of User
        user_can_edit: Can the user set this value
        value_is_hidden: If true, the "value" field will be null, because the attribute settings block access to this value
        user_attribute_id: Id of User Attribute
        source: How user got this value for this attribute
        hidden_value_domain_whitelist: If this user attribute is hidden, whitelist of destinations to which it may be sent.
    """

    can: Optional[MutableMapping[str, bool]] = None
    name: Optional[str] = None
    label: Optional[str] = None
    rank: Optional[int] = None
    value: Optional[str] = None
    user_id: Optional[int] = None
    user_can_edit: Optional[bool] = None
    value_is_hidden: Optional[bool] = None
    user_attribute_id: Optional[int] = None
    source: Optional[str] = None
    hidden_value_domain_whitelist: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class UserIdOnly(model.Model):
    """
    Attributes:
        id: Unique Id
    """

    id: Optional[int] = None


@attr.s(auto_attribs=True, kw_only=True)
class UserLoginLockout(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        key: Hash of user's client id
        auth_type: Authentication method for login failures
        ip: IP address of most recent failed attempt
        user_id: User ID
        remote_id: Remote ID of user if using LDAP
        full_name: User's name
        email: Email address associated with the user's account
        fail_count: Number of failures that triggered the lockout
        lockout_at: Time when lockout was triggered
    """

    can: Optional[MutableMapping[str, bool]] = None
    key: Optional[str] = None
    auth_type: Optional[str] = None
    ip: Optional[str] = None
    user_id: Optional[int] = None
    remote_id: Optional[str] = None
    full_name: Optional[str] = None
    email: Optional[str] = None
    fail_count: Optional[int] = None
    lockout_at: Optional[datetime.datetime] = None


@attr.s(auto_attribs=True, kw_only=True)
class UserPublic(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: Unique Id
        first_name: First Name
        last_name: Last Name
        display_name: Full name for display (available only if both first_name and last_name are set)
        avatar_url: URL for the avatar image (may be generic)
        url: Link to get this item
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[int] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    display_name: Optional[str] = None
    avatar_url: Optional[str] = None
    url: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class ValidationError(model.Model):
    """
    Attributes:
        message: Error details
        errors: Error detail array
        documentation_url: Documentation link
    """

    message: str
    errors: Optional[Sequence["ValidationErrorDetail"]] = None
    documentation_url: str


@attr.s(auto_attribs=True, kw_only=True)
class ValidationErrorDetail(model.Model):
    """
    Attributes:
        field: Field with error
        code: Error code
        message: Error info message
        documentation_url: Documentation link
    """

    field: Optional[str] = None
    code: Optional[str] = None
    message: Optional[str] = None
    documentation_url: str


@attr.s(auto_attribs=True, kw_only=True)
class WelcomeEmailTest(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        content: The content that will be sent as part of a custom welcome email
    """

    can: Optional[MutableMapping[str, bool]] = None
    content: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class WhitelabelConfiguration(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: Unique Id
        logo_file: Customer logo image. Expected base64 encoded data (write-only)
        logo_url: Logo image url (read-only)
        favicon_file: Custom favicon image. Expected base64 encoded data (write-only)
        favicon_url: Favicon image url (read-only)
        default_title: Default page title
        show_help_menu: Boolean to toggle showing help menus
        show_docs: Boolean to toggle showing docs
        show_email_sub_options: Boolean to toggle showing email subscription options.
        allow_looker_mentions: Boolean to toggle mentions of Looker in emails
        allow_looker_links: Boolean to toggle links to Looker in emails
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[int] = None
    logo_file: Optional[str] = None
    logo_url: Optional[str] = None
    favicon_file: Optional[str] = None
    favicon_url: Optional[str] = None
    default_title: Optional[str] = None
    show_help_menu: Optional[bool] = None
    show_docs: Optional[bool] = None
    show_email_sub_options: Optional[bool] = None
    allow_looker_mentions: Optional[bool] = None
    allow_looker_links: Optional[bool] = None


@attr.s(auto_attribs=True, kw_only=True)
class Workspace(model.Model):
    """
    Attributes:
        can: Operations the current user is able to perform on this object
        id: The unique id of this user workspace. Predefined workspace ids include "production" and "dev"
        projects: The local state of each project in the workspace
    """

    can: Optional[MutableMapping[str, bool]] = None
    id: Optional[str] = None
    projects: Optional[Sequence["Project"]] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteApiSession(model.Model):
    """
    Dynamically generated writeable type for ApiSession

    Attributes:
        workspace_id: The id of active workspace for this session
    """

    workspace_id: Optional[str] = None

    def __init__(self, *, workspace_id: Optional[str] = None):
        self.workspace_id = workspace_id


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteBackupConfiguration(model.Model):
    """
    Dynamically generated writeable type for BackupConfiguration

    Attributes:
        type: Type of backup: looker-s3 or custom-s3
        custom_s3_bucket: Name of bucket for custom-s3 backups
        custom_s3_bucket_region: Name of region where the bucket is located
        custom_s3_key: (Write-Only) AWS S3 key used for custom-s3 backups
        custom_s3_secret: (Write-Only) AWS S3 secret used for custom-s3 backups
    """

    type: Optional[str] = None
    custom_s3_bucket: Optional[str] = None
    custom_s3_bucket_region: Optional[str] = None
    custom_s3_key: Optional[str] = None
    custom_s3_secret: Optional[str] = None

    def __init__(
        self,
        *,
        type: Optional[str] = None,
        custom_s3_bucket: Optional[str] = None,
        custom_s3_bucket_region: Optional[str] = None,
        custom_s3_key: Optional[str] = None,
        custom_s3_secret: Optional[str] = None
    ):
        self.type = type
        self.custom_s3_bucket = custom_s3_bucket
        self.custom_s3_bucket_region = custom_s3_bucket_region
        self.custom_s3_key = custom_s3_key
        self.custom_s3_secret = custom_s3_secret


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteColorCollection(model.Model):
    """
    Dynamically generated writeable type for ColorCollection

    Attributes:
        label: Label of color collection
        categoricalPalettes: Array of categorical palette definitions
        sequentialPalettes: Array of discrete palette definitions
        divergingPalettes: Array of diverging palette definitions
    """

    label: Optional[str] = None
    categoricalPalettes: Optional[Sequence["DiscretePalette"]] = None
    sequentialPalettes: Optional[Sequence["ContinuousPalette"]] = None
    divergingPalettes: Optional[Sequence["ContinuousPalette"]] = None

    def __init__(
        self,
        *,
        label: Optional[str] = None,
        categoricalPalettes: Optional[Sequence["DiscretePalette"]] = None,
        sequentialPalettes: Optional[Sequence["ContinuousPalette"]] = None,
        divergingPalettes: Optional[Sequence["ContinuousPalette"]] = None
    ):
        self.label = label
        self.categoricalPalettes = categoricalPalettes
        self.sequentialPalettes = sequentialPalettes
        self.divergingPalettes = divergingPalettes


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteContentFavorite(model.Model):
    """
    Dynamically generated writeable type for ContentFavorite

    Attributes:
        user_id: User Id which owns this ContentFavorite
        content_metadata_id: Content Metadata Id associated with this ContentFavorite
        dashboard:
    """

    user_id: Optional[int] = None
    content_metadata_id: Optional[int] = None
    dashboard: Optional["WriteDashboardBase"] = None

    def __init__(
        self,
        *,
        user_id: Optional[int] = None,
        content_metadata_id: Optional[int] = None,
        dashboard: Optional["WriteDashboardBase"] = None
    ):
        self.user_id = user_id
        self.content_metadata_id = content_metadata_id
        self.dashboard = dashboard


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteContentMeta(model.Model):
    """
    Dynamically generated writeable type for ContentMeta

    Attributes:
        inherits: Whether content inherits its access levels from parent
    """

    inherits: Optional[bool] = None

    def __init__(self, *, inherits: Optional[bool] = None):
        self.inherits = inherits


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteCreateDashboardFilter(model.Model):
    """
    Dynamically generated writeable type for CreateDashboardFilter

    Attributes:
        dashboard_id: Id of Dashboard
        name: Name of filter
        title: Title of filter
        type: Type of filter: one of date, number, string, or field
        default_value: Default value of filter
        model: Model of filter (required if type = field)
        explore: Explore of filter (required if type = field)
        dimension: Dimension of filter (required if type = field)
        row: Display order of this filter relative to other filters
        listens_to_filters: Array of listeners for faceted filters
        allow_multiple_values: Whether the filter allows multiple filter values
        required: Whether the filter requires a value to run the dashboard
        ui_config: The visual configuration for this filter. Used to set up how the UI for this filter should appear.
    """

    dashboard_id: str
    name: str
    title: str
    type: str
    default_value: Optional[str] = None
    model: Optional[str] = None
    explore: Optional[str] = None
    dimension: Optional[str] = None
    row: Optional[int] = None
    listens_to_filters: Optional[Sequence[str]] = None
    allow_multiple_values: Optional[bool] = None
    required: Optional[bool] = None
    ui_config: Optional[MutableMapping[str, str]] = None

    def __init__(
        self,
        *,
        dashboard_id: str,
        name: str,
        title: str,
        type: str,
        default_value: Optional[str] = None,
        model: Optional[str] = None,
        explore: Optional[str] = None,
        dimension: Optional[str] = None,
        row: Optional[int] = None,
        listens_to_filters: Optional[Sequence[str]] = None,
        allow_multiple_values: Optional[bool] = None,
        required: Optional[bool] = None,
        ui_config: Optional[MutableMapping[str, str]] = None
    ):
        self.dashboard_id = dashboard_id
        self.name = name
        self.title = title
        self.type = type
        self.default_value = default_value
        self.model = model
        self.explore = explore
        self.dimension = dimension
        self.row = row
        self.listens_to_filters = listens_to_filters
        self.allow_multiple_values = allow_multiple_values
        self.required = required
        self.ui_config = ui_config


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteCreateQueryTask(model.Model):
    """
    Dynamically generated writeable type for CreateQueryTask

    Attributes:
        query_id: Id of query to run
        result_format: Desired async query result format. Valid values are: "json", "json_detail", "json_fe", "csv", "html", "md", "txt", "xlsx", "gsxml".
        source: Source of query task
        deferred: Create the task but defer execution
        look_id: Id of look associated with query.
        dashboard_id: Id of dashboard associated with query.
    """

    query_id: int
    result_format: str
    source: Optional[str] = None
    deferred: Optional[bool] = None
    look_id: Optional[int] = None
    dashboard_id: Optional[str] = None

    def __init__(
        self,
        *,
        query_id: int,
        result_format: str,
        source: Optional[str] = None,
        deferred: Optional[bool] = None,
        look_id: Optional[int] = None,
        dashboard_id: Optional[str] = None
    ):
        self.query_id = query_id
        self.result_format = result_format
        self.source = source
        self.deferred = deferred
        self.look_id = look_id
        self.dashboard_id = dashboard_id


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteCredentialsEmail(model.Model):
    """
    Dynamically generated writeable type for CredentialsEmail

    Attributes:
        email: EMail address used for user login
        forced_password_reset_at_next_login: Force the user to change their password upon their next login
    """

    email: Optional[str] = None
    forced_password_reset_at_next_login: Optional[bool] = None

    def __init__(
        self,
        *,
        email: Optional[str] = None,
        forced_password_reset_at_next_login: Optional[bool] = None
    ):
        self.email = email
        self.forced_password_reset_at_next_login = forced_password_reset_at_next_login


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteCustomWelcomeEmail(model.Model):
    """
    Dynamically generated writeable type for CustomWelcomeEmail

    Attributes:
        enabled: If true, custom email content will replace the default body of welcome emails
        content: The HTML to use as custom content for welcome emails. Script elements and other potentially dangerous markup will be removed.
    """

    enabled: Optional[bool] = None
    content: Optional[str] = None

    def __init__(
        self, *, enabled: Optional[bool] = None, content: Optional[str] = None
    ):
        self.enabled = enabled
        self.content = content


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteDashboard(model.Model):
    """
    Dynamically generated writeable type for Dashboard

    Attributes:
        description: Description
        hidden: Is Hidden
        query_timezone: Timezone in which the Dashboard will run by default.
        refresh_interval: Refresh Interval, as a time duration phrase like "2 hours 30 minutes". A number with no time units will be interpreted as whole seconds.
        space:
        folder:
        title: Dashboard Title
        background_color: Background color
        deleted: Whether or not a dashboard is 'soft' deleted.
        load_configuration: configuration option that governs how dashboard loading will happen.
        lookml_link_id: Links this dashboard to a particular LookML dashboard such that calling a **sync** operation on that LookML dashboard will update this dashboard to match.
        show_filters_bar: Show filters bar.  **Security Note:** This property only affects the *cosmetic* appearance of the dashboard, not a user's ability to access data. Hiding the filters bar does **NOT** prevent users from changing filters by other means. For information on how to set up secure data access control policies, see [Control User Access to Data](https://looker.com/docs/r/api/control-access)
        show_title: Show title
        slug: Content Metadata Slug
        space_id: Id of Space
        folder_id: Id of folder
        text_tile_text_color: Color of text on text tiles
        tile_background_color: Tile background color
        tile_text_color: Tile text color
        title_color: Title color
        settings:
        preferred_viewer: The preferred route for viewing this dashboard (ie: dashboards or dashboards-next)
    """

    description: Optional[str] = None
    hidden: Optional[bool] = None
    query_timezone: Optional[str] = None
    refresh_interval: Optional[str] = None
    space: Optional["WriteSpaceBase"] = None
    folder: Optional["WriteFolderBase"] = None
    title: Optional[str] = None
    background_color: Optional[str] = None
    deleted: Optional[bool] = None
    load_configuration: Optional[str] = None
    lookml_link_id: Optional[str] = None
    show_filters_bar: Optional[bool] = None
    show_title: Optional[bool] = None
    slug: Optional[str] = None
    space_id: Optional[str] = None
    folder_id: Optional[str] = None
    text_tile_text_color: Optional[str] = None
    tile_background_color: Optional[str] = None
    tile_text_color: Optional[str] = None
    title_color: Optional[str] = None
    settings: Optional["DashboardSettings"] = None
    preferred_viewer: Optional[str] = None

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        hidden: Optional[bool] = None,
        query_timezone: Optional[str] = None,
        refresh_interval: Optional[str] = None,
        space: Optional["WriteSpaceBase"] = None,
        folder: Optional["WriteFolderBase"] = None,
        title: Optional[str] = None,
        background_color: Optional[str] = None,
        deleted: Optional[bool] = None,
        load_configuration: Optional[str] = None,
        lookml_link_id: Optional[str] = None,
        show_filters_bar: Optional[bool] = None,
        show_title: Optional[bool] = None,
        slug: Optional[str] = None,
        space_id: Optional[str] = None,
        folder_id: Optional[str] = None,
        text_tile_text_color: Optional[str] = None,
        tile_background_color: Optional[str] = None,
        tile_text_color: Optional[str] = None,
        title_color: Optional[str] = None,
        settings: Optional["DashboardSettings"] = None,
        preferred_viewer: Optional[str] = None
    ):
        self.description = description
        self.hidden = hidden
        self.query_timezone = query_timezone
        self.refresh_interval = refresh_interval
        self.space = space
        self.folder = folder
        self.title = title
        self.background_color = background_color
        self.deleted = deleted
        self.load_configuration = load_configuration
        self.lookml_link_id = lookml_link_id
        self.show_filters_bar = show_filters_bar
        self.show_title = show_title
        self.slug = slug
        self.space_id = space_id
        self.folder_id = folder_id
        self.text_tile_text_color = text_tile_text_color
        self.tile_background_color = tile_background_color
        self.tile_text_color = tile_text_color
        self.title_color = title_color
        self.settings = settings
        self.preferred_viewer = preferred_viewer


@attr.s(auto_attribs=True, kw_only=True)
class WriteDashboardBase(model.Model):
    """
    Dynamically generated writeable type for DashboardBase

    Attributes:
        space:
        folder:
    """

    space: Optional["WriteSpaceBase"] = None
    folder: Optional["WriteFolderBase"] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteDashboardElement(model.Model):
    """
    Dynamically generated writeable type for DashboardElement

    Attributes:
        body_text: Text tile body text
        dashboard_id: Id of Dashboard
        look:
        look_id: Id Of Look
        merge_result_id: ID of merge result
        note_display: Note Display
        note_state: Note State
        note_text: Note Text
        query:
        query_id: Id Of Query
        refresh_interval: Refresh Interval
        result_maker:
        subtitle_text: Text tile subtitle text
        title: Title of dashboard element
        title_hidden: Whether title is hidden
        title_text: Text tile title
        type: Type
    """

    body_text: Optional[str] = None
    dashboard_id: Optional[str] = None
    look: Optional["WriteLookWithQuery"] = None
    look_id: Optional[str] = None
    merge_result_id: Optional[str] = None
    note_display: Optional[str] = None
    note_state: Optional[str] = None
    note_text: Optional[str] = None
    query: Optional["WriteQuery"] = None
    query_id: Optional[int] = None
    refresh_interval: Optional[str] = None
    result_maker: Optional["WriteResultMakerWithIdVisConfigAndDynamicFields"] = None
    subtitle_text: Optional[str] = None
    title: Optional[str] = None
    title_hidden: Optional[bool] = None
    title_text: Optional[str] = None
    type: Optional[str] = None

    def __init__(
        self,
        *,
        body_text: Optional[str] = None,
        dashboard_id: Optional[str] = None,
        look: Optional["WriteLookWithQuery"] = None,
        look_id: Optional[str] = None,
        merge_result_id: Optional[str] = None,
        note_display: Optional[str] = None,
        note_state: Optional[str] = None,
        note_text: Optional[str] = None,
        query: Optional["WriteQuery"] = None,
        query_id: Optional[int] = None,
        refresh_interval: Optional[str] = None,
        result_maker: Optional[
            "WriteResultMakerWithIdVisConfigAndDynamicFields"
        ] = None,
        subtitle_text: Optional[str] = None,
        title: Optional[str] = None,
        title_hidden: Optional[bool] = None,
        title_text: Optional[str] = None,
        type: Optional[str] = None
    ):
        self.body_text = body_text
        self.dashboard_id = dashboard_id
        self.look = look
        self.look_id = look_id
        self.merge_result_id = merge_result_id
        self.note_display = note_display
        self.note_state = note_state
        self.note_text = note_text
        self.query = query
        self.query_id = query_id
        self.refresh_interval = refresh_interval
        self.result_maker = result_maker
        self.subtitle_text = subtitle_text
        self.title = title
        self.title_hidden = title_hidden
        self.title_text = title_text
        self.type = type


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteDashboardFilter(model.Model):
    """
    Dynamically generated writeable type for DashboardFilter

    Attributes:
        name: Name of filter
        title: Title of filter
        type: Type of filter: one of date, number, string, or field
        default_value: Default value of filter
        model: Model of filter (required if type = field)
        explore: Explore of filter (required if type = field)
        dimension: Dimension of filter (required if type = field)
        row: Display order of this filter relative to other filters
        listens_to_filters: Array of listeners for faceted filters
        allow_multiple_values: Whether the filter allows multiple filter values
        required: Whether the filter requires a value to run the dashboard
        ui_config: The visual configuration for this filter. Used to set up how the UI for this filter should appear.
    """

    name: Optional[str] = None
    title: Optional[str] = None
    type: Optional[str] = None
    default_value: Optional[str] = None
    model: Optional[str] = None
    explore: Optional[str] = None
    dimension: Optional[str] = None
    row: Optional[int] = None
    listens_to_filters: Optional[Sequence[str]] = None
    allow_multiple_values: Optional[bool] = None
    required: Optional[bool] = None
    ui_config: Optional[MutableMapping[str, str]] = None

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        title: Optional[str] = None,
        type: Optional[str] = None,
        default_value: Optional[str] = None,
        model: Optional[str] = None,
        explore: Optional[str] = None,
        dimension: Optional[str] = None,
        row: Optional[int] = None,
        listens_to_filters: Optional[Sequence[str]] = None,
        allow_multiple_values: Optional[bool] = None,
        required: Optional[bool] = None,
        ui_config: Optional[MutableMapping[str, str]] = None
    ):
        self.name = name
        self.title = title
        self.type = type
        self.default_value = default_value
        self.model = model
        self.explore = explore
        self.dimension = dimension
        self.row = row
        self.listens_to_filters = listens_to_filters
        self.allow_multiple_values = allow_multiple_values
        self.required = required
        self.ui_config = ui_config


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteDashboardLayout(model.Model):
    """
    Dynamically generated writeable type for DashboardLayout

    Attributes:
        dashboard_id: Id of Dashboard
        type: Type
        active: Is Active
        column_width: Column Width
        width: Width
    """

    dashboard_id: Optional[str] = None
    type: Optional[str] = None
    active: Optional[bool] = None
    column_width: Optional[int] = None
    width: Optional[int] = None

    def __init__(
        self,
        *,
        dashboard_id: Optional[str] = None,
        type: Optional[str] = None,
        active: Optional[bool] = None,
        column_width: Optional[int] = None,
        width: Optional[int] = None
    ):
        self.dashboard_id = dashboard_id
        self.type = type
        self.active = active
        self.column_width = column_width
        self.width = width


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteDashboardLayoutComponent(model.Model):
    """
    Dynamically generated writeable type for DashboardLayoutComponent

    Attributes:
        dashboard_layout_id: Id of Dashboard Layout
        dashboard_element_id: Id Of Dashboard Element
        row: Row
        column: Column
        width: Width
        height: Height
    """

    dashboard_layout_id: Optional[str] = None
    dashboard_element_id: Optional[str] = None
    row: Optional[int] = None
    column: Optional[int] = None
    width: Optional[int] = None
    height: Optional[int] = None

    def __init__(
        self,
        *,
        dashboard_layout_id: Optional[str] = None,
        dashboard_element_id: Optional[str] = None,
        row: Optional[int] = None,
        column: Optional[int] = None,
        width: Optional[int] = None,
        height: Optional[int] = None
    ):
        self.dashboard_layout_id = dashboard_layout_id
        self.dashboard_element_id = dashboard_element_id
        self.row = row
        self.column = column
        self.width = width
        self.height = height


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteDatagroup(model.Model):
    """
    Dynamically generated writeable type for Datagroup

    Attributes:
        stale_before: UNIX timestamp before which cache entries are considered stale. Cannot be in the future.
        triggered_at: UNIX timestamp at which this entry became triggered. Cannot be in the future.
    """

    stale_before: Optional[int] = None
    triggered_at: Optional[int] = None

    def __init__(
        self, *, stale_before: Optional[int] = None, triggered_at: Optional[int] = None
    ):
        self.stale_before = stale_before
        self.triggered_at = triggered_at


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteDBConnection(model.Model):
    """
    Dynamically generated writeable type for DBConnection

    Attributes:
        name: Name of the connection. Also used as the unique identifier
        host: Host name/address of server
        port: Port number on server
        username: Username for server authentication
        password: (Write-Only) Password for server authentication
        certificate: (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
        file_type: (Write-Only) Certificate keyfile type - .json or .p12
        database: Database name
        db_timezone: Time zone of database
        query_timezone: Timezone to use in queries
        schema: Scheme name
        max_connections: Maximum number of concurrent connection to use
        max_billing_gigabytes: Maximum size of query in GBs (BigQuery only, can be a user_attribute name)
        ssl: Use SSL/TLS when connecting to server
        verify_ssl: Verify the SSL
        tmp_db_name: Name of temporary database (if used)
        jdbc_additional_params: Additional params to add to JDBC connection string
        pool_timeout: Connection Pool Timeout, in seconds
        dialect_name: (Read/Write) SQL Dialect name
        user_db_credentials: (Limited access feature) Are per user db credentials enabled. Enabling will remove previously set username and password
        user_attribute_fields: Fields whose values map to user attribute names
        maintenance_cron: Cron string specifying when maintenance such as PDT trigger checks and drops should be performed
        sql_runner_precache_tables: Precache tables in the SQL Runner
        after_connect_statements: SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
        pdt_context_override:
    """

    name: Optional[str] = None
    host: Optional[str] = None
    port: Optional[str] = None
    username: Optional[str] = None
    password: Optional[str] = None
    certificate: Optional[str] = None
    file_type: Optional[str] = None
    database: Optional[str] = None
    db_timezone: Optional[str] = None
    query_timezone: Optional[str] = None
    schema: Optional[str] = None
    max_connections: Optional[int] = None
    max_billing_gigabytes: Optional[str] = None
    ssl: Optional[bool] = None
    verify_ssl: Optional[bool] = None
    tmp_db_name: Optional[str] = None
    jdbc_additional_params: Optional[str] = None
    pool_timeout: Optional[int] = None
    dialect_name: Optional[str] = None
    user_db_credentials: Optional[bool] = None
    user_attribute_fields: Optional[Sequence[str]] = None
    maintenance_cron: Optional[str] = None
    sql_runner_precache_tables: Optional[bool] = None
    after_connect_statements: Optional[str] = None
    pdt_context_override: Optional["WriteDBConnectionOverride"] = None

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        host: Optional[str] = None,
        port: Optional[str] = None,
        username: Optional[str] = None,
        password: Optional[str] = None,
        certificate: Optional[str] = None,
        file_type: Optional[str] = None,
        database: Optional[str] = None,
        db_timezone: Optional[str] = None,
        query_timezone: Optional[str] = None,
        schema: Optional[str] = None,
        max_connections: Optional[int] = None,
        max_billing_gigabytes: Optional[str] = None,
        ssl: Optional[bool] = None,
        verify_ssl: Optional[bool] = None,
        tmp_db_name: Optional[str] = None,
        jdbc_additional_params: Optional[str] = None,
        pool_timeout: Optional[int] = None,
        dialect_name: Optional[str] = None,
        user_db_credentials: Optional[bool] = None,
        user_attribute_fields: Optional[Sequence[str]] = None,
        maintenance_cron: Optional[str] = None,
        sql_runner_precache_tables: Optional[bool] = None,
        after_connect_statements: Optional[str] = None,
        pdt_context_override: Optional["WriteDBConnectionOverride"] = None
    ):
        self.name = name
        self.host = host
        self.port = port
        self.username = username
        self.password = password
        self.certificate = certificate
        self.file_type = file_type
        self.database = database
        self.db_timezone = db_timezone
        self.query_timezone = query_timezone
        self.schema = schema
        self.max_connections = max_connections
        self.max_billing_gigabytes = max_billing_gigabytes
        self.ssl = ssl
        self.verify_ssl = verify_ssl
        self.tmp_db_name = tmp_db_name
        self.jdbc_additional_params = jdbc_additional_params
        self.pool_timeout = pool_timeout
        self.dialect_name = dialect_name
        self.user_db_credentials = user_db_credentials
        self.user_attribute_fields = user_attribute_fields
        self.maintenance_cron = maintenance_cron
        self.sql_runner_precache_tables = sql_runner_precache_tables
        self.after_connect_statements = after_connect_statements
        self.pdt_context_override = pdt_context_override


@attr.s(auto_attribs=True, kw_only=True)
class WriteDBConnectionOverride(model.Model):
    """
    Dynamically generated writeable type for DBConnectionOverride

    Attributes:
        context: Context in which to override (`pdt` is the only allowed value)
        host: Host name/address of server
        port: Port number on server
        username: Username for server authentication
        password: (Write-Only) Password for server authentication
        certificate: (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
        file_type: (Write-Only) Certificate keyfile type - .json or .p12
        database: Database name
        schema: Scheme name
        jdbc_additional_params: Additional params to add to JDBC connection string
        after_connect_statements: SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
    """

    context: Optional[str] = None
    host: Optional[str] = None
    port: Optional[str] = None
    username: Optional[str] = None
    password: Optional[str] = None
    certificate: Optional[str] = None
    file_type: Optional[str] = None
    database: Optional[str] = None
    schema: Optional[str] = None
    jdbc_additional_params: Optional[str] = None
    after_connect_statements: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True)
class WriteFolderBase(model.Model):
    """
    Dynamically generated writeable type for FolderBase

    Attributes:
        name: Unique Name
        parent_id: Id of Parent. If the parent id is null, this is a root-level entry
    """

    name: str
    parent_id: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteGitBranch(model.Model):
    """
    Dynamically generated writeable type for GitBranch

    Attributes:
        name: The short name on the local. Updating `name` results in `git checkout <new_name>`
        ref: The resolved ref of this branch. Updating `ref` results in `git reset --hard <new_ref>``.
    """

    name: Optional[str] = None
    ref: Optional[str] = None

    def __init__(self, *, name: Optional[str] = None, ref: Optional[str] = None):
        self.name = name
        self.ref = ref


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteGroup(model.Model):
    """
    Dynamically generated writeable type for Group

    Attributes:
        can_add_to_content_metadata: Group can be used in content access controls
        name: Name of group
    """

    can_add_to_content_metadata: Optional[bool] = None
    name: Optional[str] = None

    def __init__(
        self,
        *,
        can_add_to_content_metadata: Optional[bool] = None,
        name: Optional[str] = None
    ):
        self.can_add_to_content_metadata = can_add_to_content_metadata
        self.name = name


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteHomepage(model.Model):
    """
    Dynamically generated writeable type for Homepage

    Attributes:
        deleted_at: Date of homepage deletion
        description: Description of homepage
        section_order: ids of the homepage sections in the order they should be displayed
        title: Title of homepage
    """

    deleted_at: Optional[datetime.datetime] = None
    description: Optional[str] = None
    section_order: Optional[Sequence[int]] = None
    title: Optional[str] = None

    def __init__(
        self,
        *,
        deleted_at: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        section_order: Optional[Sequence[int]] = None,
        title: Optional[str] = None
    ):
        self.deleted_at = deleted_at
        self.description = description
        self.section_order = section_order
        self.title = title


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteHomepageItem(model.Model):
    """
    Dynamically generated writeable type for HomepageItem

    Attributes:
        custom_description: Custom description entered by the user, if present
        custom_image_data_base64: (Write-Only) base64 encoded image data
        custom_title: Custom title entered by the user, if present
        custom_url: Custom url entered by the user, if present
        dashboard_id: Dashboard to base this item on
        homepage_section_id: Associated Homepage Section
        look_id: Look to base this item on
        lookml_dashboard_id: LookML Dashboard to base this item on
        order: An arbitrary integer representing the sort order within the section
        use_custom_description: Whether the custom description should be used instead of the content description, if the item is associated with content
        use_custom_image: Whether the custom image should be used instead of the content image, if the item is associated with content
        use_custom_title: Whether the custom title should be used instead of the content title, if the item is associated with content
        use_custom_url: Whether the custom url should be used instead of the content url, if the item is associated with content
    """

    custom_description: Optional[str] = None
    custom_image_data_base64: Optional[str] = None
    custom_title: Optional[str] = None
    custom_url: Optional[str] = None
    dashboard_id: Optional[int] = None
    homepage_section_id: Optional[str] = None
    look_id: Optional[int] = None
    lookml_dashboard_id: Optional[str] = None
    order: Optional[int] = None
    use_custom_description: Optional[bool] = None
    use_custom_image: Optional[bool] = None
    use_custom_title: Optional[bool] = None
    use_custom_url: Optional[bool] = None

    def __init__(
        self,
        *,
        custom_description: Optional[str] = None,
        custom_image_data_base64: Optional[str] = None,
        custom_title: Optional[str] = None,
        custom_url: Optional[str] = None,
        dashboard_id: Optional[int] = None,
        homepage_section_id: Optional[str] = None,
        look_id: Optional[int] = None,
        lookml_dashboard_id: Optional[str] = None,
        order: Optional[int] = None,
        use_custom_description: Optional[bool] = None,
        use_custom_image: Optional[bool] = None,
        use_custom_title: Optional[bool] = None,
        use_custom_url: Optional[bool] = None
    ):
        self.custom_description = custom_description
        self.custom_image_data_base64 = custom_image_data_base64
        self.custom_title = custom_title
        self.custom_url = custom_url
        self.dashboard_id = dashboard_id
        self.homepage_section_id = homepage_section_id
        self.look_id = look_id
        self.lookml_dashboard_id = lookml_dashboard_id
        self.order = order
        self.use_custom_description = use_custom_description
        self.use_custom_image = use_custom_image
        self.use_custom_title = use_custom_title
        self.use_custom_url = use_custom_url


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteHomepageSection(model.Model):
    """
    Dynamically generated writeable type for HomepageSection

    Attributes:
        deleted_at: Time at which this section was deleted.
        homepage_id: Id reference to parent homepage
        item_order: ids of the homepage items in the order they should be displayed
        title: Name of row
        description: Description of the content found in this section.
    """

    deleted_at: Optional[datetime.datetime] = None
    homepage_id: Optional[int] = None
    item_order: Optional[Sequence[int]] = None
    title: Optional[str] = None
    description: Optional[str] = None

    def __init__(
        self,
        *,
        deleted_at: Optional[datetime.datetime] = None,
        homepage_id: Optional[int] = None,
        item_order: Optional[Sequence[int]] = None,
        title: Optional[str] = None,
        description: Optional[str] = None
    ):
        self.deleted_at = deleted_at
        self.homepage_id = homepage_id
        self.item_order = item_order
        self.title = title
        self.description = description


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteIntegration(model.Model):
    """
    Dynamically generated writeable type for Integration

    Attributes:
        enabled: Whether the integration is available to users.
        params: Array of params for the integration.
        installed_delegate_oauth_targets: Whether the integration is available to users.
    """

    enabled: Optional[bool] = None
    params: Optional[Sequence["IntegrationParam"]] = None
    installed_delegate_oauth_targets: Optional[Sequence[str]] = None

    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
        params: Optional[Sequence["IntegrationParam"]] = None,
        installed_delegate_oauth_targets: Optional[Sequence[str]] = None
    ):
        self.enabled = enabled
        self.params = params
        self.installed_delegate_oauth_targets = installed_delegate_oauth_targets


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteIntegrationHub(model.Model):
    """
    Dynamically generated writeable type for IntegrationHub

    Attributes:
        url: URL of the hub.
        authorization_token: (Write-Only) An authorization key that will be sent to the integration hub on every request.
    """

    url: Optional[str] = None
    authorization_token: Optional[str] = None

    def __init__(
        self, *, url: Optional[str] = None, authorization_token: Optional[str] = None
    ):
        self.url = url
        self.authorization_token = authorization_token


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteInternalHelpResources(model.Model):
    """
    Dynamically generated writeable type for InternalHelpResources

    Attributes:
        enabled: If true and internal help resources content is not blank then the link for internal help resources will be shown in the help menu and the content displayed within Looker
    """

    enabled: Optional[bool] = None

    def __init__(self, *, enabled: Optional[bool] = None):
        self.enabled = enabled


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteInternalHelpResourcesContent(model.Model):
    """
    Dynamically generated writeable type for InternalHelpResourcesContent

    Attributes:
        organization_name: Text to display in the help menu item which will display the internal help resources
        markdown_content: Content to be displayed in the internal help resources page/modal
    """

    organization_name: Optional[str] = None
    markdown_content: Optional[str] = None

    def __init__(
        self,
        *,
        organization_name: Optional[str] = None,
        markdown_content: Optional[str] = None
    ):
        self.organization_name = organization_name
        self.markdown_content = markdown_content


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteLDAPConfig(model.Model):
    """
    Dynamically generated writeable type for LDAPConfig

    Attributes:
        alternate_email_login_allowed: Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
        auth_password: (Write-Only)  Password for the LDAP account used to access the LDAP server
        auth_requires_role: Users will not be allowed to login at all unless a role for them is found in LDAP if set to true
        auth_username: Distinguished name of LDAP account used to access the LDAP server
        connection_host: LDAP server hostname
        connection_port: LDAP host port
        connection_tls: Use Transport Layer Security
        connection_tls_no_verify: Do not verify peer when using TLS
        default_new_user_group_ids: (Write-Only)  Array of ids of groups that will be applied to new users the first time they login via LDAP
        default_new_user_role_ids: (Write-Only)  Array of ids of roles that will be applied to new users the first time they login via LDAP
        enabled: Enable/Disable LDAP authentication for the server
        force_no_page: Don't attempt to do LDAP search result paging (RFC 2696) even if the LDAP server claims to support it.
        groups_base_dn: Base dn for finding groups in LDAP searches
        groups_finder_type: Identifier for a strategy for how Looker will search for groups in the LDAP server
        groups_member_attribute: LDAP Group attribute that signifies the members of the groups. Most commonly 'member'
        groups_objectclasses: Optional comma-separated list of supported LDAP objectclass for groups when doing groups searches
        groups_user_attribute: LDAP Group attribute that signifies the user in a group. Most commonly 'dn'
        groups_with_role_ids: (Read/Write) Array of mappings between LDAP Groups and arrays of Looker Role ids
        merge_new_users_by_email: Merge first-time ldap login to existing user account by email addresses. When a user logs in for the first time via ldap this option will connect this user into their existing account by finding the account with a matching email address. Otherwise a new user account will be created for the user.
        set_roles_from_groups: Set user roles in Looker based on groups from LDAP
        test_ldap_password: (Write-Only)  Test LDAP user password. For ldap tests only.
        test_ldap_user: (Write-Only)  Test LDAP user login id. For ldap tests only.
        user_attribute_map_email: Name of user record attributes used to indicate email address field
        user_attribute_map_first_name: Name of user record attributes used to indicate first name
        user_attribute_map_last_name: Name of user record attributes used to indicate last name
        user_attribute_map_ldap_id: Name of user record attributes used to indicate unique record id
        user_attributes_with_ids: (Read/Write) Array of mappings between LDAP User Attributes and arrays of Looker User Attribute ids
        user_bind_base_dn: Distinguished name of LDAP node used as the base for user searches
        user_custom_filter: (Optional) Custom RFC-2254 filter clause for use in finding user during login. Combined via 'and' with the other generated filter clauses.
        user_id_attribute_names: Name(s) of user record attributes used for matching user login id (comma separated list)
        user_objectclass: (Optional) Name of user record objectclass used for finding user during login id
    """

    alternate_email_login_allowed: Optional[bool] = None
    auth_password: Optional[str] = None
    auth_requires_role: Optional[bool] = None
    auth_username: Optional[str] = None
    connection_host: Optional[str] = None
    connection_port: Optional[str] = None
    connection_tls: Optional[bool] = None
    connection_tls_no_verify: Optional[bool] = None
    default_new_user_group_ids: Optional[Sequence[int]] = None
    default_new_user_role_ids: Optional[Sequence[int]] = None
    enabled: Optional[bool] = None
    force_no_page: Optional[bool] = None
    groups_base_dn: Optional[str] = None
    groups_finder_type: Optional[str] = None
    groups_member_attribute: Optional[str] = None
    groups_objectclasses: Optional[str] = None
    groups_user_attribute: Optional[str] = None
    groups_with_role_ids: Optional[Sequence["LDAPGroupWrite"]] = None
    merge_new_users_by_email: Optional[bool] = None
    set_roles_from_groups: Optional[bool] = None
    test_ldap_password: Optional[str] = None
    test_ldap_user: Optional[str] = None
    user_attribute_map_email: Optional[str] = None
    user_attribute_map_first_name: Optional[str] = None
    user_attribute_map_last_name: Optional[str] = None
    user_attribute_map_ldap_id: Optional[str] = None
    user_attributes_with_ids: Optional[Sequence["LDAPUserAttributeWrite"]] = None
    user_bind_base_dn: Optional[str] = None
    user_custom_filter: Optional[str] = None
    user_id_attribute_names: Optional[str] = None
    user_objectclass: Optional[str] = None

    def __init__(
        self,
        *,
        alternate_email_login_allowed: Optional[bool] = None,
        auth_password: Optional[str] = None,
        auth_requires_role: Optional[bool] = None,
        auth_username: Optional[str] = None,
        connection_host: Optional[str] = None,
        connection_port: Optional[str] = None,
        connection_tls: Optional[bool] = None,
        connection_tls_no_verify: Optional[bool] = None,
        default_new_user_group_ids: Optional[Sequence[int]] = None,
        default_new_user_role_ids: Optional[Sequence[int]] = None,
        enabled: Optional[bool] = None,
        force_no_page: Optional[bool] = None,
        groups_base_dn: Optional[str] = None,
        groups_finder_type: Optional[str] = None,
        groups_member_attribute: Optional[str] = None,
        groups_objectclasses: Optional[str] = None,
        groups_user_attribute: Optional[str] = None,
        groups_with_role_ids: Optional[Sequence["LDAPGroupWrite"]] = None,
        merge_new_users_by_email: Optional[bool] = None,
        set_roles_from_groups: Optional[bool] = None,
        test_ldap_password: Optional[str] = None,
        test_ldap_user: Optional[str] = None,
        user_attribute_map_email: Optional[str] = None,
        user_attribute_map_first_name: Optional[str] = None,
        user_attribute_map_last_name: Optional[str] = None,
        user_attribute_map_ldap_id: Optional[str] = None,
        user_attributes_with_ids: Optional[Sequence["LDAPUserAttributeWrite"]] = None,
        user_bind_base_dn: Optional[str] = None,
        user_custom_filter: Optional[str] = None,
        user_id_attribute_names: Optional[str] = None,
        user_objectclass: Optional[str] = None
    ):
        self.alternate_email_login_allowed = alternate_email_login_allowed
        self.auth_password = auth_password
        self.auth_requires_role = auth_requires_role
        self.auth_username = auth_username
        self.connection_host = connection_host
        self.connection_port = connection_port
        self.connection_tls = connection_tls
        self.connection_tls_no_verify = connection_tls_no_verify
        self.default_new_user_group_ids = default_new_user_group_ids
        self.default_new_user_role_ids = default_new_user_role_ids
        self.enabled = enabled
        self.force_no_page = force_no_page
        self.groups_base_dn = groups_base_dn
        self.groups_finder_type = groups_finder_type
        self.groups_member_attribute = groups_member_attribute
        self.groups_objectclasses = groups_objectclasses
        self.groups_user_attribute = groups_user_attribute
        self.groups_with_role_ids = groups_with_role_ids
        self.merge_new_users_by_email = merge_new_users_by_email
        self.set_roles_from_groups = set_roles_from_groups
        self.test_ldap_password = test_ldap_password
        self.test_ldap_user = test_ldap_user
        self.user_attribute_map_email = user_attribute_map_email
        self.user_attribute_map_first_name = user_attribute_map_first_name
        self.user_attribute_map_last_name = user_attribute_map_last_name
        self.user_attribute_map_ldap_id = user_attribute_map_ldap_id
        self.user_attributes_with_ids = user_attributes_with_ids
        self.user_bind_base_dn = user_bind_base_dn
        self.user_custom_filter = user_custom_filter
        self.user_id_attribute_names = user_id_attribute_names
        self.user_objectclass = user_objectclass


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteLegacyFeature(model.Model):
    """
    Dynamically generated writeable type for LegacyFeature

    Attributes:
        enabled_locally: Whether this feature has been enabled by a user
    """

    enabled_locally: Optional[bool] = None

    def __init__(self, *, enabled_locally: Optional[bool] = None):
        self.enabled_locally = enabled_locally


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteLookmlModel(model.Model):
    """
    Dynamically generated writeable type for LookmlModel

    Attributes:
        allowed_db_connection_names: Array of names of connections this model is allowed to use
        name: Name of the model. Also used as the unique identifier
        project_name: Name of project containing the model
        unlimited_db_connections: Is this model allowed to use all current and future connections
    """

    allowed_db_connection_names: Optional[Sequence[str]] = None
    name: Optional[str] = None
    project_name: Optional[str] = None
    unlimited_db_connections: Optional[bool] = None

    def __init__(
        self,
        *,
        allowed_db_connection_names: Optional[Sequence[str]] = None,
        name: Optional[str] = None,
        project_name: Optional[str] = None,
        unlimited_db_connections: Optional[bool] = None
    ):
        self.allowed_db_connection_names = allowed_db_connection_names
        self.name = name
        self.project_name = project_name
        self.unlimited_db_connections = unlimited_db_connections


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteLookWithQuery(model.Model):
    """
    Dynamically generated writeable type for LookWithQuery

    Attributes:
        title: Look Title
        deleted: Whether or not a look is 'soft' deleted.
        description: Description
        is_run_on_load: auto-run query when Look viewed
        public: Is Public
        query_id: Query Id
        space:
        folder:
        space_id: Space Id
        folder_id: Folder Id
        user_id: User Id
        query:
    """

    title: Optional[str] = None
    deleted: Optional[bool] = None
    description: Optional[str] = None
    is_run_on_load: Optional[bool] = None
    public: Optional[bool] = None
    query_id: Optional[int] = None
    space: Optional["WriteSpaceBase"] = None
    folder: Optional["WriteFolderBase"] = None
    space_id: Optional[str] = None
    folder_id: Optional[str] = None
    user_id: Optional[int] = None
    query: Optional["WriteQuery"] = None

    def __init__(
        self,
        *,
        title: Optional[str] = None,
        deleted: Optional[bool] = None,
        description: Optional[str] = None,
        is_run_on_load: Optional[bool] = None,
        public: Optional[bool] = None,
        query_id: Optional[int] = None,
        space: Optional["WriteSpaceBase"] = None,
        folder: Optional["WriteFolderBase"] = None,
        space_id: Optional[str] = None,
        folder_id: Optional[str] = None,
        user_id: Optional[int] = None,
        query: Optional["WriteQuery"] = None
    ):
        self.title = title
        self.deleted = deleted
        self.description = description
        self.is_run_on_load = is_run_on_load
        self.public = public
        self.query_id = query_id
        self.space = space
        self.folder = folder
        self.space_id = space_id
        self.folder_id = folder_id
        self.user_id = user_id
        self.query = query


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteMergeQuery(model.Model):
    """
    Dynamically generated writeable type for MergeQuery

    Attributes:
        column_limit: Column Limit
        dynamic_fields: Dynamic Fields
        pivots: Pivots
        sorts: Sorts
        source_queries: Source Queries defining the results to be merged.
        total: Total
        vis_config: Visualization Config
    """

    column_limit: Optional[str] = None
    dynamic_fields: Optional[str] = None
    pivots: Optional[Sequence[str]] = None
    sorts: Optional[Sequence[str]] = None
    source_queries: Optional[Sequence["MergeQuerySourceQuery"]] = None
    total: Optional[bool] = None
    vis_config: Optional[MutableMapping[str, str]] = None

    def __init__(
        self,
        *,
        column_limit: Optional[str] = None,
        dynamic_fields: Optional[str] = None,
        pivots: Optional[Sequence[str]] = None,
        sorts: Optional[Sequence[str]] = None,
        source_queries: Optional[Sequence["MergeQuerySourceQuery"]] = None,
        total: Optional[bool] = None,
        vis_config: Optional[MutableMapping[str, str]] = None
    ):
        self.column_limit = column_limit
        self.dynamic_fields = dynamic_fields
        self.pivots = pivots
        self.sorts = sorts
        self.source_queries = source_queries
        self.total = total
        self.vis_config = vis_config


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteModelSet(model.Model):
    """
    Dynamically generated writeable type for ModelSet

    Attributes:
        models:
        name: Name of ModelSet
    """

    models: Optional[Sequence[str]] = None
    name: Optional[str] = None

    def __init__(
        self, *, models: Optional[Sequence[str]] = None, name: Optional[str] = None
    ):
        self.models = models
        self.name = name


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteOIDCConfig(model.Model):
    """
    Dynamically generated writeable type for OIDCConfig

    Attributes:
        alternate_email_login_allowed: Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
        audience: OpenID Provider Audience
        auth_requires_role: Users will not be allowed to login at all unless a role for them is found in OIDC if set to true
        authorization_endpoint: OpenID Provider Authorization Url
        default_new_user_group_ids: (Write-Only) Array of ids of groups that will be applied to new users the first time they login via OIDC
        default_new_user_role_ids: (Write-Only) Array of ids of roles that will be applied to new users the first time they login via OIDC
        enabled: Enable/Disable OIDC authentication for the server
        groups_attribute: Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
        groups_with_role_ids: (Read/Write) Array of mappings between OIDC Groups and arrays of Looker Role ids
        identifier: Relying Party Identifier (provided by OpenID Provider)
        issuer: OpenID Provider Issuer
        new_user_migration_types: Merge first-time oidc login to existing user account by email addresses. When a user logs in for the first time via oidc this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
        scopes: Array of scopes to request.
        secret: (Write-Only) Relying Party Secret (provided by OpenID Provider)
        set_roles_from_groups: Set user roles in Looker based on groups from OIDC
        token_endpoint: OpenID Provider Token Url
        user_attribute_map_email: Name of user record attributes used to indicate email address field
        user_attribute_map_first_name: Name of user record attributes used to indicate first name
        user_attribute_map_last_name: Name of user record attributes used to indicate last name
        user_attributes_with_ids: (Read/Write) Array of mappings between OIDC User Attributes and arrays of Looker User Attribute ids
        userinfo_endpoint: OpenID Provider User Information Url
    """

    alternate_email_login_allowed: Optional[bool] = None
    audience: Optional[str] = None
    auth_requires_role: Optional[bool] = None
    authorization_endpoint: Optional[str] = None
    default_new_user_group_ids: Optional[Sequence[int]] = None
    default_new_user_role_ids: Optional[Sequence[int]] = None
    enabled: Optional[bool] = None
    groups_attribute: Optional[str] = None
    groups_with_role_ids: Optional[Sequence["OIDCGroupWrite"]] = None
    identifier: Optional[str] = None
    issuer: Optional[str] = None
    new_user_migration_types: Optional[str] = None
    scopes: Optional[Sequence[str]] = None
    secret: Optional[str] = None
    set_roles_from_groups: Optional[bool] = None
    token_endpoint: Optional[str] = None
    user_attribute_map_email: Optional[str] = None
    user_attribute_map_first_name: Optional[str] = None
    user_attribute_map_last_name: Optional[str] = None
    user_attributes_with_ids: Optional[Sequence["OIDCUserAttributeWrite"]] = None
    userinfo_endpoint: Optional[str] = None

    def __init__(
        self,
        *,
        alternate_email_login_allowed: Optional[bool] = None,
        audience: Optional[str] = None,
        auth_requires_role: Optional[bool] = None,
        authorization_endpoint: Optional[str] = None,
        default_new_user_group_ids: Optional[Sequence[int]] = None,
        default_new_user_role_ids: Optional[Sequence[int]] = None,
        enabled: Optional[bool] = None,
        groups_attribute: Optional[str] = None,
        groups_with_role_ids: Optional[Sequence["OIDCGroupWrite"]] = None,
        identifier: Optional[str] = None,
        issuer: Optional[str] = None,
        new_user_migration_types: Optional[str] = None,
        scopes: Optional[Sequence[str]] = None,
        secret: Optional[str] = None,
        set_roles_from_groups: Optional[bool] = None,
        token_endpoint: Optional[str] = None,
        user_attribute_map_email: Optional[str] = None,
        user_attribute_map_first_name: Optional[str] = None,
        user_attribute_map_last_name: Optional[str] = None,
        user_attributes_with_ids: Optional[Sequence["OIDCUserAttributeWrite"]] = None,
        userinfo_endpoint: Optional[str] = None
    ):
        self.alternate_email_login_allowed = alternate_email_login_allowed
        self.audience = audience
        self.auth_requires_role = auth_requires_role
        self.authorization_endpoint = authorization_endpoint
        self.default_new_user_group_ids = default_new_user_group_ids
        self.default_new_user_role_ids = default_new_user_role_ids
        self.enabled = enabled
        self.groups_attribute = groups_attribute
        self.groups_with_role_ids = groups_with_role_ids
        self.identifier = identifier
        self.issuer = issuer
        self.new_user_migration_types = new_user_migration_types
        self.scopes = scopes
        self.secret = secret
        self.set_roles_from_groups = set_roles_from_groups
        self.token_endpoint = token_endpoint
        self.user_attribute_map_email = user_attribute_map_email
        self.user_attribute_map_first_name = user_attribute_map_first_name
        self.user_attribute_map_last_name = user_attribute_map_last_name
        self.user_attributes_with_ids = user_attributes_with_ids
        self.userinfo_endpoint = userinfo_endpoint


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WritePasswordConfig(model.Model):
    """
    Dynamically generated writeable type for PasswordConfig

    Attributes:
        min_length: Minimum number of characters required for a new password.  Must be between 7 and 100
        require_numeric: Require at least one numeric character
        require_upperlower: Require at least one uppercase and one lowercase letter
        require_special: Require at least one special character
    """

    min_length: Optional[int] = None
    require_numeric: Optional[bool] = None
    require_upperlower: Optional[bool] = None
    require_special: Optional[bool] = None

    def __init__(
        self,
        *,
        min_length: Optional[int] = None,
        require_numeric: Optional[bool] = None,
        require_upperlower: Optional[bool] = None,
        require_special: Optional[bool] = None
    ):
        self.min_length = min_length
        self.require_numeric = require_numeric
        self.require_upperlower = require_upperlower
        self.require_special = require_special


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WritePermissionSet(model.Model):
    """
    Dynamically generated writeable type for PermissionSet

    Attributes:
        name: Name of PermissionSet
        permissions:
    """

    name: Optional[str] = None
    permissions: Optional[Sequence[str]] = None

    def __init__(
        self, *, name: Optional[str] = None, permissions: Optional[Sequence[str]] = None
    ):
        self.name = name
        self.permissions = permissions


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteProject(model.Model):
    """
    Dynamically generated writeable type for Project

    Attributes:
        name: Project display name
        git_remote_url: Git remote repository url
        git_username: Git username for HTTPS authentication. (For production only, if using user attributes.)
        git_password: (Write-Only) Git password for HTTPS authentication. (For production only, if using user attributes.)
        git_username_user_attribute: User attribute name for username in per-user HTTPS authentication.
        git_password_user_attribute: User attribute name for password in per-user HTTPS authentication.
        git_service_name: Name of the git service provider
        deploy_secret: (Write-Only) Optional secret token with which to authenticate requests to the webhook deploy endpoint. If not set, endpoint is unauthenticated.
        unset_deploy_secret: (Write-Only) When true, unsets the deploy secret to allow unauthenticated access to the webhook deploy endpoint.
        pull_request_mode: The git pull request policy for this project. Valid values are: "off", "links", "recommended", "required".
        validation_required: Validation policy: If true, the project must pass validation checks before project changes can be committed to the git repository
        folders_enabled: If true, folders are enabled for this project
        allow_warnings: Validation policy: If true, the project can be committed with warnings when `validation_required` is true. (`allow_warnings` does nothing if `validation_required` is false).
    """

    name: Optional[str] = None
    git_remote_url: Optional[str] = None
    git_username: Optional[str] = None
    git_password: Optional[str] = None
    git_username_user_attribute: Optional[str] = None
    git_password_user_attribute: Optional[str] = None
    git_service_name: Optional[str] = None
    deploy_secret: Optional[str] = None
    unset_deploy_secret: Optional[bool] = None
    pull_request_mode: Optional[str] = None
    validation_required: Optional[bool] = None
    folders_enabled: Optional[bool] = None
    allow_warnings: Optional[bool] = None

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        git_remote_url: Optional[str] = None,
        git_username: Optional[str] = None,
        git_password: Optional[str] = None,
        git_username_user_attribute: Optional[str] = None,
        git_password_user_attribute: Optional[str] = None,
        git_service_name: Optional[str] = None,
        deploy_secret: Optional[str] = None,
        unset_deploy_secret: Optional[bool] = None,
        pull_request_mode: Optional[str] = None,
        validation_required: Optional[bool] = None,
        folders_enabled: Optional[bool] = None,
        allow_warnings: Optional[bool] = None
    ):
        self.name = name
        self.git_remote_url = git_remote_url
        self.git_username = git_username
        self.git_password = git_password
        self.git_username_user_attribute = git_username_user_attribute
        self.git_password_user_attribute = git_password_user_attribute
        self.git_service_name = git_service_name
        self.deploy_secret = deploy_secret
        self.unset_deploy_secret = unset_deploy_secret
        self.pull_request_mode = pull_request_mode
        self.validation_required = validation_required
        self.folders_enabled = folders_enabled
        self.allow_warnings = allow_warnings


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteQuery(model.Model):
    """
    Dynamically generated writeable type for Query

    Attributes:
        model: Model
        view: Explore Name
        fields: Fields
        pivots: Pivots
        fill_fields: Fill Fields
        filters: Filters
        filter_expression: Filter Expression
        sorts: Sorting for the query results. Use the format `["view.field", ...]` to sort on fields in ascending order. Use the format `["view.field desc", ...]` to sort on fields in descending order. Use `["__UNSORTED__"]` (2 underscores before and after) to disable sorting entirely. Empty sorts `[]` will trigger a default sort.
        limit: Limit
        column_limit: Column Limit
        total: Total
        row_total: Raw Total
        subtotals: Fields on which to run subtotals
        runtime: Runtime
        vis_config: Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
        filter_config: The filter_config represents the state of the filter UI on the explore page for a given query. When running a query via the Looker UI, this parameter takes precedence over "filters". When creating a query or modifying an existing query, "filter_config" should be set to null. Setting it to any other value could cause unexpected filtering behavior. The format should be considered opaque.
        visible_ui_sections: Visible UI Sections
        dynamic_fields: Dynamic Fields
        client_id: Client Id: used to generate shortened explore URLs. If set by client, must be a unique 22 character alphanumeric string. Otherwise one will be generated.
        query_timezone: Query Timezone
    """

    model: str
    view: str
    fields: Optional[Sequence[str]] = None
    pivots: Optional[Sequence[str]] = None
    fill_fields: Optional[Sequence[str]] = None
    filters: Optional[MutableMapping[str, str]] = None
    filter_expression: Optional[str] = None
    sorts: Optional[Sequence[str]] = None
    limit: Optional[str] = None
    column_limit: Optional[str] = None
    total: Optional[bool] = None
    row_total: Optional[str] = None
    subtotals: Optional[Sequence[str]] = None
    runtime: Optional[float] = None
    vis_config: Optional[MutableMapping[str, str]] = None
    filter_config: Optional[MutableMapping[str, str]] = None
    visible_ui_sections: Optional[str] = None
    dynamic_fields: Optional[str] = None
    client_id: Optional[str] = None
    query_timezone: Optional[str] = None

    def __init__(
        self,
        *,
        model: str,
        view: str,
        fields: Optional[Sequence[str]] = None,
        pivots: Optional[Sequence[str]] = None,
        fill_fields: Optional[Sequence[str]] = None,
        filters: Optional[MutableMapping[str, str]] = None,
        filter_expression: Optional[str] = None,
        sorts: Optional[Sequence[str]] = None,
        limit: Optional[str] = None,
        column_limit: Optional[str] = None,
        total: Optional[bool] = None,
        row_total: Optional[str] = None,
        subtotals: Optional[Sequence[str]] = None,
        runtime: Optional[float] = None,
        vis_config: Optional[MutableMapping[str, str]] = None,
        filter_config: Optional[MutableMapping[str, str]] = None,
        visible_ui_sections: Optional[str] = None,
        dynamic_fields: Optional[str] = None,
        client_id: Optional[str] = None,
        query_timezone: Optional[str] = None
    ):
        self.model = model
        self.view = view
        self.fields = fields
        self.pivots = pivots
        self.fill_fields = fill_fields
        self.filters = filters
        self.filter_expression = filter_expression
        self.sorts = sorts
        self.limit = limit
        self.column_limit = column_limit
        self.total = total
        self.row_total = row_total
        self.subtotals = subtotals
        self.runtime = runtime
        self.vis_config = vis_config
        self.filter_config = filter_config
        self.visible_ui_sections = visible_ui_sections
        self.dynamic_fields = dynamic_fields
        self.client_id = client_id
        self.query_timezone = query_timezone


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteRepositoryCredential(model.Model):
    """
    Dynamically generated writeable type for RepositoryCredential

    Attributes:
        git_username: Git username for HTTPS authentication.
        git_password: (Write-Only) Git password for HTTPS authentication.
        ssh_public_key: Public deploy key for SSH authentication.
    """

    git_username: Optional[str] = None
    git_password: Optional[str] = None
    ssh_public_key: Optional[str] = None

    def __init__(
        self,
        *,
        git_username: Optional[str] = None,
        git_password: Optional[str] = None,
        ssh_public_key: Optional[str] = None
    ):
        self.git_username = git_username
        self.git_password = git_password
        self.ssh_public_key = ssh_public_key


@attr.s(auto_attribs=True, kw_only=True)
class WriteResultMakerWithIdVisConfigAndDynamicFields(model.Model):
    """
    Dynamically generated writeable type for ResultMakerWithIdVisConfigAndDynamicFields

    Attributes:
        query:
    """

    query: Optional["WriteQuery"] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteRole(model.Model):
    """
    Dynamically generated writeable type for Role

    Attributes:
        name: Name of Role
        permission_set:
        permission_set_id: (Write-Only) Id of permission set
        model_set:
        model_set_id: (Write-Only) Id of model set
    """

    name: Optional[str] = None
    permission_set: Optional["WritePermissionSet"] = None
    permission_set_id: Optional[int] = None
    model_set: Optional["WriteModelSet"] = None
    model_set_id: Optional[int] = None

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        permission_set: Optional["WritePermissionSet"] = None,
        permission_set_id: Optional[int] = None,
        model_set: Optional["WriteModelSet"] = None,
        model_set_id: Optional[int] = None
    ):
        self.name = name
        self.permission_set = permission_set
        self.permission_set_id = permission_set_id
        self.model_set = model_set
        self.model_set_id = model_set_id


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteSamlConfig(model.Model):
    """
    Dynamically generated writeable type for SamlConfig

    Attributes:
        enabled: Enable/Disable Saml authentication for the server
        idp_cert: Identity Provider Certificate (provided by IdP)
        idp_url: Identity Provider Url (provided by IdP)
        idp_issuer: Identity Provider Issuer (provided by IdP)
        idp_audience: Identity Provider Audience (set in IdP config). Optional in Looker. Set this only if you want Looker to validate the audience value returned by the IdP.
        allowed_clock_drift: Count of seconds of clock drift to allow when validating timestamps of assertions.
        user_attribute_map_email: Name of user record attributes used to indicate email address field
        user_attribute_map_first_name: Name of user record attributes used to indicate first name
        user_attribute_map_last_name: Name of user record attributes used to indicate last name
        new_user_migration_types: Merge first-time saml login to existing user account by email addresses. When a user logs in for the first time via saml this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
        alternate_email_login_allowed: Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
        default_new_user_role_ids: (Write-Only) Array of ids of roles that will be applied to new users the first time they login via Saml
        default_new_user_group_ids: (Write-Only) Array of ids of groups that will be applied to new users the first time they login via Saml
        set_roles_from_groups: Set user roles in Looker based on groups from Saml
        groups_attribute: Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
        groups_with_role_ids: (Read/Write) Array of mappings between Saml Groups and arrays of Looker Role ids
        auth_requires_role: Users will not be allowed to login at all unless a role for them is found in Saml if set to true
        user_attributes_with_ids: (Read/Write) Array of mappings between Saml User Attributes and arrays of Looker User Attribute ids
        groups_finder_type: Identifier for a strategy for how Looker will find groups in the SAML response. One of ['grouped_attribute_values', 'individual_attributes']
        groups_member_value: Value for group attribute used to indicate membership. Used when 'groups_finder_type' is set to 'individual_attributes'
        bypass_login_page: Bypass the login page when user authentication is required. Redirect to IdP immediately instead.
    """

    enabled: Optional[bool] = None
    idp_cert: Optional[str] = None
    idp_url: Optional[str] = None
    idp_issuer: Optional[str] = None
    idp_audience: Optional[str] = None
    allowed_clock_drift: Optional[int] = None
    user_attribute_map_email: Optional[str] = None
    user_attribute_map_first_name: Optional[str] = None
    user_attribute_map_last_name: Optional[str] = None
    new_user_migration_types: Optional[str] = None
    alternate_email_login_allowed: Optional[bool] = None
    default_new_user_role_ids: Optional[Sequence[int]] = None
    default_new_user_group_ids: Optional[Sequence[int]] = None
    set_roles_from_groups: Optional[bool] = None
    groups_attribute: Optional[str] = None
    groups_with_role_ids: Optional[Sequence["SamlGroupWrite"]] = None
    auth_requires_role: Optional[bool] = None
    user_attributes_with_ids: Optional[Sequence["SamlUserAttributeWrite"]] = None
    groups_finder_type: Optional[str] = None
    groups_member_value: Optional[str] = None
    bypass_login_page: Optional[bool] = None

    def __init__(
        self,
        *,
        enabled: Optional[bool] = None,
        idp_cert: Optional[str] = None,
        idp_url: Optional[str] = None,
        idp_issuer: Optional[str] = None,
        idp_audience: Optional[str] = None,
        allowed_clock_drift: Optional[int] = None,
        user_attribute_map_email: Optional[str] = None,
        user_attribute_map_first_name: Optional[str] = None,
        user_attribute_map_last_name: Optional[str] = None,
        new_user_migration_types: Optional[str] = None,
        alternate_email_login_allowed: Optional[bool] = None,
        default_new_user_role_ids: Optional[Sequence[int]] = None,
        default_new_user_group_ids: Optional[Sequence[int]] = None,
        set_roles_from_groups: Optional[bool] = None,
        groups_attribute: Optional[str] = None,
        groups_with_role_ids: Optional[Sequence["SamlGroupWrite"]] = None,
        auth_requires_role: Optional[bool] = None,
        user_attributes_with_ids: Optional[Sequence["SamlUserAttributeWrite"]] = None,
        groups_finder_type: Optional[str] = None,
        groups_member_value: Optional[str] = None,
        bypass_login_page: Optional[bool] = None
    ):
        self.enabled = enabled
        self.idp_cert = idp_cert
        self.idp_url = idp_url
        self.idp_issuer = idp_issuer
        self.idp_audience = idp_audience
        self.allowed_clock_drift = allowed_clock_drift
        self.user_attribute_map_email = user_attribute_map_email
        self.user_attribute_map_first_name = user_attribute_map_first_name
        self.user_attribute_map_last_name = user_attribute_map_last_name
        self.new_user_migration_types = new_user_migration_types
        self.alternate_email_login_allowed = alternate_email_login_allowed
        self.default_new_user_role_ids = default_new_user_role_ids
        self.default_new_user_group_ids = default_new_user_group_ids
        self.set_roles_from_groups = set_roles_from_groups
        self.groups_attribute = groups_attribute
        self.groups_with_role_ids = groups_with_role_ids
        self.auth_requires_role = auth_requires_role
        self.user_attributes_with_ids = user_attributes_with_ids
        self.groups_finder_type = groups_finder_type
        self.groups_member_value = groups_member_value
        self.bypass_login_page = bypass_login_page


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteScheduledPlan(model.Model):
    """
    Dynamically generated writeable type for ScheduledPlan

    Attributes:
        name: Name of this scheduled plan
        user_id: User Id which owns this scheduled plan
        run_as_recipient: Whether schedule is run as recipient (only applicable for email recipients)
        enabled: Whether the ScheduledPlan is enabled
        look_id: Id of a look
        dashboard_id: Id of a dashboard
        lookml_dashboard_id: Id of a LookML dashboard
        filters_string: Query string to run look or dashboard with
        dashboard_filters: (DEPRECATED) Alias for filters_string field
        require_results: Delivery should occur if running the dashboard or look returns results
        require_no_results: Delivery should occur if the dashboard look does not return results
        require_change: Delivery should occur if data have changed since the last run
        send_all_results: Will run an unlimited query and send all results.
        crontab: Vixie-Style crontab specification when to run
        datagroup: Name of a datagroup; if specified will run when datagroup triggered (can't be used with cron string)
        timezone: Timezone for interpreting the specified crontab (default is Looker instance timezone)
        query_id: Query id
        scheduled_plan_destination: Scheduled plan destinations
        run_once: Whether the plan in question should only be run once (usually for testing)
        include_links: Whether links back to Looker should be included in this ScheduledPlan
        pdf_paper_size: The size of paper a PDF should be rendered for
        pdf_landscape: Whether the paper should be landscape
        embed: Whether this schedule is in an embed context or not
        color_theme: Color scheme of the dashboard if applicable
        long_tables: Whether or not to expand table vis to full length
    """

    name: Optional[str] = None
    user_id: Optional[int] = None
    run_as_recipient: Optional[bool] = None
    enabled: Optional[bool] = None
    look_id: Optional[int] = None
    dashboard_id: Optional[int] = None
    lookml_dashboard_id: Optional[str] = None
    filters_string: Optional[str] = None
    dashboard_filters: Optional[str] = None
    require_results: Optional[bool] = None
    require_no_results: Optional[bool] = None
    require_change: Optional[bool] = None
    send_all_results: Optional[bool] = None
    crontab: Optional[str] = None
    datagroup: Optional[str] = None
    timezone: Optional[str] = None
    query_id: Optional[str] = None
    scheduled_plan_destination: Optional[Sequence["ScheduledPlanDestination"]] = None
    run_once: Optional[bool] = None
    include_links: Optional[bool] = None
    pdf_paper_size: Optional[str] = None
    pdf_landscape: Optional[bool] = None
    embed: Optional[bool] = None
    color_theme: Optional[str] = None
    long_tables: Optional[bool] = None

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        user_id: Optional[int] = None,
        run_as_recipient: Optional[bool] = None,
        enabled: Optional[bool] = None,
        look_id: Optional[int] = None,
        dashboard_id: Optional[int] = None,
        lookml_dashboard_id: Optional[str] = None,
        filters_string: Optional[str] = None,
        dashboard_filters: Optional[str] = None,
        require_results: Optional[bool] = None,
        require_no_results: Optional[bool] = None,
        require_change: Optional[bool] = None,
        send_all_results: Optional[bool] = None,
        crontab: Optional[str] = None,
        datagroup: Optional[str] = None,
        timezone: Optional[str] = None,
        query_id: Optional[str] = None,
        scheduled_plan_destination: Optional[
            Sequence["ScheduledPlanDestination"]
        ] = None,
        run_once: Optional[bool] = None,
        include_links: Optional[bool] = None,
        pdf_paper_size: Optional[str] = None,
        pdf_landscape: Optional[bool] = None,
        embed: Optional[bool] = None,
        color_theme: Optional[str] = None,
        long_tables: Optional[bool] = None
    ):
        self.name = name
        self.user_id = user_id
        self.run_as_recipient = run_as_recipient
        self.enabled = enabled
        self.look_id = look_id
        self.dashboard_id = dashboard_id
        self.lookml_dashboard_id = lookml_dashboard_id
        self.filters_string = filters_string
        self.dashboard_filters = dashboard_filters
        self.require_results = require_results
        self.require_no_results = require_no_results
        self.require_change = require_change
        self.send_all_results = send_all_results
        self.crontab = crontab
        self.datagroup = datagroup
        self.timezone = timezone
        self.query_id = query_id
        self.scheduled_plan_destination = scheduled_plan_destination
        self.run_once = run_once
        self.include_links = include_links
        self.pdf_paper_size = pdf_paper_size
        self.pdf_landscape = pdf_landscape
        self.embed = embed
        self.color_theme = color_theme
        self.long_tables = long_tables


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteSessionConfig(model.Model):
    """
    Dynamically generated writeable type for SessionConfig

    Attributes:
        allow_persistent_sessions: Allow users to have persistent sessions when they login
        session_minutes: Number of minutes for user sessions.  Must be between 5 and 43200
        unlimited_sessions_per_user: Allow users to have an unbounded number of concurrent sessions (otherwise, users will be limited to only one session at a time).
        use_inactivity_based_logout: Enforce session logout for sessions that are inactive for 15 minutes.
        track_session_location: Track location of session when user logs in.
    """

    allow_persistent_sessions: Optional[bool] = None
    session_minutes: Optional[int] = None
    unlimited_sessions_per_user: Optional[bool] = None
    use_inactivity_based_logout: Optional[bool] = None
    track_session_location: Optional[bool] = None

    def __init__(
        self,
        *,
        allow_persistent_sessions: Optional[bool] = None,
        session_minutes: Optional[int] = None,
        unlimited_sessions_per_user: Optional[bool] = None,
        use_inactivity_based_logout: Optional[bool] = None,
        track_session_location: Optional[bool] = None
    ):
        self.allow_persistent_sessions = allow_persistent_sessions
        self.session_minutes = session_minutes
        self.unlimited_sessions_per_user = unlimited_sessions_per_user
        self.use_inactivity_based_logout = use_inactivity_based_logout
        self.track_session_location = track_session_location


@attr.s(auto_attribs=True, kw_only=True)
class WriteSpaceBase(model.Model):
    """
    Dynamically generated writeable type for SpaceBase

    Attributes:
        name: Unique Name
        parent_id: Id of Parent. If the parent id is null, this is a root-level entry
    """

    name: str
    parent_id: Optional[str] = None


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteTheme(model.Model):
    """
    Dynamically generated writeable type for Theme

    Attributes:
        begin_at: Timestamp for when this theme becomes active. Null=always
        end_at: Timestamp for when this theme expires. Null=never
        name: Name of theme. Can only be alphanumeric and underscores.
        settings:
    """

    begin_at: Optional[datetime.datetime] = None
    end_at: Optional[datetime.datetime] = None
    name: Optional[str] = None
    settings: Optional["ThemeSettings"] = None

    def __init__(
        self,
        *,
        begin_at: Optional[datetime.datetime] = None,
        end_at: Optional[datetime.datetime] = None,
        name: Optional[str] = None,
        settings: Optional["ThemeSettings"] = None
    ):
        self.begin_at = begin_at
        self.end_at = end_at
        self.name = name
        self.settings = settings


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteUser(model.Model):
    """
    Dynamically generated writeable type for User

    Attributes:
        credentials_email:
        first_name: First name
        home_space_id: ID string for user's home space
        home_folder_id: ID string for user's home folder
        is_disabled: Account has been disabled
        last_name: Last name
        locale: User's preferred locale. User locale takes precedence over Looker's system-wide default locale. Locale determines language of display strings and date and numeric formatting in API responses. Locale string must be a 2 letter language code or a combination of language code and region code: 'en' or 'en-US', for example.
        models_dir_validated: User's dev workspace has been checked for presence of applicable production projects
        ui_state: Per user dictionary of undocumented state information owned by the Looker UI.
    """

    credentials_email: Optional["WriteCredentialsEmail"] = None
    first_name: Optional[str] = None
    home_space_id: Optional[str] = None
    home_folder_id: Optional[str] = None
    is_disabled: Optional[bool] = None
    last_name: Optional[str] = None
    locale: Optional[str] = None
    models_dir_validated: Optional[bool] = None
    ui_state: Optional[MutableMapping[str, str]] = None

    def __init__(
        self,
        *,
        credentials_email: Optional["WriteCredentialsEmail"] = None,
        first_name: Optional[str] = None,
        home_space_id: Optional[str] = None,
        home_folder_id: Optional[str] = None,
        is_disabled: Optional[bool] = None,
        last_name: Optional[str] = None,
        locale: Optional[str] = None,
        models_dir_validated: Optional[bool] = None,
        ui_state: Optional[MutableMapping[str, str]] = None
    ):
        self.credentials_email = credentials_email
        self.first_name = first_name
        self.home_space_id = home_space_id
        self.home_folder_id = home_folder_id
        self.is_disabled = is_disabled
        self.last_name = last_name
        self.locale = locale
        self.models_dir_validated = models_dir_validated
        self.ui_state = ui_state


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteUserAttribute(model.Model):
    """
    Dynamically generated writeable type for UserAttribute

    Attributes:
        name: Name of user attribute
        label: Human-friendly label for user attribute
        type: Type of user attribute ("string", "number", "datetime", "yesno", "zipcode")
        default_value: Default value for when no value is set on the user
        value_is_hidden: If true, users will not be able to view values of this attribute
        user_can_view: Non-admin users can see the values of their attributes and use them in filters
        user_can_edit: Users can change the value of this attribute for themselves
        hidden_value_domain_whitelist: Destinations to which a hidden attribute may be sent. Once set, cannot be edited.
    """

    name: Optional[str] = None
    label: Optional[str] = None
    type: Optional[str] = None
    default_value: Optional[str] = None
    value_is_hidden: Optional[bool] = None
    user_can_view: Optional[bool] = None
    user_can_edit: Optional[bool] = None
    hidden_value_domain_whitelist: Optional[str] = None

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        label: Optional[str] = None,
        type: Optional[str] = None,
        default_value: Optional[str] = None,
        value_is_hidden: Optional[bool] = None,
        user_can_view: Optional[bool] = None,
        user_can_edit: Optional[bool] = None,
        hidden_value_domain_whitelist: Optional[str] = None
    ):
        self.name = name
        self.label = label
        self.type = type
        self.default_value = default_value
        self.value_is_hidden = value_is_hidden
        self.user_can_view = user_can_view
        self.user_can_edit = user_can_edit
        self.hidden_value_domain_whitelist = hidden_value_domain_whitelist


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteUserAttributeWithValue(model.Model):
    """
    Dynamically generated writeable type for UserAttributeWithValue

    Attributes:
        value: Value of attribute for user
    """

    value: Optional[str] = None

    def __init__(self, *, value: Optional[str] = None):
        self.value = value


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteWelcomeEmailTest(model.Model):
    """
    Dynamically generated writeable type for WelcomeEmailTest

    Attributes:
        content: The content that will be sent as part of a custom welcome email
    """

    content: Optional[str] = None

    def __init__(self, *, content: Optional[str] = None):
        self.content = content


@attr.s(auto_attribs=True, kw_only=True, init=False)
class WriteWhitelabelConfiguration(model.Model):
    """
    Dynamically generated writeable type for WhitelabelConfiguration

    Attributes:
        logo_file: Customer logo image. Expected base64 encoded data (write-only)
        favicon_file: Custom favicon image. Expected base64 encoded data (write-only)
        default_title: Default page title
        show_help_menu: Boolean to toggle showing help menus
        show_docs: Boolean to toggle showing docs
        show_email_sub_options: Boolean to toggle showing email subscription options.
        allow_looker_mentions: Boolean to toggle mentions of Looker in emails
        allow_looker_links: Boolean to toggle links to Looker in emails
    """

    logo_file: Optional[str] = None
    favicon_file: Optional[str] = None
    default_title: Optional[str] = None
    show_help_menu: Optional[bool] = None
    show_docs: Optional[bool] = None
    show_email_sub_options: Optional[bool] = None
    allow_looker_mentions: Optional[bool] = None
    allow_looker_links: Optional[bool] = None

    def __init__(
        self,
        *,
        logo_file: Optional[str] = None,
        favicon_file: Optional[str] = None,
        default_title: Optional[str] = None,
        show_help_menu: Optional[bool] = None,
        show_docs: Optional[bool] = None,
        show_email_sub_options: Optional[bool] = None,
        allow_looker_mentions: Optional[bool] = None,
        allow_looker_links: Optional[bool] = None
    ):
        self.logo_file = logo_file
        self.favicon_file = favicon_file
        self.default_title = default_title
        self.show_help_menu = show_help_menu
        self.show_docs = show_docs
        self.show_email_sub_options = show_email_sub_options
        self.allow_looker_mentions = allow_looker_mentions
        self.allow_looker_links = allow_looker_links


# The following cattrs structure hook registrations are a workaround
# for https://github.com/Tinche/cattrs/pull/42 Once this issue is resolved
# these calls will be removed.

import functools  # noqa:E402
from typing import ForwardRef  # type: ignore  # noqa:E402

structure_hook = functools.partial(sr.structure_hook, globals(), sr.converter31)
sr.converter31.register_structure_hook(
    ForwardRef("AccessToken"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ApiSession"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ApiVersion"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ApiVersionElement"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("BackupConfiguration"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ColorCollection"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ColorStop"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ContentFavorite"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ContentMeta"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ContentMetaGroupUser"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ContentValidation"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ContentValidationDashboard"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ContentValidationDashboardElement"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ContentValidationDashboardFilter"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ContentValidationError"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ContentValidationFolder"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ContentValidationLook"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ContentValidationSpace"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ContentValidatorError"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ContentView"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ContinuousPalette"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("CreateDashboardFilter"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("CreateDashboardRenderTask"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("CreateFolder"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("CreateQueryTask"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("CreateSpace"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("CredentialsApi3"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("CredentialsEmail"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("CredentialsEmbed"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("CredentialsGoogle"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("CredentialsLDAP"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("CredentialsLookerOpenid"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("CredentialsOIDC"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("CredentialsSaml"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("CredentialsTotp"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("CustomWelcomeEmail"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Dashboard"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DashboardBase"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DashboardElement"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DashboardFilter"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DashboardLayout"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DashboardLayoutComponent"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DashboardLookml"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DashboardSettings"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DataActionForm"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DataActionFormField"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DataActionFormSelectOption"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DataActionRequest"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DataActionResponse"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DataActionUserState"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Datagroup"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DBConnection"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DBConnectionBase"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DBConnectionOverride"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DBConnectionTestResult"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Dialect"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DialectInfo"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DialectInfoOptions"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("DiscretePalette"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("EmbedSsoUrl"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("EmbedSsoUrlParams"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Error"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Folder"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("FolderBase"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("GitBranch"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("GitConnectionTest"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("GitConnectionTestResult"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("GitStatus"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Group"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("GroupIdForGroupInclusion"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("GroupIdForGroupUserInclusion"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Homepage"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("HomepageItem"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("HomepageSection"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ImportedProject"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Integration"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("IntegrationHub"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("IntegrationParam"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("IntegrationRequiredField"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("IntegrationTestResult"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("InternalHelpResources"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("InternalHelpResourcesContent"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LDAPConfig"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LDAPConfigTestIssue"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LDAPConfigTestResult"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LDAPGroupRead"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LDAPGroupWrite"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LDAPUser"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LDAPUserAttributeRead"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LDAPUserAttributeWrite"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LegacyFeature"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Locale"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LocalizationSettings"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Look"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookBasic"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookmlModel"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookmlModelExplore"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookmlModelExploreAccessFilter"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookmlModelExploreAlias"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookmlModelExploreAlwaysFilter"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookmlModelExploreConditionallyFilter"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookmlModelExploreError"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookmlModelExploreField"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookmlModelExploreFieldEnumeration"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookmlModelExploreFieldMapLayer"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookmlModelExploreFieldset"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookmlModelExploreFieldSqlCase"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookmlModelExploreFieldTimeInterval"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookmlModelExploreJoins"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    LookmlModelExploreJoins,  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookmlModelExploreSet"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookmlModelExploreSupportedMeasureType"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookmlModelNavExplore"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookmlTest"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookmlTestResult"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookModel"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookWithDashboards"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("LookWithQuery"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Manifest"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("MergeFields"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("MergeQuery"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("MergeQuerySourceQuery"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ModelSet"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ModelsNotValidated"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("OIDCConfig"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("OIDCGroupRead"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("OIDCGroupWrite"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("OIDCUserAttributeRead"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("OIDCUserAttributeWrite"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("PasswordConfig"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Permission"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("PermissionSet"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Project"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ProjectError"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ProjectFile"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ProjectValidation"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ProjectValidationCache"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ProjectWorkspace"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Query"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("QueryTask"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("RenderTask"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("RepositoryCredential"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ResultMakerFilterables"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ResultMakerFilterablesListen"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ResultMakerWithIdVisConfigAndDynamicFields"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Role"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("RunningQueries"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("SamlConfig"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("SamlGroupRead"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("SamlGroupWrite"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("SamlMetadataParseResult"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("SamlUserAttributeRead"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("SamlUserAttributeWrite"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ScheduledPlan"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ScheduledPlanDestination"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Session"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("SessionConfig"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Snippet"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Space"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("SpaceBase"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("SqlQuery"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("SqlQueryCreate"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Theme"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ThemeSettings"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Timezone"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("UpdateFolder"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("UpdateSpace"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("User"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("UserAttribute"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("UserAttributeGroupValue"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("UserAttributeWithValue"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("UserIdOnly"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("UserLoginLockout"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("UserPublic"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ValidationError"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("ValidationErrorDetail"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WelcomeEmailTest"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WhitelabelConfiguration"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("Workspace"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteApiSession"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteBackupConfiguration"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteColorCollection"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteContentFavorite"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteContentMeta"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteCreateDashboardFilter"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteCreateQueryTask"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteCredentialsEmail"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteCustomWelcomeEmail"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteDashboard"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteDashboardBase"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteDashboardElement"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteDashboardFilter"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteDashboardLayout"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteDashboardLayoutComponent"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteDatagroup"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteDBConnection"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteDBConnectionOverride"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteFolderBase"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteGitBranch"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteGroup"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteHomepage"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteHomepageItem"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteHomepageSection"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteIntegration"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteIntegrationHub"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteInternalHelpResources"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteInternalHelpResourcesContent"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteLDAPConfig"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteLegacyFeature"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteLookmlModel"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteLookWithQuery"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteMergeQuery"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteModelSet"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteOIDCConfig"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WritePasswordConfig"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WritePermissionSet"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteProject"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteQuery"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteRepositoryCredential"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteResultMakerWithIdVisConfigAndDynamicFields"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteRole"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteSamlConfig"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteScheduledPlan"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteSessionConfig"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteSpaceBase"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteTheme"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteUser"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteUserAttribute"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteUserAttributeWithValue"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteWelcomeEmailTest"),  # type: ignore
    structure_hook,  # type:ignore
)
sr.converter31.register_structure_hook(
    ForwardRef("WriteWhitelabelConfiguration"),  # type: ignore
    structure_hook,  # type:ignore
)
