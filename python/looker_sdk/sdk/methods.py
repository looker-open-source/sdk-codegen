# 337 API methods

# NOTE: Do not edit this file generated by Looker SDK Codegen for Looker 7.0 API 3.1
import datetime
from typing import MutableMapping, Optional, Sequence, Union

from looker_sdk.sdk import models
from looker_sdk.rtl import api_methods
from looker_sdk.rtl import transport


class LookerSDK(api_methods.APIMethods):

    # POST /integration_hubs/{integration_hub_id}/accept_legal_agreement -> models.IntegrationHub
    def accept_integration_hub_legal_agreement(
        self,
        # Id of integration_hub
        integration_hub_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.IntegrationHub:
        """Accept Integration Hub Legal Agreement"""
        response = self.post(
            f"/integration_hubs/{integration_hub_id}/accept_legal_agreement",
            models.IntegrationHub,
            transport_options=transport_options,
        )
        assert isinstance(response, models.IntegrationHub)
        return response

    # GET /themes/active -> Sequence[models.Theme]
    def active_themes(
        self,
        # Name of theme
        name: Optional[str] = None,
        # Timestamp representing the target datetime for the active period. Defaults to 'now'
        ts: Optional[datetime.datetime] = None,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Theme]:
        """Get Active Themes"""
        response = self.get(
            f"/themes/active",
            Sequence[models.Theme],
            query_params={"name": name, "ts": ts, "fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # POST /groups/{group_id}/groups -> models.Group
    def add_group_group(
        self,
        # Id of group
        group_id: int,
        body: models.GroupIdForGroupInclusion,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Group:
        """Add a Group to Group"""
        response = self.post(
            f"/groups/{group_id}/groups",
            models.Group,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.Group)
        return response

    # POST /groups/{group_id}/users -> models.User
    def add_group_user(
        self,
        # Id of group
        group_id: int,
        body: models.GroupIdForGroupUserInclusion,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.User:
        """Add a User to Group"""
        response = self.post(
            f"/groups/{group_id}/users",
            models.User,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.User)
        return response

    # GET /color_collections -> Sequence[models.ColorCollection]
    def all_color_collections(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.ColorCollection]:
        """Get all Color Collections"""
        response = self.get(
            f"/color_collections",
            Sequence[models.ColorCollection],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /connections -> Sequence[models.DBConnection]
    def all_connections(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.DBConnection]:
        """Get All Connections"""
        response = self.get(
            f"/connections",
            Sequence[models.DBConnection],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /content_metadata_access -> Sequence[models.ContentMetaGroupUser]
    def all_content_metadata_accesses(
        self,
        # Id of content metadata
        content_metadata_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.ContentMetaGroupUser]:
        """Get All Content Metadata Accesses"""
        response = self.get(
            f"/content_metadata_access",
            Sequence[models.ContentMetaGroupUser],
            query_params={"content_metadata_id": content_metadata_id, "fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /content_metadata -> Sequence[models.ContentMeta]
    def all_content_metadatas(
        self,
        # Parent space of content.
        parent_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.ContentMeta]:
        """Get All Content Metadatas"""
        response = self.get(
            f"/content_metadata",
            Sequence[models.ContentMeta],
            query_params={"parent_id": parent_id, "fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /dashboards -> Sequence[models.DashboardBase]
    def all_dashboards(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.DashboardBase]:
        """Get All Dashboards"""
        response = self.get(
            f"/dashboards",
            Sequence[models.DashboardBase],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /datagroups -> Sequence[models.Datagroup]
    def all_datagroups(
        self, transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Datagroup]:
        """Get All Datagroups"""
        response = self.get(
            f"/datagroups",
            Sequence[models.Datagroup],
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /dialect_info -> Sequence[models.DialectInfo]
    def all_dialect_infos(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.DialectInfo]:
        """Get All Dialect Infos"""
        response = self.get(
            f"/dialect_info",
            Sequence[models.DialectInfo],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /folders -> Sequence[models.Folder]
    def all_folders(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Folder]:
        """Get All Folders"""
        response = self.get(
            f"/folders",
            Sequence[models.Folder],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /projects/{project_id}/git_branches -> Sequence[models.GitBranch]
    def all_git_branches(
        self,
        # Project Id
        project_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.GitBranch]:
        """Get All Git Branches"""
        response = self.get(
            f"/projects/{project_id}/git_branches",
            Sequence[models.GitBranch],
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /projects/{project_id}/git_connection_tests -> Sequence[models.GitConnectionTest]
    def all_git_connection_tests(
        self,
        # Project Id
        project_id: str,
        # (Optional: leave blank for root project) The remote url for remote dependency to test.
        remote_url: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.GitConnectionTest]:
        """Get All Git Connection Tests"""
        response = self.get(
            f"/projects/{project_id}/git_connection_tests",
            Sequence[models.GitConnectionTest],
            query_params={"remote_url": remote_url},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /groups/{group_id}/groups -> Sequence[models.Group]
    def all_group_groups(
        self,
        # Id of group
        group_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Group]:
        """Get All Groups in Group"""
        response = self.get(
            f"/groups/{group_id}/groups",
            Sequence[models.Group],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /groups/{group_id}/users -> Sequence[models.User]
    def all_group_users(
        self,
        # Id of group
        group_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        # Requested page.
        page: Optional[int] = None,
        # Results per page.
        per_page: Optional[int] = None,
        # Fields to sort by.
        sorts: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.User]:
        """Get All Users in Group"""
        response = self.get(
            f"/groups/{group_id}/users",
            Sequence[models.User],
            query_params={
                "fields": fields,
                "page": page,
                "per_page": per_page,
                "sorts": sorts,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /groups -> Sequence[models.Group]
    def all_groups(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        # Requested page.
        page: Optional[int] = None,
        # Results per page.
        per_page: Optional[int] = None,
        # Fields to sort by.
        sorts: Optional[str] = None,
        # Optional of ids to get specific groups.
        ids: Optional[models.DelimSequence[int]] = None,
        # Id of content metadata to which groups must have access.
        content_metadata_id: Optional[int] = None,
        # Select only groups that either can/cannot be given access to content.
        can_add_to_content_metadata: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Group]:
        """Get All Groups"""
        response = self.get(
            f"/groups",
            Sequence[models.Group],
            query_params={
                "fields": fields,
                "page": page,
                "per_page": per_page,
                "sorts": sorts,
                "ids": ids,
                "content_metadata_id": content_metadata_id,
                "can_add_to_content_metadata": can_add_to_content_metadata,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /homepage_items -> Sequence[models.HomepageItem]
    def all_homepage_items(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        # Fields to sort by.
        sorts: Optional[str] = None,
        # Filter to a specific homepage section
        homepage_section_id: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.HomepageItem]:
        """Get All Homepage Items"""
        response = self.get(
            f"/homepage_items",
            Sequence[models.HomepageItem],
            query_params={
                "fields": fields,
                "sorts": sorts,
                "homepage_section_id": homepage_section_id,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /homepage_sections -> Sequence[models.HomepageSection]
    def all_homepage_sections(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        # Fields to sort by.
        sorts: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.HomepageSection]:
        """Get All Homepage sections"""
        response = self.get(
            f"/homepage_sections",
            Sequence[models.HomepageSection],
            query_params={"fields": fields, "sorts": sorts},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /homepages -> Sequence[models.Homepage]
    def all_homepages(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Homepage]:
        """Get All Homepages"""
        response = self.get(
            f"/homepages",
            Sequence[models.Homepage],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /integration_hubs -> Sequence[models.IntegrationHub]
    def all_integration_hubs(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.IntegrationHub]:
        """Get All Integration Hubs"""
        response = self.get(
            f"/integration_hubs",
            Sequence[models.IntegrationHub],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /integrations -> Sequence[models.Integration]
    def all_integrations(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        # Filter to a specific provider
        integration_hub_id: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Integration]:
        """Get All Integrations"""
        response = self.get(
            f"/integrations",
            Sequence[models.Integration],
            query_params={"fields": fields, "integration_hub_id": integration_hub_id},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /legacy_features -> Sequence[models.LegacyFeature]
    def all_legacy_features(
        self, transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.LegacyFeature]:
        """Get All Legacy Features"""
        response = self.get(
            f"/legacy_features",
            Sequence[models.LegacyFeature],
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /locales -> Sequence[models.Locale]
    def all_locales(
        self, transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Locale]:
        """Get All Locales"""
        response = self.get(
            f"/locales", Sequence[models.Locale], transport_options=transport_options
        )
        assert isinstance(response, list)
        return response

    # GET /lookml_models -> Sequence[models.LookmlModel]
    def all_lookml_models(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.LookmlModel]:
        """Get All LookML Models"""
        response = self.get(
            f"/lookml_models",
            Sequence[models.LookmlModel],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /projects/{project_id}/lookml_tests -> Sequence[models.LookmlTest]
    def all_lookml_tests(
        self,
        # Project Id
        project_id: str,
        # File Id
        file_id: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.LookmlTest]:
        """Get All LookML Tests"""
        response = self.get(
            f"/projects/{project_id}/lookml_tests",
            Sequence[models.LookmlTest],
            query_params={"file_id": file_id},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /looks -> Sequence[models.Look]
    def all_looks(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Look]:
        """Get All Looks"""
        response = self.get(
            f"/looks",
            Sequence[models.Look],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /model_sets -> Sequence[models.ModelSet]
    def all_model_sets(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.ModelSet]:
        """Get All Model Sets"""
        response = self.get(
            f"/model_sets",
            Sequence[models.ModelSet],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /permission_sets -> Sequence[models.PermissionSet]
    def all_permission_sets(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.PermissionSet]:
        """Get All Permission Sets"""
        response = self.get(
            f"/permission_sets",
            Sequence[models.PermissionSet],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /permissions -> Sequence[models.Permission]
    def all_permissions(
        self, transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Permission]:
        """Get All Permissions"""
        response = self.get(
            f"/permissions",
            Sequence[models.Permission],
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /projects/{project_id}/files -> Sequence[models.ProjectFile]
    def all_project_files(
        self,
        # Project Id
        project_id: str,
        # Requested fields
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.ProjectFile]:
        """Get All Project Files"""
        response = self.get(
            f"/projects/{project_id}/files",
            Sequence[models.ProjectFile],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /projects -> Sequence[models.Project]
    def all_projects(
        self,
        # Requested fields
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Project]:
        """Get All Projects"""
        response = self.get(
            f"/projects",
            Sequence[models.Project],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /roles -> Sequence[models.Role]
    def all_roles(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        # Optional list of ids to get specific roles.
        ids: Optional[models.DelimSequence[int]] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Role]:
        """Get All Roles"""
        response = self.get(
            f"/roles",
            Sequence[models.Role],
            query_params={"fields": fields, "ids": ids},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /running_queries -> Sequence[models.RunningQueries]
    def all_running_queries(
        self, transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.RunningQueries]:
        """Get All Running Queries"""
        response = self.get(
            f"/running_queries",
            Sequence[models.RunningQueries],
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /scheduled_plans -> Sequence[models.ScheduledPlan]
    def all_scheduled_plans(
        self,
        # Return scheduled plans belonging to this user_id. If not provided, returns scheduled plans owned by the caller.
        user_id: Optional[int] = None,
        # Comma delimited list of field names. If provided, only the fields specified will be included in the response
        fields: Optional[str] = None,
        # Return scheduled plans belonging to all users (caller needs see_schedules permission)
        all_users: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.ScheduledPlan]:
        """Get All Scheduled Plans"""
        response = self.get(
            f"/scheduled_plans",
            Sequence[models.ScheduledPlan],
            query_params={"user_id": user_id, "fields": fields, "all_users": all_users},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /spaces -> Sequence[models.SpaceBase]
    def all_spaces(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.SpaceBase]:
        """Get All Spaces"""
        response = self.get(
            f"/spaces",
            Sequence[models.SpaceBase],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /themes -> Sequence[models.Theme]
    def all_themes(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Theme]:
        """Get All Themes"""
        response = self.get(
            f"/themes",
            Sequence[models.Theme],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /timezones -> Sequence[models.Timezone]
    def all_timezones(
        self, transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Timezone]:
        """Get All Timezones"""
        response = self.get(
            f"/timezones",
            Sequence[models.Timezone],
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /user_attributes/{user_attribute_id}/group_values -> Sequence[models.UserAttributeGroupValue]
    def all_user_attribute_group_values(
        self,
        # Id of user attribute
        user_attribute_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.UserAttributeGroupValue]:
        """Get User Attribute Group Values"""
        response = self.get(
            f"/user_attributes/{user_attribute_id}/group_values",
            Sequence[models.UserAttributeGroupValue],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /user_attributes -> Sequence[models.UserAttribute]
    def all_user_attributes(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        # Fields to order the results by. Sortable fields include: name, label
        sorts: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.UserAttribute]:
        """Get All User Attributes"""
        response = self.get(
            f"/user_attributes",
            Sequence[models.UserAttribute],
            query_params={"fields": fields, "sorts": sorts},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /users/{user_id}/credentials_api3 -> Sequence[models.CredentialsApi3]
    def all_user_credentials_api3s(
        self,
        # id of user
        user_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.CredentialsApi3]:
        """Get All API 3 Credentials"""
        response = self.get(
            f"/users/{user_id}/credentials_api3",
            Sequence[models.CredentialsApi3],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /users/{user_id}/credentials_embed -> Sequence[models.CredentialsEmbed]
    def all_user_credentials_embeds(
        self,
        # id of user
        user_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.CredentialsEmbed]:
        """Get All Embedding Credentials"""
        response = self.get(
            f"/users/{user_id}/credentials_embed",
            Sequence[models.CredentialsEmbed],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /user_login_lockouts -> Sequence[models.UserLoginLockout]
    def all_user_login_lockouts(
        self,
        # Include only these fields in the response
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.UserLoginLockout]:
        """Get All User Login Lockouts"""
        response = self.get(
            f"/user_login_lockouts",
            Sequence[models.UserLoginLockout],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /users/{user_id}/sessions -> Sequence[models.Session]
    def all_user_sessions(
        self,
        # id of user
        user_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Session]:
        """Get All Web Login Sessions"""
        response = self.get(
            f"/users/{user_id}/sessions",
            Sequence[models.Session],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /users -> Sequence[models.User]
    def all_users(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        # Requested page.
        page: Optional[int] = None,
        # Results per page.
        per_page: Optional[int] = None,
        # Fields to sort by.
        sorts: Optional[str] = None,
        # Optional list of ids to get specific users.
        ids: Optional[models.DelimSequence[int]] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.User]:
        """Get All Users"""
        response = self.get(
            f"/users",
            Sequence[models.User],
            query_params={
                "fields": fields,
                "page": page,
                "per_page": per_page,
                "sorts": sorts,
                "ids": ids,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /workspaces -> Sequence[models.Workspace]
    def all_workspaces(
        self, transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Workspace]:
        """Get All Workspaces"""
        response = self.get(
            f"/workspaces",
            Sequence[models.Workspace],
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /backup_configuration -> models.BackupConfiguration
    def backup_configuration(
        self, transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.BackupConfiguration:
        """Get Backup Configuration"""
        response = self.get(
            f"/backup_configuration",
            models.BackupConfiguration,
            transport_options=transport_options,
        )
        assert isinstance(response, models.BackupConfiguration)
        return response

    # GET /color_collections/{collection_id} -> models.ColorCollection
    def color_collection(
        self,
        # Id of Color Collection
        collection_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ColorCollection:
        """Get Color Collection by ID"""
        response = self.get(
            f"/color_collections/{collection_id}",
            models.ColorCollection,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.ColorCollection)
        return response

    # GET /color_collections/custom -> Sequence[models.ColorCollection]
    def color_collections_custom(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.ColorCollection]:
        """Get all Custom Color Collections"""
        response = self.get(
            f"/color_collections/custom",
            Sequence[models.ColorCollection],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /color_collections/standard -> Sequence[models.ColorCollection]
    def color_collections_standard(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.ColorCollection]:
        """Get all Standard Color Collections"""
        response = self.get(
            f"/color_collections/standard",
            Sequence[models.ColorCollection],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /connections/{connection_name} -> models.DBConnection
    def connection(
        self,
        # Name of connection
        connection_name: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.DBConnection:
        """Get Connection"""
        response = self.get(
            f"/connections/{connection_name}",
            models.DBConnection,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.DBConnection)
        return response

    # GET /content_favorite/{content_favorite_id} -> models.ContentFavorite
    def content_favorite(
        self,
        # Id of favorite content
        content_favorite_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ContentFavorite:
        """Get Favorite Content"""
        response = self.get(
            f"/content_favorite/{content_favorite_id}",
            models.ContentFavorite,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.ContentFavorite)
        return response

    # GET /content_metadata/{content_metadata_id} -> models.ContentMeta
    def content_metadata(
        self,
        # Id of content metadata
        content_metadata_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ContentMeta:
        """Get Content Metadata"""
        response = self.get(
            f"/content_metadata/{content_metadata_id}",
            models.ContentMeta,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.ContentMeta)
        return response

    # GET /content_validation -> models.ContentValidation
    def content_validation(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ContentValidation:
        """Validate Content"""
        response = self.get(
            f"/content_validation",
            models.ContentValidation,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.ContentValidation)
        return response

    # POST /color_collections -> models.ColorCollection
    def create_color_collection(
        self,
        body: models.WriteColorCollection,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ColorCollection:
        """Create ColorCollection"""
        response = self.post(
            f"/color_collections",
            models.ColorCollection,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.ColorCollection)
        return response

    # POST /connections -> models.DBConnection
    def create_connection(
        self,
        body: models.WriteDBConnection,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.DBConnection:
        """Create Connection"""
        response = self.post(
            f"/connections",
            models.DBConnection,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.DBConnection)
        return response

    # POST /content_favorite -> models.ContentFavorite
    def create_content_favorite(
        self,
        body: models.WriteContentFavorite,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ContentFavorite:
        """Create Favorite Content"""
        response = self.post(
            f"/content_favorite",
            models.ContentFavorite,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.ContentFavorite)
        return response

    # POST /content_metadata_access -> models.ContentMetaGroupUser
    def create_content_metadata_access(
        self,
        body: models.ContentMetaGroupUser,
        # Optionally sends notification email when granting access to a board.
        send_boards_notification_email: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ContentMetaGroupUser:
        """Create Content Metadata Access"""
        response = self.post(
            f"/content_metadata_access",
            models.ContentMetaGroupUser,
            query_params={
                "send_boards_notification_email": send_boards_notification_email
            },
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.ContentMetaGroupUser)
        return response

    # POST /dashboards -> models.Dashboard
    def create_dashboard(
        self,
        body: models.WriteDashboard,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Dashboard:
        """Create Dashboard"""
        response = self.post(
            f"/dashboards",
            models.Dashboard,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.Dashboard)
        return response

    # POST /dashboard_elements -> models.DashboardElement
    def create_dashboard_element(
        self,
        body: models.WriteDashboardElement,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.DashboardElement:
        """Create DashboardElement"""
        response = self.post(
            f"/dashboard_elements",
            models.DashboardElement,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.DashboardElement)
        return response

    # POST /dashboard_filters -> models.DashboardFilter
    def create_dashboard_filter(
        self,
        body: models.WriteCreateDashboardFilter,
        # Requested fields
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.DashboardFilter:
        """Create Dashboard Filter"""
        response = self.post(
            f"/dashboard_filters",
            models.DashboardFilter,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.DashboardFilter)
        return response

    # POST /dashboard_layouts -> models.DashboardLayout
    def create_dashboard_layout(
        self,
        body: models.WriteDashboardLayout,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.DashboardLayout:
        """Create DashboardLayout"""
        response = self.post(
            f"/dashboard_layouts",
            models.DashboardLayout,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.DashboardLayout)
        return response

    # POST /render_tasks/dashboards/{dashboard_id}/{result_format} -> models.RenderTask
    def create_dashboard_render_task(
        self,
        # Id of dashboard to render
        dashboard_id: int,
        # Output type: pdf, png, or jpg
        result_format: str,
        body: models.CreateDashboardRenderTask,
        # Output width in pixels
        width: int,
        # Output height in pixels
        height: int,
        # Requested fields.
        fields: Optional[str] = None,
        # Paper size for pdf
        pdf_paper_size: Optional[str] = None,
        # Whether to render pdf in landscape
        pdf_landscape: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.RenderTask:
        """Create Dashboard Render Task"""
        response = self.post(
            f"/render_tasks/dashboards/{dashboard_id}/{result_format}",
            models.RenderTask,
            query_params={
                "width": width,
                "height": height,
                "fields": fields,
                "pdf_paper_size": pdf_paper_size,
                "pdf_landscape": pdf_landscape,
            },
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.RenderTask)
        return response

    # POST /folders -> models.Folder
    def create_folder(
        self,
        body: models.WriteCreateFolder,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Folder:
        """Create Folder"""
        response = self.post(
            f"/folders", models.Folder, body=body, transport_options=transport_options
        )
        assert isinstance(response, models.Folder)
        return response

    # POST /projects/{project_id}/git_branch -> models.GitBranch
    def create_git_branch(
        self,
        # Project Id
        project_id: str,
        body: models.WriteGitBranch,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.GitBranch:
        """Checkout New Git Branch"""
        response = self.post(
            f"/projects/{project_id}/git_branch",
            models.GitBranch,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.GitBranch)
        return response

    # POST /projects/{project_id}/git/deploy_key -> str
    def create_git_deploy_key(
        self,
        # Project Id
        project_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Create Deploy Key"""
        response = self.post(
            f"/projects/{project_id}/git/deploy_key",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # POST /groups -> models.Group
    def create_group(
        self,
        body: models.WriteGroup,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Group:
        """Create Group"""
        response = self.post(
            f"/groups",
            models.Group,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.Group)
        return response

    # POST /homepages -> models.Homepage
    def create_homepage(
        self,
        body: models.WriteHomepage,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Homepage:
        """Create Homepage"""
        response = self.post(
            f"/homepages",
            models.Homepage,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.Homepage)
        return response

    # POST /homepage_items -> models.HomepageItem
    def create_homepage_item(
        self,
        body: models.WriteHomepageItem,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.HomepageItem:
        """Create Homepage Item"""
        response = self.post(
            f"/homepage_items",
            models.HomepageItem,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.HomepageItem)
        return response

    # POST /homepage_sections -> models.HomepageSection
    def create_homepage_section(
        self,
        body: models.WriteHomepageSection,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.HomepageSection:
        """Create Homepage section"""
        response = self.post(
            f"/homepage_sections",
            models.HomepageSection,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.HomepageSection)
        return response

    # POST /integration_hubs -> models.IntegrationHub
    def create_integration_hub(
        self,
        body: models.WriteIntegrationHub,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.IntegrationHub:
        """Create Integration Hub"""
        response = self.post(
            f"/integration_hubs",
            models.IntegrationHub,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.IntegrationHub)
        return response

    # POST /looks -> models.LookWithQuery
    def create_look(
        self,
        body: models.WriteLookWithQuery,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.LookWithQuery:
        """Create Look"""
        response = self.post(
            f"/looks",
            models.LookWithQuery,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.LookWithQuery)
        return response

    # POST /render_tasks/looks/{look_id}/{result_format} -> models.RenderTask
    def create_look_render_task(
        self,
        # Id of look to render
        look_id: int,
        # Output type: png, or jpg
        result_format: str,
        # Output width in pixels
        width: int,
        # Output height in pixels
        height: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.RenderTask:
        """Create Look Render Task"""
        response = self.post(
            f"/render_tasks/looks/{look_id}/{result_format}",
            models.RenderTask,
            query_params={"width": width, "height": height, "fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.RenderTask)
        return response

    # POST /render_tasks/lookml_dashboards/{dashboard_id}/{result_format} -> models.RenderTask
    def create_lookml_dashboard_render_task(
        self,
        # Id of lookml dashboard to render
        dashboard_id: str,
        # Output type: pdf, png, or jpg
        result_format: str,
        body: models.CreateDashboardRenderTask,
        # Output width in pixels
        width: int,
        # Output height in pixels
        height: int,
        # Requested fields.
        fields: Optional[str] = None,
        # Paper size for pdf
        pdf_paper_size: Optional[str] = None,
        # Whether to render pdf in landscape
        pdf_landscape: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.RenderTask:
        """Create Lookml Dashboard Render Task"""
        response = self.post(
            f"/render_tasks/lookml_dashboards/{dashboard_id}/{result_format}",
            models.RenderTask,
            query_params={
                "width": width,
                "height": height,
                "fields": fields,
                "pdf_paper_size": pdf_paper_size,
                "pdf_landscape": pdf_landscape,
            },
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.RenderTask)
        return response

    # POST /lookml_models -> models.LookmlModel
    def create_lookml_model(
        self,
        body: models.WriteLookmlModel,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.LookmlModel:
        """Create LookML Model"""
        response = self.post(
            f"/lookml_models",
            models.LookmlModel,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.LookmlModel)
        return response

    # POST /merge_queries -> models.MergeQuery
    def create_merge_query(
        self,
        body: Optional[models.WriteMergeQuery] = None,
        # Requested fields
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.MergeQuery:
        """Create Merge Query"""
        response = self.post(
            f"/merge_queries",
            models.MergeQuery,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.MergeQuery)
        return response

    # POST /model_sets -> models.ModelSet
    def create_model_set(
        self,
        body: models.WriteModelSet,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ModelSet:
        """Create Model Set"""
        response = self.post(
            f"/model_sets",
            models.ModelSet,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.ModelSet)
        return response

    # POST /oidc_test_configs -> models.OIDCConfig
    def create_oidc_test_config(
        self,
        body: models.WriteOIDCConfig,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.OIDCConfig:
        """Create OIDC Test Configuration"""
        response = self.post(
            f"/oidc_test_configs",
            models.OIDCConfig,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.OIDCConfig)
        return response

    # POST /permission_sets -> models.PermissionSet
    def create_permission_set(
        self,
        body: models.WritePermissionSet,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.PermissionSet:
        """Create Permission Set"""
        response = self.post(
            f"/permission_sets",
            models.PermissionSet,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.PermissionSet)
        return response

    # POST /projects -> models.Project
    def create_project(
        self,
        body: models.WriteProject,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Project:
        """Create Project"""
        response = self.post(
            f"/projects", models.Project, body=body, transport_options=transport_options
        )
        assert isinstance(response, models.Project)
        return response

    # POST /queries -> models.Query
    def create_query(
        self,
        body: models.WriteQuery,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Query:
        """Create Query"""
        response = self.post(
            f"/queries",
            models.Query,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.Query)
        return response

    # POST /render_tasks/queries/{query_id}/{result_format} -> models.RenderTask
    def create_query_render_task(
        self,
        # Id of the query to render
        query_id: int,
        # Output type: png or jpg
        result_format: str,
        # Output width in pixels
        width: int,
        # Output height in pixels
        height: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.RenderTask:
        """Create Query Render Task"""
        response = self.post(
            f"/render_tasks/queries/{query_id}/{result_format}",
            models.RenderTask,
            query_params={"width": width, "height": height, "fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.RenderTask)
        return response

    # POST /query_tasks -> models.QueryTask
    def create_query_task(
        self,
        body: models.WriteCreateQueryTask,
        # Row limit (may override the limit in the saved query).
        limit: Optional[int] = None,
        # Apply model-specified formatting to each result.
        apply_formatting: Optional[bool] = None,
        # Apply visualization options to results.
        apply_vis: Optional[bool] = None,
        # Get results from cache if available.
        cache: Optional[bool] = None,
        # Render width for image formats.
        image_width: Optional[int] = None,
        # Render height for image formats.
        image_height: Optional[int] = None,
        # Generate drill links (only applicable to 'json_detail' format.
        generate_drill_links: Optional[bool] = None,
        # Force use of production models even if the user is in development mode.
        force_production: Optional[bool] = None,
        # Retrieve any results from cache even if the results have expired.
        cache_only: Optional[bool] = None,
        # Prefix to use for drill links (url encoded).
        path_prefix: Optional[str] = None,
        # Rebuild PDTS used in query.
        rebuild_pdts: Optional[bool] = None,
        # Perform table calculations on query results
        server_table_calcs: Optional[bool] = None,
        # Requested fields
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.QueryTask:
        """Run Query Async"""
        response = self.post(
            f"/query_tasks",
            models.QueryTask,
            query_params={
                "limit": limit,
                "apply_formatting": apply_formatting,
                "apply_vis": apply_vis,
                "cache": cache,
                "image_width": image_width,
                "image_height": image_height,
                "generate_drill_links": generate_drill_links,
                "force_production": force_production,
                "cache_only": cache_only,
                "path_prefix": path_prefix,
                "rebuild_pdts": rebuild_pdts,
                "server_table_calcs": server_table_calcs,
                "fields": fields,
            },
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.QueryTask)
        return response

    # POST /roles -> models.Role
    def create_role(
        self,
        body: models.WriteRole,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Role:
        """Create Role"""
        response = self.post(
            f"/roles", models.Role, body=body, transport_options=transport_options
        )
        assert isinstance(response, models.Role)
        return response

    # POST /saml_test_configs -> models.SamlConfig
    def create_saml_test_config(
        self,
        body: models.WriteSamlConfig,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.SamlConfig:
        """Create SAML Test Configuration"""
        response = self.post(
            f"/saml_test_configs",
            models.SamlConfig,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.SamlConfig)
        return response

    # POST /scheduled_plans -> models.ScheduledPlan
    def create_scheduled_plan(
        self,
        body: models.WriteScheduledPlan,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ScheduledPlan:
        """Create Scheduled Plan"""
        response = self.post(
            f"/scheduled_plans",
            models.ScheduledPlan,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.ScheduledPlan)
        return response

    # POST /spaces -> models.Space
    def create_space(
        self,
        body: models.WriteCreateSpace,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Space:
        """Create Space"""
        response = self.post(
            f"/spaces", models.Space, body=body, transport_options=transport_options
        )
        assert isinstance(response, models.Space)
        return response

    # POST /sql_queries -> models.SqlQuery
    def create_sql_query(
        self,
        body: models.WriteSqlQueryCreate,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.SqlQuery:
        """Create SQL Runner Query"""
        response = self.post(
            f"/sql_queries",
            models.SqlQuery,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.SqlQuery)
        return response

    # POST /embed/sso_url -> models.EmbedSsoUrl
    def create_sso_embed_url(
        self,
        body: models.WriteEmbedSsoUrlParams,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.EmbedSsoUrl:
        """Create SSO Embed Url"""
        response = self.post(
            f"/embed/sso_url",
            models.EmbedSsoUrl,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.EmbedSsoUrl)
        return response

    # POST /themes -> models.Theme
    def create_theme(
        self,
        body: models.WriteTheme,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Theme:
        """Create Theme"""
        response = self.post(
            f"/themes", models.Theme, body=body, transport_options=transport_options
        )
        assert isinstance(response, models.Theme)
        return response

    # POST /users -> models.User
    def create_user(
        self,
        body: Optional[models.WriteUser] = None,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.User:
        """Create User"""
        response = self.post(
            f"/users",
            models.User,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.User)
        return response

    # POST /user_attributes -> models.UserAttribute
    def create_user_attribute(
        self,
        body: models.WriteUserAttribute,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.UserAttribute:
        """Create User Attribute"""
        response = self.post(
            f"/user_attributes",
            models.UserAttribute,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.UserAttribute)
        return response

    # POST /users/{user_id}/credentials_api3 -> models.CredentialsApi3
    def create_user_credentials_api3(
        self,
        # id of user
        user_id: int,
        body: Optional[models.CredentialsApi3] = None,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.CredentialsApi3:
        """Create API 3 Credential"""
        response = self.post(
            f"/users/{user_id}/credentials_api3",
            models.CredentialsApi3,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.CredentialsApi3)
        return response

    # POST /users/{user_id}/credentials_email -> models.CredentialsEmail
    def create_user_credentials_email(
        self,
        # id of user
        user_id: int,
        body: models.WriteCredentialsEmail,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.CredentialsEmail:
        """Create Email/Password Credential"""
        response = self.post(
            f"/users/{user_id}/credentials_email",
            models.CredentialsEmail,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.CredentialsEmail)
        return response

    # POST /users/{user_id}/credentials_email/password_reset -> models.CredentialsEmail
    def create_user_credentials_email_password_reset(
        self,
        # Id of user
        user_id: int,
        # Expiring token.
        expires: Optional[bool] = None,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.CredentialsEmail:
        """Create Password Reset Token"""
        response = self.post(
            f"/users/{user_id}/credentials_email/password_reset",
            models.CredentialsEmail,
            query_params={"expires": expires, "fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.CredentialsEmail)
        return response

    # POST /users/{user_id}/credentials_totp -> models.CredentialsTotp
    def create_user_credentials_totp(
        self,
        # id of user
        user_id: int,
        body: Optional[models.CredentialsTotp] = None,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.CredentialsTotp:
        """Create Two-Factor Credential"""
        response = self.post(
            f"/users/{user_id}/credentials_totp",
            models.CredentialsTotp,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.CredentialsTotp)
        return response

    # GET /custom_welcome_email -> models.CustomWelcomeEmail
    def custom_welcome_email(
        self, transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.CustomWelcomeEmail:
        """Get Custom Welcome Email"""
        response = self.get(
            f"/custom_welcome_email",
            models.CustomWelcomeEmail,
            transport_options=transport_options,
        )
        assert isinstance(response, models.CustomWelcomeEmail)
        return response

    # GET /dashboards/{dashboard_id} -> models.Dashboard
    def dashboard(
        self,
        # Id of dashboard
        dashboard_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Dashboard:
        """Get Dashboard"""
        response = self.get(
            f"/dashboards/{dashboard_id}",
            models.Dashboard,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.Dashboard)
        return response

    # GET /dashboards/{dashboard_id}/dashboard_elements -> Sequence[models.DashboardElement]
    def dashboard_dashboard_elements(
        self,
        # Id of dashboard
        dashboard_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.DashboardElement]:
        """Get All DashboardElements"""
        response = self.get(
            f"/dashboards/{dashboard_id}/dashboard_elements",
            Sequence[models.DashboardElement],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /dashboards/{dashboard_id}/dashboard_filters -> Sequence[models.DashboardFilter]
    def dashboard_dashboard_filters(
        self,
        # Id of dashboard
        dashboard_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.DashboardFilter]:
        """Get All Dashboard Filters"""
        response = self.get(
            f"/dashboards/{dashboard_id}/dashboard_filters",
            Sequence[models.DashboardFilter],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /dashboards/{dashboard_id}/dashboard_layouts -> Sequence[models.DashboardLayout]
    def dashboard_dashboard_layouts(
        self,
        # Id of dashboard
        dashboard_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.DashboardLayout]:
        """Get All DashboardLayouts"""
        response = self.get(
            f"/dashboards/{dashboard_id}/dashboard_layouts",
            Sequence[models.DashboardLayout],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /dashboard_elements/{dashboard_element_id} -> models.DashboardElement
    def dashboard_element(
        self,
        # Id of dashboard element
        dashboard_element_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.DashboardElement:
        """Get DashboardElement"""
        response = self.get(
            f"/dashboard_elements/{dashboard_element_id}",
            models.DashboardElement,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.DashboardElement)
        return response

    # GET /dashboard_filters/{dashboard_filter_id} -> models.DashboardFilter
    def dashboard_filter(
        self,
        # Id of dashboard filters
        dashboard_filter_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.DashboardFilter:
        """Get Dashboard Filter"""
        response = self.get(
            f"/dashboard_filters/{dashboard_filter_id}",
            models.DashboardFilter,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.DashboardFilter)
        return response

    # GET /dashboard_layouts/{dashboard_layout_id} -> models.DashboardLayout
    def dashboard_layout(
        self,
        # Id of dashboard layouts
        dashboard_layout_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.DashboardLayout:
        """Get DashboardLayout"""
        response = self.get(
            f"/dashboard_layouts/{dashboard_layout_id}",
            models.DashboardLayout,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.DashboardLayout)
        return response

    # GET /dashboard_layout_components/{dashboard_layout_component_id} -> models.DashboardLayoutComponent
    def dashboard_layout_component(
        self,
        # Id of dashboard layout component
        dashboard_layout_component_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.DashboardLayoutComponent:
        """Get DashboardLayoutComponent"""
        response = self.get(
            f"/dashboard_layout_components/{dashboard_layout_component_id}",
            models.DashboardLayoutComponent,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.DashboardLayoutComponent)
        return response

    # GET /dashboard_layouts/{dashboard_layout_id}/dashboard_layout_components -> Sequence[models.DashboardLayoutComponent]
    def dashboard_layout_dashboard_layout_components(
        self,
        # Id of dashboard layout component
        dashboard_layout_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.DashboardLayoutComponent]:
        """Get All DashboardLayoutComponents"""
        response = self.get(
            f"/dashboard_layouts/{dashboard_layout_id}/dashboard_layout_components",
            Sequence[models.DashboardLayoutComponent],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /datagroups/{datagroup_id} -> models.Datagroup
    def datagroup(
        self,
        # ID of datagroup.
        datagroup_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Datagroup:
        """Get Datagroup"""
        response = self.get(
            f"/datagroups/{datagroup_id}",
            models.Datagroup,
            transport_options=transport_options,
        )
        assert isinstance(response, models.Datagroup)
        return response

    # GET /color_collections/default -> models.ColorCollection
    def default_color_collection(
        self, transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ColorCollection:
        """Get Default Color Collection"""
        response = self.get(
            f"/color_collections/default",
            models.ColorCollection,
            transport_options=transport_options,
        )
        assert isinstance(response, models.ColorCollection)
        return response

    # GET /themes/default -> models.Theme
    def default_theme(
        self,
        # Timestamp representing the target datetime for the active period. Defaults to 'now'
        ts: Optional[datetime.datetime] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Theme:
        """Get Default Theme"""
        response = self.get(
            f"/themes/default",
            models.Theme,
            query_params={"ts": ts},
            transport_options=transport_options,
        )
        assert isinstance(response, models.Theme)
        return response

    # DELETE /color_collections/{collection_id} -> str
    def delete_color_collection(
        self,
        # Id of Color Collection
        collection_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete ColorCollection"""
        response = self.delete(
            f"/color_collections/{collection_id}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /connections/{connection_name} -> str
    def delete_connection(
        self,
        # Name of connection
        connection_name: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Connection"""
        response = self.delete(
            f"/connections/{connection_name}", str, transport_options=transport_options
        )
        assert isinstance(response, str)
        return response

    # DELETE /connections/{connection_name}/connection_override/{override_context} -> str
    def delete_connection_override(
        self,
        # Name of connection
        connection_name: str,
        # Context of connection override
        override_context: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Connection Override"""
        response = self.delete(
            f"/connections/{connection_name}/connection_override/{override_context}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /content_favorite/{content_favorite_id} -> str
    def delete_content_favorite(
        self,
        # Id of favorite content
        content_favorite_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Favorite Content"""
        response = self.delete(
            f"/content_favorite/{content_favorite_id}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /content_metadata_access/{content_metadata_access_id} -> str
    def delete_content_metadata_access(
        self,
        # Id of content metadata access
        content_metadata_access_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Content Metadata Access"""
        response = self.delete(
            f"/content_metadata_access/{content_metadata_access_id}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /dashboards/{dashboard_id} -> str
    def delete_dashboard(
        self,
        # Id of dashboard
        dashboard_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Dashboard"""
        response = self.delete(
            f"/dashboards/{dashboard_id}", str, transport_options=transport_options
        )
        assert isinstance(response, str)
        return response

    # DELETE /dashboard_elements/{dashboard_element_id} -> str
    def delete_dashboard_element(
        self,
        # Id of dashboard element
        dashboard_element_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete DashboardElement"""
        response = self.delete(
            f"/dashboard_elements/{dashboard_element_id}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /dashboard_filters/{dashboard_filter_id} -> str
    def delete_dashboard_filter(
        self,
        # Id of dashboard filter
        dashboard_filter_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Dashboard Filter"""
        response = self.delete(
            f"/dashboard_filters/{dashboard_filter_id}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /dashboard_layouts/{dashboard_layout_id} -> str
    def delete_dashboard_layout(
        self,
        # Id of dashboard layout
        dashboard_layout_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete DashboardLayout"""
        response = self.delete(
            f"/dashboard_layouts/{dashboard_layout_id}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /folders/{folder_id} -> str
    def delete_folder(
        self,
        # Id of folder
        folder_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Folder"""
        response = self.delete(
            f"/folders/{folder_id}", str, transport_options=transport_options
        )
        assert isinstance(response, str)
        return response

    # DELETE /projects/{project_id}/git_branch/{branch_name} -> str
    def delete_git_branch(
        self,
        # Project Id
        project_id: str,
        # Branch Name
        branch_name: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete a Git Branch"""
        response = self.delete(
            f"/projects/{project_id}/git_branch/{branch_name}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /groups/{group_id} -> str
    def delete_group(
        self,
        # Id of group
        group_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Group"""
        response = self.delete(
            f"/groups/{group_id}", str, transport_options=transport_options
        )
        assert isinstance(response, str)
        return response

    # DELETE /groups/{group_id}/groups/{deleting_group_id} -> None
    def delete_group_from_group(
        self,
        # Id of group
        group_id: int,
        # Id of group to delete
        deleting_group_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> None:
        """Deletes a Group from Group"""
        response = self.delete(
            f"/groups/{group_id}/groups/{deleting_group_id}",
            None,
            transport_options=transport_options,
        )
        assert response is None
        return response

    # DELETE /groups/{group_id}/users/{user_id} -> None
    def delete_group_user(
        self,
        # Id of group
        group_id: int,
        # Id of user to remove from group
        user_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> None:
        """Remove a User from Group"""
        response = self.delete(
            f"/groups/{group_id}/users/{user_id}",
            None,
            transport_options=transport_options,
        )
        assert response is None
        return response

    # DELETE /homepages/{homepage_id} -> str
    def delete_homepage(
        self,
        # Id of homepage
        homepage_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Homepage"""
        response = self.delete(
            f"/homepages/{homepage_id}", str, transport_options=transport_options
        )
        assert isinstance(response, str)
        return response

    # DELETE /homepage_items/{homepage_item_id} -> str
    def delete_homepage_item(
        self,
        # Id of homepage_item
        homepage_item_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Homepage Item"""
        response = self.delete(
            f"/homepage_items/{homepage_item_id}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /homepage_sections/{homepage_section_id} -> str
    def delete_homepage_section(
        self,
        # Id of homepage_section
        homepage_section_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Homepage section"""
        response = self.delete(
            f"/homepage_sections/{homepage_section_id}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /integration_hubs/{integration_hub_id} -> str
    def delete_integration_hub(
        self,
        # Id of integration_hub
        integration_hub_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Integration Hub"""
        response = self.delete(
            f"/integration_hubs/{integration_hub_id}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /looks/{look_id} -> str
    def delete_look(
        self,
        # Id of look
        look_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Look"""
        response = self.delete(
            f"/looks/{look_id}", str, transport_options=transport_options
        )
        assert isinstance(response, str)
        return response

    # DELETE /lookml_models/{lookml_model_name} -> str
    def delete_lookml_model(
        self,
        # Name of lookml model.
        lookml_model_name: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete LookML Model"""
        response = self.delete(
            f"/lookml_models/{lookml_model_name}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /model_sets/{model_set_id} -> str
    def delete_model_set(
        self,
        # id of model set
        model_set_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Model Set"""
        response = self.delete(
            f"/model_sets/{model_set_id}", str, transport_options=transport_options
        )
        assert isinstance(response, str)
        return response

    # DELETE /oidc_test_configs/{test_slug} -> str
    def delete_oidc_test_config(
        self,
        # Slug of test config
        test_slug: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete OIDC Test Configuration"""
        response = self.delete(
            f"/oidc_test_configs/{test_slug}", str, transport_options=transport_options
        )
        assert isinstance(response, str)
        return response

    # DELETE /permission_sets/{permission_set_id} -> str
    def delete_permission_set(
        self,
        # Id of permission set
        permission_set_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Permission Set"""
        response = self.delete(
            f"/permission_sets/{permission_set_id}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /projects/{root_project_id}/credential/{credential_id} -> str
    def delete_repository_credential(
        self,
        # Root Project Id
        root_project_id: str,
        # Credential Id
        credential_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Repository Credential"""
        response = self.delete(
            f"/projects/{root_project_id}/credential/{credential_id}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /roles/{role_id} -> str
    def delete_role(
        self,
        # id of role
        role_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Role"""
        response = self.delete(
            f"/roles/{role_id}", str, transport_options=transport_options
        )
        assert isinstance(response, str)
        return response

    # DELETE /saml_test_configs/{test_slug} -> str
    def delete_saml_test_config(
        self,
        # Slug of test config
        test_slug: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete SAML Test Configuration"""
        response = self.delete(
            f"/saml_test_configs/{test_slug}", str, transport_options=transport_options
        )
        assert isinstance(response, str)
        return response

    # DELETE /scheduled_plans/{scheduled_plan_id} -> str
    def delete_scheduled_plan(
        self,
        # Scheduled Plan Id
        scheduled_plan_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Scheduled Plan"""
        response = self.delete(
            f"/scheduled_plans/{scheduled_plan_id}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /spaces/{space_id} -> str
    def delete_space(
        self,
        # Id of space
        space_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Space"""
        response = self.delete(
            f"/spaces/{space_id}", str, transport_options=transport_options
        )
        assert isinstance(response, str)
        return response

    # DELETE /themes/{theme_id} -> str
    def delete_theme(
        self,
        # Id of theme
        theme_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Theme"""
        response = self.delete(
            f"/themes/{theme_id}", str, transport_options=transport_options
        )
        assert isinstance(response, str)
        return response

    # DELETE /users/{user_id} -> str
    def delete_user(
        self,
        # Id of user
        user_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete User"""
        response = self.delete(
            f"/users/{user_id}", str, transport_options=transport_options
        )
        assert isinstance(response, str)
        return response

    # DELETE /user_attributes/{user_attribute_id} -> str
    def delete_user_attribute(
        self,
        # Id of user_attribute
        user_attribute_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete User Attribute"""
        response = self.delete(
            f"/user_attributes/{user_attribute_id}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /groups/{group_id}/attribute_values/{user_attribute_id} -> None
    def delete_user_attribute_group_value(
        self,
        # Id of group
        group_id: int,
        # Id of user attribute
        user_attribute_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> None:
        """Delete User Attribute Group Value"""
        response = self.delete(
            f"/groups/{group_id}/attribute_values/{user_attribute_id}",
            None,
            transport_options=transport_options,
        )
        assert response is None
        return response

    # DELETE /users/{user_id}/attribute_values/{user_attribute_id} -> None
    def delete_user_attribute_user_value(
        self,
        # Id of user
        user_id: int,
        # Id of user attribute
        user_attribute_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> None:
        """Delete User Attribute User Value"""
        response = self.delete(
            f"/users/{user_id}/attribute_values/{user_attribute_id}",
            None,
            transport_options=transport_options,
        )
        assert response is None
        return response

    # DELETE /users/{user_id}/credentials_api3/{credentials_api3_id} -> str
    def delete_user_credentials_api3(
        self,
        # id of user
        user_id: int,
        # id of API 3 Credential
        credentials_api3_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete API 3 Credential"""
        response = self.delete(
            f"/users/{user_id}/credentials_api3/{credentials_api3_id}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /users/{user_id}/credentials_email -> str
    def delete_user_credentials_email(
        self,
        # id of user
        user_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Email/Password Credential"""
        response = self.delete(
            f"/users/{user_id}/credentials_email",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /users/{user_id}/credentials_embed/{credentials_embed_id} -> str
    def delete_user_credentials_embed(
        self,
        # id of user
        user_id: int,
        # id of Embedding Credential
        credentials_embed_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Embedding Credential"""
        response = self.delete(
            f"/users/{user_id}/credentials_embed/{credentials_embed_id}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /users/{user_id}/credentials_google -> str
    def delete_user_credentials_google(
        self,
        # id of user
        user_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Google Auth Credential"""
        response = self.delete(
            f"/users/{user_id}/credentials_google",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /users/{user_id}/credentials_ldap -> str
    def delete_user_credentials_ldap(
        self,
        # id of user
        user_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete LDAP Credential"""
        response = self.delete(
            f"/users/{user_id}/credentials_ldap",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /users/{user_id}/credentials_looker_openid -> str
    def delete_user_credentials_looker_openid(
        self,
        # id of user
        user_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Looker OpenId Credential"""
        response = self.delete(
            f"/users/{user_id}/credentials_looker_openid",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /users/{user_id}/credentials_oidc -> str
    def delete_user_credentials_oidc(
        self,
        # id of user
        user_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete OIDC Auth Credential"""
        response = self.delete(
            f"/users/{user_id}/credentials_oidc",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /users/{user_id}/credentials_saml -> str
    def delete_user_credentials_saml(
        self,
        # id of user
        user_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Saml Auth Credential"""
        response = self.delete(
            f"/users/{user_id}/credentials_saml",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /users/{user_id}/credentials_totp -> str
    def delete_user_credentials_totp(
        self,
        # id of user
        user_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Two-Factor Credential"""
        response = self.delete(
            f"/users/{user_id}/credentials_totp",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # DELETE /user_login_lockout/{key} -> str
    def delete_user_login_lockout(
        self,
        # The key associated with the locked user
        key: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete User Login Lockout"""
        response = self.delete(
            f"/user_login_lockout/{key}", str, transport_options=transport_options
        )
        assert isinstance(response, str)
        return response

    # DELETE /users/{user_id}/sessions/{session_id} -> str
    def delete_user_session(
        self,
        # id of user
        user_id: int,
        # id of Web Login Session
        session_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Delete Web Login Session"""
        response = self.delete(
            f"/users/{user_id}/sessions/{session_id}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # POST /projects/{project_id}/deploy_to_production -> str
    def deploy_to_production(
        self,
        # Id of project
        project_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Deploy To Production"""
        response = self.post(
            f"/projects/{project_id}/deploy_to_production",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # POST /fetch_and_parse_saml_idp_metadata -> models.SamlMetadataParseResult
    def fetch_and_parse_saml_idp_metadata(
        self,
        body: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.SamlMetadataParseResult:
        """Parse SAML IdP Url"""
        response = self.post(
            f"/fetch_and_parse_saml_idp_metadata",
            models.SamlMetadataParseResult,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.SamlMetadataParseResult)
        return response

    # POST /integrations/{integration_id}/form -> models.DataActionForm
    def fetch_integration_form(
        self,
        # Id of Integration
        integration_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.DataActionForm:
        """Fetch Remote Integration Form"""
        response = self.post(
            f"/integrations/{integration_id}/form",
            models.DataActionForm,
            transport_options=transport_options,
        )
        assert isinstance(response, models.DataActionForm)
        return response

    # POST /data_actions/form -> models.DataActionForm
    def fetch_remote_data_action_form(
        self,
        body: MutableMapping[str, str],
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.DataActionForm:
        """Fetch Remote Data Action Form"""
        response = self.post(
            f"/data_actions/form",
            models.DataActionForm,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.DataActionForm)
        return response

    # GET /projects/{project_id}/git_branch/{branch_name} -> models.GitBranch
    def find_git_branch(
        self,
        # Project Id
        project_id: str,
        # Branch Name
        branch_name: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.GitBranch:
        """Find a Git Branch"""
        response = self.get(
            f"/projects/{project_id}/git_branch/{branch_name}",
            models.GitBranch,
            transport_options=transport_options,
        )
        assert isinstance(response, models.GitBranch)
        return response

    # GET /folders/{folder_id} -> models.Folder
    def folder(
        self,
        # Id of folder
        folder_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Folder:
        """Get Folder"""
        response = self.get(
            f"/folders/{folder_id}",
            models.Folder,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.Folder)
        return response

    # GET /folders/{folder_id}/ancestors -> Sequence[models.Folder]
    def folder_ancestors(
        self,
        # Id of folder
        folder_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Folder]:
        """Get Folder Ancestors"""
        response = self.get(
            f"/folders/{folder_id}/ancestors",
            Sequence[models.Folder],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /folders/{folder_id}/children -> Sequence[models.Folder]
    def folder_children(
        self,
        # Id of folder
        folder_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        # Requested page.
        page: Optional[int] = None,
        # Results per page.
        per_page: Optional[int] = None,
        # Fields to sort by.
        sorts: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Folder]:
        """Get Folder Children"""
        response = self.get(
            f"/folders/{folder_id}/children",
            Sequence[models.Folder],
            query_params={
                "fields": fields,
                "page": page,
                "per_page": per_page,
                "sorts": sorts,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /folders/{folder_id}/children/search -> Sequence[models.Folder]
    def folder_children_search(
        self,
        # Id of folder
        folder_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        # Fields to sort by.
        sorts: Optional[str] = None,
        # Match folder name.
        name: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Folder]:
        """Search Folder Children"""
        response = self.get(
            f"/folders/{folder_id}/children/search",
            Sequence[models.Folder],
            query_params={"fields": fields, "sorts": sorts, "name": name},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /folders/{folder_id}/dashboards -> Sequence[models.Dashboard]
    def folder_dashboards(
        self,
        # Id of folder
        folder_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Dashboard]:
        """Get Folder Dashboards"""
        response = self.get(
            f"/folders/{folder_id}/dashboards",
            Sequence[models.Dashboard],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /folders/{folder_id}/looks -> Sequence[models.LookWithQuery]
    def folder_looks(
        self,
        # Id of folder
        folder_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.LookWithQuery]:
        """Get Folder Looks"""
        response = self.get(
            f"/folders/{folder_id}/looks",
            Sequence[models.LookWithQuery],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /folders/{folder_id}/parent -> models.Folder
    def folder_parent(
        self,
        # Id of folder
        folder_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Folder:
        """Get Folder Parent"""
        response = self.get(
            f"/folders/{folder_id}/parent",
            models.Folder,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.Folder)
        return response

    # PUT /password_config/force_password_reset_at_next_login_for_all_users -> str
    def force_password_reset_at_next_login_for_all_users(
        self, transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Force password reset"""
        response = self.put(
            f"/password_config/force_password_reset_at_next_login_for_all_users",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # GET /projects/{root_project_id}/credentials -> Sequence[models.RepositoryCredential]
    def get_all_repository_credentials(
        self,
        # Root Project Id
        root_project_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.RepositoryCredential]:
        """Get All Repository Credentials"""
        response = self.get(
            f"/projects/{root_project_id}/credentials",
            Sequence[models.RepositoryCredential],
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /projects/{project_id}/git_branch -> models.GitBranch
    def git_branch(
        self,
        # Project Id
        project_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.GitBranch:
        """Get Active Git Branch"""
        response = self.get(
            f"/projects/{project_id}/git_branch",
            models.GitBranch,
            transport_options=transport_options,
        )
        assert isinstance(response, models.GitBranch)
        return response

    # GET /projects/{project_id}/git/deploy_key -> str
    def git_deploy_key(
        self,
        # Project Id
        project_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Git Deploy Key"""
        response = self.get(
            f"/projects/{project_id}/git/deploy_key",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # GET /groups/{group_id} -> models.Group
    def group(
        self,
        # Id of group
        group_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Group:
        """Get Group"""
        response = self.get(
            f"/groups/{group_id}",
            models.Group,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.Group)
        return response

    # GET /homepages/{homepage_id} -> models.Homepage
    def homepage(
        self,
        # Id of homepage
        homepage_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Homepage:
        """Get Homepage"""
        response = self.get(
            f"/homepages/{homepage_id}",
            models.Homepage,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.Homepage)
        return response

    # GET /homepage_items/{homepage_item_id} -> models.HomepageItem
    def homepage_item(
        self,
        # Id of homepage item
        homepage_item_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.HomepageItem:
        """Get Homepage Item"""
        response = self.get(
            f"/homepage_items/{homepage_item_id}",
            models.HomepageItem,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.HomepageItem)
        return response

    # GET /homepage_sections/{homepage_section_id} -> models.HomepageSection
    def homepage_section(
        self,
        # Id of homepage section
        homepage_section_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.HomepageSection:
        """Get Homepage section"""
        response = self.get(
            f"/homepage_sections/{homepage_section_id}",
            models.HomepageSection,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.HomepageSection)
        return response

    # POST /dashboards/{lookml_dashboard_id}/import/{space_id} -> models.Dashboard
    def import_lookml_dashboard(
        self,
        # Id of LookML dashboard
        lookml_dashboard_id: str,
        # Id of space to import the dashboard to
        space_id: str,
        body: Optional[models.WriteDashboard] = None,
        # If true, and this dashboard is localized, export it with the raw keys, not localized.
        raw_locale: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Dashboard:
        """Import LookML Dashboard"""
        response = self.post(
            f"/dashboards/{lookml_dashboard_id}/import/{space_id}",
            models.Dashboard,
            query_params={"raw_locale": raw_locale},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.Dashboard)
        return response

    # GET /integrations/{integration_id} -> models.Integration
    def integration(
        self,
        # Id of Integration
        integration_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Integration:
        """Get Integration"""
        response = self.get(
            f"/integrations/{integration_id}",
            models.Integration,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.Integration)
        return response

    # GET /integration_hubs/{integration_hub_id} -> models.IntegrationHub
    def integration_hub(
        self,
        # Id of Integration Hub
        integration_hub_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.IntegrationHub:
        """Get Integration Hub"""
        response = self.get(
            f"/integration_hubs/{integration_hub_id}",
            models.IntegrationHub,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.IntegrationHub)
        return response

    # GET /internal_help_resources_enabled -> models.InternalHelpResources
    def internal_help_resources(
        self, transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.InternalHelpResources:
        """Get Internal Help Resources"""
        response = self.get(
            f"/internal_help_resources_enabled",
            models.InternalHelpResources,
            transport_options=transport_options,
        )
        assert isinstance(response, models.InternalHelpResources)
        return response

    # GET /internal_help_resources_content -> models.InternalHelpResourcesContent
    def internal_help_resources_content(
        self, transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.InternalHelpResourcesContent:
        """Get Internal Help Resources Content"""
        response = self.get(
            f"/internal_help_resources_content",
            models.InternalHelpResourcesContent,
            transport_options=transport_options,
        )
        assert isinstance(response, models.InternalHelpResourcesContent)
        return response

    # DELETE /running_queries/{query_task_id} -> str
    def kill_query(
        self,
        # Query task id.
        query_task_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Kill Running Query"""
        response = self.delete(
            f"/running_queries/{query_task_id}",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # GET /ldap_config -> models.LDAPConfig
    def ldap_config(
        self, transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.LDAPConfig:
        """Get LDAP Configuration"""
        response = self.get(
            f"/ldap_config", models.LDAPConfig, transport_options=transport_options
        )
        assert isinstance(response, models.LDAPConfig)
        return response

    # GET /legacy_features/{legacy_feature_id} -> models.LegacyFeature
    def legacy_feature(
        self,
        # id of legacy feature
        legacy_feature_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.LegacyFeature:
        """Get Legacy Feature"""
        response = self.get(
            f"/legacy_features/{legacy_feature_id}",
            models.LegacyFeature,
            transport_options=transport_options,
        )
        assert isinstance(response, models.LegacyFeature)
        return response

    # login() using api3credentials is automated in the client

    def login_user(self, user_id: int) -> api_methods.APIMethods:
        return super().login_user(user_id)

    def logout(self) -> None:
        super().logout()

    # GET /looks/{look_id} -> models.LookWithQuery
    def look(
        self,
        # Id of look
        look_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.LookWithQuery:
        """Get Look"""
        response = self.get(
            f"/looks/{look_id}",
            models.LookWithQuery,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.LookWithQuery)
        return response

    # GET /lookml_models/{lookml_model_name} -> models.LookmlModel
    def lookml_model(
        self,
        # Name of lookml model.
        lookml_model_name: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.LookmlModel:
        """Get LookML Model"""
        response = self.get(
            f"/lookml_models/{lookml_model_name}",
            models.LookmlModel,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.LookmlModel)
        return response

    # GET /lookml_models/{lookml_model_name}/explores/{explore_name} -> models.LookmlModelExplore
    def lookml_model_explore(
        self,
        # Name of lookml model.
        lookml_model_name: str,
        # Name of explore.
        explore_name: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.LookmlModelExplore:
        """Get LookML Model Explore"""
        response = self.get(
            f"/lookml_models/{lookml_model_name}/explores/{explore_name}",
            models.LookmlModelExplore,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.LookmlModelExplore)
        return response

    # GET /projects/{project_id}/manifest -> models.Manifest
    def manifest(
        self,
        # Project Id
        project_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Manifest:
        """Get Manifest"""
        response = self.get(
            f"/projects/{project_id}/manifest",
            models.Manifest,
            transport_options=transport_options,
        )
        assert isinstance(response, models.Manifest)
        return response

    # GET /user -> models.User
    def me(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.User:
        """Get Current User"""
        response = self.get(
            f"/user",
            models.User,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.User)
        return response

    # GET /merge_queries/{merge_query_id} -> models.MergeQuery
    def merge_query(
        self,
        # Merge Query Id
        merge_query_id: str,
        # Requested fields
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.MergeQuery:
        """Get Merge Query"""
        response = self.get(
            f"/merge_queries/{merge_query_id}",
            models.MergeQuery,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.MergeQuery)
        return response

    # GET /model_sets/{model_set_id} -> models.ModelSet
    def model_set(
        self,
        # Id of model set
        model_set_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ModelSet:
        """Get Model Set"""
        response = self.get(
            f"/model_sets/{model_set_id}",
            models.ModelSet,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.ModelSet)
        return response

    # GET /oidc_config -> models.OIDCConfig
    def oidc_config(
        self, transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.OIDCConfig:
        """Get OIDC Configuration"""
        response = self.get(
            f"/oidc_config", models.OIDCConfig, transport_options=transport_options
        )
        assert isinstance(response, models.OIDCConfig)
        return response

    # GET /oidc_test_configs/{test_slug} -> models.OIDCConfig
    def oidc_test_config(
        self,
        # Slug of test config
        test_slug: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.OIDCConfig:
        """Get OIDC Test Configuration"""
        response = self.get(
            f"/oidc_test_configs/{test_slug}",
            models.OIDCConfig,
            transport_options=transport_options,
        )
        assert isinstance(response, models.OIDCConfig)
        return response

    # POST /parse_saml_idp_metadata -> models.SamlMetadataParseResult
    def parse_saml_idp_metadata(
        self,
        body: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.SamlMetadataParseResult:
        """Parse SAML IdP XML"""
        response = self.post(
            f"/parse_saml_idp_metadata",
            models.SamlMetadataParseResult,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.SamlMetadataParseResult)
        return response

    # GET /password_config -> models.PasswordConfig
    def password_config(
        self, transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.PasswordConfig:
        """Get Password Config"""
        response = self.get(
            f"/password_config",
            models.PasswordConfig,
            transport_options=transport_options,
        )
        assert isinstance(response, models.PasswordConfig)
        return response

    # POST /data_actions -> models.DataActionResponse
    def perform_data_action(
        self,
        body: models.WriteDataActionRequest,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.DataActionResponse:
        """Send a Data Action"""
        response = self.post(
            f"/data_actions",
            models.DataActionResponse,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.DataActionResponse)
        return response

    # GET /permission_sets/{permission_set_id} -> models.PermissionSet
    def permission_set(
        self,
        # Id of permission set
        permission_set_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.PermissionSet:
        """Get Permission Set"""
        response = self.get(
            f"/permission_sets/{permission_set_id}",
            models.PermissionSet,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.PermissionSet)
        return response

    # GET /projects/{project_id} -> models.Project
    def project(
        self,
        # Project Id
        project_id: str,
        # Requested fields
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Project:
        """Get Project"""
        response = self.get(
            f"/projects/{project_id}",
            models.Project,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.Project)
        return response

    # GET /projects/{project_id}/files/file -> models.ProjectFile
    def project_file(
        self,
        # Project Id
        project_id: str,
        # File Id
        file_id: str,
        # Requested fields
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ProjectFile:
        """Get Project File"""
        response = self.get(
            f"/projects/{project_id}/files/file",
            models.ProjectFile,
            query_params={"file_id": file_id, "fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.ProjectFile)
        return response

    # GET /projects/{project_id}/validate -> models.ProjectValidationCache
    def project_validation_results(
        self,
        # Project Id
        project_id: str,
        # Requested fields
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ProjectValidationCache:
        """Cached Project Validation Results"""
        response = self.get(
            f"/projects/{project_id}/validate",
            models.ProjectValidationCache,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.ProjectValidationCache)
        return response

    # GET /projects/{project_id}/current_workspace -> models.ProjectWorkspace
    def project_workspace(
        self,
        # Project Id
        project_id: str,
        # Requested fields
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ProjectWorkspace:
        """Get Project Workspace"""
        response = self.get(
            f"/projects/{project_id}/current_workspace",
            models.ProjectWorkspace,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.ProjectWorkspace)
        return response

    # GET /queries/{query_id} -> models.Query
    def query(
        self,
        # Id of query
        query_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Query:
        """Get Query"""
        response = self.get(
            f"/queries/{query_id}",
            models.Query,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.Query)
        return response

    # GET /queries/slug/{slug} -> models.Query
    def query_for_slug(
        self,
        # Slug of query
        slug: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Query:
        """Get Query for Slug"""
        response = self.get(
            f"/queries/slug/{slug}",
            models.Query,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.Query)
        return response

    # GET /query_tasks/{query_task_id} -> models.QueryTask
    def query_task(
        self,
        # ID of the Query Task
        query_task_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.QueryTask:
        """Get Async Query Info"""
        response = self.get(
            f"/query_tasks/{query_task_id}",
            models.QueryTask,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.QueryTask)
        return response

    # GET /query_tasks/multi_results -> MutableMapping[str, str]
    def query_task_multi_results(
        self,
        # List of Query Task IDs
        query_task_ids: models.DelimSequence[str],
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> MutableMapping[str, str]:
        """Get Multiple Async Query Results"""
        response = self.get(
            f"/query_tasks/multi_results",
            MutableMapping[str, str],
            query_params={"query_task_ids": query_task_ids},
            transport_options=transport_options,
        )
        assert isinstance(response, dict)
        return response

    # GET /query_tasks/{query_task_id}/results -> MutableMapping[str, str]
    def query_task_results(
        self,
        # ID of the Query Task
        query_task_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> MutableMapping[str, str]:
        """Get Async Query Results"""
        response = self.get(
            f"/query_tasks/{query_task_id}/results",
            MutableMapping[str, str],
            transport_options=transport_options,
        )
        assert isinstance(response, dict)
        return response

    # GET /render_tasks/{render_task_id} -> models.RenderTask
    def render_task(
        self,
        # Id of render task
        render_task_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.RenderTask:
        """Get Render Task"""
        response = self.get(
            f"/render_tasks/{render_task_id}",
            models.RenderTask,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.RenderTask)
        return response

    # GET /render_tasks/{render_task_id}/results -> bytes
    def render_task_results(
        self,
        # Id of render task
        render_task_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> bytes:
        """Render Task Results"""
        response = self.get(
            f"/render_tasks/{render_task_id}/results",
            bytes,
            transport_options=transport_options,
        )
        assert isinstance(response, bytes)
        return response

    # POST /projects/{project_id}/reset_to_production -> str
    def reset_project_to_production(
        self,
        # Id of project
        project_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Reset To Production"""
        response = self.post(
            f"/projects/{project_id}/reset_to_production",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # POST /projects/{project_id}/reset_to_remote -> str
    def reset_project_to_remote(
        self,
        # Id of project
        project_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> str:
        """Reset To Remote"""
        response = self.post(
            f"/projects/{project_id}/reset_to_remote",
            str,
            transport_options=transport_options,
        )
        assert isinstance(response, str)
        return response

    # GET /roles/{role_id} -> models.Role
    def role(
        self,
        # id of role
        role_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Role:
        """Get Role"""
        response = self.get(
            f"/roles/{role_id}", models.Role, transport_options=transport_options
        )
        assert isinstance(response, models.Role)
        return response

    # GET /roles/{role_id}/groups -> Sequence[models.Group]
    def role_groups(
        self,
        # id of role
        role_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Group]:
        """Get Role Groups"""
        response = self.get(
            f"/roles/{role_id}/groups",
            Sequence[models.Group],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /roles/{role_id}/users -> Sequence[models.User]
    def role_users(
        self,
        # id of user
        role_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        # Get only users associated directly with the role: exclude those only associated through groups.
        direct_association_only: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.User]:
        """Get Role Users"""
        response = self.get(
            f"/roles/{role_id}/users",
            Sequence[models.User],
            query_params={
                "fields": fields,
                "direct_association_only": direct_association_only,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /projects/{project_id}/git_connection_tests/{test_id} -> models.GitConnectionTestResult
    def run_git_connection_test(
        self,
        # Project Id
        project_id: str,
        # Test Id
        test_id: str,
        # (Optional: leave blank for root project) The remote url for remote dependency to test.
        remote_url: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.GitConnectionTestResult:
        """Run Git Connection Test"""
        response = self.get(
            f"/projects/{project_id}/git_connection_tests/{test_id}",
            models.GitConnectionTestResult,
            query_params={"remote_url": remote_url},
            transport_options=transport_options,
        )
        assert isinstance(response, models.GitConnectionTestResult)
        return response

    # POST /queries/run/{result_format} -> Union[str, bytes]
    def run_inline_query(
        self,
        # Format of result
        result_format: str,
        body: models.WriteQuery,
        # Row limit (may override the limit in the saved query).
        limit: Optional[int] = None,
        # Apply model-specified formatting to each result.
        apply_formatting: Optional[bool] = None,
        # Apply visualization options to results.
        apply_vis: Optional[bool] = None,
        # Get results from cache if available.
        cache: Optional[bool] = None,
        # Render width for image formats.
        image_width: Optional[int] = None,
        # Render height for image formats.
        image_height: Optional[int] = None,
        # Generate drill links (only applicable to 'json_detail' format.
        generate_drill_links: Optional[bool] = None,
        # Force use of production models even if the user is in development mode.
        force_production: Optional[bool] = None,
        # Retrieve any results from cache even if the results have expired.
        cache_only: Optional[bool] = None,
        # Prefix to use for drill links (url encoded).
        path_prefix: Optional[str] = None,
        # Rebuild PDTS used in query.
        rebuild_pdts: Optional[bool] = None,
        # Perform table calculations on query results
        server_table_calcs: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Union[str, bytes]:
        """Run Inline Query"""
        response = self.post(
            f"/queries/run/{result_format}",
            Union[str, bytes],  # type: ignore
            query_params={
                "limit": limit,
                "apply_formatting": apply_formatting,
                "apply_vis": apply_vis,
                "cache": cache,
                "image_width": image_width,
                "image_height": image_height,
                "generate_drill_links": generate_drill_links,
                "force_production": force_production,
                "cache_only": cache_only,
                "path_prefix": path_prefix,
                "rebuild_pdts": rebuild_pdts,
                "server_table_calcs": server_table_calcs,
            },
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, (str, bytes))
        return response

    # GET /looks/{look_id}/run/{result_format} -> Union[str, bytes]
    def run_look(
        self,
        # Id of look
        look_id: int,
        # Format of result
        result_format: str,
        # Row limit (may override the limit in the saved query).
        limit: Optional[int] = None,
        # Apply model-specified formatting to each result.
        apply_formatting: Optional[bool] = None,
        # Apply visualization options to results.
        apply_vis: Optional[bool] = None,
        # Get results from cache if available.
        cache: Optional[bool] = None,
        # Render width for image formats.
        image_width: Optional[int] = None,
        # Render height for image formats.
        image_height: Optional[int] = None,
        # Generate drill links (only applicable to 'json_detail' format.
        generate_drill_links: Optional[bool] = None,
        # Force use of production models even if the user is in development mode.
        force_production: Optional[bool] = None,
        # Retrieve any results from cache even if the results have expired.
        cache_only: Optional[bool] = None,
        # Prefix to use for drill links (url encoded).
        path_prefix: Optional[str] = None,
        # Rebuild PDTS used in query.
        rebuild_pdts: Optional[bool] = None,
        # Perform table calculations on query results
        server_table_calcs: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Union[str, bytes]:
        """Run Look"""
        response = self.get(
            f"/looks/{look_id}/run/{result_format}",
            Union[str, bytes],  # type: ignore
            query_params={
                "limit": limit,
                "apply_formatting": apply_formatting,
                "apply_vis": apply_vis,
                "cache": cache,
                "image_width": image_width,
                "image_height": image_height,
                "generate_drill_links": generate_drill_links,
                "force_production": force_production,
                "cache_only": cache_only,
                "path_prefix": path_prefix,
                "rebuild_pdts": rebuild_pdts,
                "server_table_calcs": server_table_calcs,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, (str, bytes))
        return response

    # GET /projects/{project_id}/lookml_tests/run -> Sequence[models.LookmlTestResult]
    def run_lookml_test(
        self,
        # Project Id
        project_id: str,
        # File Name
        file_id: Optional[str] = None,
        # Test Name
        test: Optional[str] = None,
        # Model Name
        model: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.LookmlTestResult]:
        """Run LookML Test"""
        response = self.get(
            f"/projects/{project_id}/lookml_tests/run",
            Sequence[models.LookmlTestResult],
            query_params={"file_id": file_id, "test": test, "model": model},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /queries/{query_id}/run/{result_format} -> Union[str, bytes]
    def run_query(
        self,
        # Id of query
        query_id: int,
        # Format of result
        result_format: str,
        # Row limit (may override the limit in the saved query).
        limit: Optional[int] = None,
        # Apply model-specified formatting to each result.
        apply_formatting: Optional[bool] = None,
        # Apply visualization options to results.
        apply_vis: Optional[bool] = None,
        # Get results from cache if available.
        cache: Optional[bool] = None,
        # Render width for image formats.
        image_width: Optional[int] = None,
        # Render height for image formats.
        image_height: Optional[int] = None,
        # Generate drill links (only applicable to 'json_detail' format.
        generate_drill_links: Optional[bool] = None,
        # Force use of production models even if the user is in development mode.
        force_production: Optional[bool] = None,
        # Retrieve any results from cache even if the results have expired.
        cache_only: Optional[bool] = None,
        # Prefix to use for drill links (url encoded).
        path_prefix: Optional[str] = None,
        # Rebuild PDTS used in query.
        rebuild_pdts: Optional[bool] = None,
        # Perform table calculations on query results
        server_table_calcs: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Union[str, bytes]:
        """Run Query"""
        response = self.get(
            f"/queries/{query_id}/run/{result_format}",
            Union[str, bytes],  # type: ignore
            query_params={
                "limit": limit,
                "apply_formatting": apply_formatting,
                "apply_vis": apply_vis,
                "cache": cache,
                "image_width": image_width,
                "image_height": image_height,
                "generate_drill_links": generate_drill_links,
                "force_production": force_production,
                "cache_only": cache_only,
                "path_prefix": path_prefix,
                "rebuild_pdts": rebuild_pdts,
                "server_table_calcs": server_table_calcs,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, (str, bytes))
        return response

    # POST /sql_queries/{slug}/run/{result_format} -> Union[str, bytes]
    def run_sql_query(
        self,
        # slug of query
        slug: str,
        # Format of result, options are: ["json", "json_detail", "json_fe", "csv", "html", "md", "txt", "xlsx", "gsxml", "json_label"]
        result_format: str,
        # Defaults to false. If set to true, the HTTP response will have content-disposition and other headers set to make the HTTP response behave as a downloadable attachment instead of as inline content.
        download: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Union[str, bytes]:
        """Run SQL Runner Query"""
        response = self.post(
            f"/sql_queries/{slug}/run/{result_format}",
            Union[str, bytes],  # type: ignore
            query_params={"download": download},
            transport_options=transport_options,
        )
        assert isinstance(response, (str, bytes))
        return response

    # GET /queries/models/{model_name}/views/{view_name}/run/{result_format} -> Union[str, bytes]
    def run_url_encoded_query(
        self,
        # Model name
        model_name: str,
        # View name
        view_name: str,
        # Format of result
        result_format: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Union[str, bytes]:
        """Run Url Encoded Query"""
        response = self.get(
            f"/queries/models/{model_name}/views/{view_name}/run/{result_format}",
            Union[str, bytes],  # type: ignore
            transport_options=transport_options,
        )
        assert isinstance(response, (str, bytes))
        return response

    # GET /saml_config -> models.SamlConfig
    def saml_config(
        self, transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.SamlConfig:
        """Get SAML Configuration"""
        response = self.get(
            f"/saml_config", models.SamlConfig, transport_options=transport_options
        )
        assert isinstance(response, models.SamlConfig)
        return response

    # GET /saml_test_configs/{test_slug} -> models.SamlConfig
    def saml_test_config(
        self,
        # Slug of test config
        test_slug: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.SamlConfig:
        """Get SAML Test Configuration"""
        response = self.get(
            f"/saml_test_configs/{test_slug}",
            models.SamlConfig,
            transport_options=transport_options,
        )
        assert isinstance(response, models.SamlConfig)
        return response

    # GET /scheduled_plans/{scheduled_plan_id} -> models.ScheduledPlan
    def scheduled_plan(
        self,
        # Scheduled Plan Id
        scheduled_plan_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ScheduledPlan:
        """Get Scheduled Plan"""
        response = self.get(
            f"/scheduled_plans/{scheduled_plan_id}",
            models.ScheduledPlan,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.ScheduledPlan)
        return response

    # POST /scheduled_plans/run_once -> models.ScheduledPlan
    def scheduled_plan_run_once(
        self,
        body: models.WriteScheduledPlan,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ScheduledPlan:
        """Run Scheduled Plan Once"""
        response = self.post(
            f"/scheduled_plans/run_once",
            models.ScheduledPlan,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.ScheduledPlan)
        return response

    # POST /scheduled_plans/{scheduled_plan_id}/run_once -> models.ScheduledPlan
    def scheduled_plan_run_once_by_id(
        self,
        # Id of schedule plan to copy and run
        scheduled_plan_id: int,
        body: Optional[models.WriteWriteScheduledPlan] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ScheduledPlan:
        """Run Scheduled Plan Once by Id"""
        response = self.post(
            f"/scheduled_plans/{scheduled_plan_id}/run_once",
            models.ScheduledPlan,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.ScheduledPlan)
        return response

    # GET /scheduled_plans/dashboard/{dashboard_id} -> Sequence[models.ScheduledPlan]
    def scheduled_plans_for_dashboard(
        self,
        # Dashboard Id
        dashboard_id: int,
        # User Id (default is requesting user if not specified)
        user_id: Optional[int] = None,
        # Return scheduled plans belonging to all users for the dashboard
        all_users: Optional[bool] = None,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.ScheduledPlan]:
        """Scheduled Plans for Dashboard"""
        response = self.get(
            f"/scheduled_plans/dashboard/{dashboard_id}",
            Sequence[models.ScheduledPlan],
            query_params={"user_id": user_id, "all_users": all_users, "fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /scheduled_plans/look/{look_id} -> Sequence[models.ScheduledPlan]
    def scheduled_plans_for_look(
        self,
        # Look Id
        look_id: int,
        # User Id (default is requesting user if not specified)
        user_id: Optional[int] = None,
        # Requested fields.
        fields: Optional[str] = None,
        # Return scheduled plans belonging to all users for the look
        all_users: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.ScheduledPlan]:
        """Scheduled Plans for Look"""
        response = self.get(
            f"/scheduled_plans/look/{look_id}",
            Sequence[models.ScheduledPlan],
            query_params={"user_id": user_id, "fields": fields, "all_users": all_users},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /scheduled_plans/lookml_dashboard/{lookml_dashboard_id} -> Sequence[models.ScheduledPlan]
    def scheduled_plans_for_lookml_dashboard(
        self,
        # LookML Dashboard Id
        lookml_dashboard_id: int,
        # User Id (default is requesting user if not specified)
        user_id: Optional[int] = None,
        # Requested fields.
        fields: Optional[str] = None,
        # Return scheduled plans belonging to all users for the dashboard
        all_users: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.ScheduledPlan]:
        """Scheduled Plans for LookML Dashboard"""
        response = self.get(
            f"/scheduled_plans/lookml_dashboard/{lookml_dashboard_id}",
            Sequence[models.ScheduledPlan],
            query_params={"user_id": user_id, "fields": fields, "all_users": all_users},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /scheduled_plans/space/{space_id} -> Sequence[models.ScheduledPlan]
    def scheduled_plans_for_space(
        self,
        # Space Id
        space_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.ScheduledPlan]:
        """Scheduled Plans for Space"""
        response = self.get(
            f"/scheduled_plans/space/{space_id}",
            Sequence[models.ScheduledPlan],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /content_favorite/search -> Sequence[models.ContentFavorite]
    def search_content_favorites(
        self,
        # Match content favorite id(s)
        id: Optional[int] = None,
        # Match user id(s)
        user_id: Optional[int] = None,
        # Match content metadata id(s)
        content_metadata_id: Optional[int] = None,
        # Match dashboard id(s)
        dashboard_id: Optional[int] = None,
        # Match look id(s)
        look_id: Optional[int] = None,
        # Number of results to return. (used with offset)
        limit: Optional[int] = None,
        # Number of results to skip before returning any. (used with limit)
        offset: Optional[int] = None,
        # Fields to sort by.
        sorts: Optional[str] = None,
        # Requested fields.
        fields: Optional[str] = None,
        # Combine given search criteria in a boolean OR expression
        filter_or: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.ContentFavorite]:
        """Search Favorite Contents"""
        response = self.get(
            f"/content_favorite/search",
            Sequence[models.ContentFavorite],
            query_params={
                "id": id,
                "user_id": user_id,
                "content_metadata_id": content_metadata_id,
                "dashboard_id": dashboard_id,
                "look_id": look_id,
                "limit": limit,
                "offset": offset,
                "sorts": sorts,
                "fields": fields,
                "filter_or": filter_or,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /content_view/search -> Sequence[models.ContentView]
    def search_content_views(
        self,
        # Match view count
        view_count: Optional[int] = None,
        # Match Group Id
        group_id: Optional[int] = None,
        # Match look_id
        look_id: Optional[str] = None,
        # Match dashboard_id
        dashboard_id: Optional[str] = None,
        # Match content metadata id
        content_metadata_id: Optional[int] = None,
        # Match start of week date
        start_of_week_date: Optional[str] = None,
        # True if only all time view records should be returned
        all_time: Optional[bool] = None,
        # Match user id
        user_id: Optional[int] = None,
        # Requested fields
        fields: Optional[str] = None,
        # Number of results to return. Use with `offset` to manage pagination of results
        limit: Optional[int] = None,
        # Number of results to skip before returning data
        offset: Optional[int] = None,
        # Fields to sort by
        sorts: Optional[str] = None,
        # Combine given search criteria in a boolean OR expression
        filter_or: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.ContentView]:
        """Search Content Views"""
        response = self.get(
            f"/content_view/search",
            Sequence[models.ContentView],
            query_params={
                "view_count": view_count,
                "group_id": group_id,
                "look_id": look_id,
                "dashboard_id": dashboard_id,
                "content_metadata_id": content_metadata_id,
                "start_of_week_date": start_of_week_date,
                "all_time": all_time,
                "user_id": user_id,
                "fields": fields,
                "limit": limit,
                "offset": offset,
                "sorts": sorts,
                "filter_or": filter_or,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /dashboard_elements/search -> Sequence[models.DashboardElement]
    def search_dashboard_elements(
        self,
        # Select elements that refer to a given dashboard id
        dashboard_id: Optional[int] = None,
        # Select elements that refer to a given look id
        look_id: Optional[int] = None,
        # Match the title of element
        title: Optional[str] = None,
        # Select soft-deleted dashboard elements
        deleted: Optional[bool] = None,
        # Requested fields.
        fields: Optional[str] = None,
        # Combine given search criteria in a boolean OR expression
        filter_or: Optional[bool] = None,
        # Fields to sort by. Sortable fields: [:look_id, :dashboard_id, :deleted, :title]
        sorts: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.DashboardElement]:
        """Search Dashboard Elements"""
        response = self.get(
            f"/dashboard_elements/search",
            Sequence[models.DashboardElement],
            query_params={
                "dashboard_id": dashboard_id,
                "look_id": look_id,
                "title": title,
                "deleted": deleted,
                "fields": fields,
                "filter_or": filter_or,
                "sorts": sorts,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /dashboards/search -> Sequence[models.Dashboard]
    def search_dashboards(
        self,
        # Match dashboard id.
        id: Optional[int] = None,
        # Match dashboard slug.
        slug: Optional[str] = None,
        # Match Dashboard title.
        title: Optional[str] = None,
        # Match Dashboard description.
        description: Optional[str] = None,
        # Filter on a content favorite id.
        content_favorite_id: Optional[int] = None,
        # Filter on a particular space.
        space_id: Optional[str] = None,
        # Filter on dashboards deleted status.
        deleted: Optional[str] = None,
        # Filter on dashboards created by a particular user.
        user_id: Optional[str] = None,
        # Filter on a particular value of view_count
        view_count: Optional[str] = None,
        # Filter on a content favorite id.
        content_metadata_id: Optional[int] = None,
        # Exclude items that exist only in personal spaces other than the users
        curate: Optional[bool] = None,
        # Requested fields.
        fields: Optional[str] = None,
        # Requested page.
        page: Optional[int] = None,
        # Results per page.
        per_page: Optional[int] = None,
        # Number of results to return. (used with offset and takes priority over page and per_page)
        limit: Optional[int] = None,
        # Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
        offset: Optional[int] = None,
        # One or more fields to sort by. Sortable fields: [:title, :user_id, :id, :created_at, :space_id, :description, :view_count, :favorite_count, :slug, :content_favorite_id, :content_metadata_id, :deleted, :deleted_at, :last_viewed_at]
        sorts: Optional[str] = None,
        # Combine given search criteria in a boolean OR expression
        filter_or: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Dashboard]:
        """Search Dashboards"""
        response = self.get(
            f"/dashboards/search",
            Sequence[models.Dashboard],
            query_params={
                "id": id,
                "slug": slug,
                "title": title,
                "description": description,
                "content_favorite_id": content_favorite_id,
                "space_id": space_id,
                "deleted": deleted,
                "user_id": user_id,
                "view_count": view_count,
                "content_metadata_id": content_metadata_id,
                "curate": curate,
                "fields": fields,
                "page": page,
                "per_page": per_page,
                "limit": limit,
                "offset": offset,
                "sorts": sorts,
                "filter_or": filter_or,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /folders/search -> Sequence[models.Folder]
    def search_folders(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        # Requested page.
        page: Optional[int] = None,
        # Results per page.
        per_page: Optional[int] = None,
        # Number of results to return. (used with offset and takes priority over page and per_page)
        limit: Optional[int] = None,
        # Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
        offset: Optional[int] = None,
        # Fields to sort by.
        sorts: Optional[str] = None,
        # Match Space title.
        name: Optional[str] = None,
        # Match Space id
        id: Optional[int] = None,
        # Filter on a children of a particular folder.
        parent_id: Optional[str] = None,
        # Filter on folder created by a particular user.
        creator_id: Optional[str] = None,
        # Combine given search criteria in a boolean OR expression
        filter_or: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Folder]:
        """Search Folders"""
        response = self.get(
            f"/folders/search",
            Sequence[models.Folder],
            query_params={
                "fields": fields,
                "page": page,
                "per_page": per_page,
                "limit": limit,
                "offset": offset,
                "sorts": sorts,
                "name": name,
                "id": id,
                "parent_id": parent_id,
                "creator_id": creator_id,
                "filter_or": filter_or,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /groups/search -> Sequence[models.Group]
    def search_groups(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        # Number of results to return (used with `offset`).
        limit: Optional[int] = None,
        # Number of results to skip before returning any (used with `limit`).
        offset: Optional[int] = None,
        # Fields to sort by.
        sorts: Optional[str] = None,
        # Combine given search criteria in a boolean OR expression
        filter_or: Optional[bool] = None,
        # Match group id.
        id: Optional[int] = None,
        # Match group name.
        name: Optional[str] = None,
        # Match group external_group_id.
        external_group_id: Optional[bool] = None,
        # Match group externally_managed.
        externally_managed: Optional[bool] = None,
        # Match group externally_orphaned.
        externally_orphaned: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Group]:
        """Search Groups"""
        response = self.get(
            f"/groups/search",
            Sequence[models.Group],
            query_params={
                "fields": fields,
                "limit": limit,
                "offset": offset,
                "sorts": sorts,
                "filter_or": filter_or,
                "id": id,
                "name": name,
                "external_group_id": external_group_id,
                "externally_managed": externally_managed,
                "externally_orphaned": externally_orphaned,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /homepages/search -> Sequence[models.Homepage]
    def search_homepages(
        self,
        # Matches homepage title.
        title: Optional[str] = None,
        # Matches the timestamp for when the homepage was created.
        created_at: Optional[str] = None,
        # The first name of the user who created this homepage.
        first_name: Optional[str] = None,
        # The last name of the user who created this homepage.
        last_name: Optional[str] = None,
        # Requested fields.
        fields: Optional[str] = None,
        # Return favorited homepages when true.
        favorited: Optional[bool] = None,
        # Filter on homepages created by a particular user.
        creator_id: Optional[str] = None,
        # The fields to sort the results by
        sorts: Optional[str] = None,
        # The page to return.
        page: Optional[int] = None,
        # The number of items in the returned page.
        per_page: Optional[int] = None,
        # The number of items to skip before returning any. (used with limit and takes priority over page and per_page)
        offset: Optional[int] = None,
        # The maximum number of items to return. (used with offset and takes priority over page and per_page)
        limit: Optional[int] = None,
        # Combine given search criteria in a boolean OR expression
        filter_or: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Homepage]:
        """Search Homepages"""
        response = self.get(
            f"/homepages/search",
            Sequence[models.Homepage],
            query_params={
                "title": title,
                "created_at": created_at,
                "first_name": first_name,
                "last_name": last_name,
                "fields": fields,
                "favorited": favorited,
                "creator_id": creator_id,
                "sorts": sorts,
                "page": page,
                "per_page": per_page,
                "offset": offset,
                "limit": limit,
                "filter_or": filter_or,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /looks/search -> Sequence[models.Look]
    def search_looks(
        self,
        # Match Look title.
        title: Optional[str] = None,
        # Match Look description.
        description: Optional[str] = None,
        # Select looks with a particular content favorite id
        content_favorite_id: Optional[int] = None,
        # Select looks in a particular space.
        space_id: Optional[str] = None,
        # Select looks created by a particular user.
        user_id: Optional[str] = None,
        # Select looks with particular view_count value
        view_count: Optional[str] = None,
        # Select soft-deleted looks
        deleted: Optional[bool] = None,
        # Select looks that reference a particular query by query_id
        query_id: Optional[int] = None,
        # Exclude items that exist only in personal spaces other than the users
        curate: Optional[bool] = None,
        # Requested fields.
        fields: Optional[str] = None,
        # Requested page.
        page: Optional[int] = None,
        # Results per page.
        per_page: Optional[int] = None,
        # Number of results to return. (used with offset and takes priority over page and per_page)
        limit: Optional[int] = None,
        # Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
        offset: Optional[int] = None,
        # One or more fields to sort results by. Sortable fields: [:title, :user_id, :id, :created_at, :space_id, :description, :updated_at, :last_updater_id, :view_count, :favorite_count, :content_favorite_id, :deleted, :deleted_at, :last_viewed_at, :query_id]
        sorts: Optional[str] = None,
        # Combine given search criteria in a boolean OR expression
        filter_or: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Look]:
        """Search Looks"""
        response = self.get(
            f"/looks/search",
            Sequence[models.Look],
            query_params={
                "title": title,
                "description": description,
                "content_favorite_id": content_favorite_id,
                "space_id": space_id,
                "user_id": user_id,
                "view_count": view_count,
                "deleted": deleted,
                "query_id": query_id,
                "curate": curate,
                "fields": fields,
                "page": page,
                "per_page": per_page,
                "limit": limit,
                "offset": offset,
                "sorts": sorts,
                "filter_or": filter_or,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /model_sets/search -> Sequence[models.ModelSet]
    def search_model_sets(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        # Number of results to return (used with `offset`).
        limit: Optional[int] = None,
        # Number of results to skip before returning any (used with `limit`).
        offset: Optional[int] = None,
        # Fields to sort by.
        sorts: Optional[str] = None,
        # Match model set id.
        id: Optional[int] = None,
        # Match model set name.
        name: Optional[str] = None,
        # Match model sets by all_access status.
        all_access: Optional[bool] = None,
        # Match model sets by built_in status.
        built_in: Optional[bool] = None,
        # Combine given search criteria in a boolean OR expression.
        filter_or: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.ModelSet]:
        """Search Model Sets"""
        response = self.get(
            f"/model_sets/search",
            Sequence[models.ModelSet],
            query_params={
                "fields": fields,
                "limit": limit,
                "offset": offset,
                "sorts": sorts,
                "id": id,
                "name": name,
                "all_access": all_access,
                "built_in": built_in,
                "filter_or": filter_or,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /permission_sets/search -> Sequence[models.PermissionSet]
    def search_permission_sets(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        # Number of results to return (used with `offset`).
        limit: Optional[int] = None,
        # Number of results to skip before returning any (used with `limit`).
        offset: Optional[int] = None,
        # Fields to sort by.
        sorts: Optional[str] = None,
        # Match permission set id.
        id: Optional[int] = None,
        # Match permission set name.
        name: Optional[str] = None,
        # Match permission sets by all_access status.
        all_access: Optional[bool] = None,
        # Match permission sets by built_in status.
        built_in: Optional[bool] = None,
        # Combine given search criteria in a boolean OR expression.
        filter_or: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.PermissionSet]:
        """Search Permission Sets"""
        response = self.get(
            f"/permission_sets/search",
            Sequence[models.PermissionSet],
            query_params={
                "fields": fields,
                "limit": limit,
                "offset": offset,
                "sorts": sorts,
                "id": id,
                "name": name,
                "all_access": all_access,
                "built_in": built_in,
                "filter_or": filter_or,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /roles/search -> Sequence[models.Role]
    def search_roles(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        # Number of results to return (used with `offset`).
        limit: Optional[int] = None,
        # Number of results to skip before returning any (used with `limit`).
        offset: Optional[int] = None,
        # Fields to sort by.
        sorts: Optional[str] = None,
        # Match role id.
        id: Optional[int] = None,
        # Match role name.
        name: Optional[str] = None,
        # Match roles by built_in status.
        built_in: Optional[bool] = None,
        # Combine given search criteria in a boolean OR expression.
        filter_or: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Role]:
        """Search Roles"""
        response = self.get(
            f"/roles/search",
            Sequence[models.Role],
            query_params={
                "fields": fields,
                "limit": limit,
                "offset": offset,
                "sorts": sorts,
                "id": id,
                "name": name,
                "built_in": built_in,
                "filter_or": filter_or,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /spaces/search -> Sequence[models.Space]
    def search_spaces(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        # Requested page.
        page: Optional[int] = None,
        # Results per page.
        per_page: Optional[int] = None,
        # Number of results to return. (used with offset and takes priority over page and per_page)
        limit: Optional[int] = None,
        # Number of results to skip before returning any. (used with limit and takes priority over page and per_page)
        offset: Optional[int] = None,
        # Fields to sort by.
        sorts: Optional[str] = None,
        # Match Space title.
        name: Optional[str] = None,
        # Match Space id
        id: Optional[int] = None,
        # Filter on a children of a particular space.
        parent_id: Optional[str] = None,
        # Filter on spaces created by a particular user.
        creator_id: Optional[str] = None,
        # Combine given search criteria in a boolean OR expression
        filter_or: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Space]:
        """Search Spaces"""
        response = self.get(
            f"/spaces/search",
            Sequence[models.Space],
            query_params={
                "fields": fields,
                "page": page,
                "per_page": per_page,
                "limit": limit,
                "offset": offset,
                "sorts": sorts,
                "name": name,
                "id": id,
                "parent_id": parent_id,
                "creator_id": creator_id,
                "filter_or": filter_or,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /themes/search -> Sequence[models.Theme]
    def search_themes(
        self,
        # Match theme id.
        id: Optional[int] = None,
        # Match theme name.
        name: Optional[str] = None,
        # Timestamp for activation.
        begin_at: Optional[datetime.datetime] = None,
        # Timestamp for expiration.
        end_at: Optional[datetime.datetime] = None,
        # Number of results to return (used with `offset`).
        limit: Optional[int] = None,
        # Number of results to skip before returning any (used with `limit`).
        offset: Optional[int] = None,
        # Fields to sort by.
        sorts: Optional[str] = None,
        # Requested fields.
        fields: Optional[str] = None,
        # Combine given search criteria in a boolean OR expression
        filter_or: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Theme]:
        """Search Themes"""
        response = self.get(
            f"/themes/search",
            Sequence[models.Theme],
            query_params={
                "id": id,
                "name": name,
                "begin_at": begin_at,
                "end_at": end_at,
                "limit": limit,
                "offset": offset,
                "sorts": sorts,
                "fields": fields,
                "filter_or": filter_or,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /user_login_lockouts/search -> Sequence[models.UserLoginLockout]
    def search_user_login_lockouts(
        self,
        # Include only these fields in the response
        fields: Optional[str] = None,
        # Return only page N of paginated results
        page: Optional[int] = None,
        # Return N rows of data per page
        per_page: Optional[int] = None,
        # Fields to sort by.
        sorts: Optional[str] = None,
        # Auth type user is locked out for (email, ldap, totp, api)
        auth_type: Optional[str] = None,
        # Match name
        full_name: Optional[str] = None,
        # Match email
        email: Optional[str] = None,
        # Match remote LDAP ID
        remote_id: Optional[str] = None,
        # Combine given search criteria in a boolean OR expression
        filter_or: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.UserLoginLockout]:
        """Search User Login Lockouts"""
        response = self.get(
            f"/user_login_lockouts/search",
            Sequence[models.UserLoginLockout],
            query_params={
                "fields": fields,
                "page": page,
                "per_page": per_page,
                "sorts": sorts,
                "auth_type": auth_type,
                "full_name": full_name,
                "email": email,
                "remote_id": remote_id,
                "filter_or": filter_or,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /users/search -> Sequence[models.User]
    def search_users(
        self,
        # Include only these fields in the response
        fields: Optional[str] = None,
        # Return only page N of paginated results
        page: Optional[int] = None,
        # Return N rows of data per page
        per_page: Optional[int] = None,
        # Fields to sort by.
        sorts: Optional[str] = None,
        # Match User Id.
        id: Optional[int] = None,
        # Match First name.
        first_name: Optional[str] = None,
        # Match Last name.
        last_name: Optional[str] = None,
        # Search for user accounts associated with Looker employees
        verified_looker_employee: Optional[bool] = None,
        # Search for the user with this email address
        email: Optional[str] = None,
        # Search for disabled user accounts
        is_disabled: Optional[bool] = None,
        # Combine given search criteria in a boolean OR expression
        filter_or: Optional[bool] = None,
        # Search for users who have access to this content_metadata item
        content_metadata_id: Optional[int] = None,
        # Search for users who are direct members of this group
        group_id: Optional[int] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.User]:
        """Search Users"""
        response = self.get(
            f"/users/search",
            Sequence[models.User],
            query_params={
                "fields": fields,
                "page": page,
                "per_page": per_page,
                "sorts": sorts,
                "id": id,
                "first_name": first_name,
                "last_name": last_name,
                "verified_looker_employee": verified_looker_employee,
                "email": email,
                "is_disabled": is_disabled,
                "filter_or": filter_or,
                "content_metadata_id": content_metadata_id,
                "group_id": group_id,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /users/search/names/{pattern} -> Sequence[models.User]
    def search_users_names(
        self,
        # Pattern to match
        pattern: str,
        # Include only these fields in the response
        fields: Optional[str] = None,
        # Return only page N of paginated results
        page: Optional[int] = None,
        # Return N rows of data per page
        per_page: Optional[int] = None,
        # Fields to sort by
        sorts: Optional[str] = None,
        # Match User Id
        id: Optional[int] = None,
        # Match First name
        first_name: Optional[str] = None,
        # Match Last name
        last_name: Optional[str] = None,
        # Match Verified Looker employee
        verified_looker_employee: Optional[bool] = None,
        # Match Email Address
        email: Optional[str] = None,
        # Include or exclude disabled accounts in the results
        is_disabled: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.User]:
        """Search User Names"""
        response = self.get(
            f"/users/search/names/{pattern}",
            Sequence[models.User],
            query_params={
                "fields": fields,
                "page": page,
                "per_page": per_page,
                "sorts": sorts,
                "id": id,
                "first_name": first_name,
                "last_name": last_name,
                "verified_looker_employee": verified_looker_employee,
                "email": email,
                "is_disabled": is_disabled,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /session -> models.ApiSession
    def session(
        self, transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ApiSession:
        """Get Session"""
        response = self.get(
            f"/session", models.ApiSession, transport_options=transport_options
        )
        assert isinstance(response, models.ApiSession)
        return response

    # GET /session_config -> models.SessionConfig
    def session_config(
        self, transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.SessionConfig:
        """Get Session Config"""
        response = self.get(
            f"/session_config",
            models.SessionConfig,
            transport_options=transport_options,
        )
        assert isinstance(response, models.SessionConfig)
        return response

    # PUT /color_collections/default -> models.ColorCollection
    def set_default_color_collection(
        self,
        # ID of color collection to set as default
        collection_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ColorCollection:
        """Set Default Color Collection"""
        response = self.put(
            f"/color_collections/default",
            models.ColorCollection,
            query_params={"collection_id": collection_id},
            transport_options=transport_options,
        )
        assert isinstance(response, models.ColorCollection)
        return response

    # PUT /themes/default -> models.Theme
    def set_default_theme(
        self,
        # Name of theme to set as default
        name: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Theme:
        """Set Default Theme"""
        response = self.put(
            f"/themes/default",
            models.Theme,
            query_params={"name": name},
            transport_options=transport_options,
        )
        assert isinstance(response, models.Theme)
        return response

    # PUT /roles/{role_id}/groups -> Sequence[models.Group]
    def set_role_groups(
        self,
        # Id of Role
        role_id: int,
        body: Sequence[int],
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Group]:
        """Update Role Groups"""
        response = self.put(
            f"/roles/{role_id}/groups",
            Sequence[models.Group],
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # PUT /roles/{role_id}/users -> Sequence[models.User]
    def set_role_users(
        self,
        # id of role
        role_id: int,
        body: Sequence[int],
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.User]:
        """Update Role Users"""
        response = self.put(
            f"/roles/{role_id}/users",
            Sequence[models.User],
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # POST /user_attributes/{user_attribute_id}/group_values -> Sequence[models.UserAttributeGroupValue]
    def set_user_attribute_group_values(
        self,
        # Id of user attribute
        user_attribute_id: int,
        body: Sequence[models.UserAttributeGroupValue],
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.UserAttributeGroupValue]:
        """Set User Attribute Group Values"""
        response = self.post(
            f"/user_attributes/{user_attribute_id}/group_values",
            Sequence[models.UserAttributeGroupValue],
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # PATCH /users/{user_id}/attribute_values/{user_attribute_id} -> models.UserAttributeWithValue
    def set_user_attribute_user_value(
        self,
        # Id of user
        user_id: int,
        # Id of user attribute
        user_attribute_id: int,
        body: models.WriteUserAttributeWithValue,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.UserAttributeWithValue:
        """Set User Attribute User Value"""
        response = self.patch(
            f"/users/{user_id}/attribute_values/{user_attribute_id}",
            models.UserAttributeWithValue,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.UserAttributeWithValue)
        return response

    # PUT /users/{user_id}/roles -> Sequence[models.Role]
    def set_user_roles(
        self,
        # id of user
        user_id: int,
        body: Sequence[int],
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Role]:
        """Set User Roles"""
        response = self.put(
            f"/users/{user_id}/roles",
            Sequence[models.Role],
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /spaces/{space_id} -> models.Space
    def space(
        self,
        # Id of space
        space_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Space:
        """Get Space"""
        response = self.get(
            f"/spaces/{space_id}",
            models.Space,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.Space)
        return response

    # GET /spaces/{space_id}/ancestors -> Sequence[models.Space]
    def space_ancestors(
        self,
        # Id of space
        space_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Space]:
        """Get Space Ancestors"""
        response = self.get(
            f"/spaces/{space_id}/ancestors",
            Sequence[models.Space],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /spaces/{space_id}/children -> Sequence[models.Space]
    def space_children(
        self,
        # Id of space
        space_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        # Requested page.
        page: Optional[int] = None,
        # Results per page.
        per_page: Optional[int] = None,
        # Fields to sort by.
        sorts: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Space]:
        """Get Space Children"""
        response = self.get(
            f"/spaces/{space_id}/children",
            Sequence[models.Space],
            query_params={
                "fields": fields,
                "page": page,
                "per_page": per_page,
                "sorts": sorts,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /spaces/{space_id}/children/search -> Sequence[models.Space]
    def space_children_search(
        self,
        # Id of space
        space_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        # Fields to sort by.
        sorts: Optional[str] = None,
        # Match Space name.
        name: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Space]:
        """Search Space Children"""
        response = self.get(
            f"/spaces/{space_id}/children/search",
            Sequence[models.Space],
            query_params={"fields": fields, "sorts": sorts, "name": name},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /spaces/{space_id}/dashboards -> Sequence[models.Dashboard]
    def space_dashboards(
        self,
        # Id of space
        space_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Dashboard]:
        """Get Space Dashboards"""
        response = self.get(
            f"/spaces/{space_id}/dashboards",
            Sequence[models.Dashboard],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /spaces/{space_id}/looks -> Sequence[models.LookWithQuery]
    def space_looks(
        self,
        # Id of space
        space_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.LookWithQuery]:
        """Get Space Looks"""
        response = self.get(
            f"/spaces/{space_id}/looks",
            Sequence[models.LookWithQuery],
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /spaces/{space_id}/parent -> models.Space
    def space_parent(
        self,
        # Id of space
        space_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Space:
        """Get Space Parent"""
        response = self.get(
            f"/spaces/{space_id}/parent",
            models.Space,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.Space)
        return response

    # GET /sql_queries/{slug} -> models.SqlQuery
    def sql_query(
        self,
        # slug of query
        slug: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.SqlQuery:
        """Get SQL Runner Query"""
        response = self.get(
            f"/sql_queries/{slug}", models.SqlQuery, transport_options=transport_options
        )
        assert isinstance(response, models.SqlQuery)
        return response

    # PATCH /dashboards/{lookml_dashboard_id}/sync -> Sequence[int]
    def sync_lookml_dashboard(
        self,
        # Id of LookML dashboard, in the form 'model::dashboardname'
        lookml_dashboard_id: str,
        body: models.WriteDashboard,
        # If true, and this dashboard is localized, export it with the raw keys, not localized.
        raw_locale: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[int]:
        """Sync LookML Dashboard"""
        response = self.patch(
            f"/dashboards/{lookml_dashboard_id}/sync",
            Sequence[int],
            query_params={"raw_locale": raw_locale},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # PUT /connections/{connection_name}/test -> Sequence[models.DBConnectionTestResult]
    def test_connection(
        self,
        # Name of connection
        connection_name: str,
        # Array of names of tests to run
        tests: Optional[models.DelimSequence[str]] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.DBConnectionTestResult]:
        """Test Connection"""
        response = self.put(
            f"/connections/{connection_name}/test",
            Sequence[models.DBConnectionTestResult],
            query_params={"tests": tests},
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # PUT /connections/test -> Sequence[models.DBConnectionTestResult]
    def test_connection_config(
        self,
        body: models.WriteDBConnection,
        # Array of names of tests to run
        tests: Optional[models.DelimSequence[str]] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.DBConnectionTestResult]:
        """Test Connection Configuration"""
        response = self.put(
            f"/connections/test",
            Sequence[models.DBConnectionTestResult],
            query_params={"tests": tests},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # POST /integrations/{integration_id}/test -> models.IntegrationTestResult
    def test_integration(
        self,
        # Id of Integration
        integration_id: int,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.IntegrationTestResult:
        """Test integration"""
        response = self.post(
            f"/integrations/{integration_id}/test",
            models.IntegrationTestResult,
            transport_options=transport_options,
        )
        assert isinstance(response, models.IntegrationTestResult)
        return response

    # PUT /ldap_config/test_auth -> models.LDAPConfigTestResult
    def test_ldap_config_auth(
        self,
        body: models.WriteLDAPConfig,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.LDAPConfigTestResult:
        """Test LDAP Auth"""
        response = self.put(
            f"/ldap_config/test_auth",
            models.LDAPConfigTestResult,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.LDAPConfigTestResult)
        return response

    # PUT /ldap_config/test_connection -> models.LDAPConfigTestResult
    def test_ldap_config_connection(
        self,
        body: models.WriteLDAPConfig,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.LDAPConfigTestResult:
        """Test LDAP Connection"""
        response = self.put(
            f"/ldap_config/test_connection",
            models.LDAPConfigTestResult,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.LDAPConfigTestResult)
        return response

    # PUT /ldap_config/test_user_auth -> models.LDAPConfigTestResult
    def test_ldap_config_user_auth(
        self,
        body: models.WriteLDAPConfig,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.LDAPConfigTestResult:
        """Test LDAP User Auth"""
        response = self.put(
            f"/ldap_config/test_user_auth",
            models.LDAPConfigTestResult,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.LDAPConfigTestResult)
        return response

    # PUT /ldap_config/test_user_info -> models.LDAPConfigTestResult
    def test_ldap_config_user_info(
        self,
        body: models.WriteLDAPConfig,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.LDAPConfigTestResult:
        """Test LDAP User Info"""
        response = self.put(
            f"/ldap_config/test_user_info",
            models.LDAPConfigTestResult,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.LDAPConfigTestResult)
        return response

    # GET /themes/{theme_id} -> models.Theme
    def theme(
        self,
        # Id of theme
        theme_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Theme:
        """Get Theme"""
        response = self.get(
            f"/themes/{theme_id}",
            models.Theme,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.Theme)
        return response

    # GET /themes/theme_or_default -> models.Theme
    def theme_or_default(
        self,
        # Name of theme
        name: str,
        # Timestamp representing the target datetime for the active period. Defaults to 'now'
        ts: Optional[datetime.datetime] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Theme:
        """Get Theme or Default"""
        response = self.get(
            f"/themes/theme_or_default",
            models.Theme,
            query_params={"name": name, "ts": ts},
            transport_options=transport_options,
        )
        assert isinstance(response, models.Theme)
        return response

    # PATCH /backup_configuration -> models.BackupConfiguration
    def update_backup_configuration(
        self,
        body: models.WriteBackupConfiguration,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.BackupConfiguration:
        """Update Backup Configuration"""
        response = self.patch(
            f"/backup_configuration",
            models.BackupConfiguration,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.BackupConfiguration)
        return response

    # PATCH /color_collections/{collection_id} -> models.ColorCollection
    def update_color_collection(
        self,
        # Id of Custom Color Collection
        collection_id: str,
        body: models.WriteColorCollection,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ColorCollection:
        """Update Custom Color collection"""
        response = self.patch(
            f"/color_collections/{collection_id}",
            models.ColorCollection,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.ColorCollection)
        return response

    # PATCH /connections/{connection_name} -> models.DBConnection
    def update_connection(
        self,
        # Name of connection
        connection_name: str,
        body: models.WriteDBConnection,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.DBConnection:
        """Update Connection"""
        response = self.patch(
            f"/connections/{connection_name}",
            models.DBConnection,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.DBConnection)
        return response

    # PATCH /content_metadata/{content_metadata_id} -> models.ContentMeta
    def update_content_metadata(
        self,
        # Id of content metadata
        content_metadata_id: int,
        body: models.WriteContentMeta,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ContentMeta:
        """Update Content Metadata"""
        response = self.patch(
            f"/content_metadata/{content_metadata_id}",
            models.ContentMeta,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.ContentMeta)
        return response

    # PUT /content_metadata_access/{content_metadata_access_id} -> models.ContentMetaGroupUser
    def update_content_metadata_access(
        self,
        # Id of content metadata access
        content_metadata_access_id: int,
        body: models.ContentMetaGroupUser,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ContentMetaGroupUser:
        """Update Content Metadata Access"""
        response = self.put(
            f"/content_metadata_access/{content_metadata_access_id}",
            models.ContentMetaGroupUser,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.ContentMetaGroupUser)
        return response

    # PATCH /custom_welcome_email -> models.CustomWelcomeEmail
    def update_custom_welcome_email(
        self,
        body: models.WriteCustomWelcomeEmail,
        # If true a test email with the content from the request will be sent to the current user after saving
        send_test_welcome_email: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.CustomWelcomeEmail:
        """Update Custom Welcome Email Content"""
        response = self.patch(
            f"/custom_welcome_email",
            models.CustomWelcomeEmail,
            query_params={"send_test_welcome_email": send_test_welcome_email},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.CustomWelcomeEmail)
        return response

    # PUT /custom_welcome_email_test -> models.WelcomeEmailTest
    def update_custom_welcome_email_test(
        self,
        body: models.WriteWelcomeEmailTest,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.WelcomeEmailTest:
        """Send a test welcome email to the currently logged in user with the supplied content """
        response = self.put(
            f"/custom_welcome_email_test",
            models.WelcomeEmailTest,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.WelcomeEmailTest)
        return response

    # PATCH /dashboards/{dashboard_id} -> models.Dashboard
    def update_dashboard(
        self,
        # Id of dashboard
        dashboard_id: str,
        body: models.WriteDashboard,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Dashboard:
        """Update Dashboard"""
        response = self.patch(
            f"/dashboards/{dashboard_id}",
            models.Dashboard,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.Dashboard)
        return response

    # PATCH /dashboard_elements/{dashboard_element_id} -> models.DashboardElement
    def update_dashboard_element(
        self,
        # Id of dashboard element
        dashboard_element_id: str,
        body: models.WriteDashboardElement,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.DashboardElement:
        """Update DashboardElement"""
        response = self.patch(
            f"/dashboard_elements/{dashboard_element_id}",
            models.DashboardElement,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.DashboardElement)
        return response

    # PATCH /dashboard_filters/{dashboard_filter_id} -> models.DashboardFilter
    def update_dashboard_filter(
        self,
        # Id of dashboard filter
        dashboard_filter_id: str,
        body: models.WriteDashboardFilter,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.DashboardFilter:
        """Update Dashboard Filter"""
        response = self.patch(
            f"/dashboard_filters/{dashboard_filter_id}",
            models.DashboardFilter,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.DashboardFilter)
        return response

    # PATCH /dashboard_layouts/{dashboard_layout_id} -> models.DashboardLayout
    def update_dashboard_layout(
        self,
        # Id of dashboard layout
        dashboard_layout_id: str,
        body: models.WriteDashboardLayout,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.DashboardLayout:
        """Update DashboardLayout"""
        response = self.patch(
            f"/dashboard_layouts/{dashboard_layout_id}",
            models.DashboardLayout,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.DashboardLayout)
        return response

    # PATCH /dashboard_layout_components/{dashboard_layout_component_id} -> models.DashboardLayoutComponent
    def update_dashboard_layout_component(
        self,
        # Id of dashboard layout component
        dashboard_layout_component_id: str,
        body: models.WriteDashboardLayoutComponent,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.DashboardLayoutComponent:
        """Update DashboardLayoutComponent"""
        response = self.patch(
            f"/dashboard_layout_components/{dashboard_layout_component_id}",
            models.DashboardLayoutComponent,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.DashboardLayoutComponent)
        return response

    # PATCH /datagroups/{datagroup_id} -> models.Datagroup
    def update_datagroup(
        self,
        # ID of datagroup.
        datagroup_id: str,
        body: models.WriteDatagroup,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Datagroup:
        """Update Datagroup"""
        response = self.patch(
            f"/datagroups/{datagroup_id}",
            models.Datagroup,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.Datagroup)
        return response

    # PATCH /folders/{folder_id} -> models.Folder
    def update_folder(
        self,
        # Id of folder
        folder_id: str,
        body: models.WriteUpdateFolder,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Folder:
        """Update Folder"""
        response = self.patch(
            f"/folders/{folder_id}",
            models.Folder,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.Folder)
        return response

    # PUT /projects/{project_id}/git_branch -> models.GitBranch
    def update_git_branch(
        self,
        # Project Id
        project_id: str,
        body: models.WriteGitBranch,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.GitBranch:
        """Update Project Git Branch"""
        response = self.put(
            f"/projects/{project_id}/git_branch",
            models.GitBranch,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.GitBranch)
        return response

    # PATCH /groups/{group_id} -> models.Group
    def update_group(
        self,
        # Id of group
        group_id: int,
        body: models.WriteGroup,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Group:
        """Update Group"""
        response = self.patch(
            f"/groups/{group_id}",
            models.Group,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.Group)
        return response

    # PATCH /homepages/{homepage_id} -> models.Homepage
    def update_homepage(
        self,
        # Id of homepage
        homepage_id: int,
        body: models.WriteHomepage,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Homepage:
        """Update Homepage"""
        response = self.patch(
            f"/homepages/{homepage_id}",
            models.Homepage,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.Homepage)
        return response

    # PATCH /homepage_items/{homepage_item_id} -> models.HomepageItem
    def update_homepage_item(
        self,
        # Id of homepage item
        homepage_item_id: int,
        body: models.WriteHomepageItem,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.HomepageItem:
        """Update Homepage Item"""
        response = self.patch(
            f"/homepage_items/{homepage_item_id}",
            models.HomepageItem,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.HomepageItem)
        return response

    # PATCH /homepage_sections/{homepage_section_id} -> models.HomepageSection
    def update_homepage_section(
        self,
        # Id of homepage section
        homepage_section_id: int,
        body: models.WriteHomepageSection,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.HomepageSection:
        """Update Homepage section"""
        response = self.patch(
            f"/homepage_sections/{homepage_section_id}",
            models.HomepageSection,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.HomepageSection)
        return response

    # PATCH /integrations/{integration_id} -> models.Integration
    def update_integration(
        self,
        # Id of Integration
        integration_id: int,
        body: models.WriteIntegration,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Integration:
        """Update Integration"""
        response = self.patch(
            f"/integrations/{integration_id}",
            models.Integration,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.Integration)
        return response

    # PATCH /integration_hubs/{integration_hub_id} -> models.IntegrationHub
    def update_integration_hub(
        self,
        # Id of Integration Hub
        integration_hub_id: int,
        body: models.WriteIntegrationHub,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.IntegrationHub:
        """Update Integration Hub"""
        response = self.patch(
            f"/integration_hubs/{integration_hub_id}",
            models.IntegrationHub,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.IntegrationHub)
        return response

    # PATCH /internal_help_resources -> models.InternalHelpResources
    def update_internal_help_resources(
        self,
        body: models.WriteInternalHelpResources,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.InternalHelpResources:
        """Update internal help resources configuration"""
        response = self.patch(
            f"/internal_help_resources",
            models.InternalHelpResources,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.InternalHelpResources)
        return response

    # PATCH /internal_help_resources_content -> models.InternalHelpResourcesContent
    def update_internal_help_resources_content(
        self,
        body: models.WriteInternalHelpResourcesContent,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.InternalHelpResourcesContent:
        """Update internal help resources content"""
        response = self.patch(
            f"/internal_help_resources_content",
            models.InternalHelpResourcesContent,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.InternalHelpResourcesContent)
        return response

    # PATCH /ldap_config -> models.LDAPConfig
    def update_ldap_config(
        self,
        body: models.WriteLDAPConfig,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.LDAPConfig:
        """Update LDAP Configuration"""
        response = self.patch(
            f"/ldap_config",
            models.LDAPConfig,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.LDAPConfig)
        return response

    # PATCH /legacy_features/{legacy_feature_id} -> models.LegacyFeature
    def update_legacy_feature(
        self,
        # id of legacy feature
        legacy_feature_id: int,
        body: models.WriteLegacyFeature,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.LegacyFeature:
        """Update Legacy Feature"""
        response = self.patch(
            f"/legacy_features/{legacy_feature_id}",
            models.LegacyFeature,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.LegacyFeature)
        return response

    # PATCH /looks/{look_id} -> models.LookWithQuery
    def update_look(
        self,
        # Id of look
        look_id: int,
        body: models.WriteLookWithQuery,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.LookWithQuery:
        """Update Look"""
        response = self.patch(
            f"/looks/{look_id}",
            models.LookWithQuery,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.LookWithQuery)
        return response

    # PATCH /lookml_models/{lookml_model_name} -> models.LookmlModel
    def update_lookml_model(
        self,
        # Name of lookml model.
        lookml_model_name: str,
        body: models.WriteLookmlModel,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.LookmlModel:
        """Update LookML Model"""
        response = self.patch(
            f"/lookml_models/{lookml_model_name}",
            models.LookmlModel,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.LookmlModel)
        return response

    # PATCH /model_sets/{model_set_id} -> models.ModelSet
    def update_model_set(
        self,
        # id of model set
        model_set_id: int,
        body: models.WriteModelSet,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ModelSet:
        """Update Model Set"""
        response = self.patch(
            f"/model_sets/{model_set_id}",
            models.ModelSet,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.ModelSet)
        return response

    # PATCH /oidc_config -> models.OIDCConfig
    def update_oidc_config(
        self,
        body: models.WriteOIDCConfig,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.OIDCConfig:
        """Update OIDC Configuration"""
        response = self.patch(
            f"/oidc_config",
            models.OIDCConfig,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.OIDCConfig)
        return response

    # PATCH /password_config -> models.PasswordConfig
    def update_password_config(
        self,
        body: models.WritePasswordConfig,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.PasswordConfig:
        """Update Password Config"""
        response = self.patch(
            f"/password_config",
            models.PasswordConfig,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.PasswordConfig)
        return response

    # PATCH /permission_sets/{permission_set_id} -> models.PermissionSet
    def update_permission_set(
        self,
        # id of permission set
        permission_set_id: int,
        body: models.WritePermissionSet,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.PermissionSet:
        """Update Permission Set"""
        response = self.patch(
            f"/permission_sets/{permission_set_id}",
            models.PermissionSet,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.PermissionSet)
        return response

    # PATCH /projects/{project_id} -> models.Project
    def update_project(
        self,
        # Project Id
        project_id: str,
        body: models.WriteProject,
        # Requested fields
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Project:
        """Update Project"""
        response = self.patch(
            f"/projects/{project_id}",
            models.Project,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.Project)
        return response

    # PUT /projects/{root_project_id}/credential/{credential_id} -> models.RepositoryCredential
    def update_repository_credential(
        self,
        # Root Project Id
        root_project_id: str,
        # Credential Id
        credential_id: str,
        body: models.WriteRepositoryCredential,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.RepositoryCredential:
        """Create Repository Credential"""
        response = self.put(
            f"/projects/{root_project_id}/credential/{credential_id}",
            models.RepositoryCredential,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.RepositoryCredential)
        return response

    # PATCH /roles/{role_id} -> models.Role
    def update_role(
        self,
        # id of role
        role_id: int,
        body: models.WriteRole,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Role:
        """Update Role"""
        response = self.patch(
            f"/roles/{role_id}",
            models.Role,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.Role)
        return response

    # PATCH /saml_config -> models.SamlConfig
    def update_saml_config(
        self,
        body: models.WriteSamlConfig,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.SamlConfig:
        """Update SAML Configuration"""
        response = self.patch(
            f"/saml_config",
            models.SamlConfig,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.SamlConfig)
        return response

    # PATCH /scheduled_plans/{scheduled_plan_id} -> models.ScheduledPlan
    def update_scheduled_plan(
        self,
        # Scheduled Plan Id
        scheduled_plan_id: int,
        body: models.WriteScheduledPlan,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ScheduledPlan:
        """Update Scheduled Plan"""
        response = self.patch(
            f"/scheduled_plans/{scheduled_plan_id}",
            models.ScheduledPlan,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.ScheduledPlan)
        return response

    # PATCH /session -> models.ApiSession
    def update_session(
        self,
        body: models.WriteApiSession,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ApiSession:
        """Update Session"""
        response = self.patch(
            f"/session",
            models.ApiSession,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.ApiSession)
        return response

    # PATCH /session_config -> models.SessionConfig
    def update_session_config(
        self,
        body: models.WriteSessionConfig,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.SessionConfig:
        """Update Session Config"""
        response = self.patch(
            f"/session_config",
            models.SessionConfig,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.SessionConfig)
        return response

    # PATCH /spaces/{space_id} -> models.Space
    def update_space(
        self,
        # Id of space
        space_id: str,
        body: models.WriteUpdateSpace,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Space:
        """Update Space"""
        response = self.patch(
            f"/spaces/{space_id}",
            models.Space,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.Space)
        return response

    # PATCH /themes/{theme_id} -> models.Theme
    def update_theme(
        self,
        # Id of theme
        theme_id: str,
        body: models.WriteTheme,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Theme:
        """Update Theme"""
        response = self.patch(
            f"/themes/{theme_id}",
            models.Theme,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.Theme)
        return response

    # PATCH /users/{user_id} -> models.User
    def update_user(
        self,
        # Id of user
        user_id: int,
        body: models.WriteUser,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.User:
        """Update User"""
        response = self.patch(
            f"/users/{user_id}",
            models.User,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.User)
        return response

    # PATCH /user_attributes/{user_attribute_id} -> models.UserAttribute
    def update_user_attribute(
        self,
        # Id of user attribute
        user_attribute_id: int,
        body: models.WriteUserAttribute,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.UserAttribute:
        """Update User Attribute"""
        response = self.patch(
            f"/user_attributes/{user_attribute_id}",
            models.UserAttribute,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.UserAttribute)
        return response

    # PATCH /groups/{group_id}/attribute_values/{user_attribute_id} -> models.UserAttributeGroupValue
    def update_user_attribute_group_value(
        self,
        # Id of group
        group_id: int,
        # Id of user attribute
        user_attribute_id: int,
        body: models.UserAttributeGroupValue,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.UserAttributeGroupValue:
        """Set User Attribute Group Value"""
        response = self.patch(
            f"/groups/{group_id}/attribute_values/{user_attribute_id}",
            models.UserAttributeGroupValue,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.UserAttributeGroupValue)
        return response

    # PATCH /users/{user_id}/credentials_email -> models.CredentialsEmail
    def update_user_credentials_email(
        self,
        # id of user
        user_id: int,
        body: models.WriteCredentialsEmail,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.CredentialsEmail:
        """Update Email/Password Credential"""
        response = self.patch(
            f"/users/{user_id}/credentials_email",
            models.CredentialsEmail,
            query_params={"fields": fields},
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.CredentialsEmail)
        return response

    # PUT /whitelabel_configuration -> models.WhitelabelConfiguration
    def update_whitelabel_configuration(
        self,
        body: models.WriteWhitelabelConfiguration,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.WhitelabelConfiguration:
        """Update Whitelabel configuration"""
        response = self.put(
            f"/whitelabel_configuration",
            models.WhitelabelConfiguration,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.WhitelabelConfiguration)
        return response

    # GET /users/{user_id} -> models.User
    def user(
        self,
        # Id of user
        user_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.User:
        """Get User by Id"""
        response = self.get(
            f"/users/{user_id}",
            models.User,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.User)
        return response

    # GET /user_attributes/{user_attribute_id} -> models.UserAttribute
    def user_attribute(
        self,
        # Id of user attribute
        user_attribute_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.UserAttribute:
        """Get User Attribute"""
        response = self.get(
            f"/user_attributes/{user_attribute_id}",
            models.UserAttribute,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.UserAttribute)
        return response

    # GET /users/{user_id}/attribute_values -> Sequence[models.UserAttributeWithValue]
    def user_attribute_user_values(
        self,
        # Id of user
        user_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        # Specific user attributes to request. Omit or leave blank to request all user attributes.
        user_attribute_ids: Optional[models.DelimSequence[int]] = None,
        # If true, returns all values in the search path instead of just the first value found. Useful for debugging group precedence.
        all_values: Optional[bool] = None,
        # If true, returns an empty record for each requested attribute that has no user, group, or default value.
        include_unset: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.UserAttributeWithValue]:
        """Get User Attribute Values"""
        response = self.get(
            f"/users/{user_id}/attribute_values",
            Sequence[models.UserAttributeWithValue],
            query_params={
                "fields": fields,
                "user_attribute_ids": user_attribute_ids,
                "all_values": all_values,
                "include_unset": include_unset,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /users/{user_id}/credentials_api3/{credentials_api3_id} -> models.CredentialsApi3
    def user_credentials_api3(
        self,
        # Id of user
        user_id: int,
        # Id of API 3 Credential
        credentials_api3_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.CredentialsApi3:
        """Get API 3 Credential"""
        response = self.get(
            f"/users/{user_id}/credentials_api3/{credentials_api3_id}",
            models.CredentialsApi3,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.CredentialsApi3)
        return response

    # GET /users/{user_id}/credentials_email -> models.CredentialsEmail
    def user_credentials_email(
        self,
        # id of user
        user_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.CredentialsEmail:
        """Get Email/Password Credential"""
        response = self.get(
            f"/users/{user_id}/credentials_email",
            models.CredentialsEmail,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.CredentialsEmail)
        return response

    # GET /users/{user_id}/credentials_embed/{credentials_embed_id} -> models.CredentialsEmbed
    def user_credentials_embed(
        self,
        # Id of user
        user_id: int,
        # Id of Embedding Credential
        credentials_embed_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.CredentialsEmbed:
        """Get Embedding Credential"""
        response = self.get(
            f"/users/{user_id}/credentials_embed/{credentials_embed_id}",
            models.CredentialsEmbed,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.CredentialsEmbed)
        return response

    # GET /users/{user_id}/credentials_google -> models.CredentialsGoogle
    def user_credentials_google(
        self,
        # id of user
        user_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.CredentialsGoogle:
        """Get Google Auth Credential"""
        response = self.get(
            f"/users/{user_id}/credentials_google",
            models.CredentialsGoogle,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.CredentialsGoogle)
        return response

    # GET /users/{user_id}/credentials_ldap -> models.CredentialsLDAP
    def user_credentials_ldap(
        self,
        # id of user
        user_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.CredentialsLDAP:
        """Get LDAP Credential"""
        response = self.get(
            f"/users/{user_id}/credentials_ldap",
            models.CredentialsLDAP,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.CredentialsLDAP)
        return response

    # GET /users/{user_id}/credentials_looker_openid -> models.CredentialsLookerOpenid
    def user_credentials_looker_openid(
        self,
        # id of user
        user_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.CredentialsLookerOpenid:
        """Get Looker OpenId Credential"""
        response = self.get(
            f"/users/{user_id}/credentials_looker_openid",
            models.CredentialsLookerOpenid,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.CredentialsLookerOpenid)
        return response

    # GET /users/{user_id}/credentials_oidc -> models.CredentialsOIDC
    def user_credentials_oidc(
        self,
        # id of user
        user_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.CredentialsOIDC:
        """Get OIDC Auth Credential"""
        response = self.get(
            f"/users/{user_id}/credentials_oidc",
            models.CredentialsOIDC,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.CredentialsOIDC)
        return response

    # GET /users/{user_id}/credentials_saml -> models.CredentialsSaml
    def user_credentials_saml(
        self,
        # id of user
        user_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.CredentialsSaml:
        """Get Saml Auth Credential"""
        response = self.get(
            f"/users/{user_id}/credentials_saml",
            models.CredentialsSaml,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.CredentialsSaml)
        return response

    # GET /users/{user_id}/credentials_totp -> models.CredentialsTotp
    def user_credentials_totp(
        self,
        # id of user
        user_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.CredentialsTotp:
        """Get Two-Factor Credential"""
        response = self.get(
            f"/users/{user_id}/credentials_totp",
            models.CredentialsTotp,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.CredentialsTotp)
        return response

    # GET /users/credential/{credential_type}/{credential_id} -> models.User
    def user_for_credential(
        self,
        # Type name of credential
        credential_type: str,
        # Id of credential
        credential_id: str,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.User:
        """Get User by Credential Id"""
        response = self.get(
            f"/users/credential/{credential_type}/{credential_id}",
            models.User,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.User)
        return response

    # GET /users/{user_id}/roles -> Sequence[models.Role]
    def user_roles(
        self,
        # id of user
        user_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        # Get only roles associated directly with the user: exclude those only associated through groups.
        direct_association_only: Optional[bool] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> Sequence[models.Role]:
        """Get User Roles"""
        response = self.get(
            f"/users/{user_id}/roles",
            Sequence[models.Role],
            query_params={
                "fields": fields,
                "direct_association_only": direct_association_only,
            },
            transport_options=transport_options,
        )
        assert isinstance(response, list)
        return response

    # GET /users/{user_id}/sessions/{session_id} -> models.Session
    def user_session(
        self,
        # Id of user
        user_id: int,
        # Id of Web Login Session
        session_id: int,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Session:
        """Get Web Login Session"""
        response = self.get(
            f"/users/{user_id}/sessions/{session_id}",
            models.Session,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.Session)
        return response

    # POST /projects/{project_id}/validate -> models.ProjectValidation
    def validate_project(
        self,
        # Project Id
        project_id: str,
        # Requested fields
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ProjectValidation:
        """Validate Project"""
        response = self.post(
            f"/projects/{project_id}/validate",
            models.ProjectValidation,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.ProjectValidation)
        return response

    # POST /themes/validate -> models.ValidationError
    def validate_theme(
        self,
        body: models.WriteTheme,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ValidationError:
        """Validate Theme"""
        response = self.post(
            f"/themes/validate",
            models.ValidationError,
            body=body,
            transport_options=transport_options,
        )
        assert isinstance(response, models.ValidationError)
        return response

    # GET /versions -> models.ApiVersion
    def versions(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.ApiVersion:
        """Get ApiVersion"""
        response = self.get(
            f"/versions",
            models.ApiVersion,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.ApiVersion)
        return response

    # GET /whitelabel_configuration -> models.WhitelabelConfiguration
    def whitelabel_configuration(
        self,
        # Requested fields.
        fields: Optional[str] = None,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.WhitelabelConfiguration:
        """Get Whitelabel configuration"""
        response = self.get(
            f"/whitelabel_configuration",
            models.WhitelabelConfiguration,
            query_params={"fields": fields},
            transport_options=transport_options,
        )
        assert isinstance(response, models.WhitelabelConfiguration)
        return response

    # GET /workspaces/{workspace_id} -> models.Workspace
    def workspace(
        self,
        # Id of the workspace
        workspace_id: str,
        transport_options: Optional[transport.TransportSettings] = None,
    ) -> models.Workspace:
        """Get Workspace"""
        response = self.get(
            f"/workspaces/{workspace_id}",
            models.Workspace,
            transport_options=transport_options,
        )
        assert isinstance(response, models.Workspace)
        return response
