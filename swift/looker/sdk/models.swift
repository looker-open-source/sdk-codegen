/**

 MIT License

 Copyright (c) 2023 Looker Data Sciences, Inc.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

 */

/**
 * 373 API models: 287 Spec, 0 Request, 62 Write, 24 Enum
 */


/// NOTE: Do not edit this file generated by Looker SDK Codegen for API 4.0

import Foundation

public struct AccessToken: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _access_token = "access_token"
        case _token_type = "token_type"
        case _expires_in = "expires_in"
        case _refresh_token = "refresh_token"
    }
    private var _access_token: AnyString?
    /**
     * Access Token used for API calls (read-only)
     */
    public var access_token: String? {
        get { _access_token?.value }
        set { _access_token = newValue.map(AnyString.init) }
    }

    private var _token_type: AnyString?
    /**
     * Type of Token (read-only)
     */
    public var token_type: String? {
        get { _token_type?.value }
        set { _token_type = newValue.map(AnyString.init) }
    }

    private var _expires_in: AnyInt?
    /**
     * Number of seconds before the token expires (read-only)
     */
    public var expires_in: Int64? {
        get { _expires_in?.value }
        set { _expires_in = newValue.map(AnyInt.init) }
    }

    private var _refresh_token: AnyString?
    /**
     * Refresh token which can be used to obtain a new access token (read-only)
     */
    public var refresh_token: String? {
        get { _refresh_token?.value }
        set { _refresh_token = newValue.map(AnyString.init) }
    }

    public init(access_token: String? = nil, token_type: String? = nil, expires_in: Int64? = nil, refresh_token: String? = nil) {
        self._access_token = access_token.map(AnyString.init)
        self._token_type = token_type.map(AnyString.init)
        self._expires_in = expires_in.map(AnyInt.init)
        self._refresh_token = refresh_token.map(AnyString.init)
    }

}

public struct Alert: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case applied_dashboard_filters
        case comparison_type
        case _cron = "cron"
        case _custom_url_base = "custom_url_base"
        case _custom_url_params = "custom_url_params"
        case _custom_url_label = "custom_url_label"
        case show_custom_url
        case _custom_title = "custom_title"
        case _dashboard_element_id = "dashboard_element_id"
        case _description = "description"
        case destinations
        case field
        case followed
        case followable
        case _id = "id"
        case is_disabled
        case _disabled_reason = "disabled_reason"
        case is_public
        case investigative_content_type
        case _investigative_content_id = "investigative_content_id"
        case _investigative_content_title = "investigative_content_title"
        case _lookml_dashboard_id = "lookml_dashboard_id"
        case _lookml_link_id = "lookml_link_id"
        case _owner_id = "owner_id"
        case _owner_display_name = "owner_display_name"
        case threshold
        case time_series_condition_state
    }
    /**
     * Filters coming from the dashboard that are applied. Example `[{ "filter_title": "Name", "field_name": "distribution_centers.name", "filter_value": "Los Angeles CA" }]`
     */
    public var applied_dashboard_filters: [AlertAppliedDashboardFilter]?

    /**
     * This property informs the check what kind of comparison we are performing. Only certain condition types are valid for time series alerts. For details, refer to [Setting Alert Conditions](https://cloud.google.com/looker/docs/sharing-and-publishing/creating-alerts#setting_alert_conditions) Valid values are: "EQUAL_TO", "GREATER_THAN", "GREATER_THAN_OR_EQUAL_TO", "LESS_THAN", "LESS_THAN_OR_EQUAL_TO", "INCREASES_BY", "DECREASES_BY", "CHANGES_BY".
     */
    public var comparison_type: ComparisonType

    private var _cron: AnyString
    /**
     * Vixie-Style crontab specification when to run. At minimum, it has to be longer than 15 minute intervals
     */
    public var cron: String {
        get { _cron.value }
        set { _cron = AnyString.init(newValue) }
    }

    private var _custom_url_base: AnyString?
    /**
     * Domain for the custom url selected by the alert creator from the admin defined domain allowlist
     */
    public var custom_url_base: String? {
        get { _custom_url_base?.value }
        set { _custom_url_base = newValue.map(AnyString.init) }
    }

    private var _custom_url_params: AnyString?
    /**
     * Parameters and path for the custom url defined by the alert creator
     */
    public var custom_url_params: String? {
        get { _custom_url_params?.value }
        set { _custom_url_params = newValue.map(AnyString.init) }
    }

    private var _custom_url_label: AnyString?
    /**
     * Label for the custom url defined by the alert creator
     */
    public var custom_url_label: String? {
        get { _custom_url_label?.value }
        set { _custom_url_label = newValue.map(AnyString.init) }
    }

    /**
     * Boolean to determine if the custom url should be used
     */
    public var show_custom_url: Bool?

    private var _custom_title: AnyString?
    /**
     * An optional, user-defined title for the alert
     */
    public var custom_title: String? {
        get { _custom_title?.value }
        set { _custom_title = newValue.map(AnyString.init) }
    }

    private var _dashboard_element_id: AnyString?
    /**
     * ID of the dashboard element associated with the alert. Refer to [dashboard_element()](#!/Dashboard/DashboardElement)
     */
    public var dashboard_element_id: String? {
        get { _dashboard_element_id?.value }
        set { _dashboard_element_id = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * An optional description for the alert. This supplements the title
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    /**
     * Array of destinations to send alerts to. Must be the same type of destination. Example `[{ "destination_type": "EMAIL", "email_address": "test@test.com" }]`
     */
    public var destinations: [AlertDestination]

    public var field: AlertField

    /**
     * Whether or not the user follows this alert. (read-only)
     */
    public var followed: Bool?

    /**
     * Whether or not the alert is followable (read-only)
     */
    public var followable: Bool?

    private var _id: AnyString?
    /**
     * ID of the alert (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    /**
     * Whether or not the alert is disabled
     */
    public var is_disabled: Bool?

    private var _disabled_reason: AnyString?
    /**
     * Reason for disabling alert
     */
    public var disabled_reason: String? {
        get { _disabled_reason?.value }
        set { _disabled_reason = newValue.map(AnyString.init) }
    }

    /**
     * Whether or not the alert is public
     */
    public var is_public: Bool?

    /**
     * The type of the investigative content Valid values are: "dashboard".
     */
    public var investigative_content_type: InvestigativeContentType?

    private var _investigative_content_id: AnyString?
    /**
     * The ID of the investigative content. For dashboards, this will be the dashboard ID
     */
    public var investigative_content_id: String? {
        get { _investigative_content_id?.value }
        set { _investigative_content_id = newValue.map(AnyString.init) }
    }

    private var _investigative_content_title: AnyString?
    /**
     * The title of the investigative content. (read-only)
     */
    public var investigative_content_title: String? {
        get { _investigative_content_title?.value }
        set { _investigative_content_title = newValue.map(AnyString.init) }
    }

    private var _lookml_dashboard_id: AnyString?
    /**
     * ID of the LookML dashboard associated with the alert
     */
    public var lookml_dashboard_id: String? {
        get { _lookml_dashboard_id?.value }
        set { _lookml_dashboard_id = newValue.map(AnyString.init) }
    }

    private var _lookml_link_id: AnyString?
    /**
     * ID of the LookML dashboard element associated with the alert
     */
    public var lookml_link_id: String? {
        get { _lookml_link_id?.value }
        set { _lookml_link_id = newValue.map(AnyString.init) }
    }

    private var _owner_id: AnyString
    /**
     * User id of alert owner
     */
    public var owner_id: String {
        get { _owner_id.value }
        set { _owner_id = AnyString.init(newValue) }
    }

    private var _owner_display_name: AnyString?
    /**
     * Alert owner's display name (read-only)
     */
    public var owner_display_name: String? {
        get { _owner_display_name?.value }
        set { _owner_display_name = newValue.map(AnyString.init) }
    }

    /**
     * Value of the alert threshold
     */
    public var threshold: Double

    public var time_series_condition_state: AlertConditionState?

    public init(applied_dashboard_filters: [AlertAppliedDashboardFilter]? = nil, comparison_type: ComparisonType, cron: String, custom_url_base: String? = nil, custom_url_params: String? = nil, custom_url_label: String? = nil, show_custom_url: Bool? = nil, custom_title: String? = nil, dashboard_element_id: String? = nil, description: String? = nil, destinations: [AlertDestination], field: AlertField, followed: Bool? = nil, followable: Bool? = nil, id: String? = nil, is_disabled: Bool? = nil, disabled_reason: String? = nil, is_public: Bool? = nil, investigative_content_type: InvestigativeContentType? = nil, investigative_content_id: String? = nil, investigative_content_title: String? = nil, lookml_dashboard_id: String? = nil, lookml_link_id: String? = nil, owner_id: String, owner_display_name: String? = nil, threshold: Double, time_series_condition_state: AlertConditionState? = nil) {
        self.applied_dashboard_filters = applied_dashboard_filters
        self.comparison_type = comparison_type
        self._cron = AnyString.init(cron)
        self._custom_url_base = custom_url_base.map(AnyString.init)
        self._custom_url_params = custom_url_params.map(AnyString.init)
        self._custom_url_label = custom_url_label.map(AnyString.init)
        self.show_custom_url = show_custom_url
        self._custom_title = custom_title.map(AnyString.init)
        self._dashboard_element_id = dashboard_element_id.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self.destinations = destinations
        self.field = field
        self.followed = followed
        self.followable = followable
        self._id = id.map(AnyString.init)
        self.is_disabled = is_disabled
        self._disabled_reason = disabled_reason.map(AnyString.init)
        self.is_public = is_public
        self.investigative_content_type = investigative_content_type
        self._investigative_content_id = investigative_content_id.map(AnyString.init)
        self._investigative_content_title = investigative_content_title.map(AnyString.init)
        self._lookml_dashboard_id = lookml_dashboard_id.map(AnyString.init)
        self._lookml_link_id = lookml_link_id.map(AnyString.init)
        self._owner_id = AnyString.init(owner_id)
        self._owner_display_name = owner_display_name.map(AnyString.init)
        self.threshold = threshold
        self.time_series_condition_state = time_series_condition_state
    }

    public init(applied_dashboard_filters: [AlertAppliedDashboardFilter]? = nil, _ comparison_type: ComparisonType, _ cron: String, custom_url_base: String? = nil, custom_url_params: String? = nil, custom_url_label: String? = nil, show_custom_url: Bool? = nil, custom_title: String? = nil, dashboard_element_id: String? = nil, description: String? = nil, _ destinations: [AlertDestination], _ field: AlertField, followed: Bool? = nil, followable: Bool? = nil, id: String? = nil, is_disabled: Bool? = nil, disabled_reason: String? = nil, is_public: Bool? = nil, investigative_content_type: InvestigativeContentType? = nil, investigative_content_id: String? = nil, investigative_content_title: String? = nil, lookml_dashboard_id: String? = nil, lookml_link_id: String? = nil, _ owner_id: String, owner_display_name: String? = nil, _ threshold: Double, time_series_condition_state: AlertConditionState? = nil) {
        self.init(applied_dashboard_filters: applied_dashboard_filters, comparison_type: comparison_type, cron: cron, custom_url_base: custom_url_base, custom_url_params: custom_url_params, custom_url_label: custom_url_label, show_custom_url: show_custom_url, custom_title: custom_title, dashboard_element_id: dashboard_element_id, description: description, destinations: destinations, field: field, followed: followed, followable: followable, id: id, is_disabled: is_disabled, disabled_reason: disabled_reason, is_public: is_public, investigative_content_type: investigative_content_type, investigative_content_id: investigative_content_id, investigative_content_title: investigative_content_title, lookml_dashboard_id: lookml_dashboard_id, lookml_link_id: lookml_link_id, owner_id: owner_id, owner_display_name: owner_display_name, threshold: threshold, time_series_condition_state: time_series_condition_state)
    }

}

public struct AlertAppliedDashboardFilter: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _filter_title = "filter_title"
        case _field_name = "field_name"
        case _filter_value = "filter_value"
        case _filter_description = "filter_description"
    }
    private var _filter_title: AnyString
    /**
     * Field Title. Refer to `DashboardFilter.title` in [DashboardFilter](#!/types/DashboardFilter). Example `Name`
     */
    public var filter_title: String {
        get { _filter_title.value }
        set { _filter_title = AnyString.init(newValue) }
    }

    private var _field_name: AnyString
    /**
     * Field Name. Refer to `DashboardFilter.dimension` in [DashboardFilter](#!/types/DashboardFilter). Example `distribution_centers.name`
     */
    public var field_name: String {
        get { _field_name.value }
        set { _field_name = AnyString.init(newValue) }
    }

    private var _filter_value: AnyString
    /**
     * Field Value. [Filter Expressions](https://cloud.google.com/looker/docs/reference/filter-expressions). Example `Los Angeles CA`
     */
    public var filter_value: String {
        get { _filter_value.value }
        set { _filter_value = AnyString.init(newValue) }
    }

    private var _filter_description: AnyString?
    /**
     * Human Readable Filter Description. This may be null or auto-generated. Example `is Los Angeles CA` (read-only)
     */
    public var filter_description: String? {
        get { _filter_description?.value }
        set { _filter_description = newValue.map(AnyString.init) }
    }

    public init(filter_title: String, field_name: String, filter_value: String, filter_description: String? = nil) {
        self._filter_title = AnyString.init(filter_title)
        self._field_name = AnyString.init(field_name)
        self._filter_value = AnyString.init(filter_value)
        self._filter_description = filter_description.map(AnyString.init)
    }

    public init(_ filter_title: String, _ field_name: String, _ filter_value: String, filter_description: String? = nil) {
        self.init(filter_title: filter_title, field_name: field_name, filter_value: filter_value, filter_description: filter_description)
    }

}

public struct AlertConditionState: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _previous_time_series_id = "previous_time_series_id"
        case _latest_time_series_id = "latest_time_series_id"
    }
    private var _previous_time_series_id: AnyString?
    /**
     * (Write-Only) The second latest time string the alert has seen.
     */
    public var previous_time_series_id: String? {
        get { _previous_time_series_id?.value }
        set { _previous_time_series_id = newValue.map(AnyString.init) }
    }

    private var _latest_time_series_id: AnyString?
    /**
     * (Write-Only) Latest time string the alert has seen.
     */
    public var latest_time_series_id: String? {
        get { _latest_time_series_id?.value }
        set { _latest_time_series_id = newValue.map(AnyString.init) }
    }

    public init(previous_time_series_id: String? = nil, latest_time_series_id: String? = nil) {
        self._previous_time_series_id = previous_time_series_id.map(AnyString.init)
        self._latest_time_series_id = latest_time_series_id.map(AnyString.init)
    }

}

public struct AlertDestination: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case destination_type
        case _email_address = "email_address"
        case _action_hub_integration_id = "action_hub_integration_id"
        case _action_hub_form_params_json = "action_hub_form_params_json"
    }
    /**
     * Type of destination that the alert will be sent to Valid values are: "EMAIL", "ACTION_HUB".
     */
    public var destination_type: DestinationType

    private var _email_address: AnyString?
    /**
     * Email address for the 'email' type
     */
    public var email_address: String? {
        get { _email_address?.value }
        set { _email_address = newValue.map(AnyString.init) }
    }

    private var _action_hub_integration_id: AnyString?
    /**
     * Action hub integration id for the 'action_hub' type. [Integration](#!/types/Integration)
     */
    public var action_hub_integration_id: String? {
        get { _action_hub_integration_id?.value }
        set { _action_hub_integration_id = newValue.map(AnyString.init) }
    }

    private var _action_hub_form_params_json: AnyString?
    /**
     * Action hub form params json for the 'action_hub' type [IntegrationParam](#!/types/IntegrationParam)
     */
    public var action_hub_form_params_json: String? {
        get { _action_hub_form_params_json?.value }
        set { _action_hub_form_params_json = newValue.map(AnyString.init) }
    }

    public init(destination_type: DestinationType, email_address: String? = nil, action_hub_integration_id: String? = nil, action_hub_form_params_json: String? = nil) {
        self.destination_type = destination_type
        self._email_address = email_address.map(AnyString.init)
        self._action_hub_integration_id = action_hub_integration_id.map(AnyString.init)
        self._action_hub_form_params_json = action_hub_form_params_json.map(AnyString.init)
    }

    public init(_ destination_type: DestinationType, email_address: String? = nil, action_hub_integration_id: String? = nil, action_hub_form_params_json: String? = nil) {
        self.init(destination_type: destination_type, email_address: email_address, action_hub_integration_id: action_hub_integration_id, action_hub_form_params_json: action_hub_form_params_json)
    }

}

public struct AlertField: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _title = "title"
        case _name = "name"
        case filter
    }
    private var _title: AnyString
    /**
     * Field's title. Usually auto-generated to reflect field name and its filters
     */
    public var title: String {
        get { _title.value }
        set { _title = AnyString.init(newValue) }
    }

    private var _name: AnyString
    /**
     * Field's name. Has the format `<view>.<field>` Refer to [docs](https://cloud.google.com/looker/docs/sharing-and-publishing/creating-alerts) for more details
     */
    public var name: String {
        get { _name.value }
        set { _name = AnyString.init(newValue) }
    }

    /**
     * (Optional / Advance Use) List of fields filter. This further restricts the alert to certain dashboard element's field values. This can be used on top of dashboard filters `applied_dashboard_filters`. To keep thing simple, it's suggested to just use dashboard filters. Example: `{ 'title': '12 Number on Hand', 'name': 'inventory_items.number_on_hand', 'filter': [{ 'field_name': 'inventory_items.id', 'field_value': 12, 'filter_value': null }] }`
     */
    public var filter: [AlertFieldFilter]?

    public init(title: String, name: String, filter: [AlertFieldFilter]? = nil) {
        self._title = AnyString.init(title)
        self._name = AnyString.init(name)
        self.filter = filter
    }

    public init(_ title: String, _ name: String, filter: [AlertFieldFilter]? = nil) {
        self.init(title: title, name: name, filter: filter)
    }

}

public struct AlertFieldFilter: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _field_name = "field_name"
        case field_value
        case _filter_value = "filter_value"
    }
    private var _field_name: AnyString
    /**
     * Field Name. Has format `<view>.<field>`
     */
    public var field_name: String {
        get { _field_name.value }
        set { _field_name = AnyString.init(newValue) }
    }

    /**
     * Field Value. Depends on the type of field - numeric or string. For [location](https://cloud.google.com/looker/docs/reference/field-reference/dimension-type-reference#location) type, it's a list of floats. Example `[1.0, 56.0]`
     */
    public var field_value: AnyCodable

    private var _filter_value: AnyString?
    /**
     * Filter Value. Usually null except for [location](https://cloud.google.com/looker/docs/reference/field-reference/dimension-type-reference#location) type. It'll be a string of lat,long ie `'1.0,56.0'`
     */
    public var filter_value: String? {
        get { _filter_value?.value }
        set { _filter_value = newValue.map(AnyString.init) }
    }

    public init(field_name: String, field_value: AnyCodable, filter_value: String? = nil) {
        self._field_name = AnyString.init(field_name)
        self.field_value = field_value
        self._filter_value = filter_value.map(AnyString.init)
    }

    public init(_ field_name: String, _ field_value: AnyCodable, filter_value: String? = nil) {
        self.init(field_name: field_name, field_value: field_value, filter_value: filter_value)
    }

}

public struct AlertNotifications: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _notification_id = "notification_id"
        case _alert_condition_id = "alert_condition_id"
        case _user_id = "user_id"
        case is_read
        case field_value
        case threshold_value
        case _ran_at = "ran_at"
        case alert
    }
    private var _notification_id: AnyString?
    /**
     * ID of the notification (read-only)
     */
    public var notification_id: String? {
        get { _notification_id?.value }
        set { _notification_id = newValue.map(AnyString.init) }
    }

    private var _alert_condition_id: AnyString?
    /**
     * ID of the alert (read-only)
     */
    public var alert_condition_id: String? {
        get { _alert_condition_id?.value }
        set { _alert_condition_id = newValue.map(AnyString.init) }
    }

    private var _user_id: AnyString?
    /**
     * ID of the user (read-only)
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    /**
     * Read state of the notification
     */
    public var is_read: Bool?

    /**
     * The value of the field on which the alert condition is set (read-only)
     */
    public var field_value: Double?

    /**
     * The value of the threshold which triggers the alert notification (read-only)
     */
    public var threshold_value: Double?

    private var _ran_at: AnyString?
    /**
     * The time at which the alert query ran (read-only)
     */
    public var ran_at: String? {
        get { _ran_at?.value }
        set { _ran_at = newValue.map(AnyString.init) }
    }

    public var alert: MobilePayload?

    public init(notification_id: String? = nil, alert_condition_id: String? = nil, user_id: String? = nil, is_read: Bool? = nil, field_value: Double? = nil, threshold_value: Double? = nil, ran_at: String? = nil, alert: MobilePayload? = nil) {
        self._notification_id = notification_id.map(AnyString.init)
        self._alert_condition_id = alert_condition_id.map(AnyString.init)
        self._user_id = user_id.map(AnyString.init)
        self.is_read = is_read
        self.field_value = field_value
        self.threshold_value = threshold_value
        self._ran_at = ran_at.map(AnyString.init)
        self.alert = alert
    }

}

public struct AlertPatch: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _owner_id = "owner_id"
        case is_disabled
        case _disabled_reason = "disabled_reason"
        case is_public
        case threshold
    }
    private var _owner_id: AnyString?
    /**
     * New owner ID of the alert
     */
    public var owner_id: String? {
        get { _owner_id?.value }
        set { _owner_id = newValue.map(AnyString.init) }
    }

    /**
     * Set alert enabled or disabled
     */
    public var is_disabled: Bool?

    private var _disabled_reason: AnyString?
    /**
     * The reason this alert is disabled
     */
    public var disabled_reason: String? {
        get { _disabled_reason?.value }
        set { _disabled_reason = newValue.map(AnyString.init) }
    }

    /**
     * Set alert public or private
     */
    public var is_public: Bool?

    /**
     * New threshold value
     */
    public var threshold: Double?

    public init(owner_id: String? = nil, is_disabled: Bool? = nil, disabled_reason: String? = nil, is_public: Bool? = nil, threshold: Double? = nil) {
        self._owner_id = owner_id.map(AnyString.init)
        self.is_disabled = is_disabled
        self._disabled_reason = disabled_reason.map(AnyString.init)
        self.is_public = is_public
        self.threshold = threshold
    }

}

/**
 * The appropriate horizontal text alignment the values of this field should be displayed in. Valid values are: "left", "right". (Enum defined in LookmlModelExploreField)
 */
public enum Align: String, Codable {
    case left = "left"
    case right = "right"
}

public struct ApiSession: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _workspace_id = "workspace_id"
        case _sudo_user_id = "sudo_user_id"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _workspace_id: AnyString?
    /**
     * The id of active workspace for this session
     */
    public var workspace_id: String? {
        get { _workspace_id?.value }
        set { _workspace_id = newValue.map(AnyString.init) }
    }

    private var _sudo_user_id: AnyString?
    /**
     * The id of the actual user in the case when this session represents one user sudo'ing as another (read-only)
     */
    public var sudo_user_id: String? {
        get { _sudo_user_id?.value }
        set { _sudo_user_id = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, workspace_id: String? = nil, sudo_user_id: String? = nil) {
        self.can = can
        self._workspace_id = workspace_id.map(AnyString.init)
        self._sudo_user_id = sudo_user_id.map(AnyString.init)
    }

}

public struct ApiVersion: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _looker_release_version = "looker_release_version"
        case current_version
        case supported_versions
        case _api_server_url = "api_server_url"
        case _web_server_url = "web_server_url"
    }
    private var _looker_release_version: AnyString?
    /**
     * Current Looker release version number (read-only)
     */
    public var looker_release_version: String? {
        get { _looker_release_version?.value }
        set { _looker_release_version = newValue.map(AnyString.init) }
    }

    public var current_version: ApiVersionElement?

    /**
     * Array of versions supported by this Looker instance (read-only)
     */
    public var supported_versions: [ApiVersionElement]?

    private var _api_server_url: AnyString?
    /**
     * API server base url (read-only)
     */
    public var api_server_url: String? {
        get { _api_server_url?.value }
        set { _api_server_url = newValue.map(AnyString.init) }
    }

    private var _web_server_url: AnyString?
    /**
     * Web server base url (read-only)
     */
    public var web_server_url: String? {
        get { _web_server_url?.value }
        set { _web_server_url = newValue.map(AnyString.init) }
    }

    public init(looker_release_version: String? = nil, current_version: ApiVersionElement? = nil, supported_versions: [ApiVersionElement]? = nil, api_server_url: String? = nil, web_server_url: String? = nil) {
        self._looker_release_version = looker_release_version.map(AnyString.init)
        self.current_version = current_version
        self.supported_versions = supported_versions
        self._api_server_url = api_server_url.map(AnyString.init)
        self._web_server_url = web_server_url.map(AnyString.init)
    }

}

public struct ApiVersionElement: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _version = "version"
        case _full_version = "full_version"
        case _status = "status"
        case _swagger_url = "swagger_url"
    }
    private var _version: AnyString?
    /**
     * Version number as it appears in '/api/xxx/' urls (read-only)
     */
    public var version: String? {
        get { _version?.value }
        set { _version = newValue.map(AnyString.init) }
    }

    private var _full_version: AnyString?
    /**
     * Full version number including minor version (read-only)
     */
    public var full_version: String? {
        get { _full_version?.value }
        set { _full_version = newValue.map(AnyString.init) }
    }

    private var _status: AnyString?
    /**
     * Status of this version (read-only)
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    private var _swagger_url: AnyString?
    /**
     * Url for swagger.json for this version (read-only)
     */
    public var swagger_url: String? {
        get { _swagger_url?.value }
        set { _swagger_url = newValue.map(AnyString.init) }
    }

    public init(version: String? = nil, full_version: String? = nil, status: String? = nil, swagger_url: String? = nil) {
        self._version = version.map(AnyString.init)
        self._full_version = full_version.map(AnyString.init)
        self._status = status.map(AnyString.init)
        self._swagger_url = swagger_url.map(AnyString.init)
    }

}

public struct Artifact: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _key = "key"
        case _value = "value"
        case _content_type = "content_type"
        case _version = "version"
        case _namespace = "namespace"
        case created_at
        case updated_at
        case _value_size = "value_size"
        case _created_by_userid = "created_by_userid"
        case _updated_by_userid = "updated_by_userid"
    }
    private var _key: AnyString
    /**
     * Key of value to store. Namespace + Key must be unique.
     */
    public var key: String {
        get { _key.value }
        set { _key = AnyString.init(newValue) }
    }

    private var _value: AnyString
    /**
     * Value to store.
     */
    public var value: String {
        get { _value.value }
        set { _value = AnyString.init(newValue) }
    }

    private var _content_type: AnyString?
    /**
     * MIME type of content. This can only be used to override content that is detected as text/plain. Needed to set application/json content types, which are analyzed as plain text.
     */
    public var content_type: String? {
        get { _content_type?.value }
        set { _content_type = newValue.map(AnyString.init) }
    }

    private var _version: AnyInt?
    /**
     * Version number of the stored value. The version must be provided for any updates to an existing artifact. (read-only)
     */
    public var version: Int64? {
        get { _version?.value }
        set { _version = newValue.map(AnyInt.init) }
    }

    private var _namespace: AnyString
    /**
     * Artifact storage namespace. (read-only)
     */
    public var namespace: String {
        get { _namespace.value }
        set { _namespace = AnyString.init(newValue) }
    }

    /**
     * Timestamp when this artifact was created. (read-only)
     */
    public var created_at: Date

    /**
     * Timestamp when this artifact was updated. (read-only)
     */
    public var updated_at: Date

    private var _value_size: AnyInt
    /**
     * Size (in bytes) of the stored value. (read-only)
     */
    public var value_size: Int64 {
        get { _value_size.value }
        set { _value_size = AnyInt.init(newValue) }
    }

    private var _created_by_userid: AnyString
    /**
     * User id of the artifact creator. (read-only)
     */
    public var created_by_userid: String {
        get { _created_by_userid.value }
        set { _created_by_userid = AnyString.init(newValue) }
    }

    private var _updated_by_userid: AnyString
    /**
     * User id of the artifact updater. (read-only)
     */
    public var updated_by_userid: String {
        get { _updated_by_userid.value }
        set { _updated_by_userid = AnyString.init(newValue) }
    }

    public init(key: String, value: String, content_type: String? = nil, version: Int64? = nil, namespace: String, created_at: Date, updated_at: Date, value_size: Int64, created_by_userid: String, updated_by_userid: String) {
        self._key = AnyString.init(key)
        self._value = AnyString.init(value)
        self._content_type = content_type.map(AnyString.init)
        self._version = version.map(AnyInt.init)
        self._namespace = AnyString.init(namespace)
        self.created_at = created_at
        self.updated_at = updated_at
        self._value_size = AnyInt.init(value_size)
        self._created_by_userid = AnyString.init(created_by_userid)
        self._updated_by_userid = AnyString.init(updated_by_userid)
    }

    public init(_ key: String, _ value: String, content_type: String? = nil, version: Int64? = nil, _ namespace: String, _ created_at: Date, _ updated_at: Date, _ value_size: Int64, _ created_by_userid: String, _ updated_by_userid: String) {
        self.init(key: key, value: value, content_type: content_type, version: version, namespace: namespace, created_at: created_at, updated_at: updated_at, value_size: value_size, created_by_userid: created_by_userid, updated_by_userid: updated_by_userid)
    }

}

public struct ArtifactNamespace: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _namespace = "namespace"
        case _count = "count"
    }
    private var _namespace: AnyString
    /**
     * Artifact storage namespace. (read-only)
     */
    public var namespace: String {
        get { _namespace.value }
        set { _namespace = AnyString.init(newValue) }
    }

    private var _count: AnyInt
    /**
     * The number of artifacts stored in the namespace. (read-only)
     */
    public var count: Int64 {
        get { _count.value }
        set { _count = AnyInt.init(newValue) }
    }

    public init(namespace: String, count: Int64) {
        self._namespace = AnyString.init(namespace)
        self._count = AnyInt.init(count)
    }

    public init(_ namespace: String, _ count: Int64) {
        self.init(namespace: namespace, count: count)
    }

}

public struct ArtifactUsage: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _max_size = "max_size"
        case _usage = "usage"
    }
    private var _max_size: AnyInt
    /**
     * The configured maximum size in bytes of the entire artifact store. (read-only)
     */
    public var max_size: Int64 {
        get { _max_size.value }
        set { _max_size = AnyInt.init(newValue) }
    }

    private var _usage: AnyInt
    /**
     * The currently used storage size in bytes of the entire artifact store. (read-only)
     */
    public var usage: Int64 {
        get { _usage.value }
        set { _usage = AnyInt.init(newValue) }
    }

    public init(max_size: Int64, usage: Int64) {
        self._max_size = AnyInt.init(max_size)
        self._usage = AnyInt.init(usage)
    }

    public init(_ max_size: Int64, _ usage: Int64) {
        self.init(max_size: max_size, usage: usage)
    }

}

public struct AssertValidatorErrorItem: SDKModel {
    public var assert_error: AssertValidatorTestError?

    public var generic_error: GenericError?

    public init(assert_error: AssertValidatorTestError? = nil, generic_error: GenericError? = nil) {
        self.assert_error = assert_error
        self.generic_error = generic_error
    }

}

public struct AssertValidatorResult: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _status = "status"
        case results
    }
    private var _name: AnyString?
    /**
     * Name of the validator (assert) (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _status: AnyString?
    /**
     * Status of the validation (unknown, failed, passed, skipped, errored, cancelled, queued, running) (read-only)
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    /**
     * Results of the validation (read-only)
     */
    public var results: [AssertValidatorTestedExplore]?

    public init(name: String? = nil, status: String? = nil, results: [AssertValidatorTestedExplore]? = nil) {
        self._name = name.map(AnyString.init)
        self._status = status.map(AnyString.init)
        self.results = results
    }

}

public struct AssertValidatorTestedExplore: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _error_count = "error_count"
        case errors
        case _success_count = "success_count"
        case successes
    }
    private var _error_count: AnyInt?
    /**
     * Total number of failed data tests (read-only)
     */
    public var error_count: Int64? {
        get { _error_count?.value }
        set { _error_count = newValue.map(AnyInt.init) }
    }

    /**
     * Details of data tests that failed validation (read-only)
     */
    public var errors: [AssertValidatorErrorItem]?

    private var _success_count: AnyString?
    /**
     * Total number of successful data tests (read-only)
     */
    public var success_count: String? {
        get { _success_count?.value }
        set { _success_count = newValue.map(AnyString.init) }
    }

    /**
     * Details of data tests that passed validation (read-only)
     */
    public var successes: [AssertValidatorTestSuccess]?

    public init(error_count: Int64? = nil, errors: [AssertValidatorErrorItem]? = nil, success_count: String? = nil, successes: [AssertValidatorTestSuccess]? = nil) {
        self._error_count = error_count.map(AnyInt.init)
        self.errors = errors
        self._success_count = success_count.map(AnyString.init)
        self.successes = successes
    }

}

public struct AssertValidatorTestError: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _model = "model"
        case _explore = "explore"
        case _test_name = "test_name"
        case _explore_url = "explore_url"
        case _lookml_url = "lookml_url"
        case _message = "message"
    }
    private var _model: AnyString?
    /**
     * LookML model that contains the data test (read-only)
     */
    public var model: String? {
        get { _model?.value }
        set { _model = newValue.map(AnyString.init) }
    }

    private var _explore: AnyString?
    /**
     * LookML Explore that is used as the explore_source for the data test (read-only)
     */
    public var explore: String? {
        get { _explore?.value }
        set { _explore = newValue.map(AnyString.init) }
    }

    private var _test_name: AnyString?
    /**
     * Name of the data test (read-only)
     */
    public var test_name: String? {
        get { _test_name?.value }
        set { _test_name = newValue.map(AnyString.init) }
    }

    private var _explore_url: AnyString?
    /**
     * URL to the Explore (read-only)
     */
    public var explore_url: String? {
        get { _explore_url?.value }
        set { _explore_url = newValue.map(AnyString.init) }
    }

    private var _lookml_url: AnyString?
    /**
     * URL to the LookML file where the data test is defined (read-only)
     */
    public var lookml_url: String? {
        get { _lookml_url?.value }
        set { _lookml_url = newValue.map(AnyString.init) }
    }

    private var _message: AnyString?
    /**
     * Message returned by the data test (read-only)
     */
    public var message: String? {
        get { _message?.value }
        set { _message = newValue.map(AnyString.init) }
    }

    public init(model: String? = nil, explore: String? = nil, test_name: String? = nil, explore_url: String? = nil, lookml_url: String? = nil, message: String? = nil) {
        self._model = model.map(AnyString.init)
        self._explore = explore.map(AnyString.init)
        self._test_name = test_name.map(AnyString.init)
        self._explore_url = explore_url.map(AnyString.init)
        self._lookml_url = lookml_url.map(AnyString.init)
        self._message = message.map(AnyString.init)
    }

}

public struct AssertValidatorTestSuccess: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _model = "model"
        case _explore = "explore"
        case _test_name = "test_name"
        case _explore_url = "explore_url"
        case _lookml_url = "lookml_url"
    }
    private var _model: AnyString?
    /**
     * LookML model that contains the data test (read-only)
     */
    public var model: String? {
        get { _model?.value }
        set { _model = newValue.map(AnyString.init) }
    }

    private var _explore: AnyString?
    /**
     * LookML Explore that is used as the explore_source for the data test (read-only)
     */
    public var explore: String? {
        get { _explore?.value }
        set { _explore = newValue.map(AnyString.init) }
    }

    private var _test_name: AnyString?
    /**
     * Name of the data test (read-only)
     */
    public var test_name: String? {
        get { _test_name?.value }
        set { _test_name = newValue.map(AnyString.init) }
    }

    private var _explore_url: AnyString?
    /**
     * URL to the Explore (read-only)
     */
    public var explore_url: String? {
        get { _explore_url?.value }
        set { _explore_url = newValue.map(AnyString.init) }
    }

    private var _lookml_url: AnyString?
    /**
     * URL to the LookML file where the data test is defined (read-only)
     */
    public var lookml_url: String? {
        get { _lookml_url?.value }
        set { _lookml_url = newValue.map(AnyString.init) }
    }

    public init(model: String? = nil, explore: String? = nil, test_name: String? = nil, explore_url: String? = nil, lookml_url: String? = nil) {
        self._model = model.map(AnyString.init)
        self._explore = explore.map(AnyString.init)
        self._test_name = test_name.map(AnyString.init)
        self._explore_url = explore_url.map(AnyString.init)
        self._lookml_url = lookml_url.map(AnyString.init)
    }

}

public struct BackupConfiguration: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _type = "type"
        case _custom_s3_bucket = "custom_s3_bucket"
        case _custom_s3_bucket_region = "custom_s3_bucket_region"
        case _custom_s3_key = "custom_s3_key"
        case _custom_s3_secret = "custom_s3_secret"
        case _url = "url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _type: AnyString?
    /**
     * Type of backup: looker-s3 or custom-s3
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _custom_s3_bucket: AnyString?
    /**
     * Name of bucket for custom-s3 backups
     */
    public var custom_s3_bucket: String? {
        get { _custom_s3_bucket?.value }
        set { _custom_s3_bucket = newValue.map(AnyString.init) }
    }

    private var _custom_s3_bucket_region: AnyString?
    /**
     * Name of region where the bucket is located
     */
    public var custom_s3_bucket_region: String? {
        get { _custom_s3_bucket_region?.value }
        set { _custom_s3_bucket_region = newValue.map(AnyString.init) }
    }

    private var _custom_s3_key: AnyString?
    /**
     * (Write-Only) AWS S3 key used for custom-s3 backups
     */
    public var custom_s3_key: String? {
        get { _custom_s3_key?.value }
        set { _custom_s3_key = newValue.map(AnyString.init) }
    }

    private var _custom_s3_secret: AnyString?
    /**
     * (Write-Only) AWS S3 secret used for custom-s3 backups
     */
    public var custom_s3_secret: String? {
        get { _custom_s3_secret?.value }
        set { _custom_s3_secret = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, type: String? = nil, custom_s3_bucket: String? = nil, custom_s3_bucket_region: String? = nil, custom_s3_key: String? = nil, custom_s3_secret: String? = nil, url: String? = nil) {
        self.can = can
        self._type = type.map(AnyString.init)
        self._custom_s3_bucket = custom_s3_bucket.map(AnyString.init)
        self._custom_s3_bucket_region = custom_s3_bucket_region.map(AnyString.init)
        self._custom_s3_key = custom_s3_key.map(AnyString.init)
        self._custom_s3_secret = custom_s3_secret.map(AnyString.init)
        self._url = url.map(AnyString.init)
    }

}

public struct Board: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _content_metadata_id = "content_metadata_id"
        case created_at
        case deleted_at
        case _description = "description"
        case board_sections
        case _id = "id"
        case _section_order = "section_order"
        case _title = "title"
        case updated_at
        case _user_id = "user_id"
        case primary_homepage
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _content_metadata_id: AnyString?
    /**
     * Id of associated content_metadata record (read-only)
     */
    public var content_metadata_id: String? {
        get { _content_metadata_id?.value }
        set { _content_metadata_id = newValue.map(AnyString.init) }
    }

    /**
     * Date of board creation (read-only)
     */
    public var created_at: Date?

    /**
     * Date of board deletion
     */
    public var deleted_at: Date?

    private var _description: AnyString?
    /**
     * Description of the board
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    /**
     * Sections of the board (read-only)
     */
    public var board_sections: [BoardSection]?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _section_order: [AnyString]?
    /**
     * ids of the board sections in the order they should be displayed
     */
    public var section_order: [String]? {
        get { if let v = _section_order { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _section_order = v.map { AnyString.init($0) } } else { _section_order = nil } }
    }

    private var _title: AnyString?
    /**
     * Title of the board
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    /**
     * Date of last board update (read-only)
     */
    public var updated_at: Date?

    private var _user_id: AnyString?
    /**
     * User id of board creator (read-only)
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    /**
     * Whether the board is the primary homepage or not (read-only)
     */
    public var primary_homepage: Bool?

    public init(can: StringDictionary<Bool>? = nil, content_metadata_id: String? = nil, created_at: Date? = nil, deleted_at: Date? = nil, description: String? = nil, board_sections: [BoardSection]? = nil, id: String? = nil, section_order: [String]? = nil, title: String? = nil, updated_at: Date? = nil, user_id: String? = nil, primary_homepage: Bool? = nil) {
        self.can = can
        self._content_metadata_id = content_metadata_id.map(AnyString.init)
        self.created_at = created_at
        self.deleted_at = deleted_at
        self._description = description.map(AnyString.init)
        self.board_sections = board_sections
        self._id = id.map(AnyString.init)
        if let v = section_order { _section_order = v.map { AnyString.init($0) } } else { _section_order = nil }
        self._title = title.map(AnyString.init)
        self.updated_at = updated_at
        self._user_id = user_id.map(AnyString.init)
        self.primary_homepage = primary_homepage
    }

}

public struct BoardItem: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _content_created_by = "content_created_by"
        case _content_favorite_id = "content_favorite_id"
        case _content_metadata_id = "content_metadata_id"
        case _content_updated_at = "content_updated_at"
        case _custom_description = "custom_description"
        case _custom_title = "custom_title"
        case _custom_url = "custom_url"
        case _dashboard_id = "dashboard_id"
        case _description = "description"
        case _favorite_count = "favorite_count"
        case _board_section_id = "board_section_id"
        case _id = "id"
        case _image_url = "image_url"
        case _location = "location"
        case _look_id = "look_id"
        case _lookml_dashboard_id = "lookml_dashboard_id"
        case _order = "order"
        case _title = "title"
        case _url = "url"
        case use_custom_description
        case use_custom_title
        case use_custom_url
        case _view_count = "view_count"
        case _custom_image_data_base64 = "custom_image_data_base64"
        case _custom_image_url = "custom_image_url"
        case use_custom_image
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _content_created_by: AnyString?
    /**
     * Name of user who created the content this item is based on (read-only)
     */
    public var content_created_by: String? {
        get { _content_created_by?.value }
        set { _content_created_by = newValue.map(AnyString.init) }
    }

    private var _content_favorite_id: AnyString?
    /**
     * Content favorite id associated with the item this content is based on (read-only)
     */
    public var content_favorite_id: String? {
        get { _content_favorite_id?.value }
        set { _content_favorite_id = newValue.map(AnyString.init) }
    }

    private var _content_metadata_id: AnyString?
    /**
     * Content metadata id associated with the item this content is based on (read-only)
     */
    public var content_metadata_id: String? {
        get { _content_metadata_id?.value }
        set { _content_metadata_id = newValue.map(AnyString.init) }
    }

    private var _content_updated_at: AnyString?
    /**
     * Last time the content that this item is based on was updated (read-only)
     */
    public var content_updated_at: String? {
        get { _content_updated_at?.value }
        set { _content_updated_at = newValue.map(AnyString.init) }
    }

    private var _custom_description: AnyString?
    /**
     * Custom description entered by the user, if present
     */
    public var custom_description: String? {
        get { _custom_description?.value }
        set { _custom_description = newValue.map(AnyString.init) }
    }

    private var _custom_title: AnyString?
    /**
     * Custom title entered by the user, if present
     */
    public var custom_title: String? {
        get { _custom_title?.value }
        set { _custom_title = newValue.map(AnyString.init) }
    }

    private var _custom_url: AnyString?
    /**
     * Custom url entered by the user, if present
     */
    public var custom_url: String? {
        get { _custom_url?.value }
        set { _custom_url = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString?
    /**
     * Dashboard to base this item on
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * The actual description for display (read-only)
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    private var _favorite_count: AnyInt?
    /**
     * Number of times content has been favorited, if present (read-only)
     */
    public var favorite_count: Int64? {
        get { _favorite_count?.value }
        set { _favorite_count = newValue.map(AnyInt.init) }
    }

    private var _board_section_id: AnyString?
    /**
     * Associated Board Section
     */
    public var board_section_id: String? {
        get { _board_section_id?.value }
        set { _board_section_id = newValue.map(AnyString.init) }
    }

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _image_url: AnyString?
    /**
     * The actual image_url for display (read-only)
     */
    public var image_url: String? {
        get { _image_url?.value }
        set { _image_url = newValue.map(AnyString.init) }
    }

    private var _location: AnyString?
    /**
     * The container folder name of the content (read-only)
     */
    public var location: String? {
        get { _location?.value }
        set { _location = newValue.map(AnyString.init) }
    }

    private var _look_id: AnyString?
    /**
     * Look to base this item on
     */
    public var look_id: String? {
        get { _look_id?.value }
        set { _look_id = newValue.map(AnyString.init) }
    }

    private var _lookml_dashboard_id: AnyString?
    /**
     * LookML Dashboard to base this item on
     */
    public var lookml_dashboard_id: String? {
        get { _lookml_dashboard_id?.value }
        set { _lookml_dashboard_id = newValue.map(AnyString.init) }
    }

    private var _order: AnyInt?
    /**
     * An arbitrary integer representing the sort order within the section
     */
    public var order: Int64? {
        get { _order?.value }
        set { _order = newValue.map(AnyInt.init) }
    }

    private var _title: AnyString?
    /**
     * The actual title for display (read-only)
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Relative url for the associated content (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    /**
     * Whether the custom description should be used instead of the content description, if the item is associated with content
     */
    public var use_custom_description: Bool?

    /**
     * Whether the custom title should be used instead of the content title, if the item is associated with content
     */
    public var use_custom_title: Bool?

    /**
     * Whether the custom url should be used instead of the content url, if the item is associated with content
     */
    public var use_custom_url: Bool?

    private var _view_count: AnyInt?
    /**
     * Number of times content has been viewed, if present (read-only)
     */
    public var view_count: Int64? {
        get { _view_count?.value }
        set { _view_count = newValue.map(AnyInt.init) }
    }

    private var _custom_image_data_base64: AnyString?
    /**
     * (Write-Only) base64 encoded image data
     */
    public var custom_image_data_base64: String? {
        get { _custom_image_data_base64?.value }
        set { _custom_image_data_base64 = newValue.map(AnyString.init) }
    }

    private var _custom_image_url: AnyString?
    /**
     * Custom image_url entered by the user, if present (read-only)
     */
    public var custom_image_url: String? {
        get { _custom_image_url?.value }
        set { _custom_image_url = newValue.map(AnyString.init) }
    }

    /**
     * Whether the custom image should be used instead of the content image, if the item is associated with content
     */
    public var use_custom_image: Bool?

    public init(can: StringDictionary<Bool>? = nil, content_created_by: String? = nil, content_favorite_id: String? = nil, content_metadata_id: String? = nil, content_updated_at: String? = nil, custom_description: String? = nil, custom_title: String? = nil, custom_url: String? = nil, dashboard_id: String? = nil, description: String? = nil, favorite_count: Int64? = nil, board_section_id: String? = nil, id: String? = nil, image_url: String? = nil, location: String? = nil, look_id: String? = nil, lookml_dashboard_id: String? = nil, order: Int64? = nil, title: String? = nil, url: String? = nil, use_custom_description: Bool? = nil, use_custom_title: Bool? = nil, use_custom_url: Bool? = nil, view_count: Int64? = nil, custom_image_data_base64: String? = nil, custom_image_url: String? = nil, use_custom_image: Bool? = nil) {
        self.can = can
        self._content_created_by = content_created_by.map(AnyString.init)
        self._content_favorite_id = content_favorite_id.map(AnyString.init)
        self._content_metadata_id = content_metadata_id.map(AnyString.init)
        self._content_updated_at = content_updated_at.map(AnyString.init)
        self._custom_description = custom_description.map(AnyString.init)
        self._custom_title = custom_title.map(AnyString.init)
        self._custom_url = custom_url.map(AnyString.init)
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self._favorite_count = favorite_count.map(AnyInt.init)
        self._board_section_id = board_section_id.map(AnyString.init)
        self._id = id.map(AnyString.init)
        self._image_url = image_url.map(AnyString.init)
        self._location = location.map(AnyString.init)
        self._look_id = look_id.map(AnyString.init)
        self._lookml_dashboard_id = lookml_dashboard_id.map(AnyString.init)
        self._order = order.map(AnyInt.init)
        self._title = title.map(AnyString.init)
        self._url = url.map(AnyString.init)
        self.use_custom_description = use_custom_description
        self.use_custom_title = use_custom_title
        self.use_custom_url = use_custom_url
        self._view_count = view_count.map(AnyInt.init)
        self._custom_image_data_base64 = custom_image_data_base64.map(AnyString.init)
        self._custom_image_url = custom_image_url.map(AnyString.init)
        self.use_custom_image = use_custom_image
    }

}

public struct BoardSection: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case created_at
        case deleted_at
        case _description = "description"
        case _board_id = "board_id"
        case board_items
        case _id = "id"
        case _item_order = "item_order"
        case _visible_item_order = "visible_item_order"
        case _title = "title"
        case updated_at
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    /**
     * Time at which this section was created. (read-only)
     */
    public var created_at: Date?

    /**
     * Time at which this section was deleted.
     */
    public var deleted_at: Date?

    private var _description: AnyString?
    /**
     * Description of the content found in this section.
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    private var _board_id: AnyString?
    /**
     * Id reference to parent board
     */
    public var board_id: String? {
        get { _board_id?.value }
        set { _board_id = newValue.map(AnyString.init) }
    }

    /**
     * Items in the board section (read-only)
     */
    public var board_items: [BoardItem]?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _item_order: [AnyString]?
    /**
     * ids of the board items in the order they should be displayed
     */
    public var item_order: [String]? {
        get { if let v = _item_order { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _item_order = v.map { AnyString.init($0) } } else { _item_order = nil } }
    }

    private var _visible_item_order: [AnyString]?
    /**
     * ids of the homepage items the user can see in the order they should be displayed (read-only)
     */
    public var visible_item_order: [String]? {
        get { if let v = _visible_item_order { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _visible_item_order = v.map { AnyString.init($0) } } else { _visible_item_order = nil } }
    }

    private var _title: AnyString?
    /**
     * Name of row
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    /**
     * Time at which this section was last updated. (read-only)
     */
    public var updated_at: Date?

    public init(can: StringDictionary<Bool>? = nil, created_at: Date? = nil, deleted_at: Date? = nil, description: String? = nil, board_id: String? = nil, board_items: [BoardItem]? = nil, id: String? = nil, item_order: [String]? = nil, visible_item_order: [String]? = nil, title: String? = nil, updated_at: Date? = nil) {
        self.can = can
        self.created_at = created_at
        self.deleted_at = deleted_at
        self._description = description.map(AnyString.init)
        self._board_id = board_id.map(AnyString.init)
        self.board_items = board_items
        self._id = id.map(AnyString.init)
        if let v = item_order { _item_order = v.map { AnyString.init($0) } } else { _item_order = nil }
        if let v = visible_item_order { _visible_item_order = v.map { AnyString.init($0) } } else { _visible_item_order = nil }
        self._title = title.map(AnyString.init)
        self.updated_at = updated_at
    }

}

/**
 * Field category Valid values are: "parameter", "filter", "measure", "dimension". (Enum defined in LookmlModelExploreField)
 */
public enum Category: String, Codable {
    case parameter = "parameter"
    case filter = "filter"
    case measure = "measure"
    case dimension = "dimension"
}

public struct CIChangeRequest: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _change_request_number = "change_request_number"
        case _change_request_url = "change_request_url"
        case _change_request_name = "change_request_name"
        case _change_request_commits_url = "change_request_commits_url"
    }
    private var _change_request_number: AnyInt?
    /**
     * Numeric identifier of the change request (read-only)
     */
    public var change_request_number: Int64? {
        get { _change_request_number?.value }
        set { _change_request_number = newValue.map(AnyInt.init) }
    }

    private var _change_request_url: AnyString?
    /**
     * URL of the change request (read-only)
     */
    public var change_request_url: String? {
        get { _change_request_url?.value }
        set { _change_request_url = newValue.map(AnyString.init) }
    }

    private var _change_request_name: AnyString?
    /**
     * Name of the change request (read-only)
     */
    public var change_request_name: String? {
        get { _change_request_name?.value }
        set { _change_request_name = newValue.map(AnyString.init) }
    }

    private var _change_request_commits_url: AnyString?
    /**
     * For PR-triggered CI runs, the URL to the change request commit that triggered the run. (read-only)
     */
    public var change_request_commits_url: String? {
        get { _change_request_commits_url?.value }
        set { _change_request_commits_url = newValue.map(AnyString.init) }
    }

    public init(change_request_number: Int64? = nil, change_request_url: String? = nil, change_request_name: String? = nil, change_request_commits_url: String? = nil) {
        self._change_request_number = change_request_number.map(AnyInt.init)
        self._change_request_url = change_request_url.map(AnyString.init)
        self._change_request_name = change_request_name.map(AnyString.init)
        self._change_request_commits_url = change_request_commits_url.map(AnyString.init)
    }

}

public struct CIGitState: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _branch = "branch"
        case _repository = "repository"
        case _commit_ref = "commit_ref"
        case _target = "target"
    }
    private var _branch: AnyString?
    /**
     * Git branch that the CI run validates (read-only)
     */
    public var branch: String? {
        get { _branch?.value }
        set { _branch = newValue.map(AnyString.init) }
    }

    private var _repository: AnyString?
    /**
     * Git repository that contains the Git branch being validated (read-only)
     */
    public var repository: String? {
        get { _repository?.value }
        set { _repository = newValue.map(AnyString.init) }
    }

    private var _commit_ref: AnyString?
    /**
     * Git commit that the CI run validates (read-only)
     */
    public var commit_ref: String? {
        get { _commit_ref?.value }
        set { _commit_ref = newValue.map(AnyString.init) }
    }

    private var _target: AnyString?
    /**
     * For incremental runs, the Git branch that the CI run compares against during validation (read-only)
     */
    public var target: String? {
        get { _target?.value }
        set { _target = newValue.map(AnyString.init) }
    }

    public init(branch: String? = nil, repository: String? = nil, commit_ref: String? = nil, target: String? = nil) {
        self._branch = branch.map(AnyString.init)
        self._repository = repository.map(AnyString.init)
        self._commit_ref = commit_ref.map(AnyString.init)
        self._target = target.map(AnyString.init)
    }

}

public struct CIRun: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _run_id = "run_id"
        case created_at
        case started_at
        case finished_at
        case _status_url = "status_url"
        case _status = "status"
        case _git_service = "git_service"
        case git_state
        case result
        case schedule
        case _target_branch = "target_branch"
        case _title = "title"
        case _trigger = "trigger"
        case change_request
        case _suite_id = "suite_id"
        case _username = "username"
    }
    private var _run_id: AnyString?
    /**
     * ID of the CI run (read-only)
     */
    public var run_id: String? {
        get { _run_id?.value }
        set { _run_id = newValue.map(AnyString.init) }
    }

    /**
     * Time and date that the CI run was initiated (read-only)
     */
    public var created_at: Date?

    /**
     * Time and date that the CI run began executing (read-only)
     */
    public var started_at: Date?

    /**
     * Time and date that the CI run completed (read-only)
     */
    public var finished_at: Date?

    private var _status_url: AnyString?
    /**
     * Git provider URL where you can view the commit status. This is the status URL that you specify when you create a CI suite (read-only)
     */
    public var status_url: String? {
        get { _status_url?.value }
        set { _status_url = newValue.map(AnyString.init) }
    }

    private var _status: AnyString?
    /**
     * Status of the CI run (unknown, failed, passed, skipped, errored, cancelled, queued, running) (read-only)
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    private var _git_service: AnyString?
    /**
     * Git service for CI run (e.g. GitHub) (read-only)
     */
    public var git_service: String? {
        get { _git_service?.value }
        set { _git_service = newValue.map(AnyString.init) }
    }

    public var git_state: CIGitState?

    public var result: CIRunResult?

    public var schedule: CIScheduleTrigger?

    private var _target_branch: AnyString?
    /**
     * Git branch that the CI run compares against during validation, used for incremental runs (read-only)
     */
    public var target_branch: String? {
        get { _target_branch?.value }
        set { _target_branch = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Name of the CI suite (read-only)
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _trigger: AnyString?
    /**
     * Trigger for CI run (unknown, manual, schedule, change_request) (read-only)
     */
    public var trigger: String? {
        get { _trigger?.value }
        set { _trigger = newValue.map(AnyString.init) }
    }

    public var change_request: CIChangeRequest?

    private var _suite_id: AnyString?
    /**
     * ID of the CI suite (read-only)
     */
    public var suite_id: String? {
        get { _suite_id?.value }
        set { _suite_id = newValue.map(AnyString.init) }
    }

    private var _username: AnyString?
    /**
     * Username of the user who triggered the CI run, if the CI run was manually triggered (read-only)
     */
    public var username: String? {
        get { _username?.value }
        set { _username = newValue.map(AnyString.init) }
    }

    public init(run_id: String? = nil, created_at: Date? = nil, started_at: Date? = nil, finished_at: Date? = nil, status_url: String? = nil, status: String? = nil, git_service: String? = nil, git_state: CIGitState? = nil, result: CIRunResult? = nil, schedule: CIScheduleTrigger? = nil, target_branch: String? = nil, title: String? = nil, trigger: String? = nil, change_request: CIChangeRequest? = nil, suite_id: String? = nil, username: String? = nil) {
        self._run_id = run_id.map(AnyString.init)
        self.created_at = created_at
        self.started_at = started_at
        self.finished_at = finished_at
        self._status_url = status_url.map(AnyString.init)
        self._status = status.map(AnyString.init)
        self._git_service = git_service.map(AnyString.init)
        self.git_state = git_state
        self.result = result
        self.schedule = schedule
        self._target_branch = target_branch.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self._trigger = trigger.map(AnyString.init)
        self.change_request = change_request
        self._suite_id = suite_id.map(AnyString.init)
        self._username = username.map(AnyString.init)
    }

}

public struct CIRunResult: SDKModel {
    public var sql_result: SqlValidatorResult?

    public var sql_error: GenericError?

    public var assert_result: AssertValidatorResult?

    public var assert_error: GenericError?

    public var content_result: ContentValidatorResult?

    public var content_error: GenericError?

    public var lookml_result: LookMLValidatorResult?

    public var lookml_error: GenericError?

    public var generic_error: GenericError?

    public init(sql_result: SqlValidatorResult? = nil, sql_error: GenericError? = nil, assert_result: AssertValidatorResult? = nil, assert_error: GenericError? = nil, content_result: ContentValidatorResult? = nil, content_error: GenericError? = nil, lookml_result: LookMLValidatorResult? = nil, lookml_error: GenericError? = nil, generic_error: GenericError? = nil) {
        self.sql_result = sql_result
        self.sql_error = sql_error
        self.assert_result = assert_result
        self.assert_error = assert_error
        self.content_result = content_result
        self.content_error = content_error
        self.lookml_result = lookml_result
        self.lookml_error = lookml_error
        self.generic_error = generic_error
    }

}

public struct CIScheduleTrigger: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case enabled
        case _day = "day"
        case _hour = "hour"
        case _frequency = "frequency"
    }
    /**
     * Whether the CI run schedule is active (read-only)
     */
    public var enabled: Bool?

    private var _day: AnyString?
    /**
     * For scheduled runs, day of the week that the CI run is scheduled (read-only)
     */
    public var day: String? {
        get { _day?.value }
        set { _day = newValue.map(AnyString.init) }
    }

    private var _hour: AnyString?
    /**
     * For schedules runs, the hour of the day (24 hour format) that the CI run is scheduled (read-only)
     */
    public var hour: String? {
        get { _hour?.value }
        set { _hour = newValue.map(AnyString.init) }
    }

    private var _frequency: AnyString?
    /**
     * For scheduled runs, how often the CI run is scheduled to run (hourly, daily, weekly) (read-only)
     */
    public var frequency: String? {
        get { _frequency?.value }
        set { _frequency = newValue.map(AnyString.init) }
    }

    public init(enabled: Bool? = nil, day: String? = nil, hour: String? = nil, frequency: String? = nil) {
        self.enabled = enabled
        self._day = day.map(AnyString.init)
        self._hour = hour.map(AnyString.init)
        self._frequency = frequency.map(AnyString.init)
    }

}

public struct ColorCollection: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _label = "label"
        case categoricalPalettes
        case sequentialPalettes
        case divergingPalettes
    }
    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _label: AnyString?
    /**
     * Label of color collection
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    /**
     * Array of categorical palette definitions
     */
    public var categoricalPalettes: [DiscretePalette]?

    /**
     * Array of discrete palette definitions
     */
    public var sequentialPalettes: [ContinuousPalette]?

    /**
     * Array of diverging palette definitions
     */
    public var divergingPalettes: [ContinuousPalette]?

    public init(id: String? = nil, label: String? = nil, categoricalPalettes: [DiscretePalette]? = nil, sequentialPalettes: [ContinuousPalette]? = nil, divergingPalettes: [ContinuousPalette]? = nil) {
        self._id = id.map(AnyString.init)
        self._label = label.map(AnyString.init)
        self.categoricalPalettes = categoricalPalettes
        self.sequentialPalettes = sequentialPalettes
        self.divergingPalettes = divergingPalettes
    }

}

public struct ColorStop: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _color = "color"
        case _offset = "offset"
    }
    private var _color: AnyString?
    /**
     * CSS color string
     */
    public var color: String? {
        get { _color?.value }
        set { _color = newValue.map(AnyString.init) }
    }

    private var _offset: AnyInt?
    /**
     * Offset in continuous palette (0 to 100)
     */
    public var offset: Int64? {
        get { _offset?.value }
        set { _offset = newValue.map(AnyInt.init) }
    }

    public init(color: String? = nil, offset: Int64? = nil) {
        self._color = color.map(AnyString.init)
        self._offset = offset.map(AnyInt.init)
    }

}

public struct ColumnSearch: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _schema_name = "schema_name"
        case _table_name = "table_name"
        case _column_name = "column_name"
        case _data_type = "data_type"
    }
    private var _schema_name: AnyString?
    /**
     * Name of schema containing the table (read-only)
     */
    public var schema_name: String? {
        get { _schema_name?.value }
        set { _schema_name = newValue.map(AnyString.init) }
    }

    private var _table_name: AnyString?
    /**
     * Name of table containing the column (read-only)
     */
    public var table_name: String? {
        get { _table_name?.value }
        set { _table_name = newValue.map(AnyString.init) }
    }

    private var _column_name: AnyString?
    /**
     * Name of column (read-only)
     */
    public var column_name: String? {
        get { _column_name?.value }
        set { _column_name = newValue.map(AnyString.init) }
    }

    private var _data_type: AnyString?
    /**
     * Column data type (read-only)
     */
    public var data_type: String? {
        get { _data_type?.value }
        set { _data_type = newValue.map(AnyString.init) }
    }

    public init(schema_name: String? = nil, table_name: String? = nil, column_name: String? = nil, data_type: String? = nil) {
        self._schema_name = schema_name.map(AnyString.init)
        self._table_name = table_name.map(AnyString.init)
        self._column_name = column_name.map(AnyString.init)
        self._data_type = data_type.map(AnyString.init)
    }

}

/**
 * This property informs the check what kind of comparison we are performing. Only certain condition types are valid for time series alerts. For details, refer to [Setting Alert Conditions](https://cloud.google.com/looker/docs/sharing-and-publishing/creating-alerts#setting_alert_conditions) Valid values are: "EQUAL_TO", "GREATER_THAN", "GREATER_THAN_OR_EQUAL_TO", "LESS_THAN", "LESS_THAN_OR_EQUAL_TO", "INCREASES_BY", "DECREASES_BY", "CHANGES_BY". (Enum defined in Alert)
 */
public enum ComparisonType: String, Codable {
    case EQUAL_TO = "EQUAL_TO"
    case GREATER_THAN = "GREATER_THAN"
    case GREATER_THAN_OR_EQUAL_TO = "GREATER_THAN_OR_EQUAL_TO"
    case LESS_THAN = "LESS_THAN"
    case LESS_THAN_OR_EQUAL_TO = "LESS_THAN_OR_EQUAL_TO"
    case INCREASES_BY = "INCREASES_BY"
    case DECREASES_BY = "DECREASES_BY"
    case CHANGES_BY = "CHANGES_BY"
}

public struct ConnectionFeatures: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _dialect_name = "dialect_name"
        case cost_estimate
        case multiple_databases
        case column_search
        case persistent_table_indexes
        case persistent_derived_tables
        case turtles
        case percentile
        case distinct_percentile
        case stable_views
        case milliseconds
        case microseconds
        case subtotals
        case location
        case timezone
        case connection_pooling
    }
    private var _dialect_name: AnyString?
    /**
     * Name of the dialect for this connection (read-only)
     */
    public var dialect_name: String? {
        get { _dialect_name?.value }
        set { _dialect_name = newValue.map(AnyString.init) }
    }

    /**
     * True for cost estimating support (read-only)
     */
    public var cost_estimate: Bool?

    /**
     * True for multiple database support (read-only)
     */
    public var multiple_databases: Bool?

    /**
     * True for cost estimating support (read-only)
     */
    public var column_search: Bool?

    /**
     * True for secondary index support (read-only)
     */
    public var persistent_table_indexes: Bool?

    /**
     * True for persistent derived table support (read-only)
     */
    public var persistent_derived_tables: Bool?

    /**
     * True for turtles support (read-only)
     */
    public var turtles: Bool?

    /**
     * True for percentile support (read-only)
     */
    public var percentile: Bool?

    /**
     * True for distinct percentile support (read-only)
     */
    public var distinct_percentile: Bool?

    /**
     * True for stable views support (read-only)
     */
    public var stable_views: Bool?

    /**
     * True for millisecond support (read-only)
     */
    public var milliseconds: Bool?

    /**
     * True for microsecond support (read-only)
     */
    public var microseconds: Bool?

    /**
     * True for subtotal support (read-only)
     */
    public var subtotals: Bool?

    /**
     * True for geographic location support (read-only)
     */
    public var location: Bool?

    /**
     * True for timezone conversion in query support (read-only)
     */
    public var timezone: Bool?

    /**
     * True for connection pooling support (read-only)
     */
    public var connection_pooling: Bool?

    public init(dialect_name: String? = nil, cost_estimate: Bool? = nil, multiple_databases: Bool? = nil, column_search: Bool? = nil, persistent_table_indexes: Bool? = nil, persistent_derived_tables: Bool? = nil, turtles: Bool? = nil, percentile: Bool? = nil, distinct_percentile: Bool? = nil, stable_views: Bool? = nil, milliseconds: Bool? = nil, microseconds: Bool? = nil, subtotals: Bool? = nil, location: Bool? = nil, timezone: Bool? = nil, connection_pooling: Bool? = nil) {
        self._dialect_name = dialect_name.map(AnyString.init)
        self.cost_estimate = cost_estimate
        self.multiple_databases = multiple_databases
        self.column_search = column_search
        self.persistent_table_indexes = persistent_table_indexes
        self.persistent_derived_tables = persistent_derived_tables
        self.turtles = turtles
        self.percentile = percentile
        self.distinct_percentile = distinct_percentile
        self.stable_views = stable_views
        self.milliseconds = milliseconds
        self.microseconds = microseconds
        self.subtotals = subtotals
        self.location = location
        self.timezone = timezone
        self.connection_pooling = connection_pooling
    }

}

public struct ContentFavorite: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _user_id = "user_id"
        case _content_metadata_id = "content_metadata_id"
        case _look_id = "look_id"
        case _dashboard_id = "dashboard_id"
        case look
        case dashboard
        case _board_id = "board_id"
    }
    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _user_id: AnyString?
    /**
     * User Id which owns this ContentFavorite
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    private var _content_metadata_id: AnyString?
    /**
     * Content Metadata Id associated with this ContentFavorite
     */
    public var content_metadata_id: String? {
        get { _content_metadata_id?.value }
        set { _content_metadata_id = newValue.map(AnyString.init) }
    }

    private var _look_id: AnyString?
    /**
     * Id of a look (read-only)
     */
    public var look_id: String? {
        get { _look_id?.value }
        set { _look_id = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString?
    /**
     * Id of a dashboard (read-only)
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    public var look: LookBasic?

    public var dashboard: DashboardBase?

    private var _board_id: AnyString?
    /**
     * Id of a board (read-only)
     */
    public var board_id: String? {
        get { _board_id?.value }
        set { _board_id = newValue.map(AnyString.init) }
    }

    public init(id: String? = nil, user_id: String? = nil, content_metadata_id: String? = nil, look_id: String? = nil, dashboard_id: String? = nil, look: LookBasic? = nil, dashboard: DashboardBase? = nil, board_id: String? = nil) {
        self._id = id.map(AnyString.init)
        self._user_id = user_id.map(AnyString.init)
        self._content_metadata_id = content_metadata_id.map(AnyString.init)
        self._look_id = look_id.map(AnyString.init)
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self.look = look
        self.dashboard = dashboard
        self._board_id = board_id.map(AnyString.init)
    }

}

public struct ContentMeta: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _name = "name"
        case _parent_id = "parent_id"
        case _dashboard_id = "dashboard_id"
        case _look_id = "look_id"
        case _folder_id = "folder_id"
        case _content_type = "content_type"
        case inherits
        case _inheriting_id = "inheriting_id"
        case _slug = "slug"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Name or title of underlying content (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _parent_id: AnyString?
    /**
     * Id of Parent Content (read-only)
     */
    public var parent_id: String? {
        get { _parent_id?.value }
        set { _parent_id = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString?
    /**
     * Id of associated dashboard when content_type is "dashboard" (read-only)
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    private var _look_id: AnyString?
    /**
     * Id of associated look when content_type is "look" (read-only)
     */
    public var look_id: String? {
        get { _look_id?.value }
        set { _look_id = newValue.map(AnyString.init) }
    }

    private var _folder_id: AnyString?
    /**
     * Id of associated folder when content_type is "space" (read-only)
     */
    public var folder_id: String? {
        get { _folder_id?.value }
        set { _folder_id = newValue.map(AnyString.init) }
    }

    private var _content_type: AnyString?
    /**
     * Content Type ("dashboard", "look", or "folder") (read-only)
     */
    public var content_type: String? {
        get { _content_type?.value }
        set { _content_type = newValue.map(AnyString.init) }
    }

    /**
     * Whether content inherits its access levels from parent
     */
    public var inherits: Bool?

    private var _inheriting_id: AnyString?
    /**
     * Id of Inherited Content (read-only)
     */
    public var inheriting_id: String? {
        get { _inheriting_id?.value }
        set { _inheriting_id = newValue.map(AnyString.init) }
    }

    private var _slug: AnyString?
    /**
     * Content Slug (read-only)
     */
    public var slug: String? {
        get { _slug?.value }
        set { _slug = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, name: String? = nil, parent_id: String? = nil, dashboard_id: String? = nil, look_id: String? = nil, folder_id: String? = nil, content_type: String? = nil, inherits: Bool? = nil, inheriting_id: String? = nil, slug: String? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self._parent_id = parent_id.map(AnyString.init)
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self._look_id = look_id.map(AnyString.init)
        self._folder_id = folder_id.map(AnyString.init)
        self._content_type = content_type.map(AnyString.init)
        self.inherits = inherits
        self._inheriting_id = inheriting_id.map(AnyString.init)
        self._slug = slug.map(AnyString.init)
    }

}

/**
 * WARNING: no writeable properties found for POST, PUT, or PATCH
 */
public struct ContentMetaGroupUser: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _content_metadata_id = "content_metadata_id"
        case permission_type
        case _group_id = "group_id"
        case _user_id = "user_id"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _content_metadata_id: AnyString?
    /**
     * Id of associated Content Metadata (read-only)
     */
    public var content_metadata_id: String? {
        get { _content_metadata_id?.value }
        set { _content_metadata_id = newValue.map(AnyString.init) }
    }

    /**
     * Type of permission: "view" or "edit" Valid values are: "view", "edit". (read-only)
     */
    public var permission_type: PermissionType?

    private var _group_id: AnyString?
    /**
     * ID of associated group (read-only)
     */
    public var group_id: String? {
        get { _group_id?.value }
        set { _group_id = newValue.map(AnyString.init) }
    }

    private var _user_id: AnyString?
    /**
     * ID of associated user (read-only)
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, content_metadata_id: String? = nil, permission_type: PermissionType? = nil, group_id: String? = nil, user_id: String? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._content_metadata_id = content_metadata_id.map(AnyString.init)
        self.permission_type = permission_type
        self._group_id = group_id.map(AnyString.init)
        self._user_id = user_id.map(AnyString.init)
    }

}

public struct ContentSearch: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _content_id = "content_id"
        case _type = "type"
        case _title = "title"
        case _description = "description"
        case _folder_id = "folder_id"
        case _folder_name = "folder_name"
        case _view_count = "view_count"
        case _preferred_viewer = "preferred_viewer"
        case _model = "model"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _content_id: AnyString?
    /**
     * Primary id associated with the content (read-only)
     */
    public var content_id: String? {
        get { _content_id?.value }
        set { _content_id = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * Type of content (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Content title (read-only)
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * Content description (read-only)
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    private var _folder_id: AnyString?
    /**
     * Id of the folder where the content is saved (read-only)
     */
    public var folder_id: String? {
        get { _folder_id?.value }
        set { _folder_id = newValue.map(AnyString.init) }
    }

    private var _folder_name: AnyString?
    /**
     * Name of the folder where the content is saved (read-only)
     */
    public var folder_name: String? {
        get { _folder_name?.value }
        set { _folder_name = newValue.map(AnyString.init) }
    }

    private var _view_count: AnyInt?
    /**
     * Number of times the content has been viewed (read-only)
     */
    public var view_count: Int64? {
        get { _view_count?.value }
        set { _view_count = newValue.map(AnyInt.init) }
    }

    private var _preferred_viewer: AnyString?
    /**
     * Preferred way of viewing the content (only applies to dashboards) (read-only)
     */
    public var preferred_viewer: String? {
        get { _preferred_viewer?.value }
        set { _preferred_viewer = newValue.map(AnyString.init) }
    }

    private var _model: AnyString?
    /**
     * Name of the model the explore belongs to (read-only)
     */
    public var model: String? {
        get { _model?.value }
        set { _model = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, content_id: String? = nil, type: String? = nil, title: String? = nil, description: String? = nil, folder_id: String? = nil, folder_name: String? = nil, view_count: Int64? = nil, preferred_viewer: String? = nil, model: String? = nil) {
        self.can = can
        self._content_id = content_id.map(AnyString.init)
        self._type = type.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self._folder_id = folder_id.map(AnyString.init)
        self._folder_name = folder_name.map(AnyString.init)
        self._view_count = view_count.map(AnyInt.init)
        self._preferred_viewer = preferred_viewer.map(AnyString.init)
        self._model = model.map(AnyString.init)
    }

}

public struct ContentSummary: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _content_type = "content_type"
        case _content_id = "content_id"
        case _content_slug = "content_slug"
        case _content_url = "content_url"
        case _title = "title"
        case _description = "description"
        case last_viewed_at
        case _user_id = "user_id"
        case _user_full_name = "user_full_name"
        case is_scheduled
        case _favorite_count = "favorite_count"
        case _view_count = "view_count"
        case _favorite_id = "favorite_id"
        case weighted_score
        case group_weighted_score
        case suggestion_score
        case _preferred_viewer = "preferred_viewer"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _content_type: AnyString?
    /**
     * Content type (read-only)
     */
    public var content_type: String? {
        get { _content_type?.value }
        set { _content_type = newValue.map(AnyString.init) }
    }

    private var _content_id: AnyString?
    /**
     * Content id (read-only)
     */
    public var content_id: String? {
        get { _content_id?.value }
        set { _content_id = newValue.map(AnyString.init) }
    }

    private var _content_slug: AnyString?
    /**
     * Content slug (read-only)
     */
    public var content_slug: String? {
        get { _content_slug?.value }
        set { _content_slug = newValue.map(AnyString.init) }
    }

    private var _content_url: AnyString?
    /**
     * Content url (read-only)
     */
    public var content_url: String? {
        get { _content_url?.value }
        set { _content_url = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Content title (read-only)
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * Content Description (read-only)
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    /**
     * Last time viewed by current user (read-only)
     */
    public var last_viewed_at: Date?

    private var _user_id: AnyString?
    /**
     * ID of user who created the content (read-only)
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    private var _user_full_name: AnyString?
    /**
     * Full name of user who created the content (read-only)
     */
    public var user_full_name: String? {
        get { _user_full_name?.value }
        set { _user_full_name = newValue.map(AnyString.init) }
    }

    /**
     * If the content is scheduled by the current user (read-only)
     */
    public var is_scheduled: Bool?

    private var _favorite_count: AnyInt?
    /**
     * Number of favorites (read-only)
     */
    public var favorite_count: Int64? {
        get { _favorite_count?.value }
        set { _favorite_count = newValue.map(AnyInt.init) }
    }

    private var _view_count: AnyInt?
    /**
     * Number of views (read-only)
     */
    public var view_count: Int64? {
        get { _view_count?.value }
        set { _view_count = newValue.map(AnyInt.init) }
    }

    private var _favorite_id: AnyString?
    /**
     * Corresponding favorite id if item is favorited by current user (read-only)
     */
    public var favorite_id: String? {
        get { _favorite_id?.value }
        set { _favorite_id = newValue.map(AnyString.init) }
    }

    /**
     *  (read-only)
     */
    public var weighted_score: Float?

    /**
     *  (read-only)
     */
    public var group_weighted_score: Float?

    /**
     *  (read-only)
     */
    public var suggestion_score: Float?

    private var _preferred_viewer: AnyString?
    /**
     * The preferred route for viewing this content (ie: dashboards or dashboards-next) (read-only)
     */
    public var preferred_viewer: String? {
        get { _preferred_viewer?.value }
        set { _preferred_viewer = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, content_type: String? = nil, content_id: String? = nil, content_slug: String? = nil, content_url: String? = nil, title: String? = nil, description: String? = nil, last_viewed_at: Date? = nil, user_id: String? = nil, user_full_name: String? = nil, is_scheduled: Bool? = nil, favorite_count: Int64? = nil, view_count: Int64? = nil, favorite_id: String? = nil, weighted_score: Float? = nil, group_weighted_score: Float? = nil, suggestion_score: Float? = nil, preferred_viewer: String? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._content_type = content_type.map(AnyString.init)
        self._content_id = content_id.map(AnyString.init)
        self._content_slug = content_slug.map(AnyString.init)
        self._content_url = content_url.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self.last_viewed_at = last_viewed_at
        self._user_id = user_id.map(AnyString.init)
        self._user_full_name = user_full_name.map(AnyString.init)
        self.is_scheduled = is_scheduled
        self._favorite_count = favorite_count.map(AnyInt.init)
        self._view_count = view_count.map(AnyInt.init)
        self._favorite_id = favorite_id.map(AnyString.init)
        self.weighted_score = weighted_score
        self.group_weighted_score = group_weighted_score
        self.suggestion_score = suggestion_score
        self._preferred_viewer = preferred_viewer.map(AnyString.init)
    }

}

public struct ContentValidation: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case content_with_errors
        case computation_time
        case _total_looks_validated = "total_looks_validated"
        case _total_dashboard_elements_validated = "total_dashboard_elements_validated"
        case _total_dashboard_filters_validated = "total_dashboard_filters_validated"
        case _total_scheduled_plans_validated = "total_scheduled_plans_validated"
        case _total_alerts_validated = "total_alerts_validated"
        case _total_explores_validated = "total_explores_validated"
    }
    /**
     * A list of content errors (read-only)
     */
    public var content_with_errors: [ContentValidatorError]?

    /**
     * Duration of content validation in seconds (read-only)
     */
    public var computation_time: Float?

    private var _total_looks_validated: AnyInt?
    /**
     * The number of looks validated (read-only)
     */
    public var total_looks_validated: Int64? {
        get { _total_looks_validated?.value }
        set { _total_looks_validated = newValue.map(AnyInt.init) }
    }

    private var _total_dashboard_elements_validated: AnyInt?
    /**
     * The number of dashboard elements validated (read-only)
     */
    public var total_dashboard_elements_validated: Int64? {
        get { _total_dashboard_elements_validated?.value }
        set { _total_dashboard_elements_validated = newValue.map(AnyInt.init) }
    }

    private var _total_dashboard_filters_validated: AnyInt?
    /**
     * The number of dashboard filters validated (read-only)
     */
    public var total_dashboard_filters_validated: Int64? {
        get { _total_dashboard_filters_validated?.value }
        set { _total_dashboard_filters_validated = newValue.map(AnyInt.init) }
    }

    private var _total_scheduled_plans_validated: AnyInt?
    /**
     * The number of scheduled plans validated (read-only)
     */
    public var total_scheduled_plans_validated: Int64? {
        get { _total_scheduled_plans_validated?.value }
        set { _total_scheduled_plans_validated = newValue.map(AnyInt.init) }
    }

    private var _total_alerts_validated: AnyInt?
    /**
     * The number of alerts validated (read-only)
     */
    public var total_alerts_validated: Int64? {
        get { _total_alerts_validated?.value }
        set { _total_alerts_validated = newValue.map(AnyInt.init) }
    }

    private var _total_explores_validated: AnyInt?
    /**
     * The number of explores used across all content validated (read-only)
     */
    public var total_explores_validated: Int64? {
        get { _total_explores_validated?.value }
        set { _total_explores_validated = newValue.map(AnyInt.init) }
    }

    public init(content_with_errors: [ContentValidatorError]? = nil, computation_time: Float? = nil, total_looks_validated: Int64? = nil, total_dashboard_elements_validated: Int64? = nil, total_dashboard_filters_validated: Int64? = nil, total_scheduled_plans_validated: Int64? = nil, total_alerts_validated: Int64? = nil, total_explores_validated: Int64? = nil) {
        self.content_with_errors = content_with_errors
        self.computation_time = computation_time
        self._total_looks_validated = total_looks_validated.map(AnyInt.init)
        self._total_dashboard_elements_validated = total_dashboard_elements_validated.map(AnyInt.init)
        self._total_dashboard_filters_validated = total_dashboard_filters_validated.map(AnyInt.init)
        self._total_scheduled_plans_validated = total_scheduled_plans_validated.map(AnyInt.init)
        self._total_alerts_validated = total_alerts_validated.map(AnyInt.init)
        self._total_explores_validated = total_explores_validated.map(AnyInt.init)
    }

}

public struct ContentValidationAlert: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _lookml_dashboard_id = "lookml_dashboard_id"
        case _lookml_link_id = "lookml_link_id"
        case _custom_url_base = "custom_url_base"
        case _custom_url_params = "custom_url_params"
        case _custom_url_label = "custom_url_label"
        case show_custom_url
        case _custom_title = "custom_title"
    }
    private var _id: AnyString?
    /**
     * ID of the alert
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _lookml_dashboard_id: AnyString?
    /**
     * ID of the LookML dashboard associated with the alert
     */
    public var lookml_dashboard_id: String? {
        get { _lookml_dashboard_id?.value }
        set { _lookml_dashboard_id = newValue.map(AnyString.init) }
    }

    private var _lookml_link_id: AnyString?
    /**
     * ID of the LookML dashboard element associated with the alert
     */
    public var lookml_link_id: String? {
        get { _lookml_link_id?.value }
        set { _lookml_link_id = newValue.map(AnyString.init) }
    }

    private var _custom_url_base: AnyString?
    /**
     * Domain for the custom url selected by the alert creator from the admin defined domain allowlist
     */
    public var custom_url_base: String? {
        get { _custom_url_base?.value }
        set { _custom_url_base = newValue.map(AnyString.init) }
    }

    private var _custom_url_params: AnyString?
    /**
     * Parameters and path for the custom url defined by the alert creator
     */
    public var custom_url_params: String? {
        get { _custom_url_params?.value }
        set { _custom_url_params = newValue.map(AnyString.init) }
    }

    private var _custom_url_label: AnyString?
    /**
     * Label for the custom url defined by the alert creator
     */
    public var custom_url_label: String? {
        get { _custom_url_label?.value }
        set { _custom_url_label = newValue.map(AnyString.init) }
    }

    /**
     * Boolean to determine if the custom url should be used
     */
    public var show_custom_url: Bool?

    private var _custom_title: AnyString?
    /**
     * An optional, user-defined title for the alert
     */
    public var custom_title: String? {
        get { _custom_title?.value }
        set { _custom_title = newValue.map(AnyString.init) }
    }

    public init(id: String? = nil, lookml_dashboard_id: String? = nil, lookml_link_id: String? = nil, custom_url_base: String? = nil, custom_url_params: String? = nil, custom_url_label: String? = nil, show_custom_url: Bool? = nil, custom_title: String? = nil) {
        self._id = id.map(AnyString.init)
        self._lookml_dashboard_id = lookml_dashboard_id.map(AnyString.init)
        self._lookml_link_id = lookml_link_id.map(AnyString.init)
        self._custom_url_base = custom_url_base.map(AnyString.init)
        self._custom_url_params = custom_url_params.map(AnyString.init)
        self._custom_url_label = custom_url_label.map(AnyString.init)
        self.show_custom_url = show_custom_url
        self._custom_title = custom_title.map(AnyString.init)
    }

}

public struct ContentValidationDashboard: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _description = "description"
        case _id = "id"
        case folder
        case _title = "title"
        case _url = "url"
    }
    private var _description: AnyString?
    /**
     * Description
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    public var folder: ContentValidationFolder?

    private var _title: AnyString?
    /**
     * Dashboard Title
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Relative URL of the dashboard (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(description: String? = nil, id: String? = nil, folder: ContentValidationFolder? = nil, title: String? = nil, url: String? = nil) {
        self._description = description.map(AnyString.init)
        self._id = id.map(AnyString.init)
        self.folder = folder
        self._title = title.map(AnyString.init)
        self._url = url.map(AnyString.init)
    }

}

public struct ContentValidationDashboardElement: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _body_text = "body_text"
        case _dashboard_id = "dashboard_id"
        case _id = "id"
        case _look_id = "look_id"
        case _note_display = "note_display"
        case _note_state = "note_state"
        case _note_text = "note_text"
        case _note_text_as_html = "note_text_as_html"
        case _query_id = "query_id"
        case _subtitle_text = "subtitle_text"
        case _title = "title"
        case title_hidden
        case _title_text = "title_text"
        case _type = "type"
        case _rich_content_json = "rich_content_json"
        case _extension_id = "extension_id"
    }
    private var _body_text: AnyString?
    /**
     * Text tile body text
     */
    public var body_text: String? {
        get { _body_text?.value }
        set { _body_text = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString?
    /**
     * Id of Dashboard
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _look_id: AnyString?
    /**
     * Id Of Look
     */
    public var look_id: String? {
        get { _look_id?.value }
        set { _look_id = newValue.map(AnyString.init) }
    }

    private var _note_display: AnyString?
    /**
     * Note Display
     */
    public var note_display: String? {
        get { _note_display?.value }
        set { _note_display = newValue.map(AnyString.init) }
    }

    private var _note_state: AnyString?
    /**
     * Note State
     */
    public var note_state: String? {
        get { _note_state?.value }
        set { _note_state = newValue.map(AnyString.init) }
    }

    private var _note_text: AnyString?
    /**
     * Note Text
     */
    public var note_text: String? {
        get { _note_text?.value }
        set { _note_text = newValue.map(AnyString.init) }
    }

    private var _note_text_as_html: AnyString?
    /**
     * Note Text as Html (read-only)
     */
    public var note_text_as_html: String? {
        get { _note_text_as_html?.value }
        set { _note_text_as_html = newValue.map(AnyString.init) }
    }

    private var _query_id: AnyString?
    /**
     * Id Of Query
     */
    public var query_id: String? {
        get { _query_id?.value }
        set { _query_id = newValue.map(AnyString.init) }
    }

    private var _subtitle_text: AnyString?
    /**
     * Text tile subtitle text
     */
    public var subtitle_text: String? {
        get { _subtitle_text?.value }
        set { _subtitle_text = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Title of dashboard element
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    /**
     * Whether title is hidden
     */
    public var title_hidden: Bool?

    private var _title_text: AnyString?
    /**
     * Text tile title
     */
    public var title_text: String? {
        get { _title_text?.value }
        set { _title_text = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * Type
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _rich_content_json: AnyString?
    /**
     * JSON with all the properties required for rich editor and buttons elements
     */
    public var rich_content_json: String? {
        get { _rich_content_json?.value }
        set { _rich_content_json = newValue.map(AnyString.init) }
    }

    private var _extension_id: AnyString?
    /**
     * Extension ID
     */
    public var extension_id: String? {
        get { _extension_id?.value }
        set { _extension_id = newValue.map(AnyString.init) }
    }

    public init(body_text: String? = nil, dashboard_id: String? = nil, id: String? = nil, look_id: String? = nil, note_display: String? = nil, note_state: String? = nil, note_text: String? = nil, note_text_as_html: String? = nil, query_id: String? = nil, subtitle_text: String? = nil, title: String? = nil, title_hidden: Bool? = nil, title_text: String? = nil, type: String? = nil, rich_content_json: String? = nil, extension_id: String? = nil) {
        self._body_text = body_text.map(AnyString.init)
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self._id = id.map(AnyString.init)
        self._look_id = look_id.map(AnyString.init)
        self._note_display = note_display.map(AnyString.init)
        self._note_state = note_state.map(AnyString.init)
        self._note_text = note_text.map(AnyString.init)
        self._note_text_as_html = note_text_as_html.map(AnyString.init)
        self._query_id = query_id.map(AnyString.init)
        self._subtitle_text = subtitle_text.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self.title_hidden = title_hidden
        self._title_text = title_text.map(AnyString.init)
        self._type = type.map(AnyString.init)
        self._rich_content_json = rich_content_json.map(AnyString.init)
        self._extension_id = extension_id.map(AnyString.init)
    }

}

public struct ContentValidationDashboardFilter: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _dashboard_id = "dashboard_id"
        case _name = "name"
        case _title = "title"
        case _type = "type"
        case _default_value = "default_value"
        case _model = "model"
        case _explore = "explore"
        case _dimension = "dimension"
    }
    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString?
    /**
     * Id of Dashboard (read-only)
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Name of filter
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Title of filter
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * Type of filter: one of date, number, string, or field
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _default_value: AnyString?
    /**
     * Default value of filter
     */
    public var default_value: String? {
        get { _default_value?.value }
        set { _default_value = newValue.map(AnyString.init) }
    }

    private var _model: AnyString?
    /**
     * Model of filter (required if type = field)
     */
    public var model: String? {
        get { _model?.value }
        set { _model = newValue.map(AnyString.init) }
    }

    private var _explore: AnyString?
    /**
     * Explore of filter (required if type = field)
     */
    public var explore: String? {
        get { _explore?.value }
        set { _explore = newValue.map(AnyString.init) }
    }

    private var _dimension: AnyString?
    /**
     * Dimension of filter (required if type = field)
     */
    public var dimension: String? {
        get { _dimension?.value }
        set { _dimension = newValue.map(AnyString.init) }
    }

    public init(id: String? = nil, dashboard_id: String? = nil, name: String? = nil, title: String? = nil, type: String? = nil, default_value: String? = nil, model: String? = nil, explore: String? = nil, dimension: String? = nil) {
        self._id = id.map(AnyString.init)
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self._type = type.map(AnyString.init)
        self._default_value = default_value.map(AnyString.init)
        self._model = model.map(AnyString.init)
        self._explore = explore.map(AnyString.init)
        self._dimension = dimension.map(AnyString.init)
    }

}

public struct ContentValidationError: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _message = "message"
        case _field_name = "field_name"
        case _model_name = "model_name"
        case _explore_name = "explore_name"
        case removable
    }
    private var _message: AnyString?
    /**
     * Error message (read-only)
     */
    public var message: String? {
        get { _message?.value }
        set { _message = newValue.map(AnyString.init) }
    }

    private var _field_name: AnyString?
    /**
     * Name of the field involved in the error (read-only)
     */
    public var field_name: String? {
        get { _field_name?.value }
        set { _field_name = newValue.map(AnyString.init) }
    }

    private var _model_name: AnyString?
    /**
     * Name of the model involved in the error (read-only)
     */
    public var model_name: String? {
        get { _model_name?.value }
        set { _model_name = newValue.map(AnyString.init) }
    }

    private var _explore_name: AnyString?
    /**
     * Name of the explore involved in the error (read-only)
     */
    public var explore_name: String? {
        get { _explore_name?.value }
        set { _explore_name = newValue.map(AnyString.init) }
    }

    /**
     * Whether this validation error is removable (read-only)
     */
    public var removable: Bool?

    public init(message: String? = nil, field_name: String? = nil, model_name: String? = nil, explore_name: String? = nil, removable: Bool? = nil) {
        self._message = message.map(AnyString.init)
        self._field_name = field_name.map(AnyString.init)
        self._model_name = model_name.map(AnyString.init)
        self._explore_name = explore_name.map(AnyString.init)
        self.removable = removable
    }

}

public struct ContentValidationFolder: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _id = "id"
    }
    private var _name: AnyString
    /**
     * Unique Name
     */
    public var name: String {
        get { _name.value }
        set { _name = AnyString.init(newValue) }
    }

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    public init(name: String, id: String? = nil) {
        self._name = AnyString.init(name)
        self._id = id.map(AnyString.init)
    }

    public init(_ name: String, id: String? = nil) {
        self.init(name: name, id: id)
    }

}

public struct ContentValidationLook: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _title = "title"
        case _short_url = "short_url"
        case folder
    }
    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Look Title
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _short_url: AnyString?
    /**
     * Short Url (read-only)
     */
    public var short_url: String? {
        get { _short_url?.value }
        set { _short_url = newValue.map(AnyString.init) }
    }

    public var folder: ContentValidationFolder?

    public init(id: String? = nil, title: String? = nil, short_url: String? = nil, folder: ContentValidationFolder? = nil) {
        self._id = id.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self._short_url = short_url.map(AnyString.init)
        self.folder = folder
    }

}

public struct ContentValidationLookMLDashboard: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _title = "title"
        case _space_id = "space_id"
    }
    private var _id: AnyString?
    /**
     * ID of the LookML Dashboard (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Title of the LookML Dashboard (read-only)
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _space_id: AnyString?
    /**
     * ID of Space (read-only)
     */
    public var space_id: String? {
        get { _space_id?.value }
        set { _space_id = newValue.map(AnyString.init) }
    }

    public init(id: String? = nil, title: String? = nil, space_id: String? = nil) {
        self._id = id.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self._space_id = space_id.map(AnyString.init)
    }

}

public struct ContentValidationLookMLDashboardElement: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _lookml_link_id = "lookml_link_id"
        case _title = "title"
    }
    private var _lookml_link_id: AnyString?
    /**
     * Link ID of the LookML Dashboard Element (read-only)
     */
    public var lookml_link_id: String? {
        get { _lookml_link_id?.value }
        set { _lookml_link_id = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Title of the LookML Dashboard Element (read-only)
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    public init(lookml_link_id: String? = nil, title: String? = nil) {
        self._lookml_link_id = lookml_link_id.map(AnyString.init)
        self._title = title.map(AnyString.init)
    }

}

public struct ContentValidationScheduledPlan: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _look_id = "look_id"
        case _id = "id"
    }
    private var _name: AnyString?
    /**
     * Name of this scheduled plan
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _look_id: AnyString?
    /**
     * Id of a look
     */
    public var look_id: String? {
        get { _look_id?.value }
        set { _look_id = newValue.map(AnyString.init) }
    }

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, look_id: String? = nil, id: String? = nil) {
        self._name = name.map(AnyString.init)
        self._look_id = look_id.map(AnyString.init)
        self._id = id.map(AnyString.init)
    }

}

public struct ContentValidatorContentError: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _type = "type"
        case _title = "title"
        case _detail = "detail"
        case _status = "status"
        case _instance = "instance"
        case _model = "model"
        case _explore = "explore"
        case _field_name = "field_name"
        case _content_type = "content_type"
        case _folder = "folder"
        case _url = "url"
        case _tile_type = "tile_type"
        case _tile_title = "tile_title"
        case _message = "message"
    }
    private var _type: AnyString?
    /**
     * A URI reference that identifies the problem type (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Overview of the error (read-only)
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _detail: AnyString?
    /**
     * Detail of the error (read-only)
     */
    public var detail: String? {
        get { _detail?.value }
        set { _detail = newValue.map(AnyString.init) }
    }

    private var _status: AnyString?
    /**
     * The HTTP status code for the problem (read-only)
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    private var _instance: AnyString?
    /**
     * URI reference that identifies the specific occurrence of the problem (read-only)
     */
    public var instance: String? {
        get { _instance?.value }
        set { _instance = newValue.map(AnyString.init) }
    }

    private var _model: AnyString?
    /**
     * LookML model that contains the error (read-only)
     */
    public var model: String? {
        get { _model?.value }
        set { _model = newValue.map(AnyString.init) }
    }

    private var _explore: AnyString?
    /**
     * LookML Explore that contains the error (read-only)
     */
    public var explore: String? {
        get { _explore?.value }
        set { _explore = newValue.map(AnyString.init) }
    }

    private var _field_name: AnyString?
    /**
     * LookML field that caused the error (read-only)
     */
    public var field_name: String? {
        get { _field_name?.value }
        set { _field_name = newValue.map(AnyString.init) }
    }

    private var _content_type: AnyString?
    /**
     * Type of the content (dashboard, look) (read-only)
     */
    public var content_type: String? {
        get { _content_type?.value }
        set { _content_type = newValue.map(AnyString.init) }
    }

    private var _folder: AnyString?
    /**
     * Folder of the content (read-only)
     */
    public var folder: String? {
        get { _folder?.value }
        set { _folder = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * URL of the content (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    private var _tile_type: AnyString?
    /**
     * Type of the tile (dashboard_element, dashboard_filter) (read-only)
     */
    public var tile_type: String? {
        get { _tile_type?.value }
        set { _tile_type = newValue.map(AnyString.init) }
    }

    private var _tile_title: AnyString?
    /**
     * Title of the tile (read-only)
     */
    public var tile_title: String? {
        get { _tile_title?.value }
        set { _tile_title = newValue.map(AnyString.init) }
    }

    private var _message: AnyString?
    /**
     * Message returned by the content validator (read-only)
     */
    public var message: String? {
        get { _message?.value }
        set { _message = newValue.map(AnyString.init) }
    }

    public init(type: String? = nil, title: String? = nil, detail: String? = nil, status: String? = nil, instance: String? = nil, model: String? = nil, explore: String? = nil, field_name: String? = nil, content_type: String? = nil, folder: String? = nil, url: String? = nil, tile_type: String? = nil, tile_title: String? = nil, message: String? = nil) {
        self._type = type.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self._detail = detail.map(AnyString.init)
        self._status = status.map(AnyString.init)
        self._instance = instance.map(AnyString.init)
        self._model = model.map(AnyString.init)
        self._explore = explore.map(AnyString.init)
        self._field_name = field_name.map(AnyString.init)
        self._content_type = content_type.map(AnyString.init)
        self._folder = folder.map(AnyString.init)
        self._url = url.map(AnyString.init)
        self._tile_type = tile_type.map(AnyString.init)
        self._tile_title = tile_title.map(AnyString.init)
        self._message = message.map(AnyString.init)
    }

}

public struct ContentValidatorError: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case look
        case dashboard
        case dashboard_element
        case dashboard_filter
        case scheduled_plan
        case alert
        case lookml_dashboard
        case lookml_dashboard_element
        case errors
        case _id = "id"
    }
    public var look: ContentValidationLook?

    public var dashboard: ContentValidationDashboard?

    public var dashboard_element: ContentValidationDashboardElement?

    public var dashboard_filter: ContentValidationDashboardFilter?

    public var scheduled_plan: ContentValidationScheduledPlan?

    public var alert: ContentValidationAlert?

    public var lookml_dashboard: ContentValidationLookMLDashboard?

    public var lookml_dashboard_element: ContentValidationLookMLDashboardElement?

    /**
     * A list of errors found for this piece of content (read-only)
     */
    public var errors: [ContentValidationError]?

    private var _id: AnyString?
    /**
     * An id unique to this piece of content for this validation run (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    public init(look: ContentValidationLook? = nil, dashboard: ContentValidationDashboard? = nil, dashboard_element: ContentValidationDashboardElement? = nil, dashboard_filter: ContentValidationDashboardFilter? = nil, scheduled_plan: ContentValidationScheduledPlan? = nil, alert: ContentValidationAlert? = nil, lookml_dashboard: ContentValidationLookMLDashboard? = nil, lookml_dashboard_element: ContentValidationLookMLDashboardElement? = nil, errors: [ContentValidationError]? = nil, id: String? = nil) {
        self.look = look
        self.dashboard = dashboard
        self.dashboard_element = dashboard_element
        self.dashboard_filter = dashboard_filter
        self.scheduled_plan = scheduled_plan
        self.alert = alert
        self.lookml_dashboard = lookml_dashboard
        self.lookml_dashboard_element = lookml_dashboard_element
        self.errors = errors
        self._id = id.map(AnyString.init)
    }

}

public struct ContentValidatorErrorItem: SDKModel {
    public var content_error: ContentValidatorContentError?

    public var generic_error: GenericError?

    public init(content_error: ContentValidatorContentError? = nil, generic_error: GenericError? = nil) {
        self.content_error = content_error
        self.generic_error = generic_error
    }

}

public struct ContentValidatorResult: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case incremental
        case _status = "status"
        case result
    }
    private var _name: AnyString?
    /**
     * Name of the validator (content) (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     * Whether the validation was incremental (read-only)
     */
    public var incremental: Bool?

    private var _status: AnyString?
    /**
     * Status of the validation (unknown, failed, passed, skipped, errored, cancelled, queued, running) (read-only)
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    /**
     * Results of the content validation (read-only)
     */
    public var result: [ContentValidatorTestedExplore]?

    public init(name: String? = nil, incremental: Bool? = nil, status: String? = nil, result: [ContentValidatorTestedExplore]? = nil) {
        self._name = name.map(AnyString.init)
        self.incremental = incremental
        self._status = status.map(AnyString.init)
        self.result = result
    }

}

public struct ContentValidatorTestedExplore: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _error_count = "error_count"
        case errors
    }
    private var _error_count: AnyInt?
    /**
     * Total number of failed content validations (read-only)
     */
    public var error_count: Int64? {
        get { _error_count?.value }
        set { _error_count = newValue.map(AnyInt.init) }
    }

    /**
     * Details of the content that failed validation (read-only)
     */
    public var errors: [ContentValidatorErrorItem]?

    public init(error_count: Int64? = nil, errors: [ContentValidatorErrorItem]? = nil) {
        self._error_count = error_count.map(AnyInt.init)
        self.errors = errors
    }

}

public struct ContentView: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _look_id = "look_id"
        case _dashboard_id = "dashboard_id"
        case _title = "title"
        case _content_metadata_id = "content_metadata_id"
        case _user_id = "user_id"
        case _group_id = "group_id"
        case _view_count = "view_count"
        case _favorite_count = "favorite_count"
        case _last_viewed_at = "last_viewed_at"
        case _start_of_week_date = "start_of_week_date"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _look_id: AnyString?
    /**
     * Id of viewed Look (read-only)
     */
    public var look_id: String? {
        get { _look_id?.value }
        set { _look_id = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString?
    /**
     * Id of the viewed Dashboard (read-only)
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Name or title of underlying content (read-only)
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _content_metadata_id: AnyString?
    /**
     * Content metadata id of the Look or Dashboard (read-only)
     */
    public var content_metadata_id: String? {
        get { _content_metadata_id?.value }
        set { _content_metadata_id = newValue.map(AnyString.init) }
    }

    private var _user_id: AnyString?
    /**
     * Id of user content was viewed by (read-only)
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    private var _group_id: AnyString?
    /**
     * Id of group content was viewed by (read-only)
     */
    public var group_id: String? {
        get { _group_id?.value }
        set { _group_id = newValue.map(AnyString.init) }
    }

    private var _view_count: AnyInt?
    /**
     * Number of times piece of content was viewed (read-only)
     */
    public var view_count: Int64? {
        get { _view_count?.value }
        set { _view_count = newValue.map(AnyInt.init) }
    }

    private var _favorite_count: AnyInt?
    /**
     * Number of times piece of content was favorited (read-only)
     */
    public var favorite_count: Int64? {
        get { _favorite_count?.value }
        set { _favorite_count = newValue.map(AnyInt.init) }
    }

    private var _last_viewed_at: AnyString?
    /**
     * Date the piece of content was last viewed (read-only)
     */
    public var last_viewed_at: String? {
        get { _last_viewed_at?.value }
        set { _last_viewed_at = newValue.map(AnyString.init) }
    }

    private var _start_of_week_date: AnyString?
    /**
     * Week start date for the view and favorite count during that given week (read-only)
     */
    public var start_of_week_date: String? {
        get { _start_of_week_date?.value }
        set { _start_of_week_date = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, look_id: String? = nil, dashboard_id: String? = nil, title: String? = nil, content_metadata_id: String? = nil, user_id: String? = nil, group_id: String? = nil, view_count: Int64? = nil, favorite_count: Int64? = nil, last_viewed_at: String? = nil, start_of_week_date: String? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._look_id = look_id.map(AnyString.init)
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self._content_metadata_id = content_metadata_id.map(AnyString.init)
        self._user_id = user_id.map(AnyString.init)
        self._group_id = group_id.map(AnyString.init)
        self._view_count = view_count.map(AnyInt.init)
        self._favorite_count = favorite_count.map(AnyInt.init)
        self._last_viewed_at = last_viewed_at.map(AnyString.init)
        self._start_of_week_date = start_of_week_date.map(AnyString.init)
    }

}

public struct ContinuousPalette: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _label = "label"
        case _type = "type"
        case stops
    }
    private var _id: AnyString?
    /**
     * Unique identity string (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _label: AnyString?
    /**
     * Label for palette
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * Type of palette
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    /**
     * Array of ColorStops in the palette
     */
    public var stops: [ColorStop]?

    public init(id: String? = nil, label: String? = nil, type: String? = nil, stops: [ColorStop]? = nil) {
        self._id = id.map(AnyString.init)
        self._label = label.map(AnyString.init)
        self._type = type.map(AnyString.init)
        self.stops = stops
    }

}

public struct CostEstimate: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _cost = "cost"
        case cache_hit
        case _cost_unit = "cost_unit"
        case _message = "message"
    }
    private var _cost: AnyInt?
    /**
     * Cost of SQL statement (read-only)
     */
    public var cost: Int64? {
        get { _cost?.value }
        set { _cost = newValue.map(AnyInt.init) }
    }

    /**
     * Does the result come from the cache? (read-only)
     */
    public var cache_hit: Bool?

    private var _cost_unit: AnyString?
    /**
     * Cost measurement size (read-only)
     */
    public var cost_unit: String? {
        get { _cost_unit?.value }
        set { _cost_unit = newValue.map(AnyString.init) }
    }

    private var _message: AnyString?
    /**
     * Human-friendly message (read-only)
     */
    public var message: String? {
        get { _message?.value }
        set { _message = newValue.map(AnyString.init) }
    }

    public init(cost: Int64? = nil, cache_hit: Bool? = nil, cost_unit: String? = nil, message: String? = nil) {
        self._cost = cost.map(AnyInt.init)
        self.cache_hit = cache_hit
        self._cost_unit = cost_unit.map(AnyString.init)
        self._message = message.map(AnyString.init)
    }

}

public struct CreateCIRunRequest: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _suite_id = "suite_id"
        case _branch = "branch"
        case _commit = "commit"
    }
    private var _suite_id: AnyString?
    /**
     * ID of the CI suite
     */
    public var suite_id: String? {
        get { _suite_id?.value }
        set { _suite_id = newValue.map(AnyString.init) }
    }

    private var _branch: AnyString?
    /**
     * Branch that the CI run should validate. Omit to test production.
     */
    public var branch: String? {
        get { _branch?.value }
        set { _branch = newValue.map(AnyString.init) }
    }

    private var _commit: AnyString?
    /**
     * Commit that the CI run should validate. Omit to test production.
     */
    public var commit: String? {
        get { _commit?.value }
        set { _commit = newValue.map(AnyString.init) }
    }

    public init(suite_id: String? = nil, branch: String? = nil, commit: String? = nil) {
        self._suite_id = suite_id.map(AnyString.init)
        self._branch = branch.map(AnyString.init)
        self._commit = commit.map(AnyString.init)
    }

}

public struct CreateCIRunResponse: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _run_id = "run_id"
        case _status = "status"
    }
    private var _run_id: AnyString?
    /**
     * ID of the CI run (read-only)
     */
    public var run_id: String? {
        get { _run_id?.value }
        set { _run_id = newValue.map(AnyString.init) }
    }

    private var _status: AnyString?
    /**
     * Status of the CI run (unknown, failed, passed, skipped, errored, cancelled, queued, running) (read-only)
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    public init(run_id: String? = nil, status: String? = nil) {
        self._run_id = run_id.map(AnyString.init)
        self._status = status.map(AnyString.init)
    }

}

/**
 * WARNING: no writeable properties found for POST, PUT, or PATCH
 */
public struct CreateCostEstimate: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _sql = "sql"
    }
    private var _sql: AnyString?
    /**
     * SQL statement to estimate (read-only)
     */
    public var sql: String? {
        get { _sql?.value }
        set { _sql = newValue.map(AnyString.init) }
    }

    public init(sql: String? = nil) {
        self._sql = sql.map(AnyString.init)
    }

}

public struct CreateCredentialsApi3: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _client_id = "client_id"
        case _created_at = "created_at"
        case is_disabled
        case _type = "type"
        case _client_secret = "client_secret"
        case _url = "url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _client_id: AnyString?
    /**
     * API key client_id (read-only)
     */
    public var client_id: String? {
        get { _client_id?.value }
        set { _client_id = newValue.map(AnyString.init) }
    }

    private var _created_at: AnyString?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String? {
        get { _created_at?.value }
        set { _created_at = newValue.map(AnyString.init) }
    }

    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?

    private var _type: AnyString?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _client_secret: AnyString?
    /**
     * API key client_secret (read-only)
     */
    public var client_secret: String? {
        get { _client_secret?.value }
        set { _client_secret = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, client_id: String? = nil, created_at: String? = nil, is_disabled: Bool? = nil, type: String? = nil, client_secret: String? = nil, url: String? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._client_id = client_id.map(AnyString.init)
        self._created_at = created_at.map(AnyString.init)
        self.is_disabled = is_disabled
        self._type = type.map(AnyString.init)
        self._client_secret = client_secret.map(AnyString.init)
        self._url = url.map(AnyString.init)
    }

}

public struct CreateDashboardFilter: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _dashboard_id = "dashboard_id"
        case _name = "name"
        case _title = "title"
        case _type = "type"
        case _default_value = "default_value"
        case _model = "model"
        case _explore = "explore"
        case _dimension = "dimension"
        case field
        case _row = "row"
        case _listens_to_filters = "listens_to_filters"
        case allow_multiple_values
        case required
        case ui_config
    }
    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString
    /**
     * Id of Dashboard
     */
    public var dashboard_id: String {
        get { _dashboard_id.value }
        set { _dashboard_id = AnyString.init(newValue) }
    }

    private var _name: AnyString
    /**
     * Name of filter
     */
    public var name: String {
        get { _name.value }
        set { _name = AnyString.init(newValue) }
    }

    private var _title: AnyString
    /**
     * Title of filter
     */
    public var title: String {
        get { _title.value }
        set { _title = AnyString.init(newValue) }
    }

    private var _type: AnyString
    /**
     * Type of filter: one of date, number, string, or field
     */
    public var type: String {
        get { _type.value }
        set { _type = AnyString.init(newValue) }
    }

    private var _default_value: AnyString?
    /**
     * Default value of filter
     */
    public var default_value: String? {
        get { _default_value?.value }
        set { _default_value = newValue.map(AnyString.init) }
    }

    private var _model: AnyString?
    /**
     * Model of filter (required if type = field)
     */
    public var model: String? {
        get { _model?.value }
        set { _model = newValue.map(AnyString.init) }
    }

    private var _explore: AnyString?
    /**
     * Explore of filter (required if type = field)
     */
    public var explore: String? {
        get { _explore?.value }
        set { _explore = newValue.map(AnyString.init) }
    }

    private var _dimension: AnyString?
    /**
     * Dimension of filter (required if type = field)
     */
    public var dimension: String? {
        get { _dimension?.value }
        set { _dimension = newValue.map(AnyString.init) }
    }

    /**
     * Field information (read-only)
     */
    public var field: StringDictionary<AnyCodable>?

    private var _row: AnyInt?
    /**
     * Display order of this filter relative to other filters
     */
    public var row: Int64? {
        get { _row?.value }
        set { _row = newValue.map(AnyInt.init) }
    }

    private var _listens_to_filters: [AnyString]?
    /**
     * Array of listeners for faceted filters
     */
    public var listens_to_filters: [String]? {
        get { if let v = _listens_to_filters { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _listens_to_filters = v.map { AnyString.init($0) } } else { _listens_to_filters = nil } }
    }

    /**
     * Whether the filter allows multiple filter values (deprecated in the latest version of dashboards)
     */
    public var allow_multiple_values: Bool?

    /**
     * Whether the filter requires a value to run the dashboard
     */
    public var required: Bool?

    /**
     * The visual configuration for this filter. Used to set up how the UI for this filter should appear.
     */
    public var ui_config: StringDictionary<AnyCodable>?

    public init(id: String? = nil, dashboard_id: String, name: String, title: String, type: String, default_value: String? = nil, model: String? = nil, explore: String? = nil, dimension: String? = nil, field: StringDictionary<AnyCodable>? = nil, row: Int64? = nil, listens_to_filters: [String]? = nil, allow_multiple_values: Bool? = nil, required: Bool? = nil, ui_config: StringDictionary<AnyCodable>? = nil) {
        self._id = id.map(AnyString.init)
        self._dashboard_id = AnyString.init(dashboard_id)
        self._name = AnyString.init(name)
        self._title = AnyString.init(title)
        self._type = AnyString.init(type)
        self._default_value = default_value.map(AnyString.init)
        self._model = model.map(AnyString.init)
        self._explore = explore.map(AnyString.init)
        self._dimension = dimension.map(AnyString.init)
        self.field = field
        self._row = row.map(AnyInt.init)
        if let v = listens_to_filters { _listens_to_filters = v.map { AnyString.init($0) } } else { _listens_to_filters = nil }
        self.allow_multiple_values = allow_multiple_values
        self.required = required
        self.ui_config = ui_config
    }

    public init(id: String? = nil, _ dashboard_id: String, _ name: String, _ title: String, _ type: String, default_value: String? = nil, model: String? = nil, explore: String? = nil, dimension: String? = nil, field: StringDictionary<AnyCodable>? = nil, row: Int64? = nil, listens_to_filters: [String]? = nil, allow_multiple_values: Bool? = nil, required: Bool? = nil, ui_config: StringDictionary<AnyCodable>? = nil) {
        self.init(id: id, dashboard_id: dashboard_id, name: name, title: title, type: type, default_value: default_value, model: model, explore: explore, dimension: dimension, field: field, row: row, listens_to_filters: listens_to_filters, allow_multiple_values: allow_multiple_values, required: required, ui_config: ui_config)
    }

}

public struct CreateDashboardRenderTask: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _dashboard_filters = "dashboard_filters"
        case _dashboard_style = "dashboard_style"
    }
    private var _dashboard_filters: AnyString?
    /**
     * Filter values to apply to the dashboard queries, in URL query format
     */
    public var dashboard_filters: String? {
        get { _dashboard_filters?.value }
        set { _dashboard_filters = newValue.map(AnyString.init) }
    }

    private var _dashboard_style: AnyString?
    /**
     * Dashboard layout style: single_column or tiled
     */
    public var dashboard_style: String? {
        get { _dashboard_style?.value }
        set { _dashboard_style = newValue.map(AnyString.init) }
    }

    public init(dashboard_filters: String? = nil, dashboard_style: String? = nil) {
        self._dashboard_filters = dashboard_filters.map(AnyString.init)
        self._dashboard_style = dashboard_style.map(AnyString.init)
    }

}

public struct CreateEmbedUserRequest: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _external_user_id = "external_user_id"
    }
    private var _external_user_id: AnyString
    public var external_user_id: String {
        get { _external_user_id.value }
        set { _external_user_id = AnyString.init(newValue) }
    }

    public init(external_user_id: String) {
        self._external_user_id = AnyString.init(external_user_id)
    }

    public init(_ external_user_id: String) {
        self.init(external_user_id: external_user_id)
    }

}

public struct CreateFolder: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _parent_id = "parent_id"
    }
    private var _name: AnyString
    /**
     * Unique Name
     */
    public var name: String {
        get { _name.value }
        set { _name = AnyString.init(newValue) }
    }

    private var _parent_id: AnyString
    /**
     * Id of Parent. If the parent id is null, this is a root-level entry
     */
    public var parent_id: String {
        get { _parent_id.value }
        set { _parent_id = AnyString.init(newValue) }
    }

    public init(name: String, parent_id: String) {
        self._name = AnyString.init(name)
        self._parent_id = AnyString.init(parent_id)
    }

    public init(_ name: String, _ parent_id: String) {
        self.init(name: name, parent_id: parent_id)
    }

}

public struct CreateOAuthApplicationUserStateRequest: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _user_id = "user_id"
        case _oauth_application_id = "oauth_application_id"
        case _access_token = "access_token"
        case access_token_expires_at
        case _refresh_token = "refresh_token"
        case refresh_token_expires_at
    }
    private var _user_id: AnyString
    public var user_id: String {
        get { _user_id.value }
        set { _user_id = AnyString.init(newValue) }
    }

    private var _oauth_application_id: AnyString
    public var oauth_application_id: String {
        get { _oauth_application_id.value }
        set { _oauth_application_id = AnyString.init(newValue) }
    }

    private var _access_token: AnyString
    public var access_token: String {
        get { _access_token.value }
        set { _access_token = AnyString.init(newValue) }
    }

    public var access_token_expires_at: Date

    private var _refresh_token: AnyString?
    public var refresh_token: String? {
        get { _refresh_token?.value }
        set { _refresh_token = newValue.map(AnyString.init) }
    }

    public var refresh_token_expires_at: Date?

    public init(user_id: String, oauth_application_id: String, access_token: String, access_token_expires_at: Date, refresh_token: String? = nil, refresh_token_expires_at: Date? = nil) {
        self._user_id = AnyString.init(user_id)
        self._oauth_application_id = AnyString.init(oauth_application_id)
        self._access_token = AnyString.init(access_token)
        self.access_token_expires_at = access_token_expires_at
        self._refresh_token = refresh_token.map(AnyString.init)
        self.refresh_token_expires_at = refresh_token_expires_at
    }

    public init(_ user_id: String, _ oauth_application_id: String, _ access_token: String, _ access_token_expires_at: Date, refresh_token: String? = nil, refresh_token_expires_at: Date? = nil) {
        self.init(user_id: user_id, oauth_application_id: oauth_application_id, access_token: access_token, access_token_expires_at: access_token_expires_at, refresh_token: refresh_token, refresh_token_expires_at: refresh_token_expires_at)
    }

}

public struct CreateOAuthApplicationUserStateResponse: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _user_id = "user_id"
        case _oauth_application_id = "oauth_application_id"
    }
    private var _user_id: AnyString
    /**
     * User Id (read-only)
     */
    public var user_id: String {
        get { _user_id.value }
        set { _user_id = AnyString.init(newValue) }
    }

    private var _oauth_application_id: AnyString
    /**
     * OAuth Application ID (read-only)
     */
    public var oauth_application_id: String {
        get { _oauth_application_id.value }
        set { _oauth_application_id = AnyString.init(newValue) }
    }

    public init(user_id: String, oauth_application_id: String) {
        self._user_id = AnyString.init(user_id)
        self._oauth_application_id = AnyString.init(oauth_application_id)
    }

    public init(_ user_id: String, _ oauth_application_id: String) {
        self.init(user_id: user_id, oauth_application_id: oauth_application_id)
    }

}

public struct CreateQueryTask: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _query_id = "query_id"
        case result_format
        case _source = "source"
        case deferred
        case _look_id = "look_id"
        case _dashboard_id = "dashboard_id"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _query_id: AnyString
    /**
     * Id of query to run
     */
    public var query_id: String {
        get { _query_id.value }
        set { _query_id = AnyString.init(newValue) }
    }

    /**
     * Desired async query result format. Valid values are: "inline_json", "json", "json_detail", "json_fe", "json_bi", "csv", "html", "md", "txt", "xlsx", "gsxml", "sql", "odc".
     */
    public var result_format: ResultFormat

    private var _source: AnyString?
    /**
     * Source of query task
     */
    public var source: String? {
        get { _source?.value }
        set { _source = newValue.map(AnyString.init) }
    }

    /**
     * Create the task but defer execution
     */
    public var deferred: Bool?

    private var _look_id: AnyString?
    /**
     * Id of look associated with query.
     */
    public var look_id: String? {
        get { _look_id?.value }
        set { _look_id = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString?
    /**
     * Id of dashboard associated with query.
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, query_id: String, result_format: ResultFormat, source: String? = nil, deferred: Bool? = nil, look_id: String? = nil, dashboard_id: String? = nil) {
        self.can = can
        self._query_id = AnyString.init(query_id)
        self.result_format = result_format
        self._source = source.map(AnyString.init)
        self.deferred = deferred
        self._look_id = look_id.map(AnyString.init)
        self._dashboard_id = dashboard_id.map(AnyString.init)
    }

    public init(can: StringDictionary<Bool>? = nil, _ query_id: String, _ result_format: ResultFormat, source: String? = nil, deferred: Bool? = nil, look_id: String? = nil, dashboard_id: String? = nil) {
        self.init(can: can, query_id: query_id, result_format: result_format, source: source, deferred: deferred, look_id: look_id, dashboard_id: dashboard_id)
    }

}

public struct CredentialsApi3: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _client_id = "client_id"
        case _created_at = "created_at"
        case is_disabled
        case _type = "type"
        case _url = "url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _client_id: AnyString?
    /**
     * API key client_id (read-only)
     */
    public var client_id: String? {
        get { _client_id?.value }
        set { _client_id = newValue.map(AnyString.init) }
    }

    private var _created_at: AnyString?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String? {
        get { _created_at?.value }
        set { _created_at = newValue.map(AnyString.init) }
    }

    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?

    private var _type: AnyString?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, client_id: String? = nil, created_at: String? = nil, is_disabled: Bool? = nil, type: String? = nil, url: String? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._client_id = client_id.map(AnyString.init)
        self._created_at = created_at.map(AnyString.init)
        self.is_disabled = is_disabled
        self._type = type.map(AnyString.init)
        self._url = url.map(AnyString.init)
    }

}

public struct CredentialsEmail: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _created_at = "created_at"
        case _email = "email"
        case forced_password_reset_at_next_login
        case _user_id = "user_id"
        case is_disabled
        case _logged_in_at = "logged_in_at"
        case _password_reset_url = "password_reset_url"
        case _account_setup_url = "account_setup_url"
        case password_reset_url_expired
        case account_setup_url_expired
        case _type = "type"
        case _url = "url"
        case _user_url = "user_url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _created_at: AnyString?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String? {
        get { _created_at?.value }
        set { _created_at = newValue.map(AnyString.init) }
    }

    private var _email: AnyString?
    /**
     * EMail address used for user login
     */
    public var email: String? {
        get { _email?.value }
        set { _email = newValue.map(AnyString.init) }
    }

    /**
     * Force the user to change their password upon their next login
     */
    public var forced_password_reset_at_next_login: Bool?

    private var _user_id: AnyString?
    /**
     * Unique Id of the user (read-only)
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?

    private var _logged_in_at: AnyString?
    /**
     * Timestamp for most recent login using credential (read-only)
     */
    public var logged_in_at: String? {
        get { _logged_in_at?.value }
        set { _logged_in_at = newValue.map(AnyString.init) }
    }

    private var _password_reset_url: AnyString?
    /**
     * Url with one-time use secret token that the user can use to reset password (read-only)
     */
    public var password_reset_url: String? {
        get { _password_reset_url?.value }
        set { _password_reset_url = newValue.map(AnyString.init) }
    }

    private var _account_setup_url: AnyString?
    /**
     * Url with one-time use secret token that the user can use to setup account (read-only)
     */
    public var account_setup_url: String? {
        get { _account_setup_url?.value }
        set { _account_setup_url = newValue.map(AnyString.init) }
    }

    /**
     * Is password_reset_url expired or not present? (read-only)
     */
    public var password_reset_url_expired: Bool?

    /**
     * Is account_setup_url expired or not present? (read-only)
     */
    public var account_setup_url_expired: Bool?

    private var _type: AnyString?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    private var _user_url: AnyString?
    /**
     * Link to get this user (read-only)
     */
    public var user_url: String? {
        get { _user_url?.value }
        set { _user_url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, created_at: String? = nil, email: String? = nil, forced_password_reset_at_next_login: Bool? = nil, user_id: String? = nil, is_disabled: Bool? = nil, logged_in_at: String? = nil, password_reset_url: String? = nil, account_setup_url: String? = nil, password_reset_url_expired: Bool? = nil, account_setup_url_expired: Bool? = nil, type: String? = nil, url: String? = nil, user_url: String? = nil) {
        self.can = can
        self._created_at = created_at.map(AnyString.init)
        self._email = email.map(AnyString.init)
        self.forced_password_reset_at_next_login = forced_password_reset_at_next_login
        self._user_id = user_id.map(AnyString.init)
        self.is_disabled = is_disabled
        self._logged_in_at = logged_in_at.map(AnyString.init)
        self._password_reset_url = password_reset_url.map(AnyString.init)
        self._account_setup_url = account_setup_url.map(AnyString.init)
        self.password_reset_url_expired = password_reset_url_expired
        self.account_setup_url_expired = account_setup_url_expired
        self._type = type.map(AnyString.init)
        self._url = url.map(AnyString.init)
        self._user_url = user_url.map(AnyString.init)
    }

}

public struct CredentialsEmailSearch: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _created_at = "created_at"
        case _email = "email"
        case forced_password_reset_at_next_login
        case _user_id = "user_id"
        case is_disabled
        case _logged_in_at = "logged_in_at"
        case _password_reset_url = "password_reset_url"
        case _account_setup_url = "account_setup_url"
        case password_reset_url_expired
        case account_setup_url_expired
        case _type = "type"
        case _url = "url"
        case _user_url = "user_url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _created_at: AnyString?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String? {
        get { _created_at?.value }
        set { _created_at = newValue.map(AnyString.init) }
    }

    private var _email: AnyString?
    /**
     * EMail address used for user login
     */
    public var email: String? {
        get { _email?.value }
        set { _email = newValue.map(AnyString.init) }
    }

    /**
     * Force the user to change their password upon their next login
     */
    public var forced_password_reset_at_next_login: Bool?

    private var _user_id: AnyString?
    /**
     * Unique Id of the user (read-only)
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?

    private var _logged_in_at: AnyString?
    /**
     * Timestamp for most recent login using credential (read-only)
     */
    public var logged_in_at: String? {
        get { _logged_in_at?.value }
        set { _logged_in_at = newValue.map(AnyString.init) }
    }

    private var _password_reset_url: AnyString?
    /**
     * Url with one-time use secret token that the user can use to reset password (read-only)
     */
    public var password_reset_url: String? {
        get { _password_reset_url?.value }
        set { _password_reset_url = newValue.map(AnyString.init) }
    }

    private var _account_setup_url: AnyString?
    /**
     * Url with one-time use secret token that the user can use to setup account (read-only)
     */
    public var account_setup_url: String? {
        get { _account_setup_url?.value }
        set { _account_setup_url = newValue.map(AnyString.init) }
    }

    /**
     * Is password_reset_url expired or not present? (read-only)
     */
    public var password_reset_url_expired: Bool?

    /**
     * Is account_setup_url expired or not present? (read-only)
     */
    public var account_setup_url_expired: Bool?

    private var _type: AnyString?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    private var _user_url: AnyString?
    /**
     * Link to get this user (read-only)
     */
    public var user_url: String? {
        get { _user_url?.value }
        set { _user_url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, created_at: String? = nil, email: String? = nil, forced_password_reset_at_next_login: Bool? = nil, user_id: String? = nil, is_disabled: Bool? = nil, logged_in_at: String? = nil, password_reset_url: String? = nil, account_setup_url: String? = nil, password_reset_url_expired: Bool? = nil, account_setup_url_expired: Bool? = nil, type: String? = nil, url: String? = nil, user_url: String? = nil) {
        self.can = can
        self._created_at = created_at.map(AnyString.init)
        self._email = email.map(AnyString.init)
        self.forced_password_reset_at_next_login = forced_password_reset_at_next_login
        self._user_id = user_id.map(AnyString.init)
        self.is_disabled = is_disabled
        self._logged_in_at = logged_in_at.map(AnyString.init)
        self._password_reset_url = password_reset_url.map(AnyString.init)
        self._account_setup_url = account_setup_url.map(AnyString.init)
        self.password_reset_url_expired = password_reset_url_expired
        self.account_setup_url_expired = account_setup_url_expired
        self._type = type.map(AnyString.init)
        self._url = url.map(AnyString.init)
        self._user_url = user_url.map(AnyString.init)
    }

}

public struct CredentialsEmbed: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _created_at = "created_at"
        case _external_group_id = "external_group_id"
        case _external_user_id = "external_user_id"
        case _id = "id"
        case is_disabled
        case _logged_in_at = "logged_in_at"
        case _type = "type"
        case _url = "url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _created_at: AnyString?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String? {
        get { _created_at?.value }
        set { _created_at = newValue.map(AnyString.init) }
    }

    private var _external_group_id: AnyString?
    /**
     * Embedder's id for a group to which this user was added during the most recent login (read-only)
     */
    public var external_group_id: String? {
        get { _external_group_id?.value }
        set { _external_group_id = newValue.map(AnyString.init) }
    }

    private var _external_user_id: AnyString?
    /**
     * Embedder's unique id for the user (read-only)
     */
    public var external_user_id: String? {
        get { _external_user_id?.value }
        set { _external_user_id = newValue.map(AnyString.init) }
    }

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?

    private var _logged_in_at: AnyString?
    /**
     * Timestamp for most recent login using credential (read-only)
     */
    public var logged_in_at: String? {
        get { _logged_in_at?.value }
        set { _logged_in_at = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, created_at: String? = nil, external_group_id: String? = nil, external_user_id: String? = nil, id: String? = nil, is_disabled: Bool? = nil, logged_in_at: String? = nil, type: String? = nil, url: String? = nil) {
        self.can = can
        self._created_at = created_at.map(AnyString.init)
        self._external_group_id = external_group_id.map(AnyString.init)
        self._external_user_id = external_user_id.map(AnyString.init)
        self._id = id.map(AnyString.init)
        self.is_disabled = is_disabled
        self._logged_in_at = logged_in_at.map(AnyString.init)
        self._type = type.map(AnyString.init)
        self._url = url.map(AnyString.init)
    }

}

public struct CredentialsGoogle: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _created_at = "created_at"
        case _domain = "domain"
        case _email = "email"
        case _google_user_id = "google_user_id"
        case is_disabled
        case _logged_in_at = "logged_in_at"
        case _type = "type"
        case _url = "url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _created_at: AnyString?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String? {
        get { _created_at?.value }
        set { _created_at = newValue.map(AnyString.init) }
    }

    private var _domain: AnyString?
    /**
     * Google domain (read-only)
     */
    public var domain: String? {
        get { _domain?.value }
        set { _domain = newValue.map(AnyString.init) }
    }

    private var _email: AnyString?
    /**
     * EMail address (read-only)
     */
    public var email: String? {
        get { _email?.value }
        set { _email = newValue.map(AnyString.init) }
    }

    private var _google_user_id: AnyString?
    /**
     * Google's Unique ID for this user (read-only)
     */
    public var google_user_id: String? {
        get { _google_user_id?.value }
        set { _google_user_id = newValue.map(AnyString.init) }
    }

    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?

    private var _logged_in_at: AnyString?
    /**
     * Timestamp for most recent login using credential (read-only)
     */
    public var logged_in_at: String? {
        get { _logged_in_at?.value }
        set { _logged_in_at = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, created_at: String? = nil, domain: String? = nil, email: String? = nil, google_user_id: String? = nil, is_disabled: Bool? = nil, logged_in_at: String? = nil, type: String? = nil, url: String? = nil) {
        self.can = can
        self._created_at = created_at.map(AnyString.init)
        self._domain = domain.map(AnyString.init)
        self._email = email.map(AnyString.init)
        self._google_user_id = google_user_id.map(AnyString.init)
        self.is_disabled = is_disabled
        self._logged_in_at = logged_in_at.map(AnyString.init)
        self._type = type.map(AnyString.init)
        self._url = url.map(AnyString.init)
    }

}

public struct CredentialsLDAP: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _created_at = "created_at"
        case _email = "email"
        case is_disabled
        case _ldap_dn = "ldap_dn"
        case _ldap_id = "ldap_id"
        case _logged_in_at = "logged_in_at"
        case _type = "type"
        case _url = "url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _created_at: AnyString?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String? {
        get { _created_at?.value }
        set { _created_at = newValue.map(AnyString.init) }
    }

    private var _email: AnyString?
    /**
     * EMail address (read-only)
     */
    public var email: String? {
        get { _email?.value }
        set { _email = newValue.map(AnyString.init) }
    }

    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?

    private var _ldap_dn: AnyString?
    /**
     * LDAP Distinguished name for this user (as-of the last login) (read-only)
     */
    public var ldap_dn: String? {
        get { _ldap_dn?.value }
        set { _ldap_dn = newValue.map(AnyString.init) }
    }

    private var _ldap_id: AnyString?
    /**
     * LDAP Unique ID for this user (read-only)
     */
    public var ldap_id: String? {
        get { _ldap_id?.value }
        set { _ldap_id = newValue.map(AnyString.init) }
    }

    private var _logged_in_at: AnyString?
    /**
     * Timestamp for most recent login using credential (read-only)
     */
    public var logged_in_at: String? {
        get { _logged_in_at?.value }
        set { _logged_in_at = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, created_at: String? = nil, email: String? = nil, is_disabled: Bool? = nil, ldap_dn: String? = nil, ldap_id: String? = nil, logged_in_at: String? = nil, type: String? = nil, url: String? = nil) {
        self.can = can
        self._created_at = created_at.map(AnyString.init)
        self._email = email.map(AnyString.init)
        self.is_disabled = is_disabled
        self._ldap_dn = ldap_dn.map(AnyString.init)
        self._ldap_id = ldap_id.map(AnyString.init)
        self._logged_in_at = logged_in_at.map(AnyString.init)
        self._type = type.map(AnyString.init)
        self._url = url.map(AnyString.init)
    }

}

public struct CredentialsLookerOpenid: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _created_at = "created_at"
        case _email = "email"
        case is_disabled
        case _logged_in_at = "logged_in_at"
        case _logged_in_ip = "logged_in_ip"
        case _type = "type"
        case _url = "url"
        case _user_url = "user_url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _created_at: AnyString?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String? {
        get { _created_at?.value }
        set { _created_at = newValue.map(AnyString.init) }
    }

    private var _email: AnyString?
    /**
     * EMail address used for user login (read-only)
     */
    public var email: String? {
        get { _email?.value }
        set { _email = newValue.map(AnyString.init) }
    }

    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?

    private var _logged_in_at: AnyString?
    /**
     * Timestamp for most recent login using credential (read-only)
     */
    public var logged_in_at: String? {
        get { _logged_in_at?.value }
        set { _logged_in_at = newValue.map(AnyString.init) }
    }

    private var _logged_in_ip: AnyString?
    /**
     * IP address of client for most recent login using credential (read-only)
     */
    public var logged_in_ip: String? {
        get { _logged_in_ip?.value }
        set { _logged_in_ip = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    private var _user_url: AnyString?
    /**
     * Link to get this user (read-only)
     */
    public var user_url: String? {
        get { _user_url?.value }
        set { _user_url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, created_at: String? = nil, email: String? = nil, is_disabled: Bool? = nil, logged_in_at: String? = nil, logged_in_ip: String? = nil, type: String? = nil, url: String? = nil, user_url: String? = nil) {
        self.can = can
        self._created_at = created_at.map(AnyString.init)
        self._email = email.map(AnyString.init)
        self.is_disabled = is_disabled
        self._logged_in_at = logged_in_at.map(AnyString.init)
        self._logged_in_ip = logged_in_ip.map(AnyString.init)
        self._type = type.map(AnyString.init)
        self._url = url.map(AnyString.init)
        self._user_url = user_url.map(AnyString.init)
    }

}

public struct CredentialsOIDC: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _created_at = "created_at"
        case _email = "email"
        case is_disabled
        case _logged_in_at = "logged_in_at"
        case _oidc_user_id = "oidc_user_id"
        case _type = "type"
        case _url = "url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _created_at: AnyString?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String? {
        get { _created_at?.value }
        set { _created_at = newValue.map(AnyString.init) }
    }

    private var _email: AnyString?
    /**
     * EMail address (read-only)
     */
    public var email: String? {
        get { _email?.value }
        set { _email = newValue.map(AnyString.init) }
    }

    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?

    private var _logged_in_at: AnyString?
    /**
     * Timestamp for most recent login using credential (read-only)
     */
    public var logged_in_at: String? {
        get { _logged_in_at?.value }
        set { _logged_in_at = newValue.map(AnyString.init) }
    }

    private var _oidc_user_id: AnyString?
    /**
     * OIDC OP's Unique ID for this user (read-only)
     */
    public var oidc_user_id: String? {
        get { _oidc_user_id?.value }
        set { _oidc_user_id = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, created_at: String? = nil, email: String? = nil, is_disabled: Bool? = nil, logged_in_at: String? = nil, oidc_user_id: String? = nil, type: String? = nil, url: String? = nil) {
        self.can = can
        self._created_at = created_at.map(AnyString.init)
        self._email = email.map(AnyString.init)
        self.is_disabled = is_disabled
        self._logged_in_at = logged_in_at.map(AnyString.init)
        self._oidc_user_id = oidc_user_id.map(AnyString.init)
        self._type = type.map(AnyString.init)
        self._url = url.map(AnyString.init)
    }

}

public struct CredentialsSaml: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _created_at = "created_at"
        case _email = "email"
        case is_disabled
        case _logged_in_at = "logged_in_at"
        case _saml_user_id = "saml_user_id"
        case _type = "type"
        case _url = "url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _created_at: AnyString?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String? {
        get { _created_at?.value }
        set { _created_at = newValue.map(AnyString.init) }
    }

    private var _email: AnyString?
    /**
     * EMail address (read-only)
     */
    public var email: String? {
        get { _email?.value }
        set { _email = newValue.map(AnyString.init) }
    }

    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?

    private var _logged_in_at: AnyString?
    /**
     * Timestamp for most recent login using credential (read-only)
     */
    public var logged_in_at: String? {
        get { _logged_in_at?.value }
        set { _logged_in_at = newValue.map(AnyString.init) }
    }

    private var _saml_user_id: AnyString?
    /**
     * Saml IdP's Unique ID for this user (read-only)
     */
    public var saml_user_id: String? {
        get { _saml_user_id?.value }
        set { _saml_user_id = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, created_at: String? = nil, email: String? = nil, is_disabled: Bool? = nil, logged_in_at: String? = nil, saml_user_id: String? = nil, type: String? = nil, url: String? = nil) {
        self.can = can
        self._created_at = created_at.map(AnyString.init)
        self._email = email.map(AnyString.init)
        self.is_disabled = is_disabled
        self._logged_in_at = logged_in_at.map(AnyString.init)
        self._saml_user_id = saml_user_id.map(AnyString.init)
        self._type = type.map(AnyString.init)
        self._url = url.map(AnyString.init)
    }

}

/**
 * WARNING: no writeable properties found for POST, PUT, or PATCH
 */
public struct CredentialsTotp: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _created_at = "created_at"
        case is_disabled
        case _type = "type"
        case verified
        case _url = "url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _created_at: AnyString?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String? {
        get { _created_at?.value }
        set { _created_at = newValue.map(AnyString.init) }
    }

    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?

    private var _type: AnyString?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    /**
     * User has verified (read-only)
     */
    public var verified: Bool?

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, created_at: String? = nil, is_disabled: Bool? = nil, type: String? = nil, verified: Bool? = nil, url: String? = nil) {
        self.can = can
        self._created_at = created_at.map(AnyString.init)
        self.is_disabled = is_disabled
        self._type = type.map(AnyString.init)
        self.verified = verified
        self._url = url.map(AnyString.init)
    }

}

public struct CustomWelcomeEmail: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case enabled
        case _content = "content"
        case _subject = "subject"
        case _header = "header"
    }
    /**
     * If true, custom email content will replace the default body of welcome emails
     */
    public var enabled: Bool?

    private var _content: AnyString?
    /**
     * The HTML to use as custom content for welcome emails. Script elements and other potentially dangerous markup will be removed.
     */
    public var content: String? {
        get { _content?.value }
        set { _content = newValue.map(AnyString.init) }
    }

    private var _subject: AnyString?
    /**
     * The text to appear in the email subject line. Only available with a whitelabel license and whitelabel_configuration.advanced_custom_welcome_email enabled.
     */
    public var subject: String? {
        get { _subject?.value }
        set { _subject = newValue.map(AnyString.init) }
    }

    private var _header: AnyString?
    /**
     * The text to appear in the header line of the email body. Only available with a whitelabel license and whitelabel_configuration.advanced_custom_welcome_email enabled.
     */
    public var header: String? {
        get { _header?.value }
        set { _header = newValue.map(AnyString.init) }
    }

    public init(enabled: Bool? = nil, content: String? = nil, subject: String? = nil, header: String? = nil) {
        self.enabled = enabled
        self._content = content.map(AnyString.init)
        self._subject = subject.map(AnyString.init)
        self._header = header.map(AnyString.init)
    }

}

public struct Dashboard: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _content_favorite_id = "content_favorite_id"
        case _content_metadata_id = "content_metadata_id"
        case _description = "description"
        case hidden
        case _id = "id"
        case model
        case _query_timezone = "query_timezone"
        case readonly
        case _refresh_interval = "refresh_interval"
        case _refresh_interval_to_i = "refresh_interval_to_i"
        case folder
        case _title = "title"
        case _user_id = "user_id"
        case _slug = "slug"
        case _preferred_viewer = "preferred_viewer"
        case alert_sync_with_dashboard_filter_enabled
        case _background_color = "background_color"
        case created_at
        case crossfilter_enabled
        case dashboard_elements
        case dashboard_filters
        case dashboard_layouts
        case deleted
        case deleted_at
        case _deleter_id = "deleter_id"
        case _edit_uri = "edit_uri"
        case enable_viz_full_screen
        case _favorite_count = "favorite_count"
        case filters_bar_collapsed
        case filters_location_top
        case last_accessed_at
        case last_viewed_at
        case updated_at
        case _last_updater_id = "last_updater_id"
        case _last_updater_name = "last_updater_name"
        case _user_name = "user_name"
        case _load_configuration = "load_configuration"
        case _lookml_link_id = "lookml_link_id"
        case show_filters_bar
        case show_title
        case _folder_id = "folder_id"
        case _text_tile_text_color = "text_tile_text_color"
        case _tile_background_color = "tile_background_color"
        case _tile_text_color = "tile_text_color"
        case _title_color = "title_color"
        case _view_count = "view_count"
        case appearance
        case _url = "url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _content_favorite_id: AnyString?
    /**
     * Content Favorite Id (read-only)
     */
    public var content_favorite_id: String? {
        get { _content_favorite_id?.value }
        set { _content_favorite_id = newValue.map(AnyString.init) }
    }

    private var _content_metadata_id: AnyString?
    /**
     * Id of content metadata (read-only)
     */
    public var content_metadata_id: String? {
        get { _content_metadata_id?.value }
        set { _content_metadata_id = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * Description
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    /**
     * Is Hidden
     */
    public var hidden: Bool?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    public var model: LookModel?

    private var _query_timezone: AnyString?
    /**
     * Timezone in which the Dashboard will run by default.
     */
    public var query_timezone: String? {
        get { _query_timezone?.value }
        set { _query_timezone = newValue.map(AnyString.init) }
    }

    /**
     * Is Read-only (read-only)
     */
    public var readonly: Bool?

    private var _refresh_interval: AnyString?
    /**
     * Refresh Interval, as a time duration phrase like "2 hours 30 minutes". A number with no time units will be interpreted as whole seconds.
     */
    public var refresh_interval: String? {
        get { _refresh_interval?.value }
        set { _refresh_interval = newValue.map(AnyString.init) }
    }

    private var _refresh_interval_to_i: AnyInt?
    /**
     * Refresh Interval in milliseconds (read-only)
     */
    public var refresh_interval_to_i: Int64? {
        get { _refresh_interval_to_i?.value }
        set { _refresh_interval_to_i = newValue.map(AnyInt.init) }
    }

    public var folder: FolderBase?

    private var _title: AnyString?
    /**
     * Dashboard Title
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _user_id: AnyString?
    /**
     * Id of User (read-only)
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    private var _slug: AnyString?
    /**
     * Content Metadata Slug
     */
    public var slug: String? {
        get { _slug?.value }
        set { _slug = newValue.map(AnyString.init) }
    }

    private var _preferred_viewer: AnyString?
    /**
     * The preferred route for viewing this dashboard (ie: dashboards or dashboards-next)
     */
    public var preferred_viewer: String? {
        get { _preferred_viewer?.value }
        set { _preferred_viewer = newValue.map(AnyString.init) }
    }

    /**
     * Enables alerts to keep in sync with dashboard filter changes
     */
    public var alert_sync_with_dashboard_filter_enabled: Bool?

    private var _background_color: AnyString?
    /**
     * Background color
     */
    public var background_color: String? {
        get { _background_color?.value }
        set { _background_color = newValue.map(AnyString.init) }
    }

    /**
     * Time that the Dashboard was created. (read-only)
     */
    public var created_at: Date?

    /**
     * Enables crossfiltering in dashboards - only available in dashboards-next (beta)
     */
    public var crossfilter_enabled: Bool?

    /**
     * Elements (read-only)
     */
    public var dashboard_elements: [DashboardElement]?

    /**
     * Filters (read-only)
     */
    public var dashboard_filters: [DashboardFilter]?

    /**
     * Layouts (read-only)
     */
    public var dashboard_layouts: [DashboardLayout]?

    /**
     * Whether or not a dashboard is 'soft' deleted.
     */
    public var deleted: Bool?

    /**
     * Time that the Dashboard was 'soft' deleted. (read-only)
     */
    public var deleted_at: Date?

    private var _deleter_id: AnyString?
    /**
     * Id of User that 'soft' deleted the dashboard. (read-only)
     */
    public var deleter_id: String? {
        get { _deleter_id?.value }
        set { _deleter_id = newValue.map(AnyString.init) }
    }

    private var _edit_uri: AnyString?
    /**
     * Relative path of URI of LookML file to edit the dashboard (LookML dashboard only). (read-only)
     */
    public var edit_uri: String? {
        get { _edit_uri?.value }
        set { _edit_uri = newValue.map(AnyString.init) }
    }

    /**
     * Allow visualizations to be viewed in full screen mode
     */
    public var enable_viz_full_screen: Bool?

    private var _favorite_count: AnyInt?
    /**
     * Number of times favorited (read-only)
     */
    public var favorite_count: Int64? {
        get { _favorite_count?.value }
        set { _favorite_count = newValue.map(AnyInt.init) }
    }

    /**
     * Sets the default state of the filters bar to collapsed or open
     */
    public var filters_bar_collapsed: Bool?

    /**
     * Sets the default state of the filters location to top(true) or right(false)
     */
    public var filters_location_top: Bool?

    /**
     * Time the dashboard was last accessed (read-only)
     */
    public var last_accessed_at: Date?

    /**
     * Time last viewed in the Looker web UI (read-only)
     */
    public var last_viewed_at: Date?

    /**
     * Time that the Dashboard was most recently updated. (read-only)
     */
    public var updated_at: Date?

    private var _last_updater_id: AnyString?
    /**
     * Id of User that most recently updated the dashboard. (read-only)
     */
    public var last_updater_id: String? {
        get { _last_updater_id?.value }
        set { _last_updater_id = newValue.map(AnyString.init) }
    }

    private var _last_updater_name: AnyString?
    /**
     * Name of User that most recently updated the dashboard. (read-only)
     */
    public var last_updater_name: String? {
        get { _last_updater_name?.value }
        set { _last_updater_name = newValue.map(AnyString.init) }
    }

    private var _user_name: AnyString?
    /**
     * Name of User that created the dashboard. (read-only)
     */
    public var user_name: String? {
        get { _user_name?.value }
        set { _user_name = newValue.map(AnyString.init) }
    }

    private var _load_configuration: AnyString?
    /**
     * configuration option that governs how dashboard loading will happen.
     */
    public var load_configuration: String? {
        get { _load_configuration?.value }
        set { _load_configuration = newValue.map(AnyString.init) }
    }

    private var _lookml_link_id: AnyString?
    /**
     * Links this dashboard to a particular LookML dashboard such that calling a **sync** operation on that LookML dashboard will update this dashboard to match.
     */
    public var lookml_link_id: String? {
        get { _lookml_link_id?.value }
        set { _lookml_link_id = newValue.map(AnyString.init) }
    }

    /**
     * Show filters bar.  **Security Note:** This property only affects the *cosmetic* appearance of the dashboard, not a user's ability to access data. Hiding the filters bar does **NOT** prevent users from changing filters by other means. For information on how to set up secure data access control policies, see [Control User Access to Data](https://cloud.google.com/looker/docs/r/api/control-access)
     */
    public var show_filters_bar: Bool?

    /**
     * Show title
     */
    public var show_title: Bool?

    private var _folder_id: AnyString?
    /**
     * Id of folder
     */
    public var folder_id: String? {
        get { _folder_id?.value }
        set { _folder_id = newValue.map(AnyString.init) }
    }

    private var _text_tile_text_color: AnyString?
    /**
     * Color of text on text tiles
     */
    public var text_tile_text_color: String? {
        get { _text_tile_text_color?.value }
        set { _text_tile_text_color = newValue.map(AnyString.init) }
    }

    private var _tile_background_color: AnyString?
    /**
     * Tile background color
     */
    public var tile_background_color: String? {
        get { _tile_background_color?.value }
        set { _tile_background_color = newValue.map(AnyString.init) }
    }

    private var _tile_text_color: AnyString?
    /**
     * Tile text color
     */
    public var tile_text_color: String? {
        get { _tile_text_color?.value }
        set { _tile_text_color = newValue.map(AnyString.init) }
    }

    private var _title_color: AnyString?
    /**
     * Title color
     */
    public var title_color: String? {
        get { _title_color?.value }
        set { _title_color = newValue.map(AnyString.init) }
    }

    private var _view_count: AnyInt?
    /**
     * Number of times viewed in the Looker web UI (read-only)
     */
    public var view_count: Int64? {
        get { _view_count?.value }
        set { _view_count = newValue.map(AnyInt.init) }
    }

    public var appearance: DashboardAppearance?

    private var _url: AnyString?
    /**
     * Relative URL of the dashboard (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, content_favorite_id: String? = nil, content_metadata_id: String? = nil, description: String? = nil, hidden: Bool? = nil, id: String? = nil, model: LookModel? = nil, query_timezone: String? = nil, readonly: Bool? = nil, refresh_interval: String? = nil, refresh_interval_to_i: Int64? = nil, folder: FolderBase? = nil, title: String? = nil, user_id: String? = nil, slug: String? = nil, preferred_viewer: String? = nil, alert_sync_with_dashboard_filter_enabled: Bool? = nil, background_color: String? = nil, created_at: Date? = nil, crossfilter_enabled: Bool? = nil, dashboard_elements: [DashboardElement]? = nil, dashboard_filters: [DashboardFilter]? = nil, dashboard_layouts: [DashboardLayout]? = nil, deleted: Bool? = nil, deleted_at: Date? = nil, deleter_id: String? = nil, edit_uri: String? = nil, enable_viz_full_screen: Bool? = nil, favorite_count: Int64? = nil, filters_bar_collapsed: Bool? = nil, filters_location_top: Bool? = nil, last_accessed_at: Date? = nil, last_viewed_at: Date? = nil, updated_at: Date? = nil, last_updater_id: String? = nil, last_updater_name: String? = nil, user_name: String? = nil, load_configuration: String? = nil, lookml_link_id: String? = nil, show_filters_bar: Bool? = nil, show_title: Bool? = nil, folder_id: String? = nil, text_tile_text_color: String? = nil, tile_background_color: String? = nil, tile_text_color: String? = nil, title_color: String? = nil, view_count: Int64? = nil, appearance: DashboardAppearance? = nil, url: String? = nil) {
        self.can = can
        self._content_favorite_id = content_favorite_id.map(AnyString.init)
        self._content_metadata_id = content_metadata_id.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self.hidden = hidden
        self._id = id.map(AnyString.init)
        self.model = model
        self._query_timezone = query_timezone.map(AnyString.init)
        self.readonly = readonly
        self._refresh_interval = refresh_interval.map(AnyString.init)
        self._refresh_interval_to_i = refresh_interval_to_i.map(AnyInt.init)
        self.folder = folder
        self._title = title.map(AnyString.init)
        self._user_id = user_id.map(AnyString.init)
        self._slug = slug.map(AnyString.init)
        self._preferred_viewer = preferred_viewer.map(AnyString.init)
        self.alert_sync_with_dashboard_filter_enabled = alert_sync_with_dashboard_filter_enabled
        self._background_color = background_color.map(AnyString.init)
        self.created_at = created_at
        self.crossfilter_enabled = crossfilter_enabled
        self.dashboard_elements = dashboard_elements
        self.dashboard_filters = dashboard_filters
        self.dashboard_layouts = dashboard_layouts
        self.deleted = deleted
        self.deleted_at = deleted_at
        self._deleter_id = deleter_id.map(AnyString.init)
        self._edit_uri = edit_uri.map(AnyString.init)
        self.enable_viz_full_screen = enable_viz_full_screen
        self._favorite_count = favorite_count.map(AnyInt.init)
        self.filters_bar_collapsed = filters_bar_collapsed
        self.filters_location_top = filters_location_top
        self.last_accessed_at = last_accessed_at
        self.last_viewed_at = last_viewed_at
        self.updated_at = updated_at
        self._last_updater_id = last_updater_id.map(AnyString.init)
        self._last_updater_name = last_updater_name.map(AnyString.init)
        self._user_name = user_name.map(AnyString.init)
        self._load_configuration = load_configuration.map(AnyString.init)
        self._lookml_link_id = lookml_link_id.map(AnyString.init)
        self.show_filters_bar = show_filters_bar
        self.show_title = show_title
        self._folder_id = folder_id.map(AnyString.init)
        self._text_tile_text_color = text_tile_text_color.map(AnyString.init)
        self._tile_background_color = tile_background_color.map(AnyString.init)
        self._tile_text_color = tile_text_color.map(AnyString.init)
        self._title_color = title_color.map(AnyString.init)
        self._view_count = view_count.map(AnyInt.init)
        self.appearance = appearance
        self._url = url.map(AnyString.init)
    }

}

public struct DashboardAggregateTableLookml: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _dashboard_id = "dashboard_id"
        case _aggregate_table_lookml = "aggregate_table_lookml"
    }
    private var _dashboard_id: AnyString?
    /**
     * Dashboard Id (read-only)
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    private var _aggregate_table_lookml: AnyString?
    /**
     * Aggregate Table LookML (read-only)
     */
    public var aggregate_table_lookml: String? {
        get { _aggregate_table_lookml?.value }
        set { _aggregate_table_lookml = newValue.map(AnyString.init) }
    }

    public init(dashboard_id: String? = nil, aggregate_table_lookml: String? = nil) {
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self._aggregate_table_lookml = aggregate_table_lookml.map(AnyString.init)
    }

}

public struct DashboardAppearance: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _page_side_margins = "page_side_margins"
        case _page_background_color = "page_background_color"
        case _tile_title_alignment = "tile_title_alignment"
        case _tile_space_between = "tile_space_between"
        case _tile_background_color = "tile_background_color"
        case tile_shadow
        case _key_color = "key_color"
    }
    private var _page_side_margins: AnyInt?
    /**
     * Page margin (side) width
     */
    public var page_side_margins: Int64? {
        get { _page_side_margins?.value }
        set { _page_side_margins = newValue.map(AnyInt.init) }
    }

    private var _page_background_color: AnyString?
    /**
     * Background color for the dashboard
     */
    public var page_background_color: String? {
        get { _page_background_color?.value }
        set { _page_background_color = newValue.map(AnyString.init) }
    }

    private var _tile_title_alignment: AnyString?
    /**
     * Title alignment on dashboard tiles
     */
    public var tile_title_alignment: String? {
        get { _tile_title_alignment?.value }
        set { _tile_title_alignment = newValue.map(AnyString.init) }
    }

    private var _tile_space_between: AnyInt?
    /**
     * Space between tiles
     */
    public var tile_space_between: Int64? {
        get { _tile_space_between?.value }
        set { _tile_space_between = newValue.map(AnyInt.init) }
    }

    private var _tile_background_color: AnyString?
    /**
     * Background color for tiles
     */
    public var tile_background_color: String? {
        get { _tile_background_color?.value }
        set { _tile_background_color = newValue.map(AnyString.init) }
    }

    /**
     * Tile shadow on/off
     */
    public var tile_shadow: Bool?

    private var _key_color: AnyString?
    /**
     * Key color
     */
    public var key_color: String? {
        get { _key_color?.value }
        set { _key_color = newValue.map(AnyString.init) }
    }

    public init(page_side_margins: Int64? = nil, page_background_color: String? = nil, tile_title_alignment: String? = nil, tile_space_between: Int64? = nil, tile_background_color: String? = nil, tile_shadow: Bool? = nil, key_color: String? = nil) {
        self._page_side_margins = page_side_margins.map(AnyInt.init)
        self._page_background_color = page_background_color.map(AnyString.init)
        self._tile_title_alignment = tile_title_alignment.map(AnyString.init)
        self._tile_space_between = tile_space_between.map(AnyInt.init)
        self._tile_background_color = tile_background_color.map(AnyString.init)
        self.tile_shadow = tile_shadow
        self._key_color = key_color.map(AnyString.init)
    }

}

public struct DashboardBase: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _content_favorite_id = "content_favorite_id"
        case _content_metadata_id = "content_metadata_id"
        case _description = "description"
        case hidden
        case _id = "id"
        case model
        case _query_timezone = "query_timezone"
        case readonly
        case _refresh_interval = "refresh_interval"
        case _refresh_interval_to_i = "refresh_interval_to_i"
        case folder
        case _title = "title"
        case _user_id = "user_id"
        case _slug = "slug"
        case _preferred_viewer = "preferred_viewer"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _content_favorite_id: AnyString?
    /**
     * Content Favorite Id (read-only)
     */
    public var content_favorite_id: String? {
        get { _content_favorite_id?.value }
        set { _content_favorite_id = newValue.map(AnyString.init) }
    }

    private var _content_metadata_id: AnyString?
    /**
     * Id of content metadata (read-only)
     */
    public var content_metadata_id: String? {
        get { _content_metadata_id?.value }
        set { _content_metadata_id = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * Description (read-only)
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    /**
     * Is Hidden (read-only)
     */
    public var hidden: Bool?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    public var model: LookModel?

    private var _query_timezone: AnyString?
    /**
     * Timezone in which the Dashboard will run by default. (read-only)
     */
    public var query_timezone: String? {
        get { _query_timezone?.value }
        set { _query_timezone = newValue.map(AnyString.init) }
    }

    /**
     * Is Read-only (read-only)
     */
    public var readonly: Bool?

    private var _refresh_interval: AnyString?
    /**
     * Refresh Interval, as a time duration phrase like "2 hours 30 minutes". A number with no time units will be interpreted as whole seconds. (read-only)
     */
    public var refresh_interval: String? {
        get { _refresh_interval?.value }
        set { _refresh_interval = newValue.map(AnyString.init) }
    }

    private var _refresh_interval_to_i: AnyInt?
    /**
     * Refresh Interval in milliseconds (read-only)
     */
    public var refresh_interval_to_i: Int64? {
        get { _refresh_interval_to_i?.value }
        set { _refresh_interval_to_i = newValue.map(AnyInt.init) }
    }

    public var folder: FolderBase?

    private var _title: AnyString?
    /**
     * Dashboard Title (read-only)
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _user_id: AnyString?
    /**
     * Id of User (read-only)
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    private var _slug: AnyString?
    /**
     * Content Metadata Slug (read-only)
     */
    public var slug: String? {
        get { _slug?.value }
        set { _slug = newValue.map(AnyString.init) }
    }

    private var _preferred_viewer: AnyString?
    /**
     * The preferred route for viewing this dashboard (ie: dashboards or dashboards-next) (read-only)
     */
    public var preferred_viewer: String? {
        get { _preferred_viewer?.value }
        set { _preferred_viewer = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, content_favorite_id: String? = nil, content_metadata_id: String? = nil, description: String? = nil, hidden: Bool? = nil, id: String? = nil, model: LookModel? = nil, query_timezone: String? = nil, readonly: Bool? = nil, refresh_interval: String? = nil, refresh_interval_to_i: Int64? = nil, folder: FolderBase? = nil, title: String? = nil, user_id: String? = nil, slug: String? = nil, preferred_viewer: String? = nil) {
        self.can = can
        self._content_favorite_id = content_favorite_id.map(AnyString.init)
        self._content_metadata_id = content_metadata_id.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self.hidden = hidden
        self._id = id.map(AnyString.init)
        self.model = model
        self._query_timezone = query_timezone.map(AnyString.init)
        self.readonly = readonly
        self._refresh_interval = refresh_interval.map(AnyString.init)
        self._refresh_interval_to_i = refresh_interval_to_i.map(AnyInt.init)
        self.folder = folder
        self._title = title.map(AnyString.init)
        self._user_id = user_id.map(AnyString.init)
        self._slug = slug.map(AnyString.init)
        self._preferred_viewer = preferred_viewer.map(AnyString.init)
    }

}

public struct DashboardElement: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _body_text = "body_text"
        case _body_text_as_html = "body_text_as_html"
        case _dashboard_id = "dashboard_id"
        case _edit_uri = "edit_uri"
        case _id = "id"
        case look
        case _look_id = "look_id"
        case _lookml_link_id = "lookml_link_id"
        case _merge_result_id = "merge_result_id"
        case _note_display = "note_display"
        case _note_state = "note_state"
        case _note_text = "note_text"
        case _note_text_as_html = "note_text_as_html"
        case query
        case _query_id = "query_id"
        case _refresh_interval = "refresh_interval"
        case _refresh_interval_to_i = "refresh_interval_to_i"
        case result_maker
        case _result_maker_id = "result_maker_id"
        case _subtitle_text = "subtitle_text"
        case _title = "title"
        case title_hidden
        case _title_text = "title_text"
        case _type = "type"
        case _alert_count = "alert_count"
        case _rich_content_json = "rich_content_json"
        case _title_text_as_html = "title_text_as_html"
        case _subtitle_text_as_html = "subtitle_text_as_html"
        case _extension_id = "extension_id"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _body_text: AnyString?
    /**
     * Text tile body text
     */
    public var body_text: String? {
        get { _body_text?.value }
        set { _body_text = newValue.map(AnyString.init) }
    }

    private var _body_text_as_html: AnyString?
    /**
     * Text tile body text as Html (read-only)
     */
    public var body_text_as_html: String? {
        get { _body_text_as_html?.value }
        set { _body_text_as_html = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString?
    /**
     * Id of Dashboard
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    private var _edit_uri: AnyString?
    /**
     * Relative path of URI of LookML file to edit the dashboard element (LookML dashboard only). (read-only)
     */
    public var edit_uri: String? {
        get { _edit_uri?.value }
        set { _edit_uri = newValue.map(AnyString.init) }
    }

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    public var look: LookWithQuery?

    private var _look_id: AnyString?
    /**
     * Id Of Look
     */
    public var look_id: String? {
        get { _look_id?.value }
        set { _look_id = newValue.map(AnyString.init) }
    }

    private var _lookml_link_id: AnyString?
    /**
     * LookML link ID (read-only)
     */
    public var lookml_link_id: String? {
        get { _lookml_link_id?.value }
        set { _lookml_link_id = newValue.map(AnyString.init) }
    }

    private var _merge_result_id: AnyString?
    /**
     * ID of merge result
     */
    public var merge_result_id: String? {
        get { _merge_result_id?.value }
        set { _merge_result_id = newValue.map(AnyString.init) }
    }

    private var _note_display: AnyString?
    /**
     * Note Display
     */
    public var note_display: String? {
        get { _note_display?.value }
        set { _note_display = newValue.map(AnyString.init) }
    }

    private var _note_state: AnyString?
    /**
     * Note State
     */
    public var note_state: String? {
        get { _note_state?.value }
        set { _note_state = newValue.map(AnyString.init) }
    }

    private var _note_text: AnyString?
    /**
     * Note Text
     */
    public var note_text: String? {
        get { _note_text?.value }
        set { _note_text = newValue.map(AnyString.init) }
    }

    private var _note_text_as_html: AnyString?
    /**
     * Note Text as Html (read-only)
     */
    public var note_text_as_html: String? {
        get { _note_text_as_html?.value }
        set { _note_text_as_html = newValue.map(AnyString.init) }
    }

    public var query: Query?

    private var _query_id: AnyString?
    /**
     * Id Of Query
     */
    public var query_id: String? {
        get { _query_id?.value }
        set { _query_id = newValue.map(AnyString.init) }
    }

    private var _refresh_interval: AnyString?
    /**
     * Refresh Interval
     */
    public var refresh_interval: String? {
        get { _refresh_interval?.value }
        set { _refresh_interval = newValue.map(AnyString.init) }
    }

    private var _refresh_interval_to_i: AnyInt?
    /**
     * Refresh Interval as integer (read-only)
     */
    public var refresh_interval_to_i: Int64? {
        get { _refresh_interval_to_i?.value }
        set { _refresh_interval_to_i = newValue.map(AnyInt.init) }
    }

    public var result_maker: ResultMakerWithIdVisConfigAndDynamicFields?

    private var _result_maker_id: AnyString?
    /**
     * ID of the ResultMakerLookup entry.
     */
    public var result_maker_id: String? {
        get { _result_maker_id?.value }
        set { _result_maker_id = newValue.map(AnyString.init) }
    }

    private var _subtitle_text: AnyString?
    /**
     * Text tile subtitle text
     */
    public var subtitle_text: String? {
        get { _subtitle_text?.value }
        set { _subtitle_text = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Title of dashboard element
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    /**
     * Whether title is hidden
     */
    public var title_hidden: Bool?

    private var _title_text: AnyString?
    /**
     * Text tile title
     */
    public var title_text: String? {
        get { _title_text?.value }
        set { _title_text = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * Type
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _alert_count: AnyInt?
    /**
     * Count of Alerts associated to a dashboard element (read-only)
     */
    public var alert_count: Int64? {
        get { _alert_count?.value }
        set { _alert_count = newValue.map(AnyInt.init) }
    }

    private var _rich_content_json: AnyString?
    /**
     * JSON with all the properties required for rich editor and buttons elements
     */
    public var rich_content_json: String? {
        get { _rich_content_json?.value }
        set { _rich_content_json = newValue.map(AnyString.init) }
    }

    private var _title_text_as_html: AnyString?
    /**
     * Text tile title text as Html (read-only)
     */
    public var title_text_as_html: String? {
        get { _title_text_as_html?.value }
        set { _title_text_as_html = newValue.map(AnyString.init) }
    }

    private var _subtitle_text_as_html: AnyString?
    /**
     * Text tile subtitle text as Html (read-only)
     */
    public var subtitle_text_as_html: String? {
        get { _subtitle_text_as_html?.value }
        set { _subtitle_text_as_html = newValue.map(AnyString.init) }
    }

    private var _extension_id: AnyString?
    /**
     * Extension ID
     */
    public var extension_id: String? {
        get { _extension_id?.value }
        set { _extension_id = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, body_text: String? = nil, body_text_as_html: String? = nil, dashboard_id: String? = nil, edit_uri: String? = nil, id: String? = nil, look: LookWithQuery? = nil, look_id: String? = nil, lookml_link_id: String? = nil, merge_result_id: String? = nil, note_display: String? = nil, note_state: String? = nil, note_text: String? = nil, note_text_as_html: String? = nil, query: Query? = nil, query_id: String? = nil, refresh_interval: String? = nil, refresh_interval_to_i: Int64? = nil, result_maker: ResultMakerWithIdVisConfigAndDynamicFields? = nil, result_maker_id: String? = nil, subtitle_text: String? = nil, title: String? = nil, title_hidden: Bool? = nil, title_text: String? = nil, type: String? = nil, alert_count: Int64? = nil, rich_content_json: String? = nil, title_text_as_html: String? = nil, subtitle_text_as_html: String? = nil, extension_id: String? = nil) {
        self.can = can
        self._body_text = body_text.map(AnyString.init)
        self._body_text_as_html = body_text_as_html.map(AnyString.init)
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self._edit_uri = edit_uri.map(AnyString.init)
        self._id = id.map(AnyString.init)
        self.look = look
        self._look_id = look_id.map(AnyString.init)
        self._lookml_link_id = lookml_link_id.map(AnyString.init)
        self._merge_result_id = merge_result_id.map(AnyString.init)
        self._note_display = note_display.map(AnyString.init)
        self._note_state = note_state.map(AnyString.init)
        self._note_text = note_text.map(AnyString.init)
        self._note_text_as_html = note_text_as_html.map(AnyString.init)
        self.query = query
        self._query_id = query_id.map(AnyString.init)
        self._refresh_interval = refresh_interval.map(AnyString.init)
        self._refresh_interval_to_i = refresh_interval_to_i.map(AnyInt.init)
        self.result_maker = result_maker
        self._result_maker_id = result_maker_id.map(AnyString.init)
        self._subtitle_text = subtitle_text.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self.title_hidden = title_hidden
        self._title_text = title_text.map(AnyString.init)
        self._type = type.map(AnyString.init)
        self._alert_count = alert_count.map(AnyInt.init)
        self._rich_content_json = rich_content_json.map(AnyString.init)
        self._title_text_as_html = title_text_as_html.map(AnyString.init)
        self._subtitle_text_as_html = subtitle_text_as_html.map(AnyString.init)
        self._extension_id = extension_id.map(AnyString.init)
    }

}

public struct DashboardFilter: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _dashboard_id = "dashboard_id"
        case _name = "name"
        case _title = "title"
        case _type = "type"
        case _default_value = "default_value"
        case _model = "model"
        case _explore = "explore"
        case _dimension = "dimension"
        case field
        case _row = "row"
        case _listens_to_filters = "listens_to_filters"
        case allow_multiple_values
        case required
        case ui_config
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString?
    /**
     * Id of Dashboard (read-only)
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Name of filter
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Title of filter
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * Type of filter: one of date, number, string, or field
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _default_value: AnyString?
    /**
     * Default value of filter
     */
    public var default_value: String? {
        get { _default_value?.value }
        set { _default_value = newValue.map(AnyString.init) }
    }

    private var _model: AnyString?
    /**
     * Model of filter (required if type = field)
     */
    public var model: String? {
        get { _model?.value }
        set { _model = newValue.map(AnyString.init) }
    }

    private var _explore: AnyString?
    /**
     * Explore of filter (required if type = field)
     */
    public var explore: String? {
        get { _explore?.value }
        set { _explore = newValue.map(AnyString.init) }
    }

    private var _dimension: AnyString?
    /**
     * Dimension of filter (required if type = field)
     */
    public var dimension: String? {
        get { _dimension?.value }
        set { _dimension = newValue.map(AnyString.init) }
    }

    /**
     * Field information (read-only)
     */
    public var field: StringDictionary<AnyCodable>?

    private var _row: AnyInt?
    /**
     * Display order of this filter relative to other filters
     */
    public var row: Int64? {
        get { _row?.value }
        set { _row = newValue.map(AnyInt.init) }
    }

    private var _listens_to_filters: [AnyString]?
    /**
     * Array of listeners for faceted filters
     */
    public var listens_to_filters: [String]? {
        get { if let v = _listens_to_filters { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _listens_to_filters = v.map { AnyString.init($0) } } else { _listens_to_filters = nil } }
    }

    /**
     * Whether the filter allows multiple filter values (deprecated in the latest version of dashboards)
     */
    public var allow_multiple_values: Bool?

    /**
     * Whether the filter requires a value to run the dashboard
     */
    public var required: Bool?

    /**
     * The visual configuration for this filter. Used to set up how the UI for this filter should appear.
     */
    public var ui_config: StringDictionary<AnyCodable>?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, dashboard_id: String? = nil, name: String? = nil, title: String? = nil, type: String? = nil, default_value: String? = nil, model: String? = nil, explore: String? = nil, dimension: String? = nil, field: StringDictionary<AnyCodable>? = nil, row: Int64? = nil, listens_to_filters: [String]? = nil, allow_multiple_values: Bool? = nil, required: Bool? = nil, ui_config: StringDictionary<AnyCodable>? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self._type = type.map(AnyString.init)
        self._default_value = default_value.map(AnyString.init)
        self._model = model.map(AnyString.init)
        self._explore = explore.map(AnyString.init)
        self._dimension = dimension.map(AnyString.init)
        self.field = field
        self._row = row.map(AnyInt.init)
        if let v = listens_to_filters { _listens_to_filters = v.map { AnyString.init($0) } } else { _listens_to_filters = nil }
        self.allow_multiple_values = allow_multiple_values
        self.required = required
        self.ui_config = ui_config
    }

}

public struct DashboardLayout: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _dashboard_id = "dashboard_id"
        case _type = "type"
        case active
        case _column_width = "column_width"
        case _width = "width"
        case deleted
        case _dashboard_title = "dashboard_title"
        case dashboard_layout_components
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString?
    /**
     * Id of Dashboard
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * Type
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    /**
     * Is Active
     */
    public var active: Bool?

    private var _column_width: AnyInt?
    /**
     * Column Width
     */
    public var column_width: Int64? {
        get { _column_width?.value }
        set { _column_width = newValue.map(AnyInt.init) }
    }

    private var _width: AnyInt?
    /**
     * Width
     */
    public var width: Int64? {
        get { _width?.value }
        set { _width = newValue.map(AnyInt.init) }
    }

    /**
     * Whether or not the dashboard layout is deleted. (read-only)
     */
    public var deleted: Bool?

    private var _dashboard_title: AnyString?
    /**
     * Title extracted from the dashboard this layout represents. (read-only)
     */
    public var dashboard_title: String? {
        get { _dashboard_title?.value }
        set { _dashboard_title = newValue.map(AnyString.init) }
    }

    /**
     * Components (read-only)
     */
    public var dashboard_layout_components: [DashboardLayoutComponent]?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, dashboard_id: String? = nil, type: String? = nil, active: Bool? = nil, column_width: Int64? = nil, width: Int64? = nil, deleted: Bool? = nil, dashboard_title: String? = nil, dashboard_layout_components: [DashboardLayoutComponent]? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self._type = type.map(AnyString.init)
        self.active = active
        self._column_width = column_width.map(AnyInt.init)
        self._width = width.map(AnyInt.init)
        self.deleted = deleted
        self._dashboard_title = dashboard_title.map(AnyString.init)
        self.dashboard_layout_components = dashboard_layout_components
    }

}

public struct DashboardLayoutComponent: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _dashboard_layout_id = "dashboard_layout_id"
        case _dashboard_element_id = "dashboard_element_id"
        case _row = "row"
        case _column = "column"
        case _width = "width"
        case _height = "height"
        case deleted
        case _element_title = "element_title"
        case element_title_hidden
        case _vis_type = "vis_type"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _dashboard_layout_id: AnyString?
    /**
     * Id of Dashboard Layout
     */
    public var dashboard_layout_id: String? {
        get { _dashboard_layout_id?.value }
        set { _dashboard_layout_id = newValue.map(AnyString.init) }
    }

    private var _dashboard_element_id: AnyString?
    /**
     * Id Of Dashboard Element
     */
    public var dashboard_element_id: String? {
        get { _dashboard_element_id?.value }
        set { _dashboard_element_id = newValue.map(AnyString.init) }
    }

    private var _row: AnyInt?
    /**
     * Row
     */
    public var row: Int64? {
        get { _row?.value }
        set { _row = newValue.map(AnyInt.init) }
    }

    private var _column: AnyInt?
    /**
     * Column
     */
    public var column: Int64? {
        get { _column?.value }
        set { _column = newValue.map(AnyInt.init) }
    }

    private var _width: AnyInt?
    /**
     * Width
     */
    public var width: Int64? {
        get { _width?.value }
        set { _width = newValue.map(AnyInt.init) }
    }

    private var _height: AnyInt?
    /**
     * Height
     */
    public var height: Int64? {
        get { _height?.value }
        set { _height = newValue.map(AnyInt.init) }
    }

    /**
     * Whether or not the dashboard layout component is deleted (read-only)
     */
    public var deleted: Bool?

    private var _element_title: AnyString?
    /**
     * Dashboard element title, extracted from the Dashboard Element. (read-only)
     */
    public var element_title: String? {
        get { _element_title?.value }
        set { _element_title = newValue.map(AnyString.init) }
    }

    /**
     * Whether or not the dashboard element title is displayed. (read-only)
     */
    public var element_title_hidden: Bool?

    private var _vis_type: AnyString?
    /**
     * Visualization type, extracted from a query's vis_config (read-only)
     */
    public var vis_type: String? {
        get { _vis_type?.value }
        set { _vis_type = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, dashboard_layout_id: String? = nil, dashboard_element_id: String? = nil, row: Int64? = nil, column: Int64? = nil, width: Int64? = nil, height: Int64? = nil, deleted: Bool? = nil, element_title: String? = nil, element_title_hidden: Bool? = nil, vis_type: String? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._dashboard_layout_id = dashboard_layout_id.map(AnyString.init)
        self._dashboard_element_id = dashboard_element_id.map(AnyString.init)
        self._row = row.map(AnyInt.init)
        self._column = column.map(AnyInt.init)
        self._width = width.map(AnyInt.init)
        self._height = height.map(AnyInt.init)
        self.deleted = deleted
        self._element_title = element_title.map(AnyString.init)
        self.element_title_hidden = element_title_hidden
        self._vis_type = vis_type.map(AnyString.init)
    }

}

public struct DashboardLookml: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _dashboard_id = "dashboard_id"
        case _folder_id = "folder_id"
        case _lookml = "lookml"
    }
    private var _dashboard_id: AnyString?
    /**
     * Id of Dashboard (read-only)
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    private var _folder_id: AnyString?
    /**
     * (Write-Only) Id of the folder
     */
    public var folder_id: String? {
        get { _folder_id?.value }
        set { _folder_id = newValue.map(AnyString.init) }
    }

    private var _lookml: AnyString?
    /**
     * lookml of UDD
     */
    public var lookml: String? {
        get { _lookml?.value }
        set { _lookml = newValue.map(AnyString.init) }
    }

    public init(dashboard_id: String? = nil, folder_id: String? = nil, lookml: String? = nil) {
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self._folder_id = folder_id.map(AnyString.init)
        self._lookml = lookml.map(AnyString.init)
    }

}

public struct DataActionForm: SDKModel {
    public var state: DataActionUserState?

    /**
     * Array of form fields. (read-only)
     */
    public var fields: [DataActionFormField]?

    public init(state: DataActionUserState? = nil, fields: [DataActionFormField]? = nil) {
        self.state = state
        self.fields = fields
    }

}

public struct DataActionFormField: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _label = "label"
        case _description = "description"
        case _type = "type"
        case _default = "default"
        case _oauth_url = "oauth_url"
        case interactive
        case required
        case options
    }
    private var _name: AnyString?
    /**
     * Name (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _label: AnyString?
    /**
     * Human-readable label (read-only)
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * Description of field (read-only)
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * Type of field. (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _default: AnyString?
    /**
     * Default value of the field. (read-only)
     */
    public var `default`: String? {
        get { _default?.value }
        set { _default = newValue.map(AnyString.init) }
    }

    private var _oauth_url: AnyString?
    /**
     * The URL for an oauth link, if type is 'oauth_link'. (read-only)
     */
    public var oauth_url: String? {
        get { _oauth_url?.value }
        set { _oauth_url = newValue.map(AnyString.init) }
    }

    /**
     * Whether or not a field supports interactive forms. (read-only)
     */
    public var interactive: Bool?

    /**
     * Whether or not the field is required. This is a user-interface hint. A user interface displaying this form should not submit it without a value for this field. The action server must also perform this validation. (read-only)
     */
    public var required: Bool?

    /**
     * If the form type is 'select', a list of options to be selected from. (read-only)
     */
    public var options: [DataActionFormSelectOption]?

    public init(name: String? = nil, label: String? = nil, description: String? = nil, type: String? = nil, `default`: String? = nil, oauth_url: String? = nil, interactive: Bool? = nil, required: Bool? = nil, options: [DataActionFormSelectOption]? = nil) {
        self._name = name.map(AnyString.init)
        self._label = label.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self._type = type.map(AnyString.init)
        self._default = `default`.map(AnyString.init)
        self._oauth_url = oauth_url.map(AnyString.init)
        self.interactive = interactive
        self.required = required
        self.options = options
    }

}

public struct DataActionFormSelectOption: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _label = "label"
    }
    private var _name: AnyString?
    /**
     * Name (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _label: AnyString?
    /**
     * Human-readable label (read-only)
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, label: String? = nil) {
        self._name = name.map(AnyString.init)
        self._label = label.map(AnyString.init)
    }

}

public struct DataActionRequest: SDKModel {
    /**
     * The JSON describing the data action. This JSON should be considered opaque and should be passed through unmodified from the query result it came from.
     */
    public var action: StringDictionary<AnyCodable>?

    /**
     * User input for any form values the data action might use.
     */
    public var form_values: StringDictionary<AnyCodable>?

    public init(action: StringDictionary<AnyCodable>? = nil, form_values: StringDictionary<AnyCodable>? = nil) {
        self.action = action
        self.form_values = form_values
    }

}

public struct DataActionResponse: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _webhook_id = "webhook_id"
        case success
        case refresh_query
        case validation_errors
        case _message = "message"
    }
    private var _webhook_id: AnyString?
    /**
     * ID of the webhook event that sent this data action. In some error conditions, this may be null. (read-only)
     */
    public var webhook_id: String? {
        get { _webhook_id?.value }
        set { _webhook_id = newValue.map(AnyString.init) }
    }

    /**
     * Whether the data action was successful. (read-only)
     */
    public var success: Bool?

    /**
     * When true, indicates that the client should refresh (rerun) the source query because the data may have been changed by the action. (read-only)
     */
    public var refresh_query: Bool?

    public var validation_errors: ValidationError?

    private var _message: AnyString?
    /**
     * Optional message returned by the data action server describing the state of the action that took place. This can be used to implement custom failure messages. If a failure is related to a particular form field, the server should send back a validation error instead. The Looker web UI does not currently display any message if the action indicates 'success', but may do so in the future. (read-only)
     */
    public var message: String? {
        get { _message?.value }
        set { _message = newValue.map(AnyString.init) }
    }

    public init(webhook_id: String? = nil, success: Bool? = nil, refresh_query: Bool? = nil, validation_errors: ValidationError? = nil, message: String? = nil) {
        self._webhook_id = webhook_id.map(AnyString.init)
        self.success = success
        self.refresh_query = refresh_query
        self.validation_errors = validation_errors
        self._message = message.map(AnyString.init)
    }

}

public struct DataActionUserState: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _data = "data"
        case _refresh_time = "refresh_time"
    }
    private var _data: AnyString?
    /**
     * User state data (read-only)
     */
    public var data: String? {
        get { _data?.value }
        set { _data = newValue.map(AnyString.init) }
    }

    private var _refresh_time: AnyInt?
    /**
     * Time in seconds until the state needs to be refreshed (read-only)
     */
    public var refresh_time: Int64? {
        get { _refresh_time?.value }
        set { _refresh_time = newValue.map(AnyInt.init) }
    }

    public init(data: String? = nil, refresh_time: Int64? = nil) {
        self._data = data.map(AnyString.init)
        self._refresh_time = refresh_time.map(AnyInt.init)
    }

}

public struct Datagroup: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _created_at = "created_at"
        case _id = "id"
        case _model_name = "model_name"
        case _name = "name"
        case _stale_before = "stale_before"
        case _trigger_check_at = "trigger_check_at"
        case _trigger_error = "trigger_error"
        case _trigger_value = "trigger_value"
        case _triggered_at = "triggered_at"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _created_at: AnyInt?
    /**
     * UNIX timestamp at which this entry was created. (read-only)
     */
    public var created_at: Int64? {
        get { _created_at?.value }
        set { _created_at = newValue.map(AnyInt.init) }
    }

    private var _id: AnyString?
    /**
     * Unique ID of the datagroup (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _model_name: AnyString?
    /**
     * Name of the model containing the datagroup. Unique when combined with name. (read-only)
     */
    public var model_name: String? {
        get { _model_name?.value }
        set { _model_name = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Name of the datagroup. Unique when combined with model_name. (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _stale_before: AnyInt?
    /**
     * UNIX timestamp before which cache entries are considered stale. Cannot be in the future.
     */
    public var stale_before: Int64? {
        get { _stale_before?.value }
        set { _stale_before = newValue.map(AnyInt.init) }
    }

    private var _trigger_check_at: AnyInt?
    /**
     * UNIX timestamp at which this entry trigger was last checked. (read-only)
     */
    public var trigger_check_at: Int64? {
        get { _trigger_check_at?.value }
        set { _trigger_check_at = newValue.map(AnyInt.init) }
    }

    private var _trigger_error: AnyString?
    /**
     * The message returned with the error of the last trigger check. (read-only)
     */
    public var trigger_error: String? {
        get { _trigger_error?.value }
        set { _trigger_error = newValue.map(AnyString.init) }
    }

    private var _trigger_value: AnyString?
    /**
     * The value of the trigger when last checked. (read-only)
     */
    public var trigger_value: String? {
        get { _trigger_value?.value }
        set { _trigger_value = newValue.map(AnyString.init) }
    }

    private var _triggered_at: AnyInt?
    /**
     * UNIX timestamp at which this entry became triggered. Cannot be in the future.
     */
    public var triggered_at: Int64? {
        get { _triggered_at?.value }
        set { _triggered_at = newValue.map(AnyInt.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, created_at: Int64? = nil, id: String? = nil, model_name: String? = nil, name: String? = nil, stale_before: Int64? = nil, trigger_check_at: Int64? = nil, trigger_error: String? = nil, trigger_value: String? = nil, triggered_at: Int64? = nil) {
        self.can = can
        self._created_at = created_at.map(AnyInt.init)
        self._id = id.map(AnyString.init)
        self._model_name = model_name.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self._stale_before = stale_before.map(AnyInt.init)
        self._trigger_check_at = trigger_check_at.map(AnyInt.init)
        self._trigger_error = trigger_error.map(AnyString.init)
        self._trigger_value = trigger_value.map(AnyString.init)
        self._triggered_at = triggered_at.map(AnyInt.init)
    }

}

public struct DBConnection: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _name = "name"
        case dialect
        case snippets
        case pdts_enabled
        case _named_driver_version_requested = "named_driver_version_requested"
        case _named_driver_version_actual = "named_driver_version_actual"
        case _host = "host"
        case _port = "port"
        case _username = "username"
        case _password = "password"
        case uses_oauth
        case uses_key_pair_auth
        case uses_instance_oauth
        case _certificate = "certificate"
        case _file_type = "file_type"
        case _database = "database"
        case _db_timezone = "db_timezone"
        case _query_timezone = "query_timezone"
        case _schema = "schema"
        case _max_connections = "max_connections"
        case _max_queries = "max_queries"
        case _max_queries_per_user = "max_queries_per_user"
        case _max_billing_gigabytes = "max_billing_gigabytes"
        case ssl
        case verify_ssl
        case _tmp_db_name = "tmp_db_name"
        case _tmp_db_host = "tmp_db_host"
        case _jdbc_additional_params = "jdbc_additional_params"
        case _pool_timeout = "pool_timeout"
        case _dialect_name = "dialect_name"
        case supports_data_studio_link
        case _created_at = "created_at"
        case _user_id = "user_id"
        case example
        case user_db_credentials
        case _user_attribute_fields = "user_attribute_fields"
        case _maintenance_cron = "maintenance_cron"
        case _last_regen_at = "last_regen_at"
        case _last_reap_at = "last_reap_at"
        case sql_runner_precache_tables
        case sql_writing_with_info_schema
        case _after_connect_statements = "after_connect_statements"
        case pdt_context_override
        case managed
        case _custom_local_port = "custom_local_port"
        case _tunnel_id = "tunnel_id"
        case uses_tns
        case _pdt_concurrency = "pdt_concurrency"
        case disable_context_comment
        case _oauth_application_id = "oauth_application_id"
        case always_retry_failed_builds
        case uses_application_default_credentials
        case _impersonated_service_account = "impersonated_service_account"
        case cost_estimate_enabled
        case pdt_api_control_enabled
        case connection_pooling
        case default_bq_connection
        case _bq_storage_project_id = "bq_storage_project_id"
        case bq_roles_verified
        case _p4sa_name = "p4sa_name"
        case query_holding_disabled
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _name: AnyString?
    /**
     * Name of the connection. Also used as the unique identifier
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    public var dialect: Dialect?

    /**
     * SQL Runner snippets for this connection (read-only)
     */
    public var snippets: [Snippet]?

    /**
     * True if PDTs are enabled on this connection (read-only)
     */
    public var pdts_enabled: Bool?

    private var _named_driver_version_requested: AnyString?
    /**
     * Requested JDBC driver version name
     */
    public var named_driver_version_requested: String? {
        get { _named_driver_version_requested?.value }
        set { _named_driver_version_requested = newValue.map(AnyString.init) }
    }

    private var _named_driver_version_actual: AnyString?
    /**
     * Resolved JDBC driver version (read-only)
     */
    public var named_driver_version_actual: String? {
        get { _named_driver_version_actual?.value }
        set { _named_driver_version_actual = newValue.map(AnyString.init) }
    }

    private var _host: AnyString?
    /**
     * Host name/address of server; or the string 'localhost' in case of a connection over an SSH tunnel.
     */
    public var host: String? {
        get { _host?.value }
        set { _host = newValue.map(AnyString.init) }
    }

    private var _port: AnyString?
    /**
     * Port number on server. If the connection is over an SSH tunnel, then the local port associated with the SSH tunnel.
     */
    public var port: String? {
        get { _port?.value }
        set { _port = newValue.map(AnyString.init) }
    }

    private var _username: AnyString?
    /**
     * Username for server authentication
     */
    public var username: String? {
        get { _username?.value }
        set { _username = newValue.map(AnyString.init) }
    }

    private var _password: AnyString?
    /**
     * (Write-Only) Password for server authentication
     */
    public var password: String? {
        get { _password?.value }
        set { _password = newValue.map(AnyString.init) }
    }

    /**
     * Whether the connection uses OAuth for authentication. (read-only)
     */
    public var uses_oauth: Bool?

    /**
     * Whether the connection uses key-pair for authentication.
     */
    public var uses_key_pair_auth: Bool?

    /**
     * Whether the integration uses the oauth instance account. (read-only)
     */
    public var uses_instance_oauth: Bool?

    private var _certificate: AnyString?
    /**
     * (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
     */
    public var certificate: String? {
        get { _certificate?.value }
        set { _certificate = newValue.map(AnyString.init) }
    }

    private var _file_type: AnyString?
    /**
     * (Write-Only) Certificate keyfile type - .json, .p8 or .p12
     */
    public var file_type: String? {
        get { _file_type?.value }
        set { _file_type = newValue.map(AnyString.init) }
    }

    private var _database: AnyString?
    /**
     * Database name
     */
    public var database: String? {
        get { _database?.value }
        set { _database = newValue.map(AnyString.init) }
    }

    private var _db_timezone: AnyString?
    /**
     * Time zone of database
     */
    public var db_timezone: String? {
        get { _db_timezone?.value }
        set { _db_timezone = newValue.map(AnyString.init) }
    }

    private var _query_timezone: AnyString?
    /**
     * Timezone to use in queries
     */
    public var query_timezone: String? {
        get { _query_timezone?.value }
        set { _query_timezone = newValue.map(AnyString.init) }
    }

    private var _schema: AnyString?
    /**
     * Schema name
     */
    public var schema: String? {
        get { _schema?.value }
        set { _schema = newValue.map(AnyString.init) }
    }

    private var _max_connections: AnyInt?
    /**
     * Maximum number of concurrent connection to use
     */
    public var max_connections: Int64? {
        get { _max_connections?.value }
        set { _max_connections = newValue.map(AnyInt.init) }
    }

    private var _max_queries: AnyInt?
    /**
     * Maximum number of concurrent queries to begin on this connection
     */
    public var max_queries: Int64? {
        get { _max_queries?.value }
        set { _max_queries = newValue.map(AnyInt.init) }
    }

    private var _max_queries_per_user: AnyInt?
    /**
     * Maximum number of concurrent queries per user to begin on this connection
     */
    public var max_queries_per_user: Int64? {
        get { _max_queries_per_user?.value }
        set { _max_queries_per_user = newValue.map(AnyInt.init) }
    }

    private var _max_billing_gigabytes: AnyString?
    /**
     * Maximum size of query in GBs (BigQuery only, can be a user_attribute name)
     */
    public var max_billing_gigabytes: String? {
        get { _max_billing_gigabytes?.value }
        set { _max_billing_gigabytes = newValue.map(AnyString.init) }
    }

    /**
     * Use SSL/TLS when connecting to server
     */
    public var ssl: Bool?

    /**
     * Verify the SSL
     */
    public var verify_ssl: Bool?

    private var _tmp_db_name: AnyString?
    /**
     * Name of temporary database (if used)
     */
    public var tmp_db_name: String? {
        get { _tmp_db_name?.value }
        set { _tmp_db_name = newValue.map(AnyString.init) }
    }

    private var _tmp_db_host: AnyString?
    /**
     * Name of temporary host (if used)
     */
    public var tmp_db_host: String? {
        get { _tmp_db_host?.value }
        set { _tmp_db_host = newValue.map(AnyString.init) }
    }

    private var _jdbc_additional_params: AnyString?
    /**
     * Additional params to add to JDBC connection string
     */
    public var jdbc_additional_params: String? {
        get { _jdbc_additional_params?.value }
        set { _jdbc_additional_params = newValue.map(AnyString.init) }
    }

    private var _pool_timeout: AnyInt?
    /**
     * Connection Pool Timeout, in seconds
     */
    public var pool_timeout: Int64? {
        get { _pool_timeout?.value }
        set { _pool_timeout = newValue.map(AnyInt.init) }
    }

    private var _dialect_name: AnyString?
    /**
     * (Read/Write) SQL Dialect name
     */
    public var dialect_name: String? {
        get { _dialect_name?.value }
        set { _dialect_name = newValue.map(AnyString.init) }
    }

    /**
     * Database connection has the ability to support open data studio from explore (read-only)
     */
    public var supports_data_studio_link: Bool?

    private var _created_at: AnyString?
    /**
     * Creation date for this connection (read-only)
     */
    public var created_at: String? {
        get { _created_at?.value }
        set { _created_at = newValue.map(AnyString.init) }
    }

    private var _user_id: AnyString?
    /**
     * Id of user who last modified this connection configuration (read-only)
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    /**
     * Is this an example connection? (read-only)
     */
    public var example: Bool?

    /**
     * (Limited access feature) Are per user db credentials enabled. Enabling will remove previously set username and password
     */
    public var user_db_credentials: Bool?

    private var _user_attribute_fields: [AnyString]?
    /**
     * Fields whose values map to user attribute names
     */
    public var user_attribute_fields: [String]? {
        get { if let v = _user_attribute_fields { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _user_attribute_fields = v.map { AnyString.init($0) } } else { _user_attribute_fields = nil } }
    }

    private var _maintenance_cron: AnyString?
    /**
     * Cron string specifying when maintenance such as PDT trigger checks and drops should be performed
     */
    public var maintenance_cron: String? {
        get { _maintenance_cron?.value }
        set { _maintenance_cron = newValue.map(AnyString.init) }
    }

    private var _last_regen_at: AnyString?
    /**
     * Unix timestamp at start of last completed PDT trigger check process (read-only)
     */
    public var last_regen_at: String? {
        get { _last_regen_at?.value }
        set { _last_regen_at = newValue.map(AnyString.init) }
    }

    private var _last_reap_at: AnyString?
    /**
     * Unix timestamp at start of last completed PDT reap process (read-only)
     */
    public var last_reap_at: String? {
        get { _last_reap_at?.value }
        set { _last_reap_at = newValue.map(AnyString.init) }
    }

    /**
     * Precache tables in the SQL Runner
     */
    public var sql_runner_precache_tables: Bool?

    /**
     * Fetch Information Schema For SQL Writing
     */
    public var sql_writing_with_info_schema: Bool?

    private var _after_connect_statements: AnyString?
    /**
     * SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
     */
    public var after_connect_statements: String? {
        get { _after_connect_statements?.value }
        set { _after_connect_statements = newValue.map(AnyString.init) }
    }

    public var pdt_context_override: DBConnectionOverride?

    /**
     * Is this connection created and managed by Looker (read-only)
     */
    public var managed: Bool?

    private var _custom_local_port: AnyInt?
    /**
     * This field is only applicable to connections over an SSH Tunnel. The value of this field would be the local port associated with the SSH tunnel if configured manually. Otherwise either enter NULL or exclude this field.
     */
    public var custom_local_port: Int64? {
        get { _custom_local_port?.value }
        set { _custom_local_port = newValue.map(AnyInt.init) }
    }

    private var _tunnel_id: AnyString?
    /**
     * The Id of the ssh tunnel this connection uses
     */
    public var tunnel_id: String? {
        get { _tunnel_id?.value }
        set { _tunnel_id = newValue.map(AnyString.init) }
    }

    /**
     * Enable Transparent Network Substrate (TNS) connections
     */
    public var uses_tns: Bool?

    private var _pdt_concurrency: AnyInt?
    /**
     * Maximum number of threads to use to build PDTs in parallel
     */
    public var pdt_concurrency: Int64? {
        get { _pdt_concurrency?.value }
        set { _pdt_concurrency = newValue.map(AnyInt.init) }
    }

    /**
     * When disable_context_comment is true comment will not be added to SQL
     */
    public var disable_context_comment: Bool?

    private var _oauth_application_id: AnyString?
    /**
     * An External OAuth Application to use for authenticating to the database
     */
    public var oauth_application_id: String? {
        get { _oauth_application_id?.value }
        set { _oauth_application_id = newValue.map(AnyString.init) }
    }

    /**
     * When true, error PDTs will be retried every regenerator cycle
     */
    public var always_retry_failed_builds: Bool?

    /**
     * Whether the connection should authenticate with the Application Default Credentials of the host environment (limited to GCP and certain dialects).
     */
    public var uses_application_default_credentials: Bool?

    private var _impersonated_service_account: AnyString?
    /**
     * An alternative Service Account to use for querying datasets (used primarily with `uses_application_default_credentials`) (limited to GCP and certain dialects).
     */
    public var impersonated_service_account: String? {
        get { _impersonated_service_account?.value }
        set { _impersonated_service_account = newValue.map(AnyString.init) }
    }

    /**
     * When true, query cost estimate will be displayed in explore.
     */
    public var cost_estimate_enabled: Bool?

    /**
     * PDT builds on this connection can be kicked off and cancelled via API.
     */
    public var pdt_api_control_enabled: Bool?

    /**
     * Enable database connection pooling.
     */
    public var connection_pooling: Bool?

    /**
     * When true, represents that this connection is the default BQ connection. (read-only)
     */
    public var default_bq_connection: Bool?

    private var _bq_storage_project_id: AnyString?
    /**
     * The project id of the default BigQuery storage project.
     */
    public var bq_storage_project_id: String? {
        get { _bq_storage_project_id?.value }
        set { _bq_storage_project_id = newValue.map(AnyString.init) }
    }

    /**
     * When true, represents that all project roles have been verified.
     */
    public var bq_roles_verified: Bool?

    private var _p4sa_name: AnyString?
    /**
     * The name of P4SA service account that is associated with the Looker instance (read-only)
     */
    public var p4sa_name: String? {
        get { _p4sa_name?.value }
        set { _p4sa_name = newValue.map(AnyString.init) }
    }

    /**
     * Disable query holding for this connection.
     */
    public var query_holding_disabled: Bool?

    public init(can: StringDictionary<Bool>? = nil, name: String? = nil, dialect: Dialect? = nil, snippets: [Snippet]? = nil, pdts_enabled: Bool? = nil, named_driver_version_requested: String? = nil, named_driver_version_actual: String? = nil, host: String? = nil, port: String? = nil, username: String? = nil, password: String? = nil, uses_oauth: Bool? = nil, uses_key_pair_auth: Bool? = nil, uses_instance_oauth: Bool? = nil, certificate: String? = nil, file_type: String? = nil, database: String? = nil, db_timezone: String? = nil, query_timezone: String? = nil, schema: String? = nil, max_connections: Int64? = nil, max_queries: Int64? = nil, max_queries_per_user: Int64? = nil, max_billing_gigabytes: String? = nil, ssl: Bool? = nil, verify_ssl: Bool? = nil, tmp_db_name: String? = nil, tmp_db_host: String? = nil, jdbc_additional_params: String? = nil, pool_timeout: Int64? = nil, dialect_name: String? = nil, supports_data_studio_link: Bool? = nil, created_at: String? = nil, user_id: String? = nil, example: Bool? = nil, user_db_credentials: Bool? = nil, user_attribute_fields: [String]? = nil, maintenance_cron: String? = nil, last_regen_at: String? = nil, last_reap_at: String? = nil, sql_runner_precache_tables: Bool? = nil, sql_writing_with_info_schema: Bool? = nil, after_connect_statements: String? = nil, pdt_context_override: DBConnectionOverride? = nil, managed: Bool? = nil, custom_local_port: Int64? = nil, tunnel_id: String? = nil, uses_tns: Bool? = nil, pdt_concurrency: Int64? = nil, disable_context_comment: Bool? = nil, oauth_application_id: String? = nil, always_retry_failed_builds: Bool? = nil, uses_application_default_credentials: Bool? = nil, impersonated_service_account: String? = nil, cost_estimate_enabled: Bool? = nil, pdt_api_control_enabled: Bool? = nil, connection_pooling: Bool? = nil, default_bq_connection: Bool? = nil, bq_storage_project_id: String? = nil, bq_roles_verified: Bool? = nil, p4sa_name: String? = nil, query_holding_disabled: Bool? = nil) {
        self.can = can
        self._name = name.map(AnyString.init)
        self.dialect = dialect
        self.snippets = snippets
        self.pdts_enabled = pdts_enabled
        self._named_driver_version_requested = named_driver_version_requested.map(AnyString.init)
        self._named_driver_version_actual = named_driver_version_actual.map(AnyString.init)
        self._host = host.map(AnyString.init)
        self._port = port.map(AnyString.init)
        self._username = username.map(AnyString.init)
        self._password = password.map(AnyString.init)
        self.uses_oauth = uses_oauth
        self.uses_key_pair_auth = uses_key_pair_auth
        self.uses_instance_oauth = uses_instance_oauth
        self._certificate = certificate.map(AnyString.init)
        self._file_type = file_type.map(AnyString.init)
        self._database = database.map(AnyString.init)
        self._db_timezone = db_timezone.map(AnyString.init)
        self._query_timezone = query_timezone.map(AnyString.init)
        self._schema = schema.map(AnyString.init)
        self._max_connections = max_connections.map(AnyInt.init)
        self._max_queries = max_queries.map(AnyInt.init)
        self._max_queries_per_user = max_queries_per_user.map(AnyInt.init)
        self._max_billing_gigabytes = max_billing_gigabytes.map(AnyString.init)
        self.ssl = ssl
        self.verify_ssl = verify_ssl
        self._tmp_db_name = tmp_db_name.map(AnyString.init)
        self._tmp_db_host = tmp_db_host.map(AnyString.init)
        self._jdbc_additional_params = jdbc_additional_params.map(AnyString.init)
        self._pool_timeout = pool_timeout.map(AnyInt.init)
        self._dialect_name = dialect_name.map(AnyString.init)
        self.supports_data_studio_link = supports_data_studio_link
        self._created_at = created_at.map(AnyString.init)
        self._user_id = user_id.map(AnyString.init)
        self.example = example
        self.user_db_credentials = user_db_credentials
        if let v = user_attribute_fields { _user_attribute_fields = v.map { AnyString.init($0) } } else { _user_attribute_fields = nil }
        self._maintenance_cron = maintenance_cron.map(AnyString.init)
        self._last_regen_at = last_regen_at.map(AnyString.init)
        self._last_reap_at = last_reap_at.map(AnyString.init)
        self.sql_runner_precache_tables = sql_runner_precache_tables
        self.sql_writing_with_info_schema = sql_writing_with_info_schema
        self._after_connect_statements = after_connect_statements.map(AnyString.init)
        self.pdt_context_override = pdt_context_override
        self.managed = managed
        self._custom_local_port = custom_local_port.map(AnyInt.init)
        self._tunnel_id = tunnel_id.map(AnyString.init)
        self.uses_tns = uses_tns
        self._pdt_concurrency = pdt_concurrency.map(AnyInt.init)
        self.disable_context_comment = disable_context_comment
        self._oauth_application_id = oauth_application_id.map(AnyString.init)
        self.always_retry_failed_builds = always_retry_failed_builds
        self.uses_application_default_credentials = uses_application_default_credentials
        self._impersonated_service_account = impersonated_service_account.map(AnyString.init)
        self.cost_estimate_enabled = cost_estimate_enabled
        self.pdt_api_control_enabled = pdt_api_control_enabled
        self.connection_pooling = connection_pooling
        self.default_bq_connection = default_bq_connection
        self._bq_storage_project_id = bq_storage_project_id.map(AnyString.init)
        self.bq_roles_verified = bq_roles_verified
        self._p4sa_name = p4sa_name.map(AnyString.init)
        self.query_holding_disabled = query_holding_disabled
    }

}

public struct DBConnectionBase: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _name = "name"
        case dialect
        case snippets
        case pdts_enabled
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _name: AnyString?
    /**
     * Name of the connection. Also used as the unique identifier (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    public var dialect: Dialect?

    /**
     * SQL Runner snippets for this connection (read-only)
     */
    public var snippets: [Snippet]?

    /**
     * True if PDTs are enabled on this connection (read-only)
     */
    public var pdts_enabled: Bool?

    public init(can: StringDictionary<Bool>? = nil, name: String? = nil, dialect: Dialect? = nil, snippets: [Snippet]? = nil, pdts_enabled: Bool? = nil) {
        self.can = can
        self._name = name.map(AnyString.init)
        self.dialect = dialect
        self.snippets = snippets
        self.pdts_enabled = pdts_enabled
    }

}

public struct DBConnectionOverride: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _context = "context"
        case _host = "host"
        case _pdt_host = "pdt_host"
        case _port = "port"
        case _pdt_port = "pdt_port"
        case _username = "username"
        case _pdt_username = "pdt_username"
        case _password = "password"
        case _pdt_password = "pdt_password"
        case has_password
        case _certificate = "certificate"
        case _pdt_certificate = "pdt_certificate"
        case _file_type = "file_type"
        case _pdt_file_type = "pdt_file_type"
        case _database = "database"
        case _pdt_database = "pdt_database"
        case _schema = "schema"
        case _pdt_schema = "pdt_schema"
        case _jdbc_additional_params = "jdbc_additional_params"
        case _pdt_jdbc_additional_params = "pdt_jdbc_additional_params"
        case _after_connect_statements = "after_connect_statements"
        case _pdt_after_connect_statements = "pdt_after_connect_statements"
    }
    private var _context: AnyString?
    /**
     * Context in which to override (`pdt` is the only allowed value)
     */
    public var context: String? {
        get { _context?.value }
        set { _context = newValue.map(AnyString.init) }
    }

    private var _host: AnyString?
    /**
     * Host name/address of server
     */
    public var host: String? {
        get { _host?.value }
        set { _host = newValue.map(AnyString.init) }
    }

    private var _pdt_host: AnyString?
    /**
     * Host name/address of server (same as host)
     */
    public var pdt_host: String? {
        get { _pdt_host?.value }
        set { _pdt_host = newValue.map(AnyString.init) }
    }

    private var _port: AnyString?
    /**
     * Port number on server
     */
    public var port: String? {
        get { _port?.value }
        set { _port = newValue.map(AnyString.init) }
    }

    private var _pdt_port: AnyString?
    /**
     * Port number on server (same as port)
     */
    public var pdt_port: String? {
        get { _pdt_port?.value }
        set { _pdt_port = newValue.map(AnyString.init) }
    }

    private var _username: AnyString?
    /**
     * Username for server authentication
     */
    public var username: String? {
        get { _username?.value }
        set { _username = newValue.map(AnyString.init) }
    }

    private var _pdt_username: AnyString?
    /**
     * Username for server authentication (same as username)
     */
    public var pdt_username: String? {
        get { _pdt_username?.value }
        set { _pdt_username = newValue.map(AnyString.init) }
    }

    private var _password: AnyString?
    /**
     * (Write-Only) Password for server authentication
     */
    public var password: String? {
        get { _password?.value }
        set { _password = newValue.map(AnyString.init) }
    }

    private var _pdt_password: AnyString?
    /**
     * (Write-Only) Password for server authentication (same as password)
     */
    public var pdt_password: String? {
        get { _pdt_password?.value }
        set { _pdt_password = newValue.map(AnyString.init) }
    }

    /**
     * Whether or not the password is overridden in this context (read-only)
     */
    public var has_password: Bool?

    private var _certificate: AnyString?
    /**
     * (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
     */
    public var certificate: String? {
        get { _certificate?.value }
        set { _certificate = newValue.map(AnyString.init) }
    }

    private var _pdt_certificate: AnyString?
    /**
     * (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect) (same as certificate).
     */
    public var pdt_certificate: String? {
        get { _pdt_certificate?.value }
        set { _pdt_certificate = newValue.map(AnyString.init) }
    }

    private var _file_type: AnyString?
    /**
     * (Write-Only) Certificate keyfile type - .json or .p12
     */
    public var file_type: String? {
        get { _file_type?.value }
        set { _file_type = newValue.map(AnyString.init) }
    }

    private var _pdt_file_type: AnyString?
    /**
     * (Write-Only) Certificate keyfile type - .json or .p12 (same as file_type)
     */
    public var pdt_file_type: String? {
        get { _pdt_file_type?.value }
        set { _pdt_file_type = newValue.map(AnyString.init) }
    }

    private var _database: AnyString?
    /**
     * Database name
     */
    public var database: String? {
        get { _database?.value }
        set { _database = newValue.map(AnyString.init) }
    }

    private var _pdt_database: AnyString?
    /**
     * Database name (same as database)
     */
    public var pdt_database: String? {
        get { _pdt_database?.value }
        set { _pdt_database = newValue.map(AnyString.init) }
    }

    private var _schema: AnyString?
    /**
     * Schema name
     */
    public var schema: String? {
        get { _schema?.value }
        set { _schema = newValue.map(AnyString.init) }
    }

    private var _pdt_schema: AnyString?
    /**
     * Schema name (same as schema)
     */
    public var pdt_schema: String? {
        get { _pdt_schema?.value }
        set { _pdt_schema = newValue.map(AnyString.init) }
    }

    private var _jdbc_additional_params: AnyString?
    /**
     * Additional params to add to JDBC connection string
     */
    public var jdbc_additional_params: String? {
        get { _jdbc_additional_params?.value }
        set { _jdbc_additional_params = newValue.map(AnyString.init) }
    }

    private var _pdt_jdbc_additional_params: AnyString?
    /**
     * Additional params to add to JDBC connection string (same as jdbc_additional_params)
     */
    public var pdt_jdbc_additional_params: String? {
        get { _pdt_jdbc_additional_params?.value }
        set { _pdt_jdbc_additional_params = newValue.map(AnyString.init) }
    }

    private var _after_connect_statements: AnyString?
    /**
     * SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
     */
    public var after_connect_statements: String? {
        get { _after_connect_statements?.value }
        set { _after_connect_statements = newValue.map(AnyString.init) }
    }

    private var _pdt_after_connect_statements: AnyString?
    /**
     * SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature (same as after_connect_statements)
     */
    public var pdt_after_connect_statements: String? {
        get { _pdt_after_connect_statements?.value }
        set { _pdt_after_connect_statements = newValue.map(AnyString.init) }
    }

    public init(context: String? = nil, host: String? = nil, pdt_host: String? = nil, port: String? = nil, pdt_port: String? = nil, username: String? = nil, pdt_username: String? = nil, password: String? = nil, pdt_password: String? = nil, has_password: Bool? = nil, certificate: String? = nil, pdt_certificate: String? = nil, file_type: String? = nil, pdt_file_type: String? = nil, database: String? = nil, pdt_database: String? = nil, schema: String? = nil, pdt_schema: String? = nil, jdbc_additional_params: String? = nil, pdt_jdbc_additional_params: String? = nil, after_connect_statements: String? = nil, pdt_after_connect_statements: String? = nil) {
        self._context = context.map(AnyString.init)
        self._host = host.map(AnyString.init)
        self._pdt_host = pdt_host.map(AnyString.init)
        self._port = port.map(AnyString.init)
        self._pdt_port = pdt_port.map(AnyString.init)
        self._username = username.map(AnyString.init)
        self._pdt_username = pdt_username.map(AnyString.init)
        self._password = password.map(AnyString.init)
        self._pdt_password = pdt_password.map(AnyString.init)
        self.has_password = has_password
        self._certificate = certificate.map(AnyString.init)
        self._pdt_certificate = pdt_certificate.map(AnyString.init)
        self._file_type = file_type.map(AnyString.init)
        self._pdt_file_type = pdt_file_type.map(AnyString.init)
        self._database = database.map(AnyString.init)
        self._pdt_database = pdt_database.map(AnyString.init)
        self._schema = schema.map(AnyString.init)
        self._pdt_schema = pdt_schema.map(AnyString.init)
        self._jdbc_additional_params = jdbc_additional_params.map(AnyString.init)
        self._pdt_jdbc_additional_params = pdt_jdbc_additional_params.map(AnyString.init)
        self._after_connect_statements = after_connect_statements.map(AnyString.init)
        self._pdt_after_connect_statements = pdt_after_connect_statements.map(AnyString.init)
    }

}

public struct DBConnectionTestResult: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _connection_string = "connection_string"
        case _message = "message"
        case _name = "name"
        case _status = "status"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _connection_string: AnyString?
    /**
     * JDBC connection string. (only populated in the 'connect' test) (read-only)
     */
    public var connection_string: String? {
        get { _connection_string?.value }
        set { _connection_string = newValue.map(AnyString.init) }
    }

    private var _message: AnyString?
    /**
     * Result message of test (read-only)
     */
    public var message: String? {
        get { _message?.value }
        set { _message = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Name of test (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _status: AnyString?
    /**
     * Result code of test (read-only)
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, connection_string: String? = nil, message: String? = nil, name: String? = nil, status: String? = nil) {
        self.can = can
        self._connection_string = connection_string.map(AnyString.init)
        self._message = message.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self._status = status.map(AnyString.init)
    }

}

public struct DelegateOauthTest: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _installation_target_id = "installation_target_id"
        case _installation_id = "installation_id"
        case success
    }
    private var _name: AnyString?
    /**
     * Delegate Oauth Connection Name (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _installation_target_id: AnyString?
    /**
     * The ID of the installation target. For Slack, this would be workspace id. (read-only)
     */
    public var installation_target_id: String? {
        get { _installation_target_id?.value }
        set { _installation_target_id = newValue.map(AnyString.init) }
    }

    private var _installation_id: AnyString?
    /**
     * Installation ID (read-only)
     */
    public var installation_id: String? {
        get { _installation_id?.value }
        set { _installation_id = newValue.map(AnyString.init) }
    }

    /**
     * Whether or not the test was successful (read-only)
     */
    public var success: Bool?

    public init(name: String? = nil, installation_target_id: String? = nil, installation_id: String? = nil, success: Bool? = nil) {
        self._name = name.map(AnyString.init)
        self._installation_target_id = installation_target_id.map(AnyString.init)
        self._installation_id = installation_id.map(AnyString.init)
        self.success = success
    }

}

public struct DependencyGraph: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _graph_text = "graph_text"
    }
    private var _graph_text: AnyString?
    /**
     * The graph structure in the dot language that can be rendered into an image. (read-only)
     */
    public var graph_text: String? {
        get { _graph_text?.value }
        set { _graph_text = newValue.map(AnyString.init) }
    }

    public init(graph_text: String? = nil) {
        self._graph_text = graph_text.map(AnyString.init)
    }

}

/**
 * Status of the dependencies in your project. Valid values are: "lock_optional", "lock_required", "lock_error", "install_none". (Enum defined in ProjectWorkspace)
 */
public enum DependencyStatus: String, Codable {
    case lock_optional = "lock_optional"
    case lock_required = "lock_required"
    case lock_error = "lock_error"
    case install_none = "install_none"
}

/**
 * Type of destination that the alert will be sent to Valid values are: "EMAIL", "ACTION_HUB". (Enum defined in AlertDestination)
 */
public enum DestinationType: String, Codable {
    case EMAIL = "EMAIL"
    case ACTION_HUB = "ACTION_HUB"
}

/**
 * Specifies type of device. Valid values are: "android", "ios". (Enum defined in MobileToken)
 */
public enum DeviceType: String, Codable {
    case android = "android"
    case ios = "ios"
}

public struct Dialect: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _label = "label"
        case supports_cost_estimate
        case _cost_estimate_style = "cost_estimate_style"
        case _persistent_table_indexes = "persistent_table_indexes"
        case _persistent_table_sortkeys = "persistent_table_sortkeys"
        case _persistent_table_distkey = "persistent_table_distkey"
        case supports_streaming
        case automatically_run_sql_runner_snippets
        case _connection_tests = "connection_tests"
        case supports_inducer
        case supports_multiple_databases
        case supports_persistent_derived_tables
        case has_ssl_support
    }
    private var _name: AnyString?
    /**
     * The name of the dialect (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _label: AnyString?
    /**
     * The human-readable label of the connection (read-only)
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    /**
     * Whether the dialect supports query cost estimates (read-only)
     */
    public var supports_cost_estimate: Bool?

    private var _cost_estimate_style: AnyString?
    /**
     * How the dialect handles cost estimation (read-only)
     */
    public var cost_estimate_style: String? {
        get { _cost_estimate_style?.value }
        set { _cost_estimate_style = newValue.map(AnyString.init) }
    }

    private var _persistent_table_indexes: AnyString?
    /**
     * PDT index columns (read-only)
     */
    public var persistent_table_indexes: String? {
        get { _persistent_table_indexes?.value }
        set { _persistent_table_indexes = newValue.map(AnyString.init) }
    }

    private var _persistent_table_sortkeys: AnyString?
    /**
     * PDT sortkey columns (read-only)
     */
    public var persistent_table_sortkeys: String? {
        get { _persistent_table_sortkeys?.value }
        set { _persistent_table_sortkeys = newValue.map(AnyString.init) }
    }

    private var _persistent_table_distkey: AnyString?
    /**
     * PDT distkey column (read-only)
     */
    public var persistent_table_distkey: String? {
        get { _persistent_table_distkey?.value }
        set { _persistent_table_distkey = newValue.map(AnyString.init) }
    }

    /**
     * Supports streaming results (read-only)
     */
    public var supports_streaming: Bool?

    /**
     * Should SQL Runner snippets automatically be run (read-only)
     */
    public var automatically_run_sql_runner_snippets: Bool?

    private var _connection_tests: [AnyString]?
    /**
     * Array of names of the tests that can be run on a connection using this dialect (read-only)
     */
    public var connection_tests: [String]? {
        get { if let v = _connection_tests { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _connection_tests = v.map { AnyString.init($0) } } else { _connection_tests = nil } }
    }

    /**
     * Is supported with the inducer (i.e. generate from sql) (read-only)
     */
    public var supports_inducer: Bool?

    /**
     * Can multiple databases be accessed from a connection using this dialect (read-only)
     */
    public var supports_multiple_databases: Bool?

    /**
     * Whether the dialect supports allowing Looker to build persistent derived tables (read-only)
     */
    public var supports_persistent_derived_tables: Bool?

    /**
     * Does the database have client SSL support settable through the JDBC string explicitly? (read-only)
     */
    public var has_ssl_support: Bool?

    public init(name: String? = nil, label: String? = nil, supports_cost_estimate: Bool? = nil, cost_estimate_style: String? = nil, persistent_table_indexes: String? = nil, persistent_table_sortkeys: String? = nil, persistent_table_distkey: String? = nil, supports_streaming: Bool? = nil, automatically_run_sql_runner_snippets: Bool? = nil, connection_tests: [String]? = nil, supports_inducer: Bool? = nil, supports_multiple_databases: Bool? = nil, supports_persistent_derived_tables: Bool? = nil, has_ssl_support: Bool? = nil) {
        self._name = name.map(AnyString.init)
        self._label = label.map(AnyString.init)
        self.supports_cost_estimate = supports_cost_estimate
        self._cost_estimate_style = cost_estimate_style.map(AnyString.init)
        self._persistent_table_indexes = persistent_table_indexes.map(AnyString.init)
        self._persistent_table_sortkeys = persistent_table_sortkeys.map(AnyString.init)
        self._persistent_table_distkey = persistent_table_distkey.map(AnyString.init)
        self.supports_streaming = supports_streaming
        self.automatically_run_sql_runner_snippets = automatically_run_sql_runner_snippets
        if let v = connection_tests { _connection_tests = v.map { AnyString.init($0) } } else { _connection_tests = nil }
        self.supports_inducer = supports_inducer
        self.supports_multiple_databases = supports_multiple_databases
        self.supports_persistent_derived_tables = supports_persistent_derived_tables
        self.has_ssl_support = has_ssl_support
    }

}

public struct DialectDriverNamesVersion: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _display_name = "display_name"
    }
    private var _name: AnyString?
    /**
     * Name to be passed to the backend (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _display_name: AnyString?
    /**
     * Name to be displayed in the frontend. (read-only)
     */
    public var display_name: String? {
        get { _display_name?.value }
        set { _display_name = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, display_name: String? = nil) {
        self._name = name.map(AnyString.init)
        self._display_name = display_name.map(AnyString.init)
    }

}

public struct DialectInfo: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _default_max_connections = "default_max_connections"
        case _default_port = "default_port"
        case _default_max_queries = "default_max_queries"
        case _default_max_queries_per_user = "default_max_queries_per_user"
        case installed
        case _label = "label"
        case _label_for_database_equivalent = "label_for_database_equivalent"
        case _label_for_schema_equivalent = "label_for_schema_equivalent"
        case _name = "name"
        case _supported_driver_name = "supported_driver_name"
        case supported_driver_versions
        case supported_options
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _default_max_connections: AnyString?
    /**
     * Default number max connections (read-only)
     */
    public var default_max_connections: String? {
        get { _default_max_connections?.value }
        set { _default_max_connections = newValue.map(AnyString.init) }
    }

    private var _default_port: AnyString?
    /**
     * Default port number (read-only)
     */
    public var default_port: String? {
        get { _default_port?.value }
        set { _default_port = newValue.map(AnyString.init) }
    }

    private var _default_max_queries: AnyString?
    /**
     * Default number max queries (read-only)
     */
    public var default_max_queries: String? {
        get { _default_max_queries?.value }
        set { _default_max_queries = newValue.map(AnyString.init) }
    }

    private var _default_max_queries_per_user: AnyString?
    /**
     * Default number max queries per user (read-only)
     */
    public var default_max_queries_per_user: String? {
        get { _default_max_queries_per_user?.value }
        set { _default_max_queries_per_user = newValue.map(AnyString.init) }
    }

    /**
     * Is the supporting driver installed (read-only)
     */
    public var installed: Bool?

    private var _label: AnyString?
    /**
     * The human-readable label of the connection (read-only)
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    private var _label_for_database_equivalent: AnyString?
    /**
     * What the dialect calls the equivalent of a normal SQL table (read-only)
     */
    public var label_for_database_equivalent: String? {
        get { _label_for_database_equivalent?.value }
        set { _label_for_database_equivalent = newValue.map(AnyString.init) }
    }

    private var _label_for_schema_equivalent: AnyString?
    /**
     * What the dialect calls the equivalent of a schema-level namespace (read-only)
     */
    public var label_for_schema_equivalent: String? {
        get { _label_for_schema_equivalent?.value }
        set { _label_for_schema_equivalent = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * The name of the dialect (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _supported_driver_name: AnyString?
    /**
     * The name of the driver used for this dialect (read-only)
     */
    public var supported_driver_name: String? {
        get { _supported_driver_name?.value }
        set { _supported_driver_name = newValue.map(AnyString.init) }
    }

    /**
     * Array of supported drivers for a given dialect (read-only)
     */
    public var supported_driver_versions: [DialectDriverNamesVersion]?

    public var supported_options: DialectInfoOptions?

    public init(can: StringDictionary<Bool>? = nil, default_max_connections: String? = nil, default_port: String? = nil, default_max_queries: String? = nil, default_max_queries_per_user: String? = nil, installed: Bool? = nil, label: String? = nil, label_for_database_equivalent: String? = nil, label_for_schema_equivalent: String? = nil, name: String? = nil, supported_driver_name: String? = nil, supported_driver_versions: [DialectDriverNamesVersion]? = nil, supported_options: DialectInfoOptions? = nil) {
        self.can = can
        self._default_max_connections = default_max_connections.map(AnyString.init)
        self._default_port = default_port.map(AnyString.init)
        self._default_max_queries = default_max_queries.map(AnyString.init)
        self._default_max_queries_per_user = default_max_queries_per_user.map(AnyString.init)
        self.installed = installed
        self._label = label.map(AnyString.init)
        self._label_for_database_equivalent = label_for_database_equivalent.map(AnyString.init)
        self._label_for_schema_equivalent = label_for_schema_equivalent.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self._supported_driver_name = supported_driver_name.map(AnyString.init)
        self.supported_driver_versions = supported_driver_versions
        self.supported_options = supported_options
    }

}

public struct DialectInfoOptions: SDKModel {
    /**
     * Has additional params support (read-only)
     */
    public var additional_params: Bool?

    /**
     * Has support for issuing statements after connecting to the database (read-only)
     */
    public var after_connect_statements: Bool?

    /**
     * Has analytical view support (read-only)
     */
    public var analytical_view_dataset: Bool?

    /**
     * Has auth support (read-only)
     */
    public var auth: Bool?

    /**
     * Has configurable cost estimation (read-only)
     */
    public var cost_estimate: Bool?

    /**
     * Can disable query context comments (read-only)
     */
    public var disable_context_comment: Bool?

    /**
     * Host is required (read-only)
     */
    public var host: Bool?

    /**
     * Instance name is required (read-only)
     */
    public var instance_name: Bool?

    /**
     * Has max billing gigabytes support (read-only)
     */
    public var max_billing_gigabytes: Bool?

    /**
     * Has support for a service account (read-only)
     */
    public var oauth_credentials: Bool?

    /**
     * Has OAuth for PDT support (read-only)
     */
    public var pdts_for_oauth: Bool?

    /**
     * Port can be specified (read-only)
     */
    public var port: Bool?

    /**
     * Has project name support (read-only)
     */
    public var project_name: Bool?

    /**
     * Schema can be specified (read-only)
     */
    public var schema: Bool?

    /**
     * Has support for a service account (read-only)
     */
    public var service_account_credentials: Bool?

    /**
     * Has TLS/SSL support (read-only)
     */
    public var ssl: Bool?

    /**
     * Has timezone support (read-only)
     */
    public var timezone: Bool?

    /**
     * Has tmp table support (read-only)
     */
    public var tmp_table: Bool?

    /**
     * Has Oracle TNS support (read-only)
     */
    public var tns: Bool?

    /**
     * Username can be specified (read-only)
     */
    public var username: Bool?

    /**
     * Username is required (read-only)
     */
    public var username_required: Bool?

    /**
     * Has support for connection pooling (read-only)
     */
    public var supports_connection_pooling: Bool?

    public init(additional_params: Bool? = nil, after_connect_statements: Bool? = nil, analytical_view_dataset: Bool? = nil, auth: Bool? = nil, cost_estimate: Bool? = nil, disable_context_comment: Bool? = nil, host: Bool? = nil, instance_name: Bool? = nil, max_billing_gigabytes: Bool? = nil, oauth_credentials: Bool? = nil, pdts_for_oauth: Bool? = nil, port: Bool? = nil, project_name: Bool? = nil, schema: Bool? = nil, service_account_credentials: Bool? = nil, ssl: Bool? = nil, timezone: Bool? = nil, tmp_table: Bool? = nil, tns: Bool? = nil, username: Bool? = nil, username_required: Bool? = nil, supports_connection_pooling: Bool? = nil) {
        self.additional_params = additional_params
        self.after_connect_statements = after_connect_statements
        self.analytical_view_dataset = analytical_view_dataset
        self.auth = auth
        self.cost_estimate = cost_estimate
        self.disable_context_comment = disable_context_comment
        self.host = host
        self.instance_name = instance_name
        self.max_billing_gigabytes = max_billing_gigabytes
        self.oauth_credentials = oauth_credentials
        self.pdts_for_oauth = pdts_for_oauth
        self.port = port
        self.project_name = project_name
        self.schema = schema
        self.service_account_credentials = service_account_credentials
        self.ssl = ssl
        self.timezone = timezone
        self.tmp_table = tmp_table
        self.tns = tns
        self.username = username
        self.username_required = username_required
        self.supports_connection_pooling = supports_connection_pooling
    }

}

public struct DigestEmails: SDKModel {
    /**
     * Whether or not digest emails are enabled
     */
    public var is_enabled: Bool?

    public init(is_enabled: Bool? = nil) {
        self.is_enabled = is_enabled
    }

}

public struct DigestEmailSend: SDKModel {
    /**
     * True if content was successfully generated and delivered
     */
    public var configuration_delivered: Bool?

    public init(configuration_delivered: Bool? = nil) {
        self.configuration_delivered = configuration_delivered
    }

}

public struct DiscretePalette: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _label = "label"
        case _type = "type"
        case _colors = "colors"
    }
    private var _id: AnyString?
    /**
     * Unique identity string (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _label: AnyString?
    /**
     * Label for palette
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * Type of palette
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _colors: [AnyString]?
    /**
     * Array of colors in the palette
     */
    public var colors: [String]? {
        get { if let v = _colors { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _colors = v.map { AnyString.init($0) } } else { _colors = nil } }
    }

    public init(id: String? = nil, label: String? = nil, type: String? = nil, colors: [String]? = nil) {
        self._id = id.map(AnyString.init)
        self._label = label.map(AnyString.init)
        self._type = type.map(AnyString.init)
        if let v = colors { _colors = v.map { AnyString.init($0) } } else { _colors = nil }
    }

}

public struct EgressIpAddresses: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _egress_ip_addresses = "egress_ip_addresses"
    }
    private var _egress_ip_addresses: [AnyString]?
    /**
     * Egress IP addresses (read-only)
     */
    public var egress_ip_addresses: [String]? {
        get { if let v = _egress_ip_addresses { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _egress_ip_addresses = v.map { AnyString.init($0) } } else { _egress_ip_addresses = nil } }
    }

    public init(egress_ip_addresses: [String]? = nil) {
        if let v = egress_ip_addresses { _egress_ip_addresses = v.map { AnyString.init($0) } } else { _egress_ip_addresses = nil }
    }

}

public struct EmbedConfig: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _domain_allowlist = "domain_allowlist"
        case _alert_url_allowlist = "alert_url_allowlist"
        case _alert_url_param_owner = "alert_url_param_owner"
        case _alert_url_label = "alert_url_label"
        case sso_auth_enabled
        case embed_cookieless_v2
        case embed_content_navigation
        case embed_content_management
        case strict_sameorigin_for_login
        case look_filters
        case hide_look_navigation
        case embed_enabled
    }
    private var _domain_allowlist: [AnyString]?
    /**
     * List of domains to allow for embedding
     */
    public var domain_allowlist: [String]? {
        get { if let v = _domain_allowlist { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _domain_allowlist = v.map { AnyString.init($0) } } else { _domain_allowlist = nil } }
    }

    private var _alert_url_allowlist: [AnyString]?
    /**
     * List of base urls to allow for alert/schedule
     */
    public var alert_url_allowlist: [String]? {
        get { if let v = _alert_url_allowlist { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _alert_url_allowlist = v.map { AnyString.init($0) } } else { _alert_url_allowlist = nil } }
    }

    private var _alert_url_param_owner: AnyString?
    /**
     * Owner of who defines the alert/schedule params on the base url
     */
    public var alert_url_param_owner: String? {
        get { _alert_url_param_owner?.value }
        set { _alert_url_param_owner = newValue.map(AnyString.init) }
    }

    private var _alert_url_label: AnyString?
    /**
     * Label for the alert/schedule url
     */
    public var alert_url_label: String? {
        get { _alert_url_label?.value }
        set { _alert_url_label = newValue.map(AnyString.init) }
    }

    /**
     * Is SSO embedding enabled for this Looker
     */
    public var sso_auth_enabled: Bool?

    /**
     * Is Cookieless embedding enabled for this Looker
     */
    public var embed_cookieless_v2: Bool?

    /**
     * Is embed content navigation enabled for this looker
     */
    public var embed_content_navigation: Bool?

    /**
     * Is embed content management enabled for this Looker
     */
    public var embed_content_management: Bool?

    /**
     * When true, prohibits the use of Looker login pages in non-Looker iframes. When false, Looker login pages may be used in non-Looker hosted iframes.
     */
    public var strict_sameorigin_for_login: Bool?

    /**
     * When true, filters are enabled on embedded Looks
     */
    public var look_filters: Bool?

    /**
     * When true, removes navigation to Looks from embedded dashboards and explores.
     */
    public var hide_look_navigation: Bool?

    /**
     * True if embedding is licensed for this Looker instance. (read-only)
     */
    public var embed_enabled: Bool?

    public init(domain_allowlist: [String]? = nil, alert_url_allowlist: [String]? = nil, alert_url_param_owner: String? = nil, alert_url_label: String? = nil, sso_auth_enabled: Bool? = nil, embed_cookieless_v2: Bool? = nil, embed_content_navigation: Bool? = nil, embed_content_management: Bool? = nil, strict_sameorigin_for_login: Bool? = nil, look_filters: Bool? = nil, hide_look_navigation: Bool? = nil, embed_enabled: Bool? = nil) {
        if let v = domain_allowlist { _domain_allowlist = v.map { AnyString.init($0) } } else { _domain_allowlist = nil }
        if let v = alert_url_allowlist { _alert_url_allowlist = v.map { AnyString.init($0) } } else { _alert_url_allowlist = nil }
        self._alert_url_param_owner = alert_url_param_owner.map(AnyString.init)
        self._alert_url_label = alert_url_label.map(AnyString.init)
        self.sso_auth_enabled = sso_auth_enabled
        self.embed_cookieless_v2 = embed_cookieless_v2
        self.embed_content_navigation = embed_content_navigation
        self.embed_content_management = embed_content_management
        self.strict_sameorigin_for_login = strict_sameorigin_for_login
        self.look_filters = look_filters
        self.hide_look_navigation = hide_look_navigation
        self.embed_enabled = embed_enabled
    }

}

public struct EmbedCookielessSessionAcquire: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _session_length = "session_length"
        case force_logout_login
        case _external_user_id = "external_user_id"
        case _first_name = "first_name"
        case _last_name = "last_name"
        case _user_timezone = "user_timezone"
        case _permissions = "permissions"
        case _models = "models"
        case _group_ids = "group_ids"
        case _external_group_id = "external_group_id"
        case user_attributes
        case _embed_domain = "embed_domain"
        case _session_reference_token = "session_reference_token"
    }
    private var _session_length: AnyInt?
    /**
     * Number of seconds the signed embed session will be valid after the embed session is started. Defaults to 300 seconds. Maximum session length accepted is 2592000 seconds (30 days).
     */
    public var session_length: Int64? {
        get { _session_length?.value }
        set { _session_length = newValue.map(AnyInt.init) }
    }

    /**
     * When true, the embed session will purge any residual Looker login state (such as in browser cookies) before creating a new login state with the given embed user info. Defaults to true.
     */
    public var force_logout_login: Bool?

    private var _external_user_id: AnyString?
    /**
     * A value from an external system that uniquely identifies the embed user. Since the user_ids of Looker embed users may change with every embed session, external_user_id provides a way to assign a known, stable user identifier across multiple embed sessions. When the same external user id value is used for a new embed session, any existing session is terminated and existing access grants are replaced with the access grants associated with the new embed session.
     */
    public var external_user_id: String? {
        get { _external_user_id?.value }
        set { _external_user_id = newValue.map(AnyString.init) }
    }

    private var _first_name: AnyString?
    /**
     * First name of the embed user. Defaults to 'Embed' if not specified
     */
    public var first_name: String? {
        get { _first_name?.value }
        set { _first_name = newValue.map(AnyString.init) }
    }

    private var _last_name: AnyString?
    /**
     * Last name of the embed user. Defaults to 'User' if not specified
     */
    public var last_name: String? {
        get { _last_name?.value }
        set { _last_name = newValue.map(AnyString.init) }
    }

    private var _user_timezone: AnyString?
    /**
     * Sets the user timezone for the embed user session, if the User Specific Timezones setting is enabled in the Looker admin settings. A value of `null` forces the embed user to use the Looker Application Default Timezone. You MUST omit this property from the request if the User Specific Timezones setting is disabled. Timezone values are validated against the IANA Timezone standard and can be seen in the Application Time Zone dropdown list on the Looker General Settings admin page.
     */
    public var user_timezone: String? {
        get { _user_timezone?.value }
        set { _user_timezone = newValue.map(AnyString.init) }
    }

    private var _permissions: [AnyString]?
    /**
     * List of Looker permission names to grant to the embed user. Requested permissions will be filtered to permissions allowed for embed sessions.
     */
    public var permissions: [String]? {
        get { if let v = _permissions { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _permissions = v.map { AnyString.init($0) } } else { _permissions = nil } }
    }

    private var _models: [AnyString]?
    /**
     * List of model names that the embed user may access
     */
    public var models: [String]? {
        get { if let v = _models { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _models = v.map { AnyString.init($0) } } else { _models = nil } }
    }

    private var _group_ids: [AnyString]?
    /**
     * List of Looker group ids in which to enroll the embed user
     */
    public var group_ids: [String]? {
        get { if let v = _group_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _group_ids = v.map { AnyString.init($0) } } else { _group_ids = nil } }
    }

    private var _external_group_id: AnyString?
    /**
     * A unique value identifying an embed-exclusive group. Multiple embed users using the same `external_group_id` value will be able to share Looker content with each other. Content and embed users associated with the `external_group_id` will not be accessible to normal Looker users or embed users not associated with this `external_group_id`.
     */
    public var external_group_id: String? {
        get { _external_group_id?.value }
        set { _external_group_id = newValue.map(AnyString.init) }
    }

    /**
     * A dictionary of name-value pairs associating a Looker user attribute name with a value.
     */
    public var user_attributes: StringDictionary<AnyCodable>?

    private var _embed_domain: AnyString?
    /**
     * The domain of the server embedding the Looker IFRAME. This is an alternative to specifying the domain in the embedded domain allow list in the Looker embed admin page.
     */
    public var embed_domain: String? {
        get { _embed_domain?.value }
        set { _embed_domain = newValue.map(AnyString.init) }
    }

    private var _session_reference_token: AnyString?
    /**
     * Token referencing the embed session and is used to generate new authentication, navigation and api tokens.
     */
    public var session_reference_token: String? {
        get { _session_reference_token?.value }
        set { _session_reference_token = newValue.map(AnyString.init) }
    }

    public init(session_length: Int64? = nil, force_logout_login: Bool? = nil, external_user_id: String? = nil, first_name: String? = nil, last_name: String? = nil, user_timezone: String? = nil, permissions: [String]? = nil, models: [String]? = nil, group_ids: [String]? = nil, external_group_id: String? = nil, user_attributes: StringDictionary<AnyCodable>? = nil, embed_domain: String? = nil, session_reference_token: String? = nil) {
        self._session_length = session_length.map(AnyInt.init)
        self.force_logout_login = force_logout_login
        self._external_user_id = external_user_id.map(AnyString.init)
        self._first_name = first_name.map(AnyString.init)
        self._last_name = last_name.map(AnyString.init)
        self._user_timezone = user_timezone.map(AnyString.init)
        if let v = permissions { _permissions = v.map { AnyString.init($0) } } else { _permissions = nil }
        if let v = models { _models = v.map { AnyString.init($0) } } else { _models = nil }
        if let v = group_ids { _group_ids = v.map { AnyString.init($0) } } else { _group_ids = nil }
        self._external_group_id = external_group_id.map(AnyString.init)
        self.user_attributes = user_attributes
        self._embed_domain = embed_domain.map(AnyString.init)
        self._session_reference_token = session_reference_token.map(AnyString.init)
    }

}

public struct EmbedCookielessSessionAcquireResponse: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _authentication_token = "authentication_token"
        case _authentication_token_ttl = "authentication_token_ttl"
        case _navigation_token = "navigation_token"
        case _navigation_token_ttl = "navigation_token_ttl"
        case _api_token = "api_token"
        case _api_token_ttl = "api_token_ttl"
        case _session_reference_token = "session_reference_token"
        case _session_reference_token_ttl = "session_reference_token_ttl"
    }
    private var _authentication_token: AnyString?
    /**
     * One time token used to create or to attach to an embedded session in the Looker application server.
     */
    public var authentication_token: String? {
        get { _authentication_token?.value }
        set { _authentication_token = newValue.map(AnyString.init) }
    }

    private var _authentication_token_ttl: AnyInt?
    /**
     * Authentication token time to live in seconds.
     */
    public var authentication_token_ttl: Int64? {
        get { _authentication_token_ttl?.value }
        set { _authentication_token_ttl = newValue.map(AnyInt.init) }
    }

    private var _navigation_token: AnyString?
    /**
     * Token used to load and navigate between Looker pages.
     */
    public var navigation_token: String? {
        get { _navigation_token?.value }
        set { _navigation_token = newValue.map(AnyString.init) }
    }

    private var _navigation_token_ttl: AnyInt?
    /**
     * Navigation token time to live in seconds.
     */
    public var navigation_token_ttl: Int64? {
        get { _navigation_token_ttl?.value }
        set { _navigation_token_ttl = newValue.map(AnyInt.init) }
    }

    private var _api_token: AnyString?
    /**
     * Token to used to call Looker APIs.
     */
    public var api_token: String? {
        get { _api_token?.value }
        set { _api_token = newValue.map(AnyString.init) }
    }

    private var _api_token_ttl: AnyInt?
    /**
     * Api token time to live in seconds.
     */
    public var api_token_ttl: Int64? {
        get { _api_token_ttl?.value }
        set { _api_token_ttl = newValue.map(AnyInt.init) }
    }

    private var _session_reference_token: AnyString?
    /**
     * Token referencing the actual embed session. It is used to generate new api, navigation and authentication tokens. api and navigation tokens are short lived and must be refreshed regularly. A new authentication token must be acquired for each IFRAME that is created. The session_reference_token should be kept secure, ideally in the embed hosts application server.
     */
    public var session_reference_token: String? {
        get { _session_reference_token?.value }
        set { _session_reference_token = newValue.map(AnyString.init) }
    }

    private var _session_reference_token_ttl: AnyInt?
    /**
     * Session reference token time to live in seconds. Note that this is the same as actual embed session. The session is expired when the value is set to zero. It is important to note that the generate token endpoint does NOT return an error when the embed session has expired. If an embedding application needs to monitor expiration of embed sessions, check this property for a value of zero.
     */
    public var session_reference_token_ttl: Int64? {
        get { _session_reference_token_ttl?.value }
        set { _session_reference_token_ttl = newValue.map(AnyInt.init) }
    }

    public init(authentication_token: String? = nil, authentication_token_ttl: Int64? = nil, navigation_token: String? = nil, navigation_token_ttl: Int64? = nil, api_token: String? = nil, api_token_ttl: Int64? = nil, session_reference_token: String? = nil, session_reference_token_ttl: Int64? = nil) {
        self._authentication_token = authentication_token.map(AnyString.init)
        self._authentication_token_ttl = authentication_token_ttl.map(AnyInt.init)
        self._navigation_token = navigation_token.map(AnyString.init)
        self._navigation_token_ttl = navigation_token_ttl.map(AnyInt.init)
        self._api_token = api_token.map(AnyString.init)
        self._api_token_ttl = api_token_ttl.map(AnyInt.init)
        self._session_reference_token = session_reference_token.map(AnyString.init)
        self._session_reference_token_ttl = session_reference_token_ttl.map(AnyInt.init)
    }

}

public struct EmbedCookielessSessionGenerateTokens: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _session_reference_token = "session_reference_token"
        case _navigation_token = "navigation_token"
        case _api_token = "api_token"
    }
    private var _session_reference_token: AnyString
    /**
     * Token referencing the embed session and is used to generate new authentication, navigation and api tokens.
     */
    public var session_reference_token: String {
        get { _session_reference_token.value }
        set { _session_reference_token = AnyString.init(newValue) }
    }

    private var _navigation_token: AnyString?
    /**
     * Token used to load and navigate between Looker pages.
     */
    public var navigation_token: String? {
        get { _navigation_token?.value }
        set { _navigation_token = newValue.map(AnyString.init) }
    }

    private var _api_token: AnyString?
    /**
     * Token to used to call Looker APIs.
     */
    public var api_token: String? {
        get { _api_token?.value }
        set { _api_token = newValue.map(AnyString.init) }
    }

    public init(session_reference_token: String, navigation_token: String? = nil, api_token: String? = nil) {
        self._session_reference_token = AnyString.init(session_reference_token)
        self._navigation_token = navigation_token.map(AnyString.init)
        self._api_token = api_token.map(AnyString.init)
    }

    public init(_ session_reference_token: String, navigation_token: String? = nil, api_token: String? = nil) {
        self.init(session_reference_token: session_reference_token, navigation_token: navigation_token, api_token: api_token)
    }

}

public struct EmbedCookielessSessionGenerateTokensResponse: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _navigation_token = "navigation_token"
        case _navigation_token_ttl = "navigation_token_ttl"
        case _api_token = "api_token"
        case _api_token_ttl = "api_token_ttl"
        case _session_reference_token = "session_reference_token"
        case _session_reference_token_ttl = "session_reference_token_ttl"
    }
    private var _navigation_token: AnyString?
    /**
     * Token used to load and navigate between Looker pages.
     */
    public var navigation_token: String? {
        get { _navigation_token?.value }
        set { _navigation_token = newValue.map(AnyString.init) }
    }

    private var _navigation_token_ttl: AnyInt?
    /**
     * Navigation token time to live in seconds.
     */
    public var navigation_token_ttl: Int64? {
        get { _navigation_token_ttl?.value }
        set { _navigation_token_ttl = newValue.map(AnyInt.init) }
    }

    private var _api_token: AnyString?
    /**
     * Token to used to call Looker APIs.
     */
    public var api_token: String? {
        get { _api_token?.value }
        set { _api_token = newValue.map(AnyString.init) }
    }

    private var _api_token_ttl: AnyInt?
    /**
     * Api token time to live in seconds.
     */
    public var api_token_ttl: Int64? {
        get { _api_token_ttl?.value }
        set { _api_token_ttl = newValue.map(AnyInt.init) }
    }

    private var _session_reference_token: AnyString
    /**
     * Token referencing the embed session and is used to generate new authentication, navigation and api tokens.
     */
    public var session_reference_token: String {
        get { _session_reference_token.value }
        set { _session_reference_token = AnyString.init(newValue) }
    }

    private var _session_reference_token_ttl: AnyInt?
    /**
     * Session reference token time to live in seconds. Note that this is the same as actual session.
     */
    public var session_reference_token_ttl: Int64? {
        get { _session_reference_token_ttl?.value }
        set { _session_reference_token_ttl = newValue.map(AnyInt.init) }
    }

    public init(navigation_token: String? = nil, navigation_token_ttl: Int64? = nil, api_token: String? = nil, api_token_ttl: Int64? = nil, session_reference_token: String, session_reference_token_ttl: Int64? = nil) {
        self._navigation_token = navigation_token.map(AnyString.init)
        self._navigation_token_ttl = navigation_token_ttl.map(AnyInt.init)
        self._api_token = api_token.map(AnyString.init)
        self._api_token_ttl = api_token_ttl.map(AnyInt.init)
        self._session_reference_token = AnyString.init(session_reference_token)
        self._session_reference_token_ttl = session_reference_token_ttl.map(AnyInt.init)
    }

    public init(navigation_token: String? = nil, navigation_token_ttl: Int64? = nil, api_token: String? = nil, api_token_ttl: Int64? = nil, _ session_reference_token: String, session_reference_token_ttl: Int64? = nil) {
        self.init(navigation_token: navigation_token, navigation_token_ttl: navigation_token_ttl, api_token: api_token, api_token_ttl: api_token_ttl, session_reference_token: session_reference_token, session_reference_token_ttl: session_reference_token_ttl)
    }

}

public struct EmbedParams: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _target_url = "target_url"
        case _session_length = "session_length"
        case force_logout_login
    }
    private var _target_url: AnyString
    /**
     * The complete URL of the Looker UI page to display in the embed context. For example, to display the dashboard with id 34, `target_url` would look like: `https://mycompany.looker.com:9999/dashboards/34`. `target_uri` MUST contain a scheme (HTTPS), domain name, and URL path. Port must be included if it is required to reach the Looker server from browser clients. If the Looker instance is behind a load balancer or other proxy, `target_uri` must be the public-facing domain name and port required to reach the Looker instance, not the actual internal network machine name of the Looker instance.
     */
    public var target_url: String {
        get { _target_url.value }
        set { _target_url = AnyString.init(newValue) }
    }

    private var _session_length: AnyInt?
    /**
     * Number of seconds the signed embed session will be valid after the embed session is started. Defaults to 300 seconds. Maximum session length accepted is 2592000 seconds (30 days).
     */
    public var session_length: Int64? {
        get { _session_length?.value }
        set { _session_length = newValue.map(AnyInt.init) }
    }

    /**
     * When true, the embed session will purge any residual Looker login state (such as in browser cookies) before creating a new login state with the given embed user info. Defaults to true.
     */
    public var force_logout_login: Bool?

    public init(target_url: String, session_length: Int64? = nil, force_logout_login: Bool? = nil) {
        self._target_url = AnyString.init(target_url)
        self._session_length = session_length.map(AnyInt.init)
        self.force_logout_login = force_logout_login
    }

    public init(_ target_url: String, session_length: Int64? = nil, force_logout_login: Bool? = nil) {
        self.init(target_url: target_url, session_length: session_length, force_logout_login: force_logout_login)
    }

}

public struct EmbedSecret: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _algorithm = "algorithm"
        case _created_at = "created_at"
        case enabled
        case _id = "id"
        case _secret = "secret"
        case _user_id = "user_id"
        case secret_type
    }
    private var _algorithm: AnyString?
    /**
     * Signing algorithm to use with this secret. Either `hmac/sha-256`(default) or `hmac/sha-1`
     */
    public var algorithm: String? {
        get { _algorithm?.value }
        set { _algorithm = newValue.map(AnyString.init) }
    }

    private var _created_at: AnyString?
    /**
     * When secret was created (read-only)
     */
    public var created_at: String? {
        get { _created_at?.value }
        set { _created_at = newValue.map(AnyString.init) }
    }

    /**
     * Is this secret currently enabled
     */
    public var enabled: Bool?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _secret: AnyString?
    /**
     * Secret for use with SSO embedding (read-only)
     */
    public var secret: String? {
        get { _secret?.value }
        set { _secret = newValue.map(AnyString.init) }
    }

    private var _user_id: AnyString?
    /**
     * Id of user who created this secret (read-only)
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    /**
     * Field to distinguish between SSO secrets and JWT secrets Valid values are: "SSO", "JWT".
     */
    public var secret_type: SecretType?

    public init(algorithm: String? = nil, created_at: String? = nil, enabled: Bool? = nil, id: String? = nil, secret: String? = nil, user_id: String? = nil, secret_type: SecretType? = nil) {
        self._algorithm = algorithm.map(AnyString.init)
        self._created_at = created_at.map(AnyString.init)
        self.enabled = enabled
        self._id = id.map(AnyString.init)
        self._secret = secret.map(AnyString.init)
        self._user_id = user_id.map(AnyString.init)
        self.secret_type = secret_type
    }

}

public struct EmbedSsoParams: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _target_url = "target_url"
        case _session_length = "session_length"
        case force_logout_login
        case _external_user_id = "external_user_id"
        case _first_name = "first_name"
        case _last_name = "last_name"
        case _user_timezone = "user_timezone"
        case _permissions = "permissions"
        case _models = "models"
        case _group_ids = "group_ids"
        case _external_group_id = "external_group_id"
        case user_attributes
        case _secret_id = "secret_id"
        case _embed_domain = "embed_domain"
    }
    private var _target_url: AnyString
    /**
     * The complete URL of the Looker UI page to display in the embed context. For example, to display the dashboard with id 34, `target_url` would look like: `https://mycompany.looker.com:9999/dashboards/34`. `target_uri` MUST contain a scheme (HTTPS), domain name, and URL path. Port must be included if it is required to reach the Looker server from browser clients. If the Looker instance is behind a load balancer or other proxy, `target_uri` must be the public-facing domain name and port required to reach the Looker instance, not the actual internal network machine name of the Looker instance.
     */
    public var target_url: String {
        get { _target_url.value }
        set { _target_url = AnyString.init(newValue) }
    }

    private var _session_length: AnyInt?
    /**
     * Number of seconds the signed embed session will be valid after the embed session is started. Defaults to 300 seconds. Maximum session length accepted is 2592000 seconds (30 days).
     */
    public var session_length: Int64? {
        get { _session_length?.value }
        set { _session_length = newValue.map(AnyInt.init) }
    }

    /**
     * When true, the embed session will purge any residual Looker login state (such as in browser cookies) before creating a new login state with the given embed user info. Defaults to true.
     */
    public var force_logout_login: Bool?

    private var _external_user_id: AnyString?
    /**
     * A value from an external system that uniquely identifies the embed user. Since the user_ids of Looker embed users may change with every embed session, external_user_id provides a way to assign a known, stable user identifier across multiple embed sessions. When the same external user id value is used for a new embed session, any existing session is terminated and existing access grants are replaced with the access grants associated with the new embed session.
     */
    public var external_user_id: String? {
        get { _external_user_id?.value }
        set { _external_user_id = newValue.map(AnyString.init) }
    }

    private var _first_name: AnyString?
    /**
     * First name of the embed user. Defaults to 'Embed' if not specified
     */
    public var first_name: String? {
        get { _first_name?.value }
        set { _first_name = newValue.map(AnyString.init) }
    }

    private var _last_name: AnyString?
    /**
     * Last name of the embed user. Defaults to 'User' if not specified
     */
    public var last_name: String? {
        get { _last_name?.value }
        set { _last_name = newValue.map(AnyString.init) }
    }

    private var _user_timezone: AnyString?
    /**
     * Sets the user timezone for the embed user session, if the User Specific Timezones setting is enabled in the Looker admin settings. A value of `null` forces the embed user to use the Looker Application Default Timezone. You MUST omit this property from the request if the User Specific Timezones setting is disabled. Timezone values are validated against the IANA Timezone standard and can be seen in the Application Time Zone dropdown list on the Looker General Settings admin page.
     */
    public var user_timezone: String? {
        get { _user_timezone?.value }
        set { _user_timezone = newValue.map(AnyString.init) }
    }

    private var _permissions: [AnyString]?
    /**
     * List of Looker permission names to grant to the embed user. Requested permissions will be filtered to permissions allowed for embed sessions.
     */
    public var permissions: [String]? {
        get { if let v = _permissions { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _permissions = v.map { AnyString.init($0) } } else { _permissions = nil } }
    }

    private var _models: [AnyString]?
    /**
     * List of model names that the embed user may access
     */
    public var models: [String]? {
        get { if let v = _models { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _models = v.map { AnyString.init($0) } } else { _models = nil } }
    }

    private var _group_ids: [AnyString]?
    /**
     * List of Looker group ids in which to enroll the embed user
     */
    public var group_ids: [String]? {
        get { if let v = _group_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _group_ids = v.map { AnyString.init($0) } } else { _group_ids = nil } }
    }

    private var _external_group_id: AnyString?
    /**
     * A unique value identifying an embed-exclusive group. Multiple embed users using the same `external_group_id` value will be able to share Looker content with each other. Content and embed users associated with the `external_group_id` will not be accessible to normal Looker users or embed users not associated with this `external_group_id`.
     */
    public var external_group_id: String? {
        get { _external_group_id?.value }
        set { _external_group_id = newValue.map(AnyString.init) }
    }

    /**
     * A dictionary of name-value pairs associating a Looker user attribute name with a value.
     */
    public var user_attributes: StringDictionary<AnyCodable>?

    private var _secret_id: AnyString?
    /**
     * Id of the embed secret to use to sign this SSO url. If specified, the value must be an id of a valid (active) secret defined in the Looker instance. If not specified, the URL will be signed with the newest active embed secret defined in the Looker instance.
     */
    public var secret_id: String? {
        get { _secret_id?.value }
        set { _secret_id = newValue.map(AnyString.init) }
    }

    private var _embed_domain: AnyString?
    /**
     * Optional. URL of the domain hosting the signed embed URL. If provided and valid, the embed_domain will be added to the embed domain allowlist if it is not currently in the list
     */
    public var embed_domain: String? {
        get { _embed_domain?.value }
        set { _embed_domain = newValue.map(AnyString.init) }
    }

    public init(target_url: String, session_length: Int64? = nil, force_logout_login: Bool? = nil, external_user_id: String? = nil, first_name: String? = nil, last_name: String? = nil, user_timezone: String? = nil, permissions: [String]? = nil, models: [String]? = nil, group_ids: [String]? = nil, external_group_id: String? = nil, user_attributes: StringDictionary<AnyCodable>? = nil, secret_id: String? = nil, embed_domain: String? = nil) {
        self._target_url = AnyString.init(target_url)
        self._session_length = session_length.map(AnyInt.init)
        self.force_logout_login = force_logout_login
        self._external_user_id = external_user_id.map(AnyString.init)
        self._first_name = first_name.map(AnyString.init)
        self._last_name = last_name.map(AnyString.init)
        self._user_timezone = user_timezone.map(AnyString.init)
        if let v = permissions { _permissions = v.map { AnyString.init($0) } } else { _permissions = nil }
        if let v = models { _models = v.map { AnyString.init($0) } } else { _models = nil }
        if let v = group_ids { _group_ids = v.map { AnyString.init($0) } } else { _group_ids = nil }
        self._external_group_id = external_group_id.map(AnyString.init)
        self.user_attributes = user_attributes
        self._secret_id = secret_id.map(AnyString.init)
        self._embed_domain = embed_domain.map(AnyString.init)
    }

    public init(_ target_url: String, session_length: Int64? = nil, force_logout_login: Bool? = nil, external_user_id: String? = nil, first_name: String? = nil, last_name: String? = nil, user_timezone: String? = nil, permissions: [String]? = nil, models: [String]? = nil, group_ids: [String]? = nil, external_group_id: String? = nil, user_attributes: StringDictionary<AnyCodable>? = nil, secret_id: String? = nil, embed_domain: String? = nil) {
        self.init(target_url: target_url, session_length: session_length, force_logout_login: force_logout_login, external_user_id: external_user_id, first_name: first_name, last_name: last_name, user_timezone: user_timezone, permissions: permissions, models: models, group_ids: group_ids, external_group_id: external_group_id, user_attributes: user_attributes, secret_id: secret_id, embed_domain: embed_domain)
    }

}

public struct EmbedUrlResponse: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _url = "url"
    }
    private var _url: AnyString?
    /**
     * The embed URL. Any modification to this string will make the URL unusable. (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(url: String? = nil) {
        self._url = url.map(AnyString.init)
    }

}

public struct LkError: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _message = "message"
        case _documentation_url = "documentation_url"
    }
    private var _message: AnyString
    /**
     * Error details (read-only)
     */
    public var message: String {
        get { _message.value }
        set { _message = AnyString.init(newValue) }
    }

    private var _documentation_url: AnyString
    /**
     * Documentation link (read-only)
     */
    public var documentation_url: String {
        get { _documentation_url.value }
        set { _documentation_url = AnyString.init(newValue) }
    }

    public init(message: String, documentation_url: String) {
        self._message = AnyString.init(message)
        self._documentation_url = AnyString.init(documentation_url)
    }

    public init(_ message: String, _ documentation_url: String) {
        self.init(message: message, documentation_url: documentation_url)
    }

}

public struct ExternalOauthApplication: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _name = "name"
        case _client_id = "client_id"
        case _client_secret = "client_secret"
        case _tenant_id = "tenant_id"
        case _dialect_name = "dialect_name"
        case created_at
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * ID of this OAuth Application (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * The name of this application.  For Snowflake connections, this should be the name of the host database.
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _client_id: AnyString?
    /**
     * The OAuth Client ID for this application
     */
    public var client_id: String? {
        get { _client_id?.value }
        set { _client_id = newValue.map(AnyString.init) }
    }

    private var _client_secret: AnyString?
    /**
     * (Write-Only) The OAuth Client Secret for this application
     */
    public var client_secret: String? {
        get { _client_secret?.value }
        set { _client_secret = newValue.map(AnyString.init) }
    }

    private var _tenant_id: AnyString?
    /**
     * The OAuth Tenant ID for this application
     */
    public var tenant_id: String? {
        get { _tenant_id?.value }
        set { _tenant_id = newValue.map(AnyString.init) }
    }

    private var _dialect_name: AnyString?
    /**
     * The database dialect for this application.
     */
    public var dialect_name: String? {
        get { _dialect_name?.value }
        set { _dialect_name = newValue.map(AnyString.init) }
    }

    /**
     * Creation time for this application (read-only)
     */
    public var created_at: Date?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, name: String? = nil, client_id: String? = nil, client_secret: String? = nil, tenant_id: String? = nil, dialect_name: String? = nil, created_at: Date? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self._client_id = client_id.map(AnyString.init)
        self._client_secret = client_secret.map(AnyString.init)
        self._tenant_id = tenant_id.map(AnyString.init)
        self._dialect_name = dialect_name.map(AnyString.init)
        self.created_at = created_at
    }

}

/**
 * The style of dimension fill that is possible for this field. Null if no dimension fill is possible. Valid values are: "enumeration", "range". (Enum defined in LookmlModelExploreField)
 */
public enum FillStyle: String, Codable {
    case enumeration = "enumeration"
    case range = "range"
}

public struct Folder: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _parent_id = "parent_id"
        case _id = "id"
        case _content_metadata_id = "content_metadata_id"
        case created_at
        case _creator_id = "creator_id"
        case _child_count = "child_count"
        case _external_id = "external_id"
        case is_embed
        case is_embed_shared_root
        case is_embed_users_root
        case is_personal
        case is_personal_descendant
        case is_shared_root
        case is_users_root
        case can
        case dashboards
        case looks
    }
    private var _name: AnyString
    /**
     * Unique Name
     */
    public var name: String {
        get { _name.value }
        set { _name = AnyString.init(newValue) }
    }

    private var _parent_id: AnyString?
    /**
     * Id of Parent. If the parent id is null, this is a root-level entry
     */
    public var parent_id: String? {
        get { _parent_id?.value }
        set { _parent_id = newValue.map(AnyString.init) }
    }

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _content_metadata_id: AnyString?
    /**
     * Id of content metadata (read-only)
     */
    public var content_metadata_id: String? {
        get { _content_metadata_id?.value }
        set { _content_metadata_id = newValue.map(AnyString.init) }
    }

    /**
     * Time the space was created (read-only)
     */
    public var created_at: Date?

    private var _creator_id: AnyString?
    /**
     * User Id of Creator (read-only)
     */
    public var creator_id: String? {
        get { _creator_id?.value }
        set { _creator_id = newValue.map(AnyString.init) }
    }

    private var _child_count: AnyInt?
    /**
     * Children Count (read-only)
     */
    public var child_count: Int64? {
        get { _child_count?.value }
        set { _child_count = newValue.map(AnyInt.init) }
    }

    private var _external_id: AnyString?
    /**
     * Embedder's Id if this folder was autogenerated as an embedding shared folder via 'external_group_id' in an SSO embed login (read-only)
     */
    public var external_id: String? {
        get { _external_id?.value }
        set { _external_id = newValue.map(AnyString.init) }
    }

    /**
     * Folder is an embed folder (read-only)
     */
    public var is_embed: Bool?

    /**
     * Folder is the root embed shared folder (read-only)
     */
    public var is_embed_shared_root: Bool?

    /**
     * Folder is the root embed users folder (read-only)
     */
    public var is_embed_users_root: Bool?

    /**
     * Folder is a user's personal folder (read-only)
     */
    public var is_personal: Bool?

    /**
     * Folder is descendant of a user's personal folder (read-only)
     */
    public var is_personal_descendant: Bool?

    /**
     * Folder is the root shared folder (read-only)
     */
    public var is_shared_root: Bool?

    /**
     * Folder is the root user folder (read-only)
     */
    public var is_users_root: Bool?

    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    /**
     * Dashboards (read-only)
     */
    public var dashboards: [DashboardBase]?

    /**
     * Looks (read-only)
     */
    public var looks: [LookWithDashboards]?

    public init(name: String, parent_id: String? = nil, id: String? = nil, content_metadata_id: String? = nil, created_at: Date? = nil, creator_id: String? = nil, child_count: Int64? = nil, external_id: String? = nil, is_embed: Bool? = nil, is_embed_shared_root: Bool? = nil, is_embed_users_root: Bool? = nil, is_personal: Bool? = nil, is_personal_descendant: Bool? = nil, is_shared_root: Bool? = nil, is_users_root: Bool? = nil, can: StringDictionary<Bool>? = nil, dashboards: [DashboardBase]? = nil, looks: [LookWithDashboards]? = nil) {
        self._name = AnyString.init(name)
        self._parent_id = parent_id.map(AnyString.init)
        self._id = id.map(AnyString.init)
        self._content_metadata_id = content_metadata_id.map(AnyString.init)
        self.created_at = created_at
        self._creator_id = creator_id.map(AnyString.init)
        self._child_count = child_count.map(AnyInt.init)
        self._external_id = external_id.map(AnyString.init)
        self.is_embed = is_embed
        self.is_embed_shared_root = is_embed_shared_root
        self.is_embed_users_root = is_embed_users_root
        self.is_personal = is_personal
        self.is_personal_descendant = is_personal_descendant
        self.is_shared_root = is_shared_root
        self.is_users_root = is_users_root
        self.can = can
        self.dashboards = dashboards
        self.looks = looks
    }

    public init(_ name: String, parent_id: String? = nil, id: String? = nil, content_metadata_id: String? = nil, created_at: Date? = nil, creator_id: String? = nil, child_count: Int64? = nil, external_id: String? = nil, is_embed: Bool? = nil, is_embed_shared_root: Bool? = nil, is_embed_users_root: Bool? = nil, is_personal: Bool? = nil, is_personal_descendant: Bool? = nil, is_shared_root: Bool? = nil, is_users_root: Bool? = nil, can: StringDictionary<Bool>? = nil, dashboards: [DashboardBase]? = nil, looks: [LookWithDashboards]? = nil) {
        self.init(name: name, parent_id: parent_id, id: id, content_metadata_id: content_metadata_id, created_at: created_at, creator_id: creator_id, child_count: child_count, external_id: external_id, is_embed: is_embed, is_embed_shared_root: is_embed_shared_root, is_embed_users_root: is_embed_users_root, is_personal: is_personal, is_personal_descendant: is_personal_descendant, is_shared_root: is_shared_root, is_users_root: is_users_root, can: can, dashboards: dashboards, looks: looks)
    }

}

public struct FolderBase: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _parent_id = "parent_id"
        case _id = "id"
        case _content_metadata_id = "content_metadata_id"
        case created_at
        case _creator_id = "creator_id"
        case _child_count = "child_count"
        case _external_id = "external_id"
        case is_embed
        case is_embed_shared_root
        case is_embed_users_root
        case is_personal
        case is_personal_descendant
        case is_shared_root
        case is_users_root
        case can
    }
    private var _name: AnyString
    /**
     * Unique Name
     */
    public var name: String {
        get { _name.value }
        set { _name = AnyString.init(newValue) }
    }

    private var _parent_id: AnyString?
    /**
     * Id of Parent. If the parent id is null, this is a root-level entry
     */
    public var parent_id: String? {
        get { _parent_id?.value }
        set { _parent_id = newValue.map(AnyString.init) }
    }

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _content_metadata_id: AnyString?
    /**
     * Id of content metadata (read-only)
     */
    public var content_metadata_id: String? {
        get { _content_metadata_id?.value }
        set { _content_metadata_id = newValue.map(AnyString.init) }
    }

    /**
     * Time the folder was created (read-only)
     */
    public var created_at: Date?

    private var _creator_id: AnyString?
    /**
     * User Id of Creator (read-only)
     */
    public var creator_id: String? {
        get { _creator_id?.value }
        set { _creator_id = newValue.map(AnyString.init) }
    }

    private var _child_count: AnyInt?
    /**
     * Children Count (read-only)
     */
    public var child_count: Int64? {
        get { _child_count?.value }
        set { _child_count = newValue.map(AnyInt.init) }
    }

    private var _external_id: AnyString?
    /**
     * Embedder's Id if this folder was autogenerated as an embedding shared folder via 'external_group_id' in an SSO embed login (read-only)
     */
    public var external_id: String? {
        get { _external_id?.value }
        set { _external_id = newValue.map(AnyString.init) }
    }

    /**
     * Folder is an embed folder (read-only)
     */
    public var is_embed: Bool?

    /**
     * Folder is the root embed shared folder (read-only)
     */
    public var is_embed_shared_root: Bool?

    /**
     * Folder is the root embed users folder (read-only)
     */
    public var is_embed_users_root: Bool?

    /**
     * Folder is a user's personal folder (read-only)
     */
    public var is_personal: Bool?

    /**
     * Folder is descendant of a user's personal folder (read-only)
     */
    public var is_personal_descendant: Bool?

    /**
     * Folder is the root shared folder (read-only)
     */
    public var is_shared_root: Bool?

    /**
     * Folder is the root user folder (read-only)
     */
    public var is_users_root: Bool?

    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    public init(name: String, parent_id: String? = nil, id: String? = nil, content_metadata_id: String? = nil, created_at: Date? = nil, creator_id: String? = nil, child_count: Int64? = nil, external_id: String? = nil, is_embed: Bool? = nil, is_embed_shared_root: Bool? = nil, is_embed_users_root: Bool? = nil, is_personal: Bool? = nil, is_personal_descendant: Bool? = nil, is_shared_root: Bool? = nil, is_users_root: Bool? = nil, can: StringDictionary<Bool>? = nil) {
        self._name = AnyString.init(name)
        self._parent_id = parent_id.map(AnyString.init)
        self._id = id.map(AnyString.init)
        self._content_metadata_id = content_metadata_id.map(AnyString.init)
        self.created_at = created_at
        self._creator_id = creator_id.map(AnyString.init)
        self._child_count = child_count.map(AnyInt.init)
        self._external_id = external_id.map(AnyString.init)
        self.is_embed = is_embed
        self.is_embed_shared_root = is_embed_shared_root
        self.is_embed_users_root = is_embed_users_root
        self.is_personal = is_personal
        self.is_personal_descendant = is_personal_descendant
        self.is_shared_root = is_shared_root
        self.is_users_root = is_users_root
        self.can = can
    }

    public init(_ name: String, parent_id: String? = nil, id: String? = nil, content_metadata_id: String? = nil, created_at: Date? = nil, creator_id: String? = nil, child_count: Int64? = nil, external_id: String? = nil, is_embed: Bool? = nil, is_embed_shared_root: Bool? = nil, is_embed_users_root: Bool? = nil, is_personal: Bool? = nil, is_personal_descendant: Bool? = nil, is_shared_root: Bool? = nil, is_users_root: Bool? = nil, can: StringDictionary<Bool>? = nil) {
        self.init(name: name, parent_id: parent_id, id: id, content_metadata_id: content_metadata_id, created_at: created_at, creator_id: creator_id, child_count: child_count, external_id: external_id, is_embed: is_embed, is_embed_shared_root: is_embed_shared_root, is_embed_users_root: is_embed_users_root, is_personal: is_personal, is_personal_descendant: is_personal_descendant, is_shared_root: is_shared_root, is_users_root: is_users_root, can: can)
    }

}

/**
 * Specifies the data format of the region information. Valid values are: "topojson", "vector_tile_region". (Enum defined in LookmlModelExploreFieldMapLayer)
 */
public enum Format: String, Codable {
    case topojson = "topojson"
    case vector_tile_region = "vector_tile_region"
}

public struct GenericError: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _type = "type"
        case _title = "title"
        case _detail = "detail"
        case _status = "status"
        case _instance = "instance"
    }
    private var _type: AnyString?
    /**
     * A URI reference that identifies the problem type (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Overview of the error (read-only)
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _detail: AnyString?
    /**
     * Detail of the error (read-only)
     */
    public var detail: String? {
        get { _detail?.value }
        set { _detail = newValue.map(AnyString.init) }
    }

    private var _status: AnyString?
    /**
     * The HTTP status code for the problem (read-only)
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    private var _instance: AnyString?
    /**
     * URI reference that identifies the specific occurrence of the problem (read-only)
     */
    public var instance: String? {
        get { _instance?.value }
        set { _instance = newValue.map(AnyString.init) }
    }

    public init(type: String? = nil, title: String? = nil, detail: String? = nil, status: String? = nil, instance: String? = nil) {
        self._type = type.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self._detail = detail.map(AnyString.init)
        self._status = status.map(AnyString.init)
        self._instance = instance.map(AnyString.init)
    }

}

public struct GitBranch: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _name = "name"
        case _remote = "remote"
        case _remote_name = "remote_name"
        case _error = "error"
        case _message = "message"
        case _owner_name = "owner_name"
        case readonly
        case personal
        case is_local
        case is_remote
        case is_production
        case _ahead_count = "ahead_count"
        case _behind_count = "behind_count"
        case _commit_at = "commit_at"
        case _ref = "ref"
        case _remote_ref = "remote_ref"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _name: AnyString?
    /**
     * The short name on the local. Updating `name` results in `git checkout <new_name>`
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _remote: AnyString?
    /**
     * The name of the remote (read-only)
     */
    public var remote: String? {
        get { _remote?.value }
        set { _remote = newValue.map(AnyString.init) }
    }

    private var _remote_name: AnyString?
    /**
     * The short name on the remote (read-only)
     */
    public var remote_name: String? {
        get { _remote_name?.value }
        set { _remote_name = newValue.map(AnyString.init) }
    }

    private var _error: AnyString?
    /**
     * Name of error (read-only)
     */
    public var error: String? {
        get { _error?.value }
        set { _error = newValue.map(AnyString.init) }
    }

    private var _message: AnyString?
    /**
     * Message describing an error if present (read-only)
     */
    public var message: String? {
        get { _message?.value }
        set { _message = newValue.map(AnyString.init) }
    }

    private var _owner_name: AnyString?
    /**
     * Name of the owner of a personal branch (read-only)
     */
    public var owner_name: String? {
        get { _owner_name?.value }
        set { _owner_name = newValue.map(AnyString.init) }
    }

    /**
     * Whether or not this branch is readonly (read-only)
     */
    public var readonly: Bool?

    /**
     * Whether or not this branch is a personal branch - readonly for all developers except the owner (read-only)
     */
    public var personal: Bool?

    /**
     * Whether or not a local ref exists for the branch (read-only)
     */
    public var is_local: Bool?

    /**
     * Whether or not a remote ref exists for the branch (read-only)
     */
    public var is_remote: Bool?

    /**
     * Whether or not this is the production branch (read-only)
     */
    public var is_production: Bool?

    private var _ahead_count: AnyInt?
    /**
     * Number of commits the local branch is ahead of the remote (read-only)
     */
    public var ahead_count: Int64? {
        get { _ahead_count?.value }
        set { _ahead_count = newValue.map(AnyInt.init) }
    }

    private var _behind_count: AnyInt?
    /**
     * Number of commits the local branch is behind the remote (read-only)
     */
    public var behind_count: Int64? {
        get { _behind_count?.value }
        set { _behind_count = newValue.map(AnyInt.init) }
    }

    private var _commit_at: AnyInt?
    /**
     * UNIX timestamp at which this branch was last committed. (read-only)
     */
    public var commit_at: Int64? {
        get { _commit_at?.value }
        set { _commit_at = newValue.map(AnyInt.init) }
    }

    private var _ref: AnyString?
    /**
     * The resolved ref of this branch. Updating `ref` results in `git reset --hard <new_ref>``.
     */
    public var ref: String? {
        get { _ref?.value }
        set { _ref = newValue.map(AnyString.init) }
    }

    private var _remote_ref: AnyString?
    /**
     * The resolved ref of this branch remote. (read-only)
     */
    public var remote_ref: String? {
        get { _remote_ref?.value }
        set { _remote_ref = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, name: String? = nil, remote: String? = nil, remote_name: String? = nil, error: String? = nil, message: String? = nil, owner_name: String? = nil, readonly: Bool? = nil, personal: Bool? = nil, is_local: Bool? = nil, is_remote: Bool? = nil, is_production: Bool? = nil, ahead_count: Int64? = nil, behind_count: Int64? = nil, commit_at: Int64? = nil, ref: String? = nil, remote_ref: String? = nil) {
        self.can = can
        self._name = name.map(AnyString.init)
        self._remote = remote.map(AnyString.init)
        self._remote_name = remote_name.map(AnyString.init)
        self._error = error.map(AnyString.init)
        self._message = message.map(AnyString.init)
        self._owner_name = owner_name.map(AnyString.init)
        self.readonly = readonly
        self.personal = personal
        self.is_local = is_local
        self.is_remote = is_remote
        self.is_production = is_production
        self._ahead_count = ahead_count.map(AnyInt.init)
        self._behind_count = behind_count.map(AnyInt.init)
        self._commit_at = commit_at.map(AnyInt.init)
        self._ref = ref.map(AnyString.init)
        self._remote_ref = remote_ref.map(AnyString.init)
    }

}

public struct GitConnectionTest: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _description = "description"
        case _id = "id"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _description: AnyString?
    /**
     * Human readable string describing the test (read-only)
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    private var _id: AnyString?
    /**
     * A short string, uniquely naming this test (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, description: String? = nil, id: String? = nil) {
        self.can = can
        self._description = description.map(AnyString.init)
        self._id = id.map(AnyString.init)
    }

}

public struct GitConnectionTestResult: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _message = "message"
        case _status = "status"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * A short string, uniquely naming this test (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _message: AnyString?
    /**
     * Additional data from the test (read-only)
     */
    public var message: String? {
        get { _message?.value }
        set { _message = newValue.map(AnyString.init) }
    }

    private var _status: AnyString?
    /**
     * Either 'pass' or 'fail' (read-only)
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, message: String? = nil, status: String? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._message = message.map(AnyString.init)
        self._status = status.map(AnyString.init)
    }

}

public struct GitStatus: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _action = "action"
        case conflict
        case revertable
        case _text = "text"
    }
    private var _action: AnyString?
    /**
     * Git action: add, delete, etc (read-only)
     */
    public var action: String? {
        get { _action?.value }
        set { _action = newValue.map(AnyString.init) }
    }

    /**
     * When true, changes to the local file conflict with the remote repository (read-only)
     */
    public var conflict: Bool?

    /**
     * When true, the file can be reverted to an earlier state (read-only)
     */
    public var revertable: Bool?

    private var _text: AnyString?
    /**
     * Git description of the action (read-only)
     */
    public var text: String? {
        get { _text?.value }
        set { _text = newValue.map(AnyString.init) }
    }

    public init(action: String? = nil, conflict: Bool? = nil, revertable: Bool? = nil, text: String? = nil) {
        self._action = action.map(AnyString.init)
        self.conflict = conflict
        self.revertable = revertable
        self._text = text.map(AnyString.init)
    }

}

public struct LkGroup: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case can_add_to_content_metadata
        case contains_current_user
        case _external_group_id = "external_group_id"
        case externally_managed
        case _id = "id"
        case include_by_default
        case _name = "name"
        case _user_count = "user_count"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    /**
     * Group can be used in content access controls
     */
    public var can_add_to_content_metadata: Bool?

    /**
     * Currently logged in user is group member (read-only)
     */
    public var contains_current_user: Bool?

    private var _external_group_id: AnyString?
    /**
     * External Id group if embed group (read-only)
     */
    public var external_group_id: String? {
        get { _external_group_id?.value }
        set { _external_group_id = newValue.map(AnyString.init) }
    }

    /**
     * Group membership controlled outside of Looker (read-only)
     */
    public var externally_managed: Bool?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    /**
     * New users are added to this group by default (read-only)
     */
    public var include_by_default: Bool?

    private var _name: AnyString?
    /**
     * Name of group
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _user_count: AnyInt?
    /**
     * Number of users included in this group (read-only)
     */
    public var user_count: Int64? {
        get { _user_count?.value }
        set { _user_count = newValue.map(AnyInt.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, can_add_to_content_metadata: Bool? = nil, contains_current_user: Bool? = nil, external_group_id: String? = nil, externally_managed: Bool? = nil, id: String? = nil, include_by_default: Bool? = nil, name: String? = nil, user_count: Int64? = nil) {
        self.can = can
        self.can_add_to_content_metadata = can_add_to_content_metadata
        self.contains_current_user = contains_current_user
        self._external_group_id = external_group_id.map(AnyString.init)
        self.externally_managed = externally_managed
        self._id = id.map(AnyString.init)
        self.include_by_default = include_by_default
        self._name = name.map(AnyString.init)
        self._user_count = user_count.map(AnyInt.init)
    }

}

public struct GroupHierarchy: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case can_add_to_content_metadata
        case contains_current_user
        case _external_group_id = "external_group_id"
        case externally_managed
        case _id = "id"
        case include_by_default
        case _name = "name"
        case _user_count = "user_count"
        case _parent_group_ids = "parent_group_ids"
        case _role_ids = "role_ids"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    /**
     * Group can be used in content access controls
     */
    public var can_add_to_content_metadata: Bool?

    /**
     * Currently logged in user is group member (read-only)
     */
    public var contains_current_user: Bool?

    private var _external_group_id: AnyString?
    /**
     * External Id group if embed group (read-only)
     */
    public var external_group_id: String? {
        get { _external_group_id?.value }
        set { _external_group_id = newValue.map(AnyString.init) }
    }

    /**
     * Group membership controlled outside of Looker (read-only)
     */
    public var externally_managed: Bool?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    /**
     * New users are added to this group by default (read-only)
     */
    public var include_by_default: Bool?

    private var _name: AnyString?
    /**
     * Name of group
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _user_count: AnyInt?
    /**
     * Number of users included in this group (read-only)
     */
    public var user_count: Int64? {
        get { _user_count?.value }
        set { _user_count = newValue.map(AnyInt.init) }
    }

    private var _parent_group_ids: [AnyString]?
    /**
     * IDs of parents of this group (read-only)
     */
    public var parent_group_ids: [String]? {
        get { if let v = _parent_group_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _parent_group_ids = v.map { AnyString.init($0) } } else { _parent_group_ids = nil } }
    }

    private var _role_ids: [AnyString]?
    /**
     * Role IDs assigned to group (read-only)
     */
    public var role_ids: [String]? {
        get { if let v = _role_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _role_ids = v.map { AnyString.init($0) } } else { _role_ids = nil } }
    }

    public init(can: StringDictionary<Bool>? = nil, can_add_to_content_metadata: Bool? = nil, contains_current_user: Bool? = nil, external_group_id: String? = nil, externally_managed: Bool? = nil, id: String? = nil, include_by_default: Bool? = nil, name: String? = nil, user_count: Int64? = nil, parent_group_ids: [String]? = nil, role_ids: [String]? = nil) {
        self.can = can
        self.can_add_to_content_metadata = can_add_to_content_metadata
        self.contains_current_user = contains_current_user
        self._external_group_id = external_group_id.map(AnyString.init)
        self.externally_managed = externally_managed
        self._id = id.map(AnyString.init)
        self.include_by_default = include_by_default
        self._name = name.map(AnyString.init)
        self._user_count = user_count.map(AnyInt.init)
        if let v = parent_group_ids { _parent_group_ids = v.map { AnyString.init($0) } } else { _parent_group_ids = nil }
        if let v = role_ids { _role_ids = v.map { AnyString.init($0) } } else { _role_ids = nil }
    }

}

/**
 * WARNING: no writeable properties found for POST, PUT, or PATCH
 */
public struct GroupIdForGroupInclusion: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _group_id = "group_id"
    }
    private var _group_id: AnyString?
    /**
     * Id of group (read-only)
     */
    public var group_id: String? {
        get { _group_id?.value }
        set { _group_id = newValue.map(AnyString.init) }
    }

    public init(group_id: String? = nil) {
        self._group_id = group_id.map(AnyString.init)
    }

}

/**
 * WARNING: no writeable properties found for POST, PUT, or PATCH
 */
public struct GroupIdForGroupUserInclusion: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _user_id = "user_id"
    }
    private var _user_id: AnyString?
    /**
     * Id of user (read-only)
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    public init(user_id: String? = nil) {
        self._user_id = user_id.map(AnyString.init)
    }

}

public struct GroupSearch: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case can_add_to_content_metadata
        case contains_current_user
        case _external_group_id = "external_group_id"
        case externally_managed
        case _id = "id"
        case include_by_default
        case _name = "name"
        case _user_count = "user_count"
        case roles
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    /**
     * Group can be used in content access controls
     */
    public var can_add_to_content_metadata: Bool?

    /**
     * Currently logged in user is group member (read-only)
     */
    public var contains_current_user: Bool?

    private var _external_group_id: AnyString?
    /**
     * External Id group if embed group (read-only)
     */
    public var external_group_id: String? {
        get { _external_group_id?.value }
        set { _external_group_id = newValue.map(AnyString.init) }
    }

    /**
     * Group membership controlled outside of Looker (read-only)
     */
    public var externally_managed: Bool?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    /**
     * New users are added to this group by default (read-only)
     */
    public var include_by_default: Bool?

    private var _name: AnyString?
    /**
     * Name of group
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _user_count: AnyInt?
    /**
     * Number of users included in this group (read-only)
     */
    public var user_count: Int64? {
        get { _user_count?.value }
        set { _user_count = newValue.map(AnyInt.init) }
    }

    /**
     * Roles assigned to group (read-only)
     */
    public var roles: [Role]?

    public init(can: StringDictionary<Bool>? = nil, can_add_to_content_metadata: Bool? = nil, contains_current_user: Bool? = nil, external_group_id: String? = nil, externally_managed: Bool? = nil, id: String? = nil, include_by_default: Bool? = nil, name: String? = nil, user_count: Int64? = nil, roles: [Role]? = nil) {
        self.can = can
        self.can_add_to_content_metadata = can_add_to_content_metadata
        self.contains_current_user = contains_current_user
        self._external_group_id = external_group_id.map(AnyString.init)
        self.externally_managed = externally_managed
        self._id = id.map(AnyString.init)
        self.include_by_default = include_by_default
        self._name = name.map(AnyString.init)
        self._user_count = user_count.map(AnyInt.init)
        self.roles = roles
    }

}

public struct HomepageItem: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _content_created_by = "content_created_by"
        case _content_favorite_id = "content_favorite_id"
        case _content_metadata_id = "content_metadata_id"
        case _content_updated_at = "content_updated_at"
        case _custom_description = "custom_description"
        case _custom_image_data_base64 = "custom_image_data_base64"
        case _custom_image_url = "custom_image_url"
        case _custom_title = "custom_title"
        case _custom_url = "custom_url"
        case _dashboard_id = "dashboard_id"
        case _description = "description"
        case _favorite_count = "favorite_count"
        case _homepage_section_id = "homepage_section_id"
        case _id = "id"
        case _image_url = "image_url"
        case _location = "location"
        case _look_id = "look_id"
        case _lookml_dashboard_id = "lookml_dashboard_id"
        case _order = "order"
        case section_fetch_time
        case _title = "title"
        case _url = "url"
        case use_custom_description
        case use_custom_image
        case use_custom_title
        case use_custom_url
        case _view_count = "view_count"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _content_created_by: AnyString?
    /**
     * Name of user who created the content this item is based on (read-only)
     */
    public var content_created_by: String? {
        get { _content_created_by?.value }
        set { _content_created_by = newValue.map(AnyString.init) }
    }

    private var _content_favorite_id: AnyString?
    /**
     * Content favorite id associated with the item this content is based on (read-only)
     */
    public var content_favorite_id: String? {
        get { _content_favorite_id?.value }
        set { _content_favorite_id = newValue.map(AnyString.init) }
    }

    private var _content_metadata_id: AnyString?
    /**
     * Content metadata id associated with the item this content is based on (read-only)
     */
    public var content_metadata_id: String? {
        get { _content_metadata_id?.value }
        set { _content_metadata_id = newValue.map(AnyString.init) }
    }

    private var _content_updated_at: AnyString?
    /**
     * Last time the content that this item is based on was updated (read-only)
     */
    public var content_updated_at: String? {
        get { _content_updated_at?.value }
        set { _content_updated_at = newValue.map(AnyString.init) }
    }

    private var _custom_description: AnyString?
    /**
     * Custom description entered by the user, if present
     */
    public var custom_description: String? {
        get { _custom_description?.value }
        set { _custom_description = newValue.map(AnyString.init) }
    }

    private var _custom_image_data_base64: AnyString?
    /**
     * (Write-Only) base64 encoded image data
     */
    public var custom_image_data_base64: String? {
        get { _custom_image_data_base64?.value }
        set { _custom_image_data_base64 = newValue.map(AnyString.init) }
    }

    private var _custom_image_url: AnyString?
    /**
     * Custom image_url entered by the user, if present (read-only)
     */
    public var custom_image_url: String? {
        get { _custom_image_url?.value }
        set { _custom_image_url = newValue.map(AnyString.init) }
    }

    private var _custom_title: AnyString?
    /**
     * Custom title entered by the user, if present
     */
    public var custom_title: String? {
        get { _custom_title?.value }
        set { _custom_title = newValue.map(AnyString.init) }
    }

    private var _custom_url: AnyString?
    /**
     * Custom url entered by the user, if present
     */
    public var custom_url: String? {
        get { _custom_url?.value }
        set { _custom_url = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString?
    /**
     * Dashboard to base this item on
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * The actual description for display (read-only)
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    private var _favorite_count: AnyInt?
    /**
     * Number of times content has been favorited, if present (read-only)
     */
    public var favorite_count: Int64? {
        get { _favorite_count?.value }
        set { _favorite_count = newValue.map(AnyInt.init) }
    }

    private var _homepage_section_id: AnyString?
    /**
     * Associated Homepage Section
     */
    public var homepage_section_id: String? {
        get { _homepage_section_id?.value }
        set { _homepage_section_id = newValue.map(AnyString.init) }
    }

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _image_url: AnyString?
    /**
     * The actual image_url for display (read-only)
     */
    public var image_url: String? {
        get { _image_url?.value }
        set { _image_url = newValue.map(AnyString.init) }
    }

    private var _location: AnyString?
    /**
     * The container folder name of the content (read-only)
     */
    public var location: String? {
        get { _location?.value }
        set { _location = newValue.map(AnyString.init) }
    }

    private var _look_id: AnyString?
    /**
     * Look to base this item on
     */
    public var look_id: String? {
        get { _look_id?.value }
        set { _look_id = newValue.map(AnyString.init) }
    }

    private var _lookml_dashboard_id: AnyString?
    /**
     * LookML Dashboard to base this item on
     */
    public var lookml_dashboard_id: String? {
        get { _lookml_dashboard_id?.value }
        set { _lookml_dashboard_id = newValue.map(AnyString.init) }
    }

    private var _order: AnyInt?
    /**
     * An arbitrary integer representing the sort order within the section
     */
    public var order: Int64? {
        get { _order?.value }
        set { _order = newValue.map(AnyInt.init) }
    }

    /**
     * Number of seconds it took to fetch the section this item is in (read-only)
     */
    public var section_fetch_time: Float?

    private var _title: AnyString?
    /**
     * The actual title for display (read-only)
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * The actual url for display (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    /**
     * Whether the custom description should be used instead of the content description, if the item is associated with content
     */
    public var use_custom_description: Bool?

    /**
     * Whether the custom image should be used instead of the content image, if the item is associated with content
     */
    public var use_custom_image: Bool?

    /**
     * Whether the custom title should be used instead of the content title, if the item is associated with content
     */
    public var use_custom_title: Bool?

    /**
     * Whether the custom url should be used instead of the content url, if the item is associated with content
     */
    public var use_custom_url: Bool?

    private var _view_count: AnyInt?
    /**
     * Number of times content has been viewed, if present (read-only)
     */
    public var view_count: Int64? {
        get { _view_count?.value }
        set { _view_count = newValue.map(AnyInt.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, content_created_by: String? = nil, content_favorite_id: String? = nil, content_metadata_id: String? = nil, content_updated_at: String? = nil, custom_description: String? = nil, custom_image_data_base64: String? = nil, custom_image_url: String? = nil, custom_title: String? = nil, custom_url: String? = nil, dashboard_id: String? = nil, description: String? = nil, favorite_count: Int64? = nil, homepage_section_id: String? = nil, id: String? = nil, image_url: String? = nil, location: String? = nil, look_id: String? = nil, lookml_dashboard_id: String? = nil, order: Int64? = nil, section_fetch_time: Float? = nil, title: String? = nil, url: String? = nil, use_custom_description: Bool? = nil, use_custom_image: Bool? = nil, use_custom_title: Bool? = nil, use_custom_url: Bool? = nil, view_count: Int64? = nil) {
        self.can = can
        self._content_created_by = content_created_by.map(AnyString.init)
        self._content_favorite_id = content_favorite_id.map(AnyString.init)
        self._content_metadata_id = content_metadata_id.map(AnyString.init)
        self._content_updated_at = content_updated_at.map(AnyString.init)
        self._custom_description = custom_description.map(AnyString.init)
        self._custom_image_data_base64 = custom_image_data_base64.map(AnyString.init)
        self._custom_image_url = custom_image_url.map(AnyString.init)
        self._custom_title = custom_title.map(AnyString.init)
        self._custom_url = custom_url.map(AnyString.init)
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self._favorite_count = favorite_count.map(AnyInt.init)
        self._homepage_section_id = homepage_section_id.map(AnyString.init)
        self._id = id.map(AnyString.init)
        self._image_url = image_url.map(AnyString.init)
        self._location = location.map(AnyString.init)
        self._look_id = look_id.map(AnyString.init)
        self._lookml_dashboard_id = lookml_dashboard_id.map(AnyString.init)
        self._order = order.map(AnyInt.init)
        self.section_fetch_time = section_fetch_time
        self._title = title.map(AnyString.init)
        self._url = url.map(AnyString.init)
        self.use_custom_description = use_custom_description
        self.use_custom_image = use_custom_image
        self.use_custom_title = use_custom_title
        self.use_custom_url = use_custom_url
        self._view_count = view_count.map(AnyInt.init)
    }

}

public struct HomepageSection: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case created_at
        case deleted_at
        case _detail_url = "detail_url"
        case _homepage_id = "homepage_id"
        case homepage_items
        case _id = "id"
        case is_header
        case _item_order = "item_order"
        case _title = "title"
        case updated_at
        case _description = "description"
        case _visible_item_order = "visible_item_order"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    /**
     * Time at which this section was created. (read-only)
     */
    public var created_at: Date?

    /**
     * Time at which this section was deleted.
     */
    public var deleted_at: Date?

    private var _detail_url: AnyString?
    /**
     * A URL pointing to a page showing further information about the content in the section. (read-only)
     */
    public var detail_url: String? {
        get { _detail_url?.value }
        set { _detail_url = newValue.map(AnyString.init) }
    }

    private var _homepage_id: AnyString?
    /**
     * Id reference to parent homepage
     */
    public var homepage_id: String? {
        get { _homepage_id?.value }
        set { _homepage_id = newValue.map(AnyString.init) }
    }

    /**
     * Items in the homepage section (read-only)
     */
    public var homepage_items: [HomepageItem]?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    /**
     * Is this a header section (has no items) (read-only)
     */
    public var is_header: Bool?

    private var _item_order: [AnyString]?
    /**
     * ids of the homepage items in the order they should be displayed
     */
    public var item_order: [String]? {
        get { if let v = _item_order { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _item_order = v.map { AnyString.init($0) } } else { _item_order = nil } }
    }

    private var _title: AnyString?
    /**
     * Name of row
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    /**
     * Time at which this section was last updated. (read-only)
     */
    public var updated_at: Date?

    private var _description: AnyString?
    /**
     * Description of the content found in this section.
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    private var _visible_item_order: [AnyString]?
    /**
     * ids of the homepage items the user can see in the order they should be displayed (read-only)
     */
    public var visible_item_order: [String]? {
        get { if let v = _visible_item_order { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _visible_item_order = v.map { AnyString.init($0) } } else { _visible_item_order = nil } }
    }

    public init(can: StringDictionary<Bool>? = nil, created_at: Date? = nil, deleted_at: Date? = nil, detail_url: String? = nil, homepage_id: String? = nil, homepage_items: [HomepageItem]? = nil, id: String? = nil, is_header: Bool? = nil, item_order: [String]? = nil, title: String? = nil, updated_at: Date? = nil, description: String? = nil, visible_item_order: [String]? = nil) {
        self.can = can
        self.created_at = created_at
        self.deleted_at = deleted_at
        self._detail_url = detail_url.map(AnyString.init)
        self._homepage_id = homepage_id.map(AnyString.init)
        self.homepage_items = homepage_items
        self._id = id.map(AnyString.init)
        self.is_header = is_header
        if let v = item_order { _item_order = v.map { AnyString.init($0) } } else { _item_order = nil }
        self._title = title.map(AnyString.init)
        self.updated_at = updated_at
        self._description = description.map(AnyString.init)
        if let v = visible_item_order { _visible_item_order = v.map { AnyString.init($0) } } else { _visible_item_order = nil }
    }

}

public struct ImportedProject: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _url = "url"
        case _ref = "ref"
        case is_remote
    }
    private var _name: AnyString?
    /**
     * Dependency name (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Url for a remote dependency (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    private var _ref: AnyString?
    /**
     * Ref for a remote dependency (read-only)
     */
    public var ref: String? {
        get { _ref?.value }
        set { _ref = newValue.map(AnyString.init) }
    }

    /**
     * Flag signifying if a dependency is remote or local (read-only)
     */
    public var is_remote: Bool?

    public init(name: String? = nil, url: String? = nil, ref: String? = nil, is_remote: Bool? = nil) {
        self._name = name.map(AnyString.init)
        self._url = url.map(AnyString.init)
        self._ref = ref.map(AnyString.init)
        self.is_remote = is_remote
    }

}

public struct InstanceConfig: SDKModel {
    /**
     * Feature flags enabled on the instance (read-only)
     */
    public var feature_flags: StringDictionary<Bool>?

    /**
     * License features enabled on the instance (read-only)
     */
    public var license_features: StringDictionary<Bool>?

    public init(feature_flags: StringDictionary<Bool>? = nil, license_features: StringDictionary<Bool>? = nil) {
        self.feature_flags = feature_flags
        self.license_features = license_features
    }

}

public struct Integration: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _integration_hub_id = "integration_hub_id"
        case _label = "label"
        case _description = "description"
        case enabled
        case params
        case supported_formats
        case supported_action_types
        case supported_formattings
        case supported_visualization_formattings
        case supported_download_settings
        case _icon_url = "icon_url"
        case uses_oauth
        case required_fields
        case _privacy_link = "privacy_link"
        case delegate_oauth
        case _installed_delegate_oauth_targets = "installed_delegate_oauth_targets"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * ID of the integration. (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _integration_hub_id: AnyString?
    /**
     * ID of the integration hub. (read-only)
     */
    public var integration_hub_id: String? {
        get { _integration_hub_id?.value }
        set { _integration_hub_id = newValue.map(AnyString.init) }
    }

    private var _label: AnyString?
    /**
     * Label for the integration. (read-only)
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * Description of the integration. (read-only)
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    /**
     * Whether the integration is available to users.
     */
    public var enabled: Bool?

    /**
     * Array of params for the integration.
     */
    public var params: [IntegrationParam]?

    /**
     * A list of data formats the integration supports. If unspecified, the default is all data formats. Valid values are: "txt", "csv", "inline_json", "json", "json_label", "json_detail", "json_detail_lite_stream", "json_bi", "xlsx", "html", "wysiwyg_pdf", "assembled_pdf", "wysiwyg_png", "csv_zip". (read-only)
     */
    public var supported_formats: [SupportedFormats]?

    /**
     * A list of action types the integration supports. Valid values are: "cell", "query", "dashboard", "none". (read-only)
     */
    public var supported_action_types: [SupportedActionTypes]?

    /**
     * A list of formatting options the integration supports. If unspecified, defaults to all formats. Valid values are: "formatted", "unformatted". (read-only)
     */
    public var supported_formattings: [SupportedFormattings]?

    /**
     * A list of visualization formatting options the integration supports. If unspecified, defaults to all formats. Valid values are: "apply", "noapply". (read-only)
     */
    public var supported_visualization_formattings: [SupportedVisualizationFormattings]?

    /**
     * A list of all the download mechanisms the integration supports. The order of values is not significant: Looker will select the most appropriate supported download mechanism for a given query. The integration must ensure it can handle any of the mechanisms it claims to support. If unspecified, this defaults to all download setting values. Valid values are: "push", "url". (read-only)
     */
    public var supported_download_settings: [SupportedDownloadSettings]?

    private var _icon_url: AnyString?
    /**
     * URL to an icon for the integration. (read-only)
     */
    public var icon_url: String? {
        get { _icon_url?.value }
        set { _icon_url = newValue.map(AnyString.init) }
    }

    /**
     * Whether the integration uses oauth. (read-only)
     */
    public var uses_oauth: Bool?

    /**
     * A list of descriptions of required fields that this integration is compatible with. If there are multiple entries in this list, the integration requires more than one field. If unspecified, no fields will be required. (read-only)
     */
    public var required_fields: [IntegrationRequiredField]?

    private var _privacy_link: AnyString?
    /**
     * Link to privacy policy for destination (read-only)
     */
    public var privacy_link: String? {
        get { _privacy_link?.value }
        set { _privacy_link = newValue.map(AnyString.init) }
    }

    /**
     * Whether the integration uses delegate oauth, which allows federation between an integration installation scope specific entity (like org, group, and team, etc.) and Looker. (read-only)
     */
    public var delegate_oauth: Bool?

    private var _installed_delegate_oauth_targets: [AnyString]?
    /**
     * Whether the integration is available to users.
     */
    public var installed_delegate_oauth_targets: [String]? {
        get { if let v = _installed_delegate_oauth_targets { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _installed_delegate_oauth_targets = v.map { AnyString.init($0) } } else { _installed_delegate_oauth_targets = nil } }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, integration_hub_id: String? = nil, label: String? = nil, description: String? = nil, enabled: Bool? = nil, params: [IntegrationParam]? = nil, supported_formats: [SupportedFormats]? = nil, supported_action_types: [SupportedActionTypes]? = nil, supported_formattings: [SupportedFormattings]? = nil, supported_visualization_formattings: [SupportedVisualizationFormattings]? = nil, supported_download_settings: [SupportedDownloadSettings]? = nil, icon_url: String? = nil, uses_oauth: Bool? = nil, required_fields: [IntegrationRequiredField]? = nil, privacy_link: String? = nil, delegate_oauth: Bool? = nil, installed_delegate_oauth_targets: [String]? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._integration_hub_id = integration_hub_id.map(AnyString.init)
        self._label = label.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self.enabled = enabled
        self.params = params
        self.supported_formats = supported_formats
        self.supported_action_types = supported_action_types
        self.supported_formattings = supported_formattings
        self.supported_visualization_formattings = supported_visualization_formattings
        self.supported_download_settings = supported_download_settings
        self._icon_url = icon_url.map(AnyString.init)
        self.uses_oauth = uses_oauth
        self.required_fields = required_fields
        self._privacy_link = privacy_link.map(AnyString.init)
        self.delegate_oauth = delegate_oauth
        if let v = installed_delegate_oauth_targets { _installed_delegate_oauth_targets = v.map { AnyString.init($0) } } else { _installed_delegate_oauth_targets = nil }
    }

}

public struct IntegrationHub: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _url = "url"
        case _label = "label"
        case official
        case _fetch_error_message = "fetch_error_message"
        case _authorization_token = "authorization_token"
        case has_authorization_token
        case legal_agreement_signed
        case legal_agreement_required
        case _legal_agreement_text = "legal_agreement_text"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * ID of the hub. (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * URL of the hub.
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    private var _label: AnyString?
    /**
     * Label of the hub. (read-only)
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    /**
     * Whether this hub is a first-party integration hub operated by Looker. (read-only)
     */
    public var official: Bool?

    private var _fetch_error_message: AnyString?
    /**
     * An error message, present if the integration hub metadata could not be fetched. If this is present, the integration hub is unusable. (read-only)
     */
    public var fetch_error_message: String? {
        get { _fetch_error_message?.value }
        set { _fetch_error_message = newValue.map(AnyString.init) }
    }

    private var _authorization_token: AnyString?
    /**
     * (Write-Only) An authorization key that will be sent to the integration hub on every request.
     */
    public var authorization_token: String? {
        get { _authorization_token?.value }
        set { _authorization_token = newValue.map(AnyString.init) }
    }

    /**
     * Whether the authorization_token is set for the hub. (read-only)
     */
    public var has_authorization_token: Bool?

    /**
     * Whether the legal agreement message has been signed by the user. This only matters if legal_agreement_required is true. (read-only)
     */
    public var legal_agreement_signed: Bool?

    /**
     * Whether the legal terms for the integration hub are required before use. (read-only)
     */
    public var legal_agreement_required: Bool?

    private var _legal_agreement_text: AnyString?
    /**
     * The legal agreement text for this integration hub. (read-only)
     */
    public var legal_agreement_text: String? {
        get { _legal_agreement_text?.value }
        set { _legal_agreement_text = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, url: String? = nil, label: String? = nil, official: Bool? = nil, fetch_error_message: String? = nil, authorization_token: String? = nil, has_authorization_token: Bool? = nil, legal_agreement_signed: Bool? = nil, legal_agreement_required: Bool? = nil, legal_agreement_text: String? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._url = url.map(AnyString.init)
        self._label = label.map(AnyString.init)
        self.official = official
        self._fetch_error_message = fetch_error_message.map(AnyString.init)
        self._authorization_token = authorization_token.map(AnyString.init)
        self.has_authorization_token = has_authorization_token
        self.legal_agreement_signed = legal_agreement_signed
        self.legal_agreement_required = legal_agreement_required
        self._legal_agreement_text = legal_agreement_text.map(AnyString.init)
    }

}

public struct IntegrationParam: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _label = "label"
        case _description = "description"
        case required
        case has_value
        case _value = "value"
        case _user_attribute_name = "user_attribute_name"
        case sensitive
        case per_user
        case _delegate_oauth_url = "delegate_oauth_url"
    }
    private var _name: AnyString?
    /**
     * Name of the parameter.
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _label: AnyString?
    /**
     * Label of the parameter. (read-only)
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * Short description of the parameter. (read-only)
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    /**
     * Whether the parameter is required to be set to use the destination. If unspecified, this defaults to false. (read-only)
     */
    public var required: Bool?

    /**
     * Whether the parameter has a value set. (read-only)
     */
    public var has_value: Bool?

    private var _value: AnyString?
    /**
     * The current value of the parameter. Always null if the value is sensitive. When writing, null values will be ignored. Set the value to an empty string to clear it.
     */
    public var value: String? {
        get { _value?.value }
        set { _value = newValue.map(AnyString.init) }
    }

    private var _user_attribute_name: AnyString?
    /**
     * When present, the param's value comes from this user attribute instead of the 'value' parameter. Set to null to use the 'value'.
     */
    public var user_attribute_name: String? {
        get { _user_attribute_name?.value }
        set { _user_attribute_name = newValue.map(AnyString.init) }
    }

    /**
     * Whether the parameter contains sensitive data like API credentials. If unspecified, this defaults to true. (read-only)
     */
    public var sensitive: Bool?

    /**
     * When true, this parameter must be assigned to a user attribute in the admin panel (instead of a constant value), and that value may be updated by the user as part of the integration flow. (read-only)
     */
    public var per_user: Bool?

    private var _delegate_oauth_url: AnyString?
    /**
     * When present, the param represents the oauth url the user will be taken to. (read-only)
     */
    public var delegate_oauth_url: String? {
        get { _delegate_oauth_url?.value }
        set { _delegate_oauth_url = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, label: String? = nil, description: String? = nil, required: Bool? = nil, has_value: Bool? = nil, value: String? = nil, user_attribute_name: String? = nil, sensitive: Bool? = nil, per_user: Bool? = nil, delegate_oauth_url: String? = nil) {
        self._name = name.map(AnyString.init)
        self._label = label.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self.required = required
        self.has_value = has_value
        self._value = value.map(AnyString.init)
        self._user_attribute_name = user_attribute_name.map(AnyString.init)
        self.sensitive = sensitive
        self.per_user = per_user
        self._delegate_oauth_url = delegate_oauth_url.map(AnyString.init)
    }

}

public struct IntegrationRequiredField: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _tag = "tag"
        case _any_tag = "any_tag"
        case _all_tags = "all_tags"
    }
    private var _tag: AnyString?
    /**
     * Matches a field that has this tag. (read-only)
     */
    public var tag: String? {
        get { _tag?.value }
        set { _tag = newValue.map(AnyString.init) }
    }

    private var _any_tag: [AnyString]?
    /**
     * If present, supersedes 'tag' and matches a field that has any of the provided tags. (read-only)
     */
    public var any_tag: [String]? {
        get { if let v = _any_tag { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _any_tag = v.map { AnyString.init($0) } } else { _any_tag = nil } }
    }

    private var _all_tags: [AnyString]?
    /**
     * If present, supersedes 'tag' and matches a field that has all of the provided tags. (read-only)
     */
    public var all_tags: [String]? {
        get { if let v = _all_tags { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _all_tags = v.map { AnyString.init($0) } } else { _all_tags = nil } }
    }

    public init(tag: String? = nil, any_tag: [String]? = nil, all_tags: [String]? = nil) {
        self._tag = tag.map(AnyString.init)
        if let v = any_tag { _any_tag = v.map { AnyString.init($0) } } else { _any_tag = nil }
        if let v = all_tags { _all_tags = v.map { AnyString.init($0) } } else { _all_tags = nil }
    }

}

public struct IntegrationTestResult: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case success
        case _message = "message"
        case delegate_oauth_result
    }
    /**
     * Whether or not the test was successful (read-only)
     */
    public var success: Bool?

    private var _message: AnyString?
    /**
     * A message representing the results of the test. (read-only)
     */
    public var message: String? {
        get { _message?.value }
        set { _message = newValue.map(AnyString.init) }
    }

    /**
     * An array of connection test result for delegate oauth actions. (read-only)
     */
    public var delegate_oauth_result: [DelegateOauthTest]?

    public init(success: Bool? = nil, message: String? = nil, delegate_oauth_result: [DelegateOauthTest]? = nil) {
        self.success = success
        self._message = message.map(AnyString.init)
        self.delegate_oauth_result = delegate_oauth_result
    }

}

public struct InternalHelpResources: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    /**
     * If true and internal help resources content is not blank then the link for internal help resources will be shown in the help menu and the content displayed within Looker
     */
    public var enabled: Bool?

    public init(can: StringDictionary<Bool>? = nil, enabled: Bool? = nil) {
        self.can = can
        self.enabled = enabled
    }

}

public struct InternalHelpResourcesContent: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _organization_name = "organization_name"
        case _markdown_content = "markdown_content"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _organization_name: AnyString?
    /**
     * Text to display in the help menu item which will display the internal help resources
     */
    public var organization_name: String? {
        get { _organization_name?.value }
        set { _organization_name = newValue.map(AnyString.init) }
    }

    private var _markdown_content: AnyString?
    /**
     * Content to be displayed in the internal help resources page/modal
     */
    public var markdown_content: String? {
        get { _markdown_content?.value }
        set { _markdown_content = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, organization_name: String? = nil, markdown_content: String? = nil) {
        self.can = can
        self._organization_name = organization_name.map(AnyString.init)
        self._markdown_content = markdown_content.map(AnyString.init)
    }

}

/**
 * The type of the investigative content Valid values are: "dashboard". (Enum defined in Alert)
 */
public enum InvestigativeContentType: String, Codable {
    case dashboard = "dashboard"
}

public struct JsonBi: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case metadata
        case _rows = "rows"
    }
    public var metadata: JsonBiMetadata

    private var _rows: [AnyString]
    /**
     * Json query results (read-only)
     */
    public var rows: [String] {
        get { _rows.map { $0.value } }
        set { _rows = newValue.map { AnyString.init($0) } }
    }

    public init(metadata: JsonBiMetadata, rows: [String]) {
        self.metadata = metadata
        self._rows = rows.map { AnyString.init($0) }
    }

    public init(_ metadata: JsonBiMetadata, _ rows: [String]) {
        self.init(metadata: metadata, rows: rows)
    }

}

public struct JsonBiBigQueryMetadata: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _total_bytes_processed = "total_bytes_processed"
        case backend_cache_hit
    }
    private var _total_bytes_processed: AnyInt
    /**
     * Total bytes processed by the BigQuery job (read-only)
     */
    public var total_bytes_processed: Int64 {
        get { _total_bytes_processed.value }
        set { _total_bytes_processed = AnyInt.init(newValue) }
    }

    /**
     * Return whether or not query results were served from the BigQuery cache. (read-only)
     */
    public var backend_cache_hit: Bool

    public init(total_bytes_processed: Int64, backend_cache_hit: Bool) {
        self._total_bytes_processed = AnyInt.init(total_bytes_processed)
        self.backend_cache_hit = backend_cache_hit
    }

    public init(_ total_bytes_processed: Int64, _ backend_cache_hit: Bool) {
        self.init(total_bytes_processed: total_bytes_processed, backend_cache_hit: backend_cache_hit)
    }

}

public struct JsonBiField: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _sql = "sql"
        case _view = "view"
        case _dimension_group = "dimension_group"
        case _category = "category"
        case _field_group_label = "field_group_label"
        case _name = "name"
        case _type = "type"
        case _view_label = "view_label"
        case _label = "label"
        case _field_group_variant = "field_group_variant"
        case hidden
        case _description = "description"
    }
    private var _sql: AnyString
    /**
     * SQL expressions for the field (read-only)
     */
    public var sql: String {
        get { _sql.value }
        set { _sql = AnyString.init(newValue) }
    }

    private var _view: AnyString
    /**
     * Explore name (read-only)
     */
    public var view: String {
        get { _view.value }
        set { _view = AnyString.init(newValue) }
    }

    private var _dimension_group: AnyString
    /**
     * Which dimension group created this dimension (read-only)
     */
    public var dimension_group: String {
        get { _dimension_group.value }
        set { _dimension_group = AnyString.init(newValue) }
    }

    private var _category: AnyString
    /**
     * Dimension, Measure, etc. (read-only)
     */
    public var category: String {
        get { _category.value }
        set { _category = AnyString.init(newValue) }
    }

    private var _field_group_label: AnyString
    /**
     * Field Group Label (read-only)
     */
    public var field_group_label: String {
        get { _field_group_label.value }
        set { _field_group_label = AnyString.init(newValue) }
    }

    private var _name: AnyString
    /**
     * Field Name (read-only)
     */
    public var name: String {
        get { _name.value }
        set { _name = AnyString.init(newValue) }
    }

    private var _type: AnyString
    /**
     * Field Type (read-only)
     */
    public var type: String {
        get { _type.value }
        set { _type = AnyString.init(newValue) }
    }

    private var _view_label: AnyString
    /**
     * View Label (read-only)
     */
    public var view_label: String {
        get { _view_label.value }
        set { _view_label = AnyString.init(newValue) }
    }

    private var _label: AnyString
    /**
     * Field Label (read-only)
     */
    public var label: String {
        get { _label.value }
        set { _label = AnyString.init(newValue) }
    }

    private var _field_group_variant: AnyString
    /**
     * Field Group Variant (read-only)
     */
    public var field_group_variant: String {
        get { _field_group_variant.value }
        set { _field_group_variant = AnyString.init(newValue) }
    }

    /**
     * If the field is marked as hidden in the Lookml (read-only)
     */
    public var hidden: Bool

    private var _description: AnyString
    /**
     * Field Description (read-only)
     */
    public var description: String {
        get { _description.value }
        set { _description = AnyString.init(newValue) }
    }

    public init(sql: String, view: String, dimension_group: String, category: String, field_group_label: String, name: String, type: String, view_label: String, label: String, field_group_variant: String, hidden: Bool, description: String) {
        self._sql = AnyString.init(sql)
        self._view = AnyString.init(view)
        self._dimension_group = AnyString.init(dimension_group)
        self._category = AnyString.init(category)
        self._field_group_label = AnyString.init(field_group_label)
        self._name = AnyString.init(name)
        self._type = AnyString.init(type)
        self._view_label = AnyString.init(view_label)
        self._label = AnyString.init(label)
        self._field_group_variant = AnyString.init(field_group_variant)
        self.hidden = hidden
        self._description = AnyString.init(description)
    }

    public init(_ sql: String, _ view: String, _ dimension_group: String, _ category: String, _ field_group_label: String, _ name: String, _ type: String, _ view_label: String, _ label: String, _ field_group_variant: String, _ hidden: Bool, _ description: String) {
        self.init(sql: sql, view: view, dimension_group: dimension_group, category: category, field_group_label: field_group_label, name: name, type: type, view_label: view_label, label: label, field_group_variant: field_group_variant, hidden: hidden, description: description)
    }

}

public struct JsonBiFields: SDKModel {
    /**
     * Dimensions represent a column in a table, or a computed value based on some sort of column manipulation or combination (read-only)
     */
    public var dimensions: [JsonBiField]

    /**
     * Measures are similar to aggregate functions in SQL (for example, COUNT, SUM, AVG) and represent information about multiple rows (read-only)
     */
    public var measures: [JsonBiField]

    /**
     * Pivots (read-only)
     */
    public var pivots: [JsonBiField]

    /**
     * Table Calculations (read-only)
     */
    public var table_calculations: [JsonBiTableCalc]

    public init(dimensions: [JsonBiField], measures: [JsonBiField], pivots: [JsonBiField], table_calculations: [JsonBiTableCalc]) {
        self.dimensions = dimensions
        self.measures = measures
        self.pivots = pivots
        self.table_calculations = table_calculations
    }

    public init(_ dimensions: [JsonBiField], _ measures: [JsonBiField], _ pivots: [JsonBiField], _ table_calculations: [JsonBiTableCalc]) {
        self.init(dimensions: dimensions, measures: measures, pivots: pivots, table_calculations: table_calculations)
    }

}

public struct JsonBiMetadata: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case big_query_metadata
        case fields
        case pivots
        case has_subtotals
        case has_totals
        case _columns_truncated = "columns_truncated"
        case _filter_expression = "filter_expression"
        case filters
        case _sql = "sql"
    }
    public var big_query_metadata: JsonBiBigQueryMetadata

    public var fields: JsonBiFields

    /**
     * Pivots (read-only)
     */
    public var pivots: [JsonBiPivots]

    /**
     * If the query has subtotals (read-only)
     */
    public var has_subtotals: Bool

    /**
     * If the query has totals (read-only)
     */
    public var has_totals: Bool

    private var _columns_truncated: AnyString
    /**
     * If the query results hit the maximum column limit and additional columns were truncated (read-only)
     */
    public var columns_truncated: String {
        get { _columns_truncated.value }
        set { _columns_truncated = AnyString.init(newValue) }
    }

    private var _filter_expression: AnyString
    /**
     * Filter expression applied to the query results (read-only)
     */
    public var filter_expression: String {
        get { _filter_expression.value }
        set { _filter_expression = AnyString.init(newValue) }
    }

    /**
     * Filters applied to the query results (read-only)
     */
    public var filters: StringDictionary<AnyCodable>

    private var _sql: AnyString
    /**
     * Raw sql query. Null if user does not have permission to view sql (read-only)
     */
    public var sql: String {
        get { _sql.value }
        set { _sql = AnyString.init(newValue) }
    }

    public init(big_query_metadata: JsonBiBigQueryMetadata, fields: JsonBiFields, pivots: [JsonBiPivots], has_subtotals: Bool, has_totals: Bool, columns_truncated: String, filter_expression: String, filters: StringDictionary<AnyCodable>, sql: String) {
        self.big_query_metadata = big_query_metadata
        self.fields = fields
        self.pivots = pivots
        self.has_subtotals = has_subtotals
        self.has_totals = has_totals
        self._columns_truncated = AnyString.init(columns_truncated)
        self._filter_expression = AnyString.init(filter_expression)
        self.filters = filters
        self._sql = AnyString.init(sql)
    }

    public init(_ big_query_metadata: JsonBiBigQueryMetadata, _ fields: JsonBiFields, _ pivots: [JsonBiPivots], _ has_subtotals: Bool, _ has_totals: Bool, _ columns_truncated: String, _ filter_expression: String, _ filters: StringDictionary<AnyCodable>, _ sql: String) {
        self.init(big_query_metadata: big_query_metadata, fields: fields, pivots: pivots, has_subtotals: has_subtotals, has_totals: has_totals, columns_truncated: columns_truncated, filter_expression: filter_expression, filters: filters, sql: sql)
    }

}

public struct JsonBiPivots: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _key = "key"
        case data
        case sort_values
        case is_total
    }
    private var _key: AnyString
    /**
     * Pivot Column Value (read-only)
     */
    public var key: String {
        get { _key.value }
        set { _key = AnyString.init(newValue) }
    }

    /**
     * Pivot Data (read-only)
     */
    public var data: StringDictionary<AnyCodable>

    /**
     * Pivot Sort Values (read-only)
     */
    public var sort_values: StringDictionary<AnyCodable>

    /**
     * If the value is a total (read-only)
     */
    public var is_total: Bool

    public init(key: String, data: StringDictionary<AnyCodable>, sort_values: StringDictionary<AnyCodable>, is_total: Bool) {
        self._key = AnyString.init(key)
        self.data = data
        self.sort_values = sort_values
        self.is_total = is_total
    }

    public init(_ key: String, _ data: StringDictionary<AnyCodable>, _ sort_values: StringDictionary<AnyCodable>, _ is_total: Bool) {
        self.init(key: key, data: data, sort_values: sort_values, is_total: is_total)
    }

}

public struct JsonBiTableCalc: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _label = "label"
        case _align = "align"
        case _expression = "expression"
        case _value_format = "value_format"
        case measure
    }
    private var _name: AnyString
    /**
     * Table Calc Name (read-only)
     */
    public var name: String {
        get { _name.value }
        set { _name = AnyString.init(newValue) }
    }

    private var _label: AnyString
    /**
     * Table Calc Label (read-only)
     */
    public var label: String {
        get { _label.value }
        set { _label = AnyString.init(newValue) }
    }

    private var _align: AnyString
    /**
     * Alignment (read-only)
     */
    public var align: String {
        get { _align.value }
        set { _align = AnyString.init(newValue) }
    }

    private var _expression: AnyString
    /**
     * Evaluated table calculation expression (read-only)
     */
    public var expression: String {
        get { _expression.value }
        set { _expression = AnyString.init(newValue) }
    }

    private var _value_format: AnyString
    /**
     * Value format (read-only)
     */
    public var value_format: String {
        get { _value_format.value }
        set { _value_format = AnyString.init(newValue) }
    }

    /**
     * If table calculation is a measure (read-only)
     */
    public var measure: Bool

    public init(name: String, label: String, align: String, expression: String, value_format: String, measure: Bool) {
        self._name = AnyString.init(name)
        self._label = AnyString.init(label)
        self._align = AnyString.init(align)
        self._expression = AnyString.init(expression)
        self._value_format = AnyString.init(value_format)
        self.measure = measure
    }

    public init(_ name: String, _ label: String, _ align: String, _ expression: String, _ value_format: String, _ measure: Bool) {
        self.init(name: name, label: label, align: align, expression: expression, value_format: value_format, measure: measure)
    }

}

/**
 * The type of calculation for the period_over_period measure. Valid values are: "previous", "difference", "relative_change". (Enum defined in LookmlModelExploreFieldPeriodOverPeriodParams)
 */
public enum Kind: String, Codable {
    case previous = "previous"
    case difference = "difference"
    case relative_change = "relative_change"
}

public struct LDAPConfig: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case alternate_email_login_allowed
        case _auth_password = "auth_password"
        case auth_requires_role
        case _auth_username = "auth_username"
        case _connection_host = "connection_host"
        case _connection_port = "connection_port"
        case connection_tls
        case connection_tls_no_verify
        case _default_new_user_group_ids = "default_new_user_group_ids"
        case default_new_user_groups
        case _default_new_user_role_ids = "default_new_user_role_ids"
        case default_new_user_roles
        case enabled
        case force_no_page
        case groups
        case _groups_base_dn = "groups_base_dn"
        case _groups_finder_type = "groups_finder_type"
        case _groups_member_attribute = "groups_member_attribute"
        case _groups_objectclasses = "groups_objectclasses"
        case _groups_user_attribute = "groups_user_attribute"
        case groups_with_role_ids
        case has_auth_password
        case merge_new_users_by_email
        case _modified_at = "modified_at"
        case _modified_by = "modified_by"
        case set_roles_from_groups
        case _test_ldap_password = "test_ldap_password"
        case _test_ldap_user = "test_ldap_user"
        case _user_attribute_map_email = "user_attribute_map_email"
        case _user_attribute_map_first_name = "user_attribute_map_first_name"
        case _user_attribute_map_last_name = "user_attribute_map_last_name"
        case _user_attribute_map_ldap_id = "user_attribute_map_ldap_id"
        case user_attributes
        case user_attributes_with_ids
        case _user_bind_base_dn = "user_bind_base_dn"
        case _user_custom_filter = "user_custom_filter"
        case _user_id_attribute_names = "user_id_attribute_names"
        case _user_objectclass = "user_objectclass"
        case allow_normal_group_membership
        case allow_roles_from_normal_groups
        case allow_direct_roles
        case _url = "url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    /**
     * Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
     */
    public var alternate_email_login_allowed: Bool?

    private var _auth_password: AnyString?
    /**
     * (Write-Only)  Password for the LDAP account used to access the LDAP server
     */
    public var auth_password: String? {
        get { _auth_password?.value }
        set { _auth_password = newValue.map(AnyString.init) }
    }

    /**
     * Users will not be allowed to login at all unless a role for them is found in LDAP if set to true
     */
    public var auth_requires_role: Bool?

    private var _auth_username: AnyString?
    /**
     * Distinguished name of LDAP account used to access the LDAP server
     */
    public var auth_username: String? {
        get { _auth_username?.value }
        set { _auth_username = newValue.map(AnyString.init) }
    }

    private var _connection_host: AnyString?
    /**
     * LDAP server hostname
     */
    public var connection_host: String? {
        get { _connection_host?.value }
        set { _connection_host = newValue.map(AnyString.init) }
    }

    private var _connection_port: AnyString?
    /**
     * LDAP host port
     */
    public var connection_port: String? {
        get { _connection_port?.value }
        set { _connection_port = newValue.map(AnyString.init) }
    }

    /**
     * Use Transport Layer Security
     */
    public var connection_tls: Bool?

    /**
     * Do not verify peer when using TLS
     */
    public var connection_tls_no_verify: Bool?

    private var _default_new_user_group_ids: [AnyString]?
    /**
     * (Write-Only)  Array of ids of groups that will be applied to new users the first time they login via LDAP
     */
    public var default_new_user_group_ids: [String]? {
        get { if let v = _default_new_user_group_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _default_new_user_group_ids = v.map { AnyString.init($0) } } else { _default_new_user_group_ids = nil } }
    }

    /**
     * (Read-only) Groups that will be applied to new users the first time they login via LDAP (read-only)
     */
    public var default_new_user_groups: [LkGroup]?

    private var _default_new_user_role_ids: [AnyString]?
    /**
     * (Write-Only)  Array of ids of roles that will be applied to new users the first time they login via LDAP
     */
    public var default_new_user_role_ids: [String]? {
        get { if let v = _default_new_user_role_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _default_new_user_role_ids = v.map { AnyString.init($0) } } else { _default_new_user_role_ids = nil } }
    }

    /**
     * (Read-only) Roles that will be applied to new users the first time they login via LDAP (read-only)
     */
    public var default_new_user_roles: [Role]?

    /**
     * Enable/Disable LDAP authentication for the server
     */
    public var enabled: Bool?

    /**
     * Don't attempt to do LDAP search result paging (RFC 2696) even if the LDAP server claims to support it.
     */
    public var force_no_page: Bool?

    /**
     * (Read-only) Array of mappings between LDAP Groups and Looker Roles (read-only)
     */
    public var groups: [LDAPGroupRead]?

    private var _groups_base_dn: AnyString?
    /**
     * Base dn for finding groups in LDAP searches
     */
    public var groups_base_dn: String? {
        get { _groups_base_dn?.value }
        set { _groups_base_dn = newValue.map(AnyString.init) }
    }

    private var _groups_finder_type: AnyString?
    /**
     * Identifier for a strategy for how Looker will search for groups in the LDAP server
     */
    public var groups_finder_type: String? {
        get { _groups_finder_type?.value }
        set { _groups_finder_type = newValue.map(AnyString.init) }
    }

    private var _groups_member_attribute: AnyString?
    /**
     * LDAP Group attribute that signifies the members of the groups. Most commonly 'member'
     */
    public var groups_member_attribute: String? {
        get { _groups_member_attribute?.value }
        set { _groups_member_attribute = newValue.map(AnyString.init) }
    }

    private var _groups_objectclasses: AnyString?
    /**
     * Optional comma-separated list of supported LDAP objectclass for groups when doing groups searches
     */
    public var groups_objectclasses: String? {
        get { _groups_objectclasses?.value }
        set { _groups_objectclasses = newValue.map(AnyString.init) }
    }

    private var _groups_user_attribute: AnyString?
    /**
     * LDAP Group attribute that signifies the user in a group. Most commonly 'dn'
     */
    public var groups_user_attribute: String? {
        get { _groups_user_attribute?.value }
        set { _groups_user_attribute = newValue.map(AnyString.init) }
    }

    /**
     * (Read/Write) Array of mappings between LDAP Groups and arrays of Looker Role ids
     */
    public var groups_with_role_ids: [LDAPGroupWrite]?

    /**
     * (Read-only) Has the password been set for the LDAP account used to access the LDAP server (read-only)
     */
    public var has_auth_password: Bool?

    /**
     * Merge first-time ldap login to existing user account by email addresses. When a user logs in for the first time via ldap this option will connect this user into their existing account by finding the account with a matching email address. Otherwise a new user account will be created for the user.
     */
    public var merge_new_users_by_email: Bool?

    private var _modified_at: AnyString?
    /**
     * When this config was last modified (read-only)
     */
    public var modified_at: String? {
        get { _modified_at?.value }
        set { _modified_at = newValue.map(AnyString.init) }
    }

    private var _modified_by: AnyString?
    /**
     * User id of user who last modified this config (read-only)
     */
    public var modified_by: String? {
        get { _modified_by?.value }
        set { _modified_by = newValue.map(AnyString.init) }
    }

    /**
     * Set user roles in Looker based on groups from LDAP
     */
    public var set_roles_from_groups: Bool?

    private var _test_ldap_password: AnyString?
    /**
     * (Write-Only)  Test LDAP user password. For ldap tests only.
     */
    public var test_ldap_password: String? {
        get { _test_ldap_password?.value }
        set { _test_ldap_password = newValue.map(AnyString.init) }
    }

    private var _test_ldap_user: AnyString?
    /**
     * (Write-Only)  Test LDAP user login id. For ldap tests only.
     */
    public var test_ldap_user: String? {
        get { _test_ldap_user?.value }
        set { _test_ldap_user = newValue.map(AnyString.init) }
    }

    private var _user_attribute_map_email: AnyString?
    /**
     * Name of user record attributes used to indicate email address field
     */
    public var user_attribute_map_email: String? {
        get { _user_attribute_map_email?.value }
        set { _user_attribute_map_email = newValue.map(AnyString.init) }
    }

    private var _user_attribute_map_first_name: AnyString?
    /**
     * Name of user record attributes used to indicate first name
     */
    public var user_attribute_map_first_name: String? {
        get { _user_attribute_map_first_name?.value }
        set { _user_attribute_map_first_name = newValue.map(AnyString.init) }
    }

    private var _user_attribute_map_last_name: AnyString?
    /**
     * Name of user record attributes used to indicate last name
     */
    public var user_attribute_map_last_name: String? {
        get { _user_attribute_map_last_name?.value }
        set { _user_attribute_map_last_name = newValue.map(AnyString.init) }
    }

    private var _user_attribute_map_ldap_id: AnyString?
    /**
     * Name of user record attributes used to indicate unique record id
     */
    public var user_attribute_map_ldap_id: String? {
        get { _user_attribute_map_ldap_id?.value }
        set { _user_attribute_map_ldap_id = newValue.map(AnyString.init) }
    }

    /**
     * (Read-only) Array of mappings between LDAP User Attributes and Looker User Attributes (read-only)
     */
    public var user_attributes: [LDAPUserAttributeRead]?

    /**
     * (Read/Write) Array of mappings between LDAP User Attributes and arrays of Looker User Attribute ids
     */
    public var user_attributes_with_ids: [LDAPUserAttributeWrite]?

    private var _user_bind_base_dn: AnyString?
    /**
     * Distinguished name of LDAP node used as the base for user searches
     */
    public var user_bind_base_dn: String? {
        get { _user_bind_base_dn?.value }
        set { _user_bind_base_dn = newValue.map(AnyString.init) }
    }

    private var _user_custom_filter: AnyString?
    /**
     * (Optional) Custom RFC-2254 filter clause for use in finding user during login. Combined via 'and' with the other generated filter clauses.
     */
    public var user_custom_filter: String? {
        get { _user_custom_filter?.value }
        set { _user_custom_filter = newValue.map(AnyString.init) }
    }

    private var _user_id_attribute_names: AnyString?
    /**
     * Name(s) of user record attributes used for matching user login id (comma separated list)
     */
    public var user_id_attribute_names: String? {
        get { _user_id_attribute_names?.value }
        set { _user_id_attribute_names = newValue.map(AnyString.init) }
    }

    private var _user_objectclass: AnyString?
    /**
     * (Optional) Name of user record objectclass used for finding user during login id
     */
    public var user_objectclass: String? {
        get { _user_objectclass?.value }
        set { _user_objectclass = newValue.map(AnyString.init) }
    }

    /**
     * Allow LDAP auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.
     */
    public var allow_normal_group_membership: Bool?

    /**
     * LDAP auth'd users will be able to inherit roles from non-reflected Looker groups.
     */
    public var allow_roles_from_normal_groups: Bool?

    /**
     * Allows roles to be directly assigned to LDAP auth'd users.
     */
    public var allow_direct_roles: Bool?

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, alternate_email_login_allowed: Bool? = nil, auth_password: String? = nil, auth_requires_role: Bool? = nil, auth_username: String? = nil, connection_host: String? = nil, connection_port: String? = nil, connection_tls: Bool? = nil, connection_tls_no_verify: Bool? = nil, default_new_user_group_ids: [String]? = nil, default_new_user_groups: [LkGroup]? = nil, default_new_user_role_ids: [String]? = nil, default_new_user_roles: [Role]? = nil, enabled: Bool? = nil, force_no_page: Bool? = nil, groups: [LDAPGroupRead]? = nil, groups_base_dn: String? = nil, groups_finder_type: String? = nil, groups_member_attribute: String? = nil, groups_objectclasses: String? = nil, groups_user_attribute: String? = nil, groups_with_role_ids: [LDAPGroupWrite]? = nil, has_auth_password: Bool? = nil, merge_new_users_by_email: Bool? = nil, modified_at: String? = nil, modified_by: String? = nil, set_roles_from_groups: Bool? = nil, test_ldap_password: String? = nil, test_ldap_user: String? = nil, user_attribute_map_email: String? = nil, user_attribute_map_first_name: String? = nil, user_attribute_map_last_name: String? = nil, user_attribute_map_ldap_id: String? = nil, user_attributes: [LDAPUserAttributeRead]? = nil, user_attributes_with_ids: [LDAPUserAttributeWrite]? = nil, user_bind_base_dn: String? = nil, user_custom_filter: String? = nil, user_id_attribute_names: String? = nil, user_objectclass: String? = nil, allow_normal_group_membership: Bool? = nil, allow_roles_from_normal_groups: Bool? = nil, allow_direct_roles: Bool? = nil, url: String? = nil) {
        self.can = can
        self.alternate_email_login_allowed = alternate_email_login_allowed
        self._auth_password = auth_password.map(AnyString.init)
        self.auth_requires_role = auth_requires_role
        self._auth_username = auth_username.map(AnyString.init)
        self._connection_host = connection_host.map(AnyString.init)
        self._connection_port = connection_port.map(AnyString.init)
        self.connection_tls = connection_tls
        self.connection_tls_no_verify = connection_tls_no_verify
        if let v = default_new_user_group_ids { _default_new_user_group_ids = v.map { AnyString.init($0) } } else { _default_new_user_group_ids = nil }
        self.default_new_user_groups = default_new_user_groups
        if let v = default_new_user_role_ids { _default_new_user_role_ids = v.map { AnyString.init($0) } } else { _default_new_user_role_ids = nil }
        self.default_new_user_roles = default_new_user_roles
        self.enabled = enabled
        self.force_no_page = force_no_page
        self.groups = groups
        self._groups_base_dn = groups_base_dn.map(AnyString.init)
        self._groups_finder_type = groups_finder_type.map(AnyString.init)
        self._groups_member_attribute = groups_member_attribute.map(AnyString.init)
        self._groups_objectclasses = groups_objectclasses.map(AnyString.init)
        self._groups_user_attribute = groups_user_attribute.map(AnyString.init)
        self.groups_with_role_ids = groups_with_role_ids
        self.has_auth_password = has_auth_password
        self.merge_new_users_by_email = merge_new_users_by_email
        self._modified_at = modified_at.map(AnyString.init)
        self._modified_by = modified_by.map(AnyString.init)
        self.set_roles_from_groups = set_roles_from_groups
        self._test_ldap_password = test_ldap_password.map(AnyString.init)
        self._test_ldap_user = test_ldap_user.map(AnyString.init)
        self._user_attribute_map_email = user_attribute_map_email.map(AnyString.init)
        self._user_attribute_map_first_name = user_attribute_map_first_name.map(AnyString.init)
        self._user_attribute_map_last_name = user_attribute_map_last_name.map(AnyString.init)
        self._user_attribute_map_ldap_id = user_attribute_map_ldap_id.map(AnyString.init)
        self.user_attributes = user_attributes
        self.user_attributes_with_ids = user_attributes_with_ids
        self._user_bind_base_dn = user_bind_base_dn.map(AnyString.init)
        self._user_custom_filter = user_custom_filter.map(AnyString.init)
        self._user_id_attribute_names = user_id_attribute_names.map(AnyString.init)
        self._user_objectclass = user_objectclass.map(AnyString.init)
        self.allow_normal_group_membership = allow_normal_group_membership
        self.allow_roles_from_normal_groups = allow_roles_from_normal_groups
        self.allow_direct_roles = allow_direct_roles
        self._url = url.map(AnyString.init)
    }

}

public struct LDAPConfigTestIssue: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _severity = "severity"
        case _message = "message"
    }
    private var _severity: AnyString?
    /**
     * Severity of the issue. Error or Warning (read-only)
     */
    public var severity: String? {
        get { _severity?.value }
        set { _severity = newValue.map(AnyString.init) }
    }

    private var _message: AnyString?
    /**
     * Message describing the issue (read-only)
     */
    public var message: String? {
        get { _message?.value }
        set { _message = newValue.map(AnyString.init) }
    }

    public init(severity: String? = nil, message: String? = nil) {
        self._severity = severity.map(AnyString.init)
        self._message = message.map(AnyString.init)
    }

}

public struct LDAPConfigTestResult: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _details = "details"
        case issues
        case _message = "message"
        case _status = "status"
        case _trace = "trace"
        case user
        case _url = "url"
    }
    private var _details: AnyString?
    /**
     * Additional details for error cases (read-only)
     */
    public var details: String? {
        get { _details?.value }
        set { _details = newValue.map(AnyString.init) }
    }

    /**
     * Array of issues/considerations about the result (read-only)
     */
    public var issues: [LDAPConfigTestIssue]?

    private var _message: AnyString?
    /**
     * Short human readable test about the result (read-only)
     */
    public var message: String? {
        get { _message?.value }
        set { _message = newValue.map(AnyString.init) }
    }

    private var _status: AnyString?
    /**
     * Test status code: always 'success' or 'error' (read-only)
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    private var _trace: AnyString?
    /**
     * A more detailed trace of incremental results during auth tests (read-only)
     */
    public var trace: String? {
        get { _trace?.value }
        set { _trace = newValue.map(AnyString.init) }
    }

    public var user: LDAPUser?

    private var _url: AnyString?
    /**
     * Link to ldap config (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(details: String? = nil, issues: [LDAPConfigTestIssue]? = nil, message: String? = nil, status: String? = nil, trace: String? = nil, user: LDAPUser? = nil, url: String? = nil) {
        self._details = details.map(AnyString.init)
        self.issues = issues
        self._message = message.map(AnyString.init)
        self._status = status.map(AnyString.init)
        self._trace = trace.map(AnyString.init)
        self.user = user
        self._url = url.map(AnyString.init)
    }

}

public struct LDAPGroupRead: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _looker_group_id = "looker_group_id"
        case _looker_group_name = "looker_group_name"
        case _name = "name"
        case roles
        case _url = "url"
    }
    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _looker_group_id: AnyString?
    /**
     * Unique Id of group in Looker (read-only)
     */
    public var looker_group_id: String? {
        get { _looker_group_id?.value }
        set { _looker_group_id = newValue.map(AnyString.init) }
    }

    private var _looker_group_name: AnyString?
    /**
     * Name of group in Looker (read-only)
     */
    public var looker_group_name: String? {
        get { _looker_group_name?.value }
        set { _looker_group_name = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Name of group in LDAP (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     * Looker Roles (read-only)
     */
    public var roles: [Role]?

    private var _url: AnyString?
    /**
     * Link to ldap config (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(id: String? = nil, looker_group_id: String? = nil, looker_group_name: String? = nil, name: String? = nil, roles: [Role]? = nil, url: String? = nil) {
        self._id = id.map(AnyString.init)
        self._looker_group_id = looker_group_id.map(AnyString.init)
        self._looker_group_name = looker_group_name.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self.roles = roles
        self._url = url.map(AnyString.init)
    }

}

public struct LDAPGroupWrite: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _looker_group_id = "looker_group_id"
        case _looker_group_name = "looker_group_name"
        case _name = "name"
        case _role_ids = "role_ids"
        case _url = "url"
    }
    private var _id: AnyString?
    /**
     * Unique Id
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _looker_group_id: AnyString?
    /**
     * Unique Id of group in Looker (read-only)
     */
    public var looker_group_id: String? {
        get { _looker_group_id?.value }
        set { _looker_group_id = newValue.map(AnyString.init) }
    }

    private var _looker_group_name: AnyString?
    /**
     * Name of group in Looker
     */
    public var looker_group_name: String? {
        get { _looker_group_name?.value }
        set { _looker_group_name = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Name of group in LDAP
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _role_ids: [AnyString]?
    /**
     * Looker Role Ids
     */
    public var role_ids: [String]? {
        get { if let v = _role_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _role_ids = v.map { AnyString.init($0) } } else { _role_ids = nil } }
    }

    private var _url: AnyString?
    /**
     * Link to ldap config (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(id: String? = nil, looker_group_id: String? = nil, looker_group_name: String? = nil, name: String? = nil, role_ids: [String]? = nil, url: String? = nil) {
        self._id = id.map(AnyString.init)
        self._looker_group_id = looker_group_id.map(AnyString.init)
        self._looker_group_name = looker_group_name.map(AnyString.init)
        self._name = name.map(AnyString.init)
        if let v = role_ids { _role_ids = v.map { AnyString.init($0) } } else { _role_ids = nil }
        self._url = url.map(AnyString.init)
    }

}

public struct LDAPUser: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _all_emails = "all_emails"
        case attributes
        case _email = "email"
        case _first_name = "first_name"
        case _groups = "groups"
        case _last_name = "last_name"
        case _ldap_dn = "ldap_dn"
        case _ldap_id = "ldap_id"
        case _roles = "roles"
        case _url = "url"
    }
    private var _all_emails: [AnyString]?
    /**
     * Array of user's email addresses and aliases for use in migration (read-only)
     */
    public var all_emails: [String]? {
        get { if let v = _all_emails { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _all_emails = v.map { AnyString.init($0) } } else { _all_emails = nil } }
    }

    /**
     * Dictionary of user's attributes (name/value) (read-only)
     */
    public var attributes: StringDictionary<AnyCodable>?

    private var _email: AnyString?
    /**
     * Primary email address (read-only)
     */
    public var email: String? {
        get { _email?.value }
        set { _email = newValue.map(AnyString.init) }
    }

    private var _first_name: AnyString?
    /**
     * First name (read-only)
     */
    public var first_name: String? {
        get { _first_name?.value }
        set { _first_name = newValue.map(AnyString.init) }
    }

    private var _groups: [AnyString]?
    /**
     * Array of user's groups (group names only) (read-only)
     */
    public var groups: [String]? {
        get { if let v = _groups { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _groups = v.map { AnyString.init($0) } } else { _groups = nil } }
    }

    private var _last_name: AnyString?
    /**
     * Last Name (read-only)
     */
    public var last_name: String? {
        get { _last_name?.value }
        set { _last_name = newValue.map(AnyString.init) }
    }

    private var _ldap_dn: AnyString?
    /**
     * LDAP's distinguished name for the user record (read-only)
     */
    public var ldap_dn: String? {
        get { _ldap_dn?.value }
        set { _ldap_dn = newValue.map(AnyString.init) }
    }

    private var _ldap_id: AnyString?
    /**
     * LDAP's Unique ID for the user (read-only)
     */
    public var ldap_id: String? {
        get { _ldap_id?.value }
        set { _ldap_id = newValue.map(AnyString.init) }
    }

    private var _roles: [AnyString]?
    /**
     * Array of user's roles (role names only) (read-only)
     */
    public var roles: [String]? {
        get { if let v = _roles { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _roles = v.map { AnyString.init($0) } } else { _roles = nil } }
    }

    private var _url: AnyString?
    /**
     * Link to ldap config (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(all_emails: [String]? = nil, attributes: StringDictionary<AnyCodable>? = nil, email: String? = nil, first_name: String? = nil, groups: [String]? = nil, last_name: String? = nil, ldap_dn: String? = nil, ldap_id: String? = nil, roles: [String]? = nil, url: String? = nil) {
        if let v = all_emails { _all_emails = v.map { AnyString.init($0) } } else { _all_emails = nil }
        self.attributes = attributes
        self._email = email.map(AnyString.init)
        self._first_name = first_name.map(AnyString.init)
        if let v = groups { _groups = v.map { AnyString.init($0) } } else { _groups = nil }
        self._last_name = last_name.map(AnyString.init)
        self._ldap_dn = ldap_dn.map(AnyString.init)
        self._ldap_id = ldap_id.map(AnyString.init)
        if let v = roles { _roles = v.map { AnyString.init($0) } } else { _roles = nil }
        self._url = url.map(AnyString.init)
    }

}

public struct LDAPUserAttributeRead: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case required
        case user_attributes
        case _url = "url"
    }
    private var _name: AnyString?
    /**
     * Name of User Attribute in LDAP (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     * Required to be in LDAP assertion for login to be allowed to succeed (read-only)
     */
    public var required: Bool?

    /**
     * Looker User Attributes (read-only)
     */
    public var user_attributes: [UserAttribute]?

    private var _url: AnyString?
    /**
     * Link to ldap config (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, required: Bool? = nil, user_attributes: [UserAttribute]? = nil, url: String? = nil) {
        self._name = name.map(AnyString.init)
        self.required = required
        self.user_attributes = user_attributes
        self._url = url.map(AnyString.init)
    }

}

public struct LDAPUserAttributeWrite: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case required
        case _user_attribute_ids = "user_attribute_ids"
        case _url = "url"
    }
    private var _name: AnyString?
    /**
     * Name of User Attribute in LDAP
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     * Required to be in LDAP assertion for login to be allowed to succeed
     */
    public var required: Bool?

    private var _user_attribute_ids: [AnyString]?
    /**
     * Looker User Attribute Ids
     */
    public var user_attribute_ids: [String]? {
        get { if let v = _user_attribute_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _user_attribute_ids = v.map { AnyString.init($0) } } else { _user_attribute_ids = nil } }
    }

    private var _url: AnyString?
    /**
     * Link to ldap config (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, required: Bool? = nil, user_attribute_ids: [String]? = nil, url: String? = nil) {
        self._name = name.map(AnyString.init)
        self.required = required
        if let v = user_attribute_ids { _user_attribute_ids = v.map { AnyString.init($0) } } else { _user_attribute_ids = nil }
        self._url = url.map(AnyString.init)
    }

}

public struct LegacyFeature: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _name = "name"
        case _description = "description"
        case enabled_locally
        case enabled
        case _disallowed_as_of_version = "disallowed_as_of_version"
        case _disable_on_upgrade_to_version = "disable_on_upgrade_to_version"
        case _end_of_life_version = "end_of_life_version"
        case _documentation_url = "documentation_url"
        case approximate_disable_date
        case approximate_end_of_life_date
        case has_disabled_on_upgrade
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Name (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * Description (read-only)
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    /**
     * Whether this feature has been enabled by a user
     */
    public var enabled_locally: Bool?

    /**
     * Whether this feature is currently enabled (read-only)
     */
    public var enabled: Bool?

    private var _disallowed_as_of_version: AnyString?
    /**
     * Looker version where this feature became a legacy feature (read-only)
     */
    public var disallowed_as_of_version: String? {
        get { _disallowed_as_of_version?.value }
        set { _disallowed_as_of_version = newValue.map(AnyString.init) }
    }

    private var _disable_on_upgrade_to_version: AnyString?
    /**
     * Looker version where this feature will be automatically disabled (read-only)
     */
    public var disable_on_upgrade_to_version: String? {
        get { _disable_on_upgrade_to_version?.value }
        set { _disable_on_upgrade_to_version = newValue.map(AnyString.init) }
    }

    private var _end_of_life_version: AnyString?
    /**
     * Future Looker version where this feature will be removed (read-only)
     */
    public var end_of_life_version: String? {
        get { _end_of_life_version?.value }
        set { _end_of_life_version = newValue.map(AnyString.init) }
    }

    private var _documentation_url: AnyString?
    /**
     * URL for documentation about this feature (read-only)
     */
    public var documentation_url: String? {
        get { _documentation_url?.value }
        set { _documentation_url = newValue.map(AnyString.init) }
    }

    /**
     * Approximate date that this feature will be automatically disabled. (read-only)
     */
    public var approximate_disable_date: Date?

    /**
     * Approximate date that this feature will be removed. (read-only)
     */
    public var approximate_end_of_life_date: Date?

    /**
     * Whether this legacy feature may have been automatically disabled when upgrading to the current version. (read-only)
     */
    public var has_disabled_on_upgrade: Bool?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, name: String? = nil, description: String? = nil, enabled_locally: Bool? = nil, enabled: Bool? = nil, disallowed_as_of_version: String? = nil, disable_on_upgrade_to_version: String? = nil, end_of_life_version: String? = nil, documentation_url: String? = nil, approximate_disable_date: Date? = nil, approximate_end_of_life_date: Date? = nil, has_disabled_on_upgrade: Bool? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self.enabled_locally = enabled_locally
        self.enabled = enabled
        self._disallowed_as_of_version = disallowed_as_of_version.map(AnyString.init)
        self._disable_on_upgrade_to_version = disable_on_upgrade_to_version.map(AnyString.init)
        self._end_of_life_version = end_of_life_version.map(AnyString.init)
        self._documentation_url = documentation_url.map(AnyString.init)
        self.approximate_disable_date = approximate_disable_date
        self.approximate_end_of_life_date = approximate_end_of_life_date
        self.has_disabled_on_upgrade = has_disabled_on_upgrade
    }

}

public struct LkLocale: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _code = "code"
        case _native_name = "native_name"
        case _english_name = "english_name"
    }
    private var _code: AnyString?
    /**
     * Code for Locale (read-only)
     */
    public var code: String? {
        get { _code?.value }
        set { _code = newValue.map(AnyString.init) }
    }

    private var _native_name: AnyString?
    /**
     * Name of Locale in its own language (read-only)
     */
    public var native_name: String? {
        get { _native_name?.value }
        set { _native_name = newValue.map(AnyString.init) }
    }

    private var _english_name: AnyString?
    /**
     * Name of Locale in English (read-only)
     */
    public var english_name: String? {
        get { _english_name?.value }
        set { _english_name = newValue.map(AnyString.init) }
    }

    public init(code: String? = nil, native_name: String? = nil, english_name: String? = nil) {
        self._code = code.map(AnyString.init)
        self._native_name = native_name.map(AnyString.init)
        self._english_name = english_name.map(AnyString.init)
    }

}

public struct LocalizationSettings: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _default_locale = "default_locale"
        case _localization_level = "localization_level"
    }
    private var _default_locale: AnyString?
    /**
     * Default locale for localization (read-only)
     */
    public var default_locale: String? {
        get { _default_locale?.value }
        set { _default_locale = newValue.map(AnyString.init) }
    }

    private var _localization_level: AnyString?
    /**
     * Localization level - strict or permissive (read-only)
     */
    public var localization_level: String? {
        get { _localization_level?.value }
        set { _localization_level = newValue.map(AnyString.init) }
    }

    public init(default_locale: String? = nil, localization_level: String? = nil) {
        self._default_locale = default_locale.map(AnyString.init)
        self._localization_level = localization_level.map(AnyString.init)
    }

}

public struct Look: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _content_metadata_id = "content_metadata_id"
        case _id = "id"
        case _title = "title"
        case _user_id = "user_id"
        case _content_favorite_id = "content_favorite_id"
        case created_at
        case deleted
        case deleted_at
        case _deleter_id = "deleter_id"
        case _description = "description"
        case _embed_url = "embed_url"
        case _excel_file_url = "excel_file_url"
        case _favorite_count = "favorite_count"
        case _google_spreadsheet_formula = "google_spreadsheet_formula"
        case _image_embed_url = "image_embed_url"
        case is_run_on_load
        case last_accessed_at
        case _last_updater_id = "last_updater_id"
        case last_viewed_at
        case model
        case `public`
        case _public_slug = "public_slug"
        case _public_url = "public_url"
        case _query_id = "query_id"
        case _short_url = "short_url"
        case folder
        case _folder_id = "folder_id"
        case updated_at
        case _user_name = "user_name"
        case _view_count = "view_count"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _content_metadata_id: AnyString?
    /**
     * Id of content metadata (read-only)
     */
    public var content_metadata_id: String? {
        get { _content_metadata_id?.value }
        set { _content_metadata_id = newValue.map(AnyString.init) }
    }

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Look Title
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _user_id: AnyString?
    /**
     * User Id
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    private var _content_favorite_id: AnyString?
    /**
     * Content Favorite Id (read-only)
     */
    public var content_favorite_id: String? {
        get { _content_favorite_id?.value }
        set { _content_favorite_id = newValue.map(AnyString.init) }
    }

    /**
     * Time that the Look was created. (read-only)
     */
    public var created_at: Date?

    /**
     * Whether or not a look is 'soft' deleted.
     */
    public var deleted: Bool?

    /**
     * Time that the Look was deleted. (read-only)
     */
    public var deleted_at: Date?

    private var _deleter_id: AnyString?
    /**
     * Id of User that deleted the look. (read-only)
     */
    public var deleter_id: String? {
        get { _deleter_id?.value }
        set { _deleter_id = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * Description
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    private var _embed_url: AnyString?
    /**
     * Embed Url (read-only)
     */
    public var embed_url: String? {
        get { _embed_url?.value }
        set { _embed_url = newValue.map(AnyString.init) }
    }

    private var _excel_file_url: AnyString?
    /**
     * Excel File Url (read-only)
     */
    public var excel_file_url: String? {
        get { _excel_file_url?.value }
        set { _excel_file_url = newValue.map(AnyString.init) }
    }

    private var _favorite_count: AnyInt?
    /**
     * Number of times favorited (read-only)
     */
    public var favorite_count: Int64? {
        get { _favorite_count?.value }
        set { _favorite_count = newValue.map(AnyInt.init) }
    }

    private var _google_spreadsheet_formula: AnyString?
    /**
     * Google Spreadsheet Formula (read-only)
     */
    public var google_spreadsheet_formula: String? {
        get { _google_spreadsheet_formula?.value }
        set { _google_spreadsheet_formula = newValue.map(AnyString.init) }
    }

    private var _image_embed_url: AnyString?
    /**
     * Image Embed Url (read-only)
     */
    public var image_embed_url: String? {
        get { _image_embed_url?.value }
        set { _image_embed_url = newValue.map(AnyString.init) }
    }

    /**
     * auto-run query when Look viewed
     */
    public var is_run_on_load: Bool?

    /**
     * Time that the Look was last accessed by any user (read-only)
     */
    public var last_accessed_at: Date?

    private var _last_updater_id: AnyString?
    /**
     * Id of User that last updated the look. (read-only)
     */
    public var last_updater_id: String? {
        get { _last_updater_id?.value }
        set { _last_updater_id = newValue.map(AnyString.init) }
    }

    /**
     * Time last viewed in the Looker web UI (read-only)
     */
    public var last_viewed_at: Date?

    public var model: LookModel?

    /**
     * Is Public
     */
    public var `public`: Bool?

    private var _public_slug: AnyString?
    /**
     * Public Slug (read-only)
     */
    public var public_slug: String? {
        get { _public_slug?.value }
        set { _public_slug = newValue.map(AnyString.init) }
    }

    private var _public_url: AnyString?
    /**
     * Public Url (read-only)
     */
    public var public_url: String? {
        get { _public_url?.value }
        set { _public_url = newValue.map(AnyString.init) }
    }

    private var _query_id: AnyString?
    /**
     * Query Id
     */
    public var query_id: String? {
        get { _query_id?.value }
        set { _query_id = newValue.map(AnyString.init) }
    }

    private var _short_url: AnyString?
    /**
     * Short Url (read-only)
     */
    public var short_url: String? {
        get { _short_url?.value }
        set { _short_url = newValue.map(AnyString.init) }
    }

    public var folder: FolderBase?

    private var _folder_id: AnyString?
    /**
     * Folder Id
     */
    public var folder_id: String? {
        get { _folder_id?.value }
        set { _folder_id = newValue.map(AnyString.init) }
    }

    /**
     * Time that the Look was updated. (read-only)
     */
    public var updated_at: Date?

    private var _user_name: AnyString?
    /**
     * Name of User that created the look. (read-only)
     */
    public var user_name: String? {
        get { _user_name?.value }
        set { _user_name = newValue.map(AnyString.init) }
    }

    private var _view_count: AnyInt?
    /**
     * Number of times viewed in the Looker web UI (read-only)
     */
    public var view_count: Int64? {
        get { _view_count?.value }
        set { _view_count = newValue.map(AnyInt.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, content_metadata_id: String? = nil, id: String? = nil, title: String? = nil, user_id: String? = nil, content_favorite_id: String? = nil, created_at: Date? = nil, deleted: Bool? = nil, deleted_at: Date? = nil, deleter_id: String? = nil, description: String? = nil, embed_url: String? = nil, excel_file_url: String? = nil, favorite_count: Int64? = nil, google_spreadsheet_formula: String? = nil, image_embed_url: String? = nil, is_run_on_load: Bool? = nil, last_accessed_at: Date? = nil, last_updater_id: String? = nil, last_viewed_at: Date? = nil, model: LookModel? = nil, `public`: Bool? = nil, public_slug: String? = nil, public_url: String? = nil, query_id: String? = nil, short_url: String? = nil, folder: FolderBase? = nil, folder_id: String? = nil, updated_at: Date? = nil, user_name: String? = nil, view_count: Int64? = nil) {
        self.can = can
        self._content_metadata_id = content_metadata_id.map(AnyString.init)
        self._id = id.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self._user_id = user_id.map(AnyString.init)
        self._content_favorite_id = content_favorite_id.map(AnyString.init)
        self.created_at = created_at
        self.deleted = deleted
        self.deleted_at = deleted_at
        self._deleter_id = deleter_id.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self._embed_url = embed_url.map(AnyString.init)
        self._excel_file_url = excel_file_url.map(AnyString.init)
        self._favorite_count = favorite_count.map(AnyInt.init)
        self._google_spreadsheet_formula = google_spreadsheet_formula.map(AnyString.init)
        self._image_embed_url = image_embed_url.map(AnyString.init)
        self.is_run_on_load = is_run_on_load
        self.last_accessed_at = last_accessed_at
        self._last_updater_id = last_updater_id.map(AnyString.init)
        self.last_viewed_at = last_viewed_at
        self.model = model
        self.`public` = `public`
        self._public_slug = public_slug.map(AnyString.init)
        self._public_url = public_url.map(AnyString.init)
        self._query_id = query_id.map(AnyString.init)
        self._short_url = short_url.map(AnyString.init)
        self.folder = folder
        self._folder_id = folder_id.map(AnyString.init)
        self.updated_at = updated_at
        self._user_name = user_name.map(AnyString.init)
        self._view_count = view_count.map(AnyInt.init)
    }

}

public struct LookBasic: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _content_metadata_id = "content_metadata_id"
        case _id = "id"
        case _title = "title"
        case _user_id = "user_id"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _content_metadata_id: AnyString?
    /**
     * Id of content metadata (read-only)
     */
    public var content_metadata_id: String? {
        get { _content_metadata_id?.value }
        set { _content_metadata_id = newValue.map(AnyString.init) }
    }

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Look Title (read-only)
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _user_id: AnyString?
    /**
     * User Id
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, content_metadata_id: String? = nil, id: String? = nil, title: String? = nil, user_id: String? = nil) {
        self.can = can
        self._content_metadata_id = content_metadata_id.map(AnyString.init)
        self._id = id.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self._user_id = user_id.map(AnyString.init)
    }

}

public struct LookmlFieldLink: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _label = "label"
        case _url = "url"
        case _icon_url = "icon_url"
    }
    private var _label: AnyString?
    /**
     * The name of the link as it would appear to users. (read-only)
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * URL the link will go to. (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    private var _icon_url: AnyString?
    /**
     * A URL containing an image file to display with a link. (read-only)
     */
    public var icon_url: String? {
        get { _icon_url?.value }
        set { _icon_url = newValue.map(AnyString.init) }
    }

    public init(label: String? = nil, url: String? = nil, icon_url: String? = nil) {
        self._label = label.map(AnyString.init)
        self._url = url.map(AnyString.init)
        self._icon_url = icon_url.map(AnyString.init)
    }

}

public struct LookmlModel: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _allowed_db_connection_names = "allowed_db_connection_names"
        case explores
        case has_content
        case _label = "label"
        case _name = "name"
        case _project_name = "project_name"
        case unlimited_db_connections
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _allowed_db_connection_names: [AnyString]?
    /**
     * Array of names of connections this model is allowed to use
     */
    public var allowed_db_connection_names: [String]? {
        get { if let v = _allowed_db_connection_names { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _allowed_db_connection_names = v.map { AnyString.init($0) } } else { _allowed_db_connection_names = nil } }
    }

    /**
     * Array of explores (if has_content) (read-only)
     */
    public var explores: [LookmlModelNavExplore]?

    /**
     * Does this model declaration have have lookml content? (read-only)
     */
    public var has_content: Bool?

    private var _label: AnyString?
    /**
     * UI-friendly name for this model (read-only)
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Name of the model. Also used as the unique identifier
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _project_name: AnyString?
    /**
     * Name of project containing the model
     */
    public var project_name: String? {
        get { _project_name?.value }
        set { _project_name = newValue.map(AnyString.init) }
    }

    /**
     * Is this model allowed to use all current and future connections
     */
    public var unlimited_db_connections: Bool?

    public init(can: StringDictionary<Bool>? = nil, allowed_db_connection_names: [String]? = nil, explores: [LookmlModelNavExplore]? = nil, has_content: Bool? = nil, label: String? = nil, name: String? = nil, project_name: String? = nil, unlimited_db_connections: Bool? = nil) {
        self.can = can
        if let v = allowed_db_connection_names { _allowed_db_connection_names = v.map { AnyString.init($0) } } else { _allowed_db_connection_names = nil }
        self.explores = explores
        self.has_content = has_content
        self._label = label.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self._project_name = project_name.map(AnyString.init)
        self.unlimited_db_connections = unlimited_db_connections
    }

}

public struct LookmlModelExplore: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _name = "name"
        case _description = "description"
        case _label = "label"
        case _title = "title"
        case _scopes = "scopes"
        case can_total
        case can_develop
        case can_see_lookml
        case _lookml_link = "lookml_link"
        case can_save
        case can_explain
        case can_pivot_in_db
        case can_subtotal
        case has_timezone_support
        case supports_cost_estimate
        case _connection_name = "connection_name"
        case _null_sort_treatment = "null_sort_treatment"
        case _files = "files"
        case _source_file = "source_file"
        case _project_name = "project_name"
        case _model_name = "model_name"
        case _view_name = "view_name"
        case hidden
        case _sql_table_name = "sql_table_name"
        case _access_filter_fields = "access_filter_fields"
        case access_filters
        case aliases
        case always_filter
        case conditionally_filter
        case _index_fields = "index_fields"
        case sets
        case _tags = "tags"
        case errors
        case fields
        case joins
        case _group_label = "group_label"
        case supported_measure_types
        case _always_join = "always_join"
    }
    private var _id: AnyString?
    /**
     * Fully qualified explore name (model name plus explore name) (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Explore name (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * Description (read-only)
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    private var _label: AnyString?
    /**
     * Label (read-only)
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Explore title (read-only)
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _scopes: [AnyString]?
    /**
     * Scopes (read-only)
     */
    public var scopes: [String]? {
        get { if let v = _scopes { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _scopes = v.map { AnyString.init($0) } } else { _scopes = nil } }
    }

    /**
     * Can Total (read-only)
     */
    public var can_total: Bool?

    /**
     * Can Develop LookML (read-only)
     */
    public var can_develop: Bool?

    /**
     * Can See LookML (read-only)
     */
    public var can_see_lookml: Bool?

    private var _lookml_link: AnyString?
    /**
     * A URL linking to the definition of this explore in the LookML IDE. (read-only)
     */
    public var lookml_link: String? {
        get { _lookml_link?.value }
        set { _lookml_link = newValue.map(AnyString.init) }
    }

    /**
     * Can Save (read-only)
     */
    public var can_save: Bool?

    /**
     * Can Explain (read-only)
     */
    public var can_explain: Bool?

    /**
     * Can pivot in the DB (read-only)
     */
    public var can_pivot_in_db: Bool?

    /**
     * Can use subtotals (read-only)
     */
    public var can_subtotal: Bool?

    /**
     * Has timezone support (read-only)
     */
    public var has_timezone_support: Bool?

    /**
     * Cost estimates supported (read-only)
     */
    public var supports_cost_estimate: Bool?

    private var _connection_name: AnyString?
    /**
     * Connection name (read-only)
     */
    public var connection_name: String? {
        get { _connection_name?.value }
        set { _connection_name = newValue.map(AnyString.init) }
    }

    private var _null_sort_treatment: AnyString?
    /**
     * How nulls are sorted, possible values are "low", "high", "first" and "last" (read-only)
     */
    public var null_sort_treatment: String? {
        get { _null_sort_treatment?.value }
        set { _null_sort_treatment = newValue.map(AnyString.init) }
    }

    private var _files: [AnyString]?
    /**
     * List of model source files (read-only)
     */
    public var files: [String]? {
        get { if let v = _files { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _files = v.map { AnyString.init($0) } } else { _files = nil } }
    }

    private var _source_file: AnyString?
    /**
     * Primary source_file file (read-only)
     */
    public var source_file: String? {
        get { _source_file?.value }
        set { _source_file = newValue.map(AnyString.init) }
    }

    private var _project_name: AnyString?
    /**
     * Name of project (read-only)
     */
    public var project_name: String? {
        get { _project_name?.value }
        set { _project_name = newValue.map(AnyString.init) }
    }

    private var _model_name: AnyString?
    /**
     * Name of model (read-only)
     */
    public var model_name: String? {
        get { _model_name?.value }
        set { _model_name = newValue.map(AnyString.init) }
    }

    private var _view_name: AnyString?
    /**
     * Name of view (read-only)
     */
    public var view_name: String? {
        get { _view_name?.value }
        set { _view_name = newValue.map(AnyString.init) }
    }

    /**
     * Is hidden (read-only)
     */
    public var hidden: Bool?

    private var _sql_table_name: AnyString?
    /**
     * A sql_table_name expression that defines what sql table the view/explore maps onto. Example: "prod_orders2 AS orders" in a view named orders. (read-only)
     */
    public var sql_table_name: String? {
        get { _sql_table_name?.value }
        set { _sql_table_name = newValue.map(AnyString.init) }
    }

    private var _access_filter_fields: [AnyString]?
    /**
     * (DEPRECATED) Array of access filter field names (read-only)
     */
    public var access_filter_fields: [String]? {
        get { if let v = _access_filter_fields { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _access_filter_fields = v.map { AnyString.init($0) } } else { _access_filter_fields = nil } }
    }

    /**
     * Access filters (read-only)
     */
    public var access_filters: [LookmlModelExploreAccessFilter]?

    /**
     * Aliases (read-only)
     */
    public var aliases: [LookmlModelExploreAlias]?

    /**
     * Always filter (read-only)
     */
    public var always_filter: [LookmlModelExploreAlwaysFilter]?

    /**
     * Conditionally filter (read-only)
     */
    public var conditionally_filter: [LookmlModelExploreConditionallyFilter]?

    private var _index_fields: [AnyString]?
    /**
     * Array of index fields (read-only)
     */
    public var index_fields: [String]? {
        get { if let v = _index_fields { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _index_fields = v.map { AnyString.init($0) } } else { _index_fields = nil } }
    }

    /**
     * Sets (read-only)
     */
    public var sets: [LookmlModelExploreSet]?

    private var _tags: [AnyString]?
    /**
     * An array of arbitrary string tags provided in the model for this explore. (read-only)
     */
    public var tags: [String]? {
        get { if let v = _tags { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _tags = v.map { AnyString.init($0) } } else { _tags = nil } }
    }

    /**
     * Errors (read-only)
     */
    public var errors: [LookmlModelExploreError]?

    public var fields: LookmlModelExploreFieldset?

    /**
     * Views joined into this explore (read-only)
     */
    public var joins: [LookmlModelExploreJoins]?

    private var _group_label: AnyString?
    /**
     * Label used to group explores in the navigation menus (read-only)
     */
    public var group_label: String? {
        get { _group_label?.value }
        set { _group_label = newValue.map(AnyString.init) }
    }

    /**
     * An array of items describing which custom measure types are supported for creating a custom measure 'based_on' each possible dimension type. (read-only)
     */
    public var supported_measure_types: [LookmlModelExploreSupportedMeasureType]?

    private var _always_join: [AnyString]?
    /**
     * An array of joins that will always be included in the SQL for this explore, even if the user has not selected a field from the joined view. (read-only)
     */
    public var always_join: [String]? {
        get { if let v = _always_join { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _always_join = v.map { AnyString.init($0) } } else { _always_join = nil } }
    }

    public init(id: String? = nil, name: String? = nil, description: String? = nil, label: String? = nil, title: String? = nil, scopes: [String]? = nil, can_total: Bool? = nil, can_develop: Bool? = nil, can_see_lookml: Bool? = nil, lookml_link: String? = nil, can_save: Bool? = nil, can_explain: Bool? = nil, can_pivot_in_db: Bool? = nil, can_subtotal: Bool? = nil, has_timezone_support: Bool? = nil, supports_cost_estimate: Bool? = nil, connection_name: String? = nil, null_sort_treatment: String? = nil, files: [String]? = nil, source_file: String? = nil, project_name: String? = nil, model_name: String? = nil, view_name: String? = nil, hidden: Bool? = nil, sql_table_name: String? = nil, access_filter_fields: [String]? = nil, access_filters: [LookmlModelExploreAccessFilter]? = nil, aliases: [LookmlModelExploreAlias]? = nil, always_filter: [LookmlModelExploreAlwaysFilter]? = nil, conditionally_filter: [LookmlModelExploreConditionallyFilter]? = nil, index_fields: [String]? = nil, sets: [LookmlModelExploreSet]? = nil, tags: [String]? = nil, errors: [LookmlModelExploreError]? = nil, fields: LookmlModelExploreFieldset? = nil, joins: [LookmlModelExploreJoins]? = nil, group_label: String? = nil, supported_measure_types: [LookmlModelExploreSupportedMeasureType]? = nil, always_join: [String]? = nil) {
        self._id = id.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self._label = label.map(AnyString.init)
        self._title = title.map(AnyString.init)
        if let v = scopes { _scopes = v.map { AnyString.init($0) } } else { _scopes = nil }
        self.can_total = can_total
        self.can_develop = can_develop
        self.can_see_lookml = can_see_lookml
        self._lookml_link = lookml_link.map(AnyString.init)
        self.can_save = can_save
        self.can_explain = can_explain
        self.can_pivot_in_db = can_pivot_in_db
        self.can_subtotal = can_subtotal
        self.has_timezone_support = has_timezone_support
        self.supports_cost_estimate = supports_cost_estimate
        self._connection_name = connection_name.map(AnyString.init)
        self._null_sort_treatment = null_sort_treatment.map(AnyString.init)
        if let v = files { _files = v.map { AnyString.init($0) } } else { _files = nil }
        self._source_file = source_file.map(AnyString.init)
        self._project_name = project_name.map(AnyString.init)
        self._model_name = model_name.map(AnyString.init)
        self._view_name = view_name.map(AnyString.init)
        self.hidden = hidden
        self._sql_table_name = sql_table_name.map(AnyString.init)
        if let v = access_filter_fields { _access_filter_fields = v.map { AnyString.init($0) } } else { _access_filter_fields = nil }
        self.access_filters = access_filters
        self.aliases = aliases
        self.always_filter = always_filter
        self.conditionally_filter = conditionally_filter
        if let v = index_fields { _index_fields = v.map { AnyString.init($0) } } else { _index_fields = nil }
        self.sets = sets
        if let v = tags { _tags = v.map { AnyString.init($0) } } else { _tags = nil }
        self.errors = errors
        self.fields = fields
        self.joins = joins
        self._group_label = group_label.map(AnyString.init)
        self.supported_measure_types = supported_measure_types
        if let v = always_join { _always_join = v.map { AnyString.init($0) } } else { _always_join = nil }
    }

}

public struct LookmlModelExploreAccessFilter: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _field = "field"
        case _user_attribute = "user_attribute"
    }
    private var _field: AnyString?
    /**
     * Field to be filtered (read-only)
     */
    public var field: String? {
        get { _field?.value }
        set { _field = newValue.map(AnyString.init) }
    }

    private var _user_attribute: AnyString?
    /**
     * User attribute name (read-only)
     */
    public var user_attribute: String? {
        get { _user_attribute?.value }
        set { _user_attribute = newValue.map(AnyString.init) }
    }

    public init(field: String? = nil, user_attribute: String? = nil) {
        self._field = field.map(AnyString.init)
        self._user_attribute = user_attribute.map(AnyString.init)
    }

}

public struct LookmlModelExploreAlias: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _value = "value"
    }
    private var _name: AnyString?
    /**
     * Name (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _value: AnyString?
    /**
     * Value (read-only)
     */
    public var value: String? {
        get { _value?.value }
        set { _value = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, value: String? = nil) {
        self._name = name.map(AnyString.init)
        self._value = value.map(AnyString.init)
    }

}

public struct LookmlModelExploreAlwaysFilter: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _value = "value"
    }
    private var _name: AnyString?
    /**
     * Name (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _value: AnyString?
    /**
     * Value (read-only)
     */
    public var value: String? {
        get { _value?.value }
        set { _value = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, value: String? = nil) {
        self._name = name.map(AnyString.init)
        self._value = value.map(AnyString.init)
    }

}

public struct LookmlModelExploreConditionallyFilter: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _value = "value"
    }
    private var _name: AnyString?
    /**
     * Name (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _value: AnyString?
    /**
     * Value (read-only)
     */
    public var value: String? {
        get { _value?.value }
        set { _value = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, value: String? = nil) {
        self._name = name.map(AnyString.init)
        self._value = value.map(AnyString.init)
    }

}

public struct LookmlModelExploreError: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _message = "message"
        case details
        case _error_pos = "error_pos"
        case field_error
    }
    private var _message: AnyString?
    /**
     * Error Message (read-only)
     */
    public var message: String? {
        get { _message?.value }
        set { _message = newValue.map(AnyString.init) }
    }

    /**
     * Details (read-only)
     */
    public var details: AnyCodable?

    private var _error_pos: AnyString?
    /**
     * Error source location (read-only)
     */
    public var error_pos: String? {
        get { _error_pos?.value }
        set { _error_pos = newValue.map(AnyString.init) }
    }

    /**
     * Is this a field error (read-only)
     */
    public var field_error: Bool?

    public init(message: String? = nil, details: AnyCodable? = nil, error_pos: String? = nil, field_error: Bool? = nil) {
        self._message = message.map(AnyString.init)
        self.details = details
        self._error_pos = error_pos.map(AnyString.init)
        self.field_error = field_error
    }

}

public struct LookmlModelExploreField: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case align
        case can_filter
        case category
        case _default_filter_value = "default_filter_value"
        case _description = "description"
        case _dimension_group = "dimension_group"
        case _drill_fields = "drill_fields"
        case enumerations
        case _error = "error"
        case _field_group_label = "field_group_label"
        case _field_group_variant = "field_group_variant"
        case fill_style
        case _fiscal_month_offset = "fiscal_month_offset"
        case has_allowed_values
        case has_drills_metadata
        case hidden
        case is_filter
        case is_fiscal
        case is_numeric
        case is_timeframe
        case can_time_filter
        case time_interval
        case _label = "label"
        case _label_from_parameter = "label_from_parameter"
        case _label_short = "label_short"
        case _lookml_link = "lookml_link"
        case links
        case map_layer
        case measure
        case _name = "name"
        case strict_value_format
        case parameter
        case period_over_period_params
        case permanent
        case primary_key
        case _project_name = "project_name"
        case requires_refresh_on_sort
        case _scope = "scope"
        case sortable
        case _source_file = "source_file"
        case _source_file_path = "source_file_path"
        case _sql = "sql"
        case sql_case
        case filters
        case _suggest_dimension = "suggest_dimension"
        case _suggest_explore = "suggest_explore"
        case suggestable
        case _suggestions = "suggestions"
        case _tags = "tags"
        case _type = "type"
        case user_attribute_filter_types
        case _value_format = "value_format"
        case _view = "view"
        case _view_label = "view_label"
        case `dynamic`
        case week_start_day
        case _times_used = "times_used"
        case _original_view = "original_view"
    }
    /**
     * The appropriate horizontal text alignment the values of this field should be displayed in. Valid values are: "left", "right". (read-only)
     */
    public var align: Align?

    /**
     * Whether it's possible to filter on this field. (read-only)
     */
    public var can_filter: Bool?

    /**
     * Field category Valid values are: "parameter", "filter", "measure", "dimension". (read-only)
     */
    public var category: Category?

    private var _default_filter_value: AnyString?
    /**
     * The default value that this field uses when filtering. Null if there is no default value. (read-only)
     */
    public var default_filter_value: String? {
        get { _default_filter_value?.value }
        set { _default_filter_value = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * Description (read-only)
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    private var _dimension_group: AnyString?
    /**
     * Dimension group if this field is part of a dimension group. If not, this will be null. (read-only)
     */
    public var dimension_group: String? {
        get { _dimension_group?.value }
        set { _dimension_group = newValue.map(AnyString.init) }
    }

    private var _drill_fields: [AnyString]?
    /**
     * Drill fields declared for this field in LookML or default drills for certain types. (read-only)
     */
    public var drill_fields: [String]? {
        get { if let v = _drill_fields { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _drill_fields = v.map { AnyString.init($0) } } else { _drill_fields = nil } }
    }

    /**
     * An array enumerating all the possible values that this field can contain. When null, there is no limit to the set of possible values this field can contain. (read-only)
     */
    public var enumerations: [LookmlModelExploreFieldEnumeration]?

    private var _error: AnyString?
    /**
     * An error message indicating a problem with the definition of this field. If there are no errors, this will be null. (read-only)
     */
    public var error: String? {
        get { _error?.value }
        set { _error = newValue.map(AnyString.init) }
    }

    private var _field_group_label: AnyString?
    /**
     * A label creating a grouping of fields. All fields with this label should be presented together when displayed in a UI. (read-only)
     */
    public var field_group_label: String? {
        get { _field_group_label?.value }
        set { _field_group_label = newValue.map(AnyString.init) }
    }

    private var _field_group_variant: AnyString?
    /**
     * When presented in a field group via field_group_label, a shorter name of the field to be displayed in that context. (read-only)
     */
    public var field_group_variant: String? {
        get { _field_group_variant?.value }
        set { _field_group_variant = newValue.map(AnyString.init) }
    }

    /**
     * The style of dimension fill that is possible for this field. Null if no dimension fill is possible. Valid values are: "enumeration", "range". (read-only)
     */
    public var fill_style: FillStyle?

    private var _fiscal_month_offset: AnyInt?
    /**
     * An offset (in months) from the calendar start month to the fiscal start month defined in the LookML model this field belongs to. (read-only)
     */
    public var fiscal_month_offset: Int64? {
        get { _fiscal_month_offset?.value }
        set { _fiscal_month_offset = newValue.map(AnyInt.init) }
    }

    /**
     * Whether this field has a set of allowed_values specified in LookML. (read-only)
     */
    public var has_allowed_values: Bool?

    /**
     * Whether this field has links or drill fields defined. (read-only)
     */
    public var has_drills_metadata: Bool?

    /**
     * Whether this field should be hidden from the user interface. (read-only)
     */
    public var hidden: Bool?

    /**
     * Whether this field is a filter. (read-only)
     */
    public var is_filter: Bool?

    /**
     * Whether this field represents a fiscal time value. (read-only)
     */
    public var is_fiscal: Bool?

    /**
     * Whether this field is of a type that represents a numeric value. (read-only)
     */
    public var is_numeric: Bool?

    /**
     * Whether this field is of a type that represents a time value. (read-only)
     */
    public var is_timeframe: Bool?

    /**
     * Whether this field can be time filtered. (read-only)
     */
    public var can_time_filter: Bool?

    public var time_interval: LookmlModelExploreFieldTimeInterval?

    private var _label: AnyString?
    /**
     * Fully-qualified human-readable label of the field. (read-only)
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    private var _label_from_parameter: AnyString?
    /**
     * The name of the parameter that will provide a parameterized label for this field, if available in the current context. (read-only)
     */
    public var label_from_parameter: String? {
        get { _label_from_parameter?.value }
        set { _label_from_parameter = newValue.map(AnyString.init) }
    }

    private var _label_short: AnyString?
    /**
     * The human-readable label of the field, without the view label. (read-only)
     */
    public var label_short: String? {
        get { _label_short?.value }
        set { _label_short = newValue.map(AnyString.init) }
    }

    private var _lookml_link: AnyString?
    /**
     * A URL linking to the definition of this field in the LookML IDE. (read-only)
     */
    public var lookml_link: String? {
        get { _lookml_link?.value }
        set { _lookml_link = newValue.map(AnyString.init) }
    }

    /**
     * Links associated with this field. (read-only)
     */
    public var links: [LookmlFieldLink]?

    public var map_layer: LookmlModelExploreFieldMapLayer?

    /**
     * Whether this field is a measure. (read-only)
     */
    public var measure: Bool?

    private var _name: AnyString?
    /**
     * Fully-qualified name of the field. (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     * If yes, the field will not be localized with the user attribute number_format. Defaults to no (read-only)
     */
    public var strict_value_format: Bool?

    /**
     * Whether this field is a parameter. (read-only)
     */
    public var parameter: Bool?

    public var period_over_period_params: LookmlModelExploreFieldPeriodOverPeriodParams?

    /**
     * Whether this field can be removed from a query. (read-only)
     */
    public var permanent: Bool?

    /**
     * Whether or not the field represents a primary key. (read-only)
     */
    public var primary_key: Bool?

    private var _project_name: AnyString?
    /**
     * The name of the project this field is defined in. (read-only)
     */
    public var project_name: String? {
        get { _project_name?.value }
        set { _project_name = newValue.map(AnyString.init) }
    }

    /**
     * When true, it's not possible to re-sort this field's values without re-running the SQL query, due to database logic that affects the sort. (read-only)
     */
    public var requires_refresh_on_sort: Bool?

    private var _scope: AnyString?
    /**
     * The LookML scope this field belongs to. The scope is typically the field's view. (read-only)
     */
    public var scope: String? {
        get { _scope?.value }
        set { _scope = newValue.map(AnyString.init) }
    }

    /**
     * Whether this field can be sorted. (read-only)
     */
    public var sortable: Bool?

    private var _source_file: AnyString?
    /**
     * The path portion of source_file_path. (read-only)
     */
    public var source_file: String? {
        get { _source_file?.value }
        set { _source_file = newValue.map(AnyString.init) }
    }

    private var _source_file_path: AnyString?
    /**
     * The fully-qualified path of the project file this field is defined in. (read-only)
     */
    public var source_file_path: String? {
        get { _source_file_path?.value }
        set { _source_file_path = newValue.map(AnyString.init) }
    }

    private var _sql: AnyString?
    /**
     * SQL expression as defined in the LookML model. The SQL syntax shown here is a representation intended for auditability, and is not neccessarily an exact match for what will ultimately be run in the database. It may contain special LookML syntax or annotations that are not valid SQL. This will be null if the current user does not have the see_lookml permission for the field's model. (read-only)
     */
    public var sql: String? {
        get { _sql?.value }
        set { _sql = newValue.map(AnyString.init) }
    }

    /**
     * An array of conditions and values that make up a SQL Case expression, as defined in the LookML model. The SQL syntax shown here is a representation intended for auditability, and is not neccessarily an exact match for what will ultimately be run in the database. It may contain special LookML syntax or annotations that are not valid SQL. This will be null if the current user does not have the see_lookml permission for the field's model. (read-only)
     */
    public var sql_case: [LookmlModelExploreFieldSqlCase]?

    /**
     * Array of filter conditions defined for the measure in LookML. (read-only)
     */
    public var filters: [LookmlModelExploreFieldMeasureFilters]?

    private var _suggest_dimension: AnyString?
    /**
     * The name of the dimension to base suggest queries from. (read-only)
     */
    public var suggest_dimension: String? {
        get { _suggest_dimension?.value }
        set { _suggest_dimension = newValue.map(AnyString.init) }
    }

    private var _suggest_explore: AnyString?
    /**
     * The name of the explore to base suggest queries from. (read-only)
     */
    public var suggest_explore: String? {
        get { _suggest_explore?.value }
        set { _suggest_explore = newValue.map(AnyString.init) }
    }

    /**
     * Whether or not suggestions are possible for this field. (read-only)
     */
    public var suggestable: Bool?

    private var _suggestions: [AnyString]?
    /**
     * If available, a list of suggestions for this field. For most fields, a suggest query is a more appropriate way to get an up-to-date list of suggestions. Or use enumerations to list all the possible values. (read-only)
     */
    public var suggestions: [String]? {
        get { if let v = _suggestions { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _suggestions = v.map { AnyString.init($0) } } else { _suggestions = nil } }
    }

    private var _tags: [AnyString]?
    /**
     * An array of arbitrary string tags provided in the model for this field. (read-only)
     */
    public var tags: [String]? {
        get { if let v = _tags { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _tags = v.map { AnyString.init($0) } } else { _tags = nil } }
    }

    private var _type: AnyString?
    /**
     * The LookML type of the field. (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    /**
     * An array of user attribute types that are allowed to be used in filters on this field. Valid values are: "advanced_filter_string", "advanced_filter_number", "advanced_filter_datetime", "string", "number", "datetime", "relative_url", "yesno", "zipcode". (read-only)
     */
    public var user_attribute_filter_types: [UserAttributeFilterTypes]?

    private var _value_format: AnyString?
    /**
     * If specified, the LookML value format string for formatting values of this field. (read-only)
     */
    public var value_format: String? {
        get { _value_format?.value }
        set { _value_format = newValue.map(AnyString.init) }
    }

    private var _view: AnyString?
    /**
     * The name of the view this field belongs to. (read-only)
     */
    public var view: String? {
        get { _view?.value }
        set { _view = newValue.map(AnyString.init) }
    }

    private var _view_label: AnyString?
    /**
     * The human-readable label of the view the field belongs to. (read-only)
     */
    public var view_label: String? {
        get { _view_label?.value }
        set { _view_label = newValue.map(AnyString.init) }
    }

    /**
     * Whether this field was specified in "dynamic_fields" and is not part of the model. (read-only)
     */
    public var `dynamic`: Bool?

    /**
     * The name of the starting day of the week. Valid values are: "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday". (read-only)
     */
    public var week_start_day: WeekStartDay?

    private var _times_used: AnyInt?
    /**
     * The number of times this field has been used in queries (read-only)
     */
    public var times_used: Int64? {
        get { _times_used?.value }
        set { _times_used = newValue.map(AnyInt.init) }
    }

    private var _original_view: AnyString?
    /**
     * The name of the view this field is defined in. This will be different than "view" when the view has been joined via a different name using the "from" parameter. (read-only)
     */
    public var original_view: String? {
        get { _original_view?.value }
        set { _original_view = newValue.map(AnyString.init) }
    }

    public init(align: Align? = nil, can_filter: Bool? = nil, category: Category? = nil, default_filter_value: String? = nil, description: String? = nil, dimension_group: String? = nil, drill_fields: [String]? = nil, enumerations: [LookmlModelExploreFieldEnumeration]? = nil, error: String? = nil, field_group_label: String? = nil, field_group_variant: String? = nil, fill_style: FillStyle? = nil, fiscal_month_offset: Int64? = nil, has_allowed_values: Bool? = nil, has_drills_metadata: Bool? = nil, hidden: Bool? = nil, is_filter: Bool? = nil, is_fiscal: Bool? = nil, is_numeric: Bool? = nil, is_timeframe: Bool? = nil, can_time_filter: Bool? = nil, time_interval: LookmlModelExploreFieldTimeInterval? = nil, label: String? = nil, label_from_parameter: String? = nil, label_short: String? = nil, lookml_link: String? = nil, links: [LookmlFieldLink]? = nil, map_layer: LookmlModelExploreFieldMapLayer? = nil, measure: Bool? = nil, name: String? = nil, strict_value_format: Bool? = nil, parameter: Bool? = nil, period_over_period_params: LookmlModelExploreFieldPeriodOverPeriodParams? = nil, permanent: Bool? = nil, primary_key: Bool? = nil, project_name: String? = nil, requires_refresh_on_sort: Bool? = nil, scope: String? = nil, sortable: Bool? = nil, source_file: String? = nil, source_file_path: String? = nil, sql: String? = nil, sql_case: [LookmlModelExploreFieldSqlCase]? = nil, filters: [LookmlModelExploreFieldMeasureFilters]? = nil, suggest_dimension: String? = nil, suggest_explore: String? = nil, suggestable: Bool? = nil, suggestions: [String]? = nil, tags: [String]? = nil, type: String? = nil, user_attribute_filter_types: [UserAttributeFilterTypes]? = nil, value_format: String? = nil, view: String? = nil, view_label: String? = nil, `dynamic`: Bool? = nil, week_start_day: WeekStartDay? = nil, times_used: Int64? = nil, original_view: String? = nil) {
        self.align = align
        self.can_filter = can_filter
        self.category = category
        self._default_filter_value = default_filter_value.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self._dimension_group = dimension_group.map(AnyString.init)
        if let v = drill_fields { _drill_fields = v.map { AnyString.init($0) } } else { _drill_fields = nil }
        self.enumerations = enumerations
        self._error = error.map(AnyString.init)
        self._field_group_label = field_group_label.map(AnyString.init)
        self._field_group_variant = field_group_variant.map(AnyString.init)
        self.fill_style = fill_style
        self._fiscal_month_offset = fiscal_month_offset.map(AnyInt.init)
        self.has_allowed_values = has_allowed_values
        self.has_drills_metadata = has_drills_metadata
        self.hidden = hidden
        self.is_filter = is_filter
        self.is_fiscal = is_fiscal
        self.is_numeric = is_numeric
        self.is_timeframe = is_timeframe
        self.can_time_filter = can_time_filter
        self.time_interval = time_interval
        self._label = label.map(AnyString.init)
        self._label_from_parameter = label_from_parameter.map(AnyString.init)
        self._label_short = label_short.map(AnyString.init)
        self._lookml_link = lookml_link.map(AnyString.init)
        self.links = links
        self.map_layer = map_layer
        self.measure = measure
        self._name = name.map(AnyString.init)
        self.strict_value_format = strict_value_format
        self.parameter = parameter
        self.period_over_period_params = period_over_period_params
        self.permanent = permanent
        self.primary_key = primary_key
        self._project_name = project_name.map(AnyString.init)
        self.requires_refresh_on_sort = requires_refresh_on_sort
        self._scope = scope.map(AnyString.init)
        self.sortable = sortable
        self._source_file = source_file.map(AnyString.init)
        self._source_file_path = source_file_path.map(AnyString.init)
        self._sql = sql.map(AnyString.init)
        self.sql_case = sql_case
        self.filters = filters
        self._suggest_dimension = suggest_dimension.map(AnyString.init)
        self._suggest_explore = suggest_explore.map(AnyString.init)
        self.suggestable = suggestable
        if let v = suggestions { _suggestions = v.map { AnyString.init($0) } } else { _suggestions = nil }
        if let v = tags { _tags = v.map { AnyString.init($0) } } else { _tags = nil }
        self._type = type.map(AnyString.init)
        self.user_attribute_filter_types = user_attribute_filter_types
        self._value_format = value_format.map(AnyString.init)
        self._view = view.map(AnyString.init)
        self._view_label = view_label.map(AnyString.init)
        self.`dynamic` = `dynamic`
        self.week_start_day = week_start_day
        self._times_used = times_used.map(AnyInt.init)
        self._original_view = original_view.map(AnyString.init)
    }

}

public struct LookmlModelExploreFieldEnumeration: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _label = "label"
        case value
    }
    private var _label: AnyString?
    /**
     * Label (read-only)
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    /**
     * Value (read-only)
     */
    public var value: AnyCodable?

    public init(label: String? = nil, value: AnyCodable? = nil) {
        self._label = label.map(AnyString.init)
        self.value = value
    }

}

public struct LookmlModelExploreFieldMapLayer: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _url = "url"
        case _name = "name"
        case _feature_key = "feature_key"
        case _property_key = "property_key"
        case _property_label_key = "property_label_key"
        case _projection = "projection"
        case format
        case _extents_json_url = "extents_json_url"
        case _max_zoom_level = "max_zoom_level"
        case _min_zoom_level = "min_zoom_level"
    }
    private var _url: AnyString?
    /**
     * URL to the map layer resource. (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Name of the map layer, as defined in LookML. (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _feature_key: AnyString?
    /**
     * Specifies the name of the TopoJSON object that the map layer references. If not specified, use the first object.. (read-only)
     */
    public var feature_key: String? {
        get { _feature_key?.value }
        set { _feature_key = newValue.map(AnyString.init) }
    }

    private var _property_key: AnyString?
    /**
     * Selects which property from the TopoJSON data to plot against. TopoJSON supports arbitrary metadata for each region. When null, the first matching property should be used. (read-only)
     */
    public var property_key: String? {
        get { _property_key?.value }
        set { _property_key = newValue.map(AnyString.init) }
    }

    private var _property_label_key: AnyString?
    /**
     * Which property from the TopoJSON data to use to label the region. When null, property_key should be used. (read-only)
     */
    public var property_label_key: String? {
        get { _property_label_key?.value }
        set { _property_label_key = newValue.map(AnyString.init) }
    }

    private var _projection: AnyString?
    /**
     * The preferred geographic projection of the map layer when displayed in a visualization that supports multiple geographic projections. (read-only)
     */
    public var projection: String? {
        get { _projection?.value }
        set { _projection = newValue.map(AnyString.init) }
    }

    /**
     * Specifies the data format of the region information. Valid values are: "topojson", "vector_tile_region". (read-only)
     */
    public var format: Format?

    private var _extents_json_url: AnyString?
    /**
     * Specifies the URL to a JSON file that defines the geographic extents of each region available in the map layer. This data is used to automatically center the map on the available data for visualization purposes. The JSON file must be a JSON object where the keys are the mapping value of the feature (as specified by property_key) and the values are arrays of four numbers representing the west longitude, south latitude, east longitude, and north latitude extents of the region. The object must include a key for every possible value of property_key. (read-only)
     */
    public var extents_json_url: String? {
        get { _extents_json_url?.value }
        set { _extents_json_url = newValue.map(AnyString.init) }
    }

    private var _max_zoom_level: AnyInt?
    /**
     * The minimum zoom level that the map layer may be displayed at, for visualizations that support zooming. (read-only)
     */
    public var max_zoom_level: Int64? {
        get { _max_zoom_level?.value }
        set { _max_zoom_level = newValue.map(AnyInt.init) }
    }

    private var _min_zoom_level: AnyInt?
    /**
     * The maximum zoom level that the map layer may be displayed at, for visualizations that support zooming. (read-only)
     */
    public var min_zoom_level: Int64? {
        get { _min_zoom_level?.value }
        set { _min_zoom_level = newValue.map(AnyInt.init) }
    }

    public init(url: String? = nil, name: String? = nil, feature_key: String? = nil, property_key: String? = nil, property_label_key: String? = nil, projection: String? = nil, format: Format? = nil, extents_json_url: String? = nil, max_zoom_level: Int64? = nil, min_zoom_level: Int64? = nil) {
        self._url = url.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self._feature_key = feature_key.map(AnyString.init)
        self._property_key = property_key.map(AnyString.init)
        self._property_label_key = property_label_key.map(AnyString.init)
        self._projection = projection.map(AnyString.init)
        self.format = format
        self._extents_json_url = extents_json_url.map(AnyString.init)
        self._max_zoom_level = max_zoom_level.map(AnyInt.init)
        self._min_zoom_level = min_zoom_level.map(AnyInt.init)
    }

}

public struct LookmlModelExploreFieldMeasureFilters: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _field = "field"
        case _condition = "condition"
    }
    private var _field: AnyString?
    /**
     * Filter field name (read-only)
     */
    public var field: String? {
        get { _field?.value }
        set { _field = newValue.map(AnyString.init) }
    }

    private var _condition: AnyString?
    /**
     * Filter condition value (read-only)
     */
    public var condition: String? {
        get { _condition?.value }
        set { _condition = newValue.map(AnyString.init) }
    }

    public init(field: String? = nil, condition: String? = nil) {
        self._field = field.map(AnyString.init)
        self._condition = condition.map(AnyString.init)
    }

}

public struct LookmlModelExploreFieldPeriodOverPeriodParams: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _based_on = "based_on"
        case _based_on_time = "based_on_time"
        case period
        case kind
    }
    private var _based_on: AnyString?
    /**
     * Specifies the measure that will be calculated over the different periods. (read-only)
     */
    public var based_on: String? {
        get { _based_on?.value }
        set { _based_on = newValue.map(AnyString.init) }
    }

    private var _based_on_time: AnyString?
    /**
     * Specifies the time dimension that this measure will operate over. (read-only)
     */
    public var based_on_time: String? {
        get { _based_on_time?.value }
        set { _based_on_time = newValue.map(AnyString.init) }
    }

    /**
     * Specifies the time frame for the comparison. Valid values are: "year", "fiscal_year", "quarter", "fiscal_quarter", "month", "week", "date". (read-only)
     */
    public var period: Period?

    /**
     * The type of calculation for the period_over_period measure. Valid values are: "previous", "difference", "relative_change". (read-only)
     */
    public var kind: Kind?

    public init(based_on: String? = nil, based_on_time: String? = nil, period: Period? = nil, kind: Kind? = nil) {
        self._based_on = based_on.map(AnyString.init)
        self._based_on_time = based_on_time.map(AnyString.init)
        self.period = period
        self.kind = kind
    }

}

public struct LookmlModelExploreFieldset: SDKModel {
    /**
     * Array of dimensions (read-only)
     */
    public var dimensions: [LookmlModelExploreField]?

    /**
     * Array of measures (read-only)
     */
    public var measures: [LookmlModelExploreField]?

    /**
     * Array of filters (read-only)
     */
    public var filters: [LookmlModelExploreField]?

    /**
     * Array of parameters (read-only)
     */
    public var parameters: [LookmlModelExploreField]?

    public init(dimensions: [LookmlModelExploreField]? = nil, measures: [LookmlModelExploreField]? = nil, filters: [LookmlModelExploreField]? = nil, parameters: [LookmlModelExploreField]? = nil) {
        self.dimensions = dimensions
        self.measures = measures
        self.filters = filters
        self.parameters = parameters
    }

}

public struct LookmlModelExploreFieldSqlCase: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _value = "value"
        case _condition = "condition"
    }
    private var _value: AnyString?
    /**
     * SQL Case label value (read-only)
     */
    public var value: String? {
        get { _value?.value }
        set { _value = newValue.map(AnyString.init) }
    }

    private var _condition: AnyString?
    /**
     * SQL Case condition expression (read-only)
     */
    public var condition: String? {
        get { _condition?.value }
        set { _condition = newValue.map(AnyString.init) }
    }

    public init(value: String? = nil, condition: String? = nil) {
        self._value = value.map(AnyString.init)
        self._condition = condition.map(AnyString.init)
    }

}

public struct LookmlModelExploreFieldTimeInterval: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case name
        case _count = "count"
    }
    /**
     * The type of time interval this field represents a grouping of. Valid values are: "day", "hour", "minute", "second", "millisecond", "microsecond", "week", "month", "quarter", "year". (read-only)
     */
    public var name: Name?

    private var _count: AnyInt?
    /**
     * The number of intervals this field represents a grouping of. (read-only)
     */
    public var count: Int64? {
        get { _count?.value }
        set { _count = newValue.map(AnyInt.init) }
    }

    public init(name: Name? = nil, count: Int64? = nil) {
        self.name = name
        self._count = count.map(AnyInt.init)
    }

}

public struct LookmlModelExploreJoins: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _dependent_fields = "dependent_fields"
        case _fields = "fields"
        case _foreign_key = "foreign_key"
        case _from = "from"
        case outer_only
        case _relationship = "relationship"
        case _required_joins = "required_joins"
        case _sql_foreign_key = "sql_foreign_key"
        case _sql_on = "sql_on"
        case _sql_table_name = "sql_table_name"
        case _type = "type"
        case _view_label = "view_label"
    }
    private var _name: AnyString?
    /**
     * Name of this join (and name of the view to join) (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _dependent_fields: [AnyString]?
    /**
     * Fields referenced by the join (read-only)
     */
    public var dependent_fields: [String]? {
        get { if let v = _dependent_fields { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _dependent_fields = v.map { AnyString.init($0) } } else { _dependent_fields = nil } }
    }

    private var _fields: [AnyString]?
    /**
     * Fields of the joined view to pull into this explore (read-only)
     */
    public var fields: [String]? {
        get { if let v = _fields { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _fields = v.map { AnyString.init($0) } } else { _fields = nil } }
    }

    private var _foreign_key: AnyString?
    /**
     * Name of the dimension in this explore whose value is in the primary key of the joined view (read-only)
     */
    public var foreign_key: String? {
        get { _foreign_key?.value }
        set { _foreign_key = newValue.map(AnyString.init) }
    }

    private var _from: AnyString?
    /**
     * Name of view to join (read-only)
     */
    public var from: String? {
        get { _from?.value }
        set { _from = newValue.map(AnyString.init) }
    }

    /**
     * Specifies whether all queries must use an outer join (read-only)
     */
    public var outer_only: Bool?

    private var _relationship: AnyString?
    /**
     * many_to_one, one_to_one, one_to_many, many_to_many (read-only)
     */
    public var relationship: String? {
        get { _relationship?.value }
        set { _relationship = newValue.map(AnyString.init) }
    }

    private var _required_joins: [AnyString]?
    /**
     * Names of joins that must always be included in SQL queries (read-only)
     */
    public var required_joins: [String]? {
        get { if let v = _required_joins { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _required_joins = v.map { AnyString.init($0) } } else { _required_joins = nil } }
    }

    private var _sql_foreign_key: AnyString?
    /**
     * SQL expression that produces a foreign key (read-only)
     */
    public var sql_foreign_key: String? {
        get { _sql_foreign_key?.value }
        set { _sql_foreign_key = newValue.map(AnyString.init) }
    }

    private var _sql_on: AnyString?
    /**
     * SQL ON expression describing the join condition (read-only)
     */
    public var sql_on: String? {
        get { _sql_on?.value }
        set { _sql_on = newValue.map(AnyString.init) }
    }

    private var _sql_table_name: AnyString?
    /**
     * SQL table name to join (read-only)
     */
    public var sql_table_name: String? {
        get { _sql_table_name?.value }
        set { _sql_table_name = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * The join type: left_outer, full_outer, inner, or cross (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _view_label: AnyString?
    /**
     * Label to display in UI selectors (read-only)
     */
    public var view_label: String? {
        get { _view_label?.value }
        set { _view_label = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, dependent_fields: [String]? = nil, fields: [String]? = nil, foreign_key: String? = nil, from: String? = nil, outer_only: Bool? = nil, relationship: String? = nil, required_joins: [String]? = nil, sql_foreign_key: String? = nil, sql_on: String? = nil, sql_table_name: String? = nil, type: String? = nil, view_label: String? = nil) {
        self._name = name.map(AnyString.init)
        if let v = dependent_fields { _dependent_fields = v.map { AnyString.init($0) } } else { _dependent_fields = nil }
        if let v = fields { _fields = v.map { AnyString.init($0) } } else { _fields = nil }
        self._foreign_key = foreign_key.map(AnyString.init)
        self._from = from.map(AnyString.init)
        self.outer_only = outer_only
        self._relationship = relationship.map(AnyString.init)
        if let v = required_joins { _required_joins = v.map { AnyString.init($0) } } else { _required_joins = nil }
        self._sql_foreign_key = sql_foreign_key.map(AnyString.init)
        self._sql_on = sql_on.map(AnyString.init)
        self._sql_table_name = sql_table_name.map(AnyString.init)
        self._type = type.map(AnyString.init)
        self._view_label = view_label.map(AnyString.init)
    }

}

public struct LookmlModelExploreSet: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _value = "value"
    }
    private var _name: AnyString?
    /**
     * Name (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _value: [AnyString]?
    /**
     * Value set (read-only)
     */
    public var value: [String]? {
        get { if let v = _value { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _value = v.map { AnyString.init($0) } } else { _value = nil } }
    }

    public init(name: String? = nil, value: [String]? = nil) {
        self._name = name.map(AnyString.init)
        if let v = value { _value = v.map { AnyString.init($0) } } else { _value = nil }
    }

}

public struct LookmlModelExploreSupportedMeasureType: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _dimension_type = "dimension_type"
        case _measure_types = "measure_types"
    }
    private var _dimension_type: AnyString?
    /**
     *  (read-only)
     */
    public var dimension_type: String? {
        get { _dimension_type?.value }
        set { _dimension_type = newValue.map(AnyString.init) }
    }

    private var _measure_types: [AnyString]?
    /**
     *  (read-only)
     */
    public var measure_types: [String]? {
        get { if let v = _measure_types { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _measure_types = v.map { AnyString.init($0) } } else { _measure_types = nil } }
    }

    public init(dimension_type: String? = nil, measure_types: [String]? = nil) {
        self._dimension_type = dimension_type.map(AnyString.init)
        if let v = measure_types { _measure_types = v.map { AnyString.init($0) } } else { _measure_types = nil }
    }

}

public struct LookmlModelNavExplore: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _description = "description"
        case _label = "label"
        case hidden
        case _group_label = "group_label"
    }
    private var _name: AnyString?
    /**
     * Name of the explore (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * Description for the explore (read-only)
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    private var _label: AnyString?
    /**
     * Label for the explore (read-only)
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    /**
     * Is this explore marked as hidden (read-only)
     */
    public var hidden: Bool?

    private var _group_label: AnyString?
    /**
     * Label used to group explores in the navigation menus (read-only)
     */
    public var group_label: String? {
        get { _group_label?.value }
        set { _group_label = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, description: String? = nil, label: String? = nil, hidden: Bool? = nil, group_label: String? = nil) {
        self._name = name.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self._label = label.map(AnyString.init)
        self.hidden = hidden
        self._group_label = group_label.map(AnyString.init)
    }

}

public struct LookmlTest: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _model_name = "model_name"
        case _name = "name"
        case _explore_name = "explore_name"
        case _query_url_params = "query_url_params"
        case _file = "file"
        case _line = "line"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _model_name: AnyString?
    /**
     * Name of model containing this test. (read-only)
     */
    public var model_name: String? {
        get { _model_name?.value }
        set { _model_name = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Name of this test. (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _explore_name: AnyString?
    /**
     * Name of the explore this test runs a query against (read-only)
     */
    public var explore_name: String? {
        get { _explore_name?.value }
        set { _explore_name = newValue.map(AnyString.init) }
    }

    private var _query_url_params: AnyString?
    /**
     * The url parameters that can be used to reproduce this test's query on an explore. (read-only)
     */
    public var query_url_params: String? {
        get { _query_url_params?.value }
        set { _query_url_params = newValue.map(AnyString.init) }
    }

    private var _file: AnyString?
    /**
     * Name of the LookML file containing this test. (read-only)
     */
    public var file: String? {
        get { _file?.value }
        set { _file = newValue.map(AnyString.init) }
    }

    private var _line: AnyInt?
    /**
     * Line number of this test in LookML. (read-only)
     */
    public var line: Int64? {
        get { _line?.value }
        set { _line = newValue.map(AnyInt.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, model_name: String? = nil, name: String? = nil, explore_name: String? = nil, query_url_params: String? = nil, file: String? = nil, line: Int64? = nil) {
        self.can = can
        self._model_name = model_name.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self._explore_name = explore_name.map(AnyString.init)
        self._query_url_params = query_url_params.map(AnyString.init)
        self._file = file.map(AnyString.init)
        self._line = line.map(AnyInt.init)
    }

}

public struct LookmlTestResult: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _model_name = "model_name"
        case _test_name = "test_name"
        case _assertions_count = "assertions_count"
        case _assertions_failed = "assertions_failed"
        case errors
        case warnings
        case success
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _model_name: AnyString?
    /**
     * Name of model containing this test. (read-only)
     */
    public var model_name: String? {
        get { _model_name?.value }
        set { _model_name = newValue.map(AnyString.init) }
    }

    private var _test_name: AnyString?
    /**
     * Name of this test. (read-only)
     */
    public var test_name: String? {
        get { _test_name?.value }
        set { _test_name = newValue.map(AnyString.init) }
    }

    private var _assertions_count: AnyInt?
    /**
     * Number of assertions in this test (read-only)
     */
    public var assertions_count: Int64? {
        get { _assertions_count?.value }
        set { _assertions_count = newValue.map(AnyInt.init) }
    }

    private var _assertions_failed: AnyInt?
    /**
     * Number of assertions passed in this test (read-only)
     */
    public var assertions_failed: Int64? {
        get { _assertions_failed?.value }
        set { _assertions_failed = newValue.map(AnyInt.init) }
    }

    /**
     * A list of any errors encountered by the test. (read-only)
     */
    public var errors: [ProjectError]?

    /**
     * A list of any warnings encountered by the test. (read-only)
     */
    public var warnings: [ProjectError]?

    /**
     * True if this test passsed without errors. (read-only)
     */
    public var success: Bool?

    public init(can: StringDictionary<Bool>? = nil, model_name: String? = nil, test_name: String? = nil, assertions_count: Int64? = nil, assertions_failed: Int64? = nil, errors: [ProjectError]? = nil, warnings: [ProjectError]? = nil, success: Bool? = nil) {
        self.can = can
        self._model_name = model_name.map(AnyString.init)
        self._test_name = test_name.map(AnyString.init)
        self._assertions_count = assertions_count.map(AnyInt.init)
        self._assertions_failed = assertions_failed.map(AnyInt.init)
        self.errors = errors
        self.warnings = warnings
        self.success = success
    }

}

public struct LookMLValidatorError: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _type = "type"
        case _title = "title"
        case _detail = "detail"
        case _status = "status"
        case _instance = "instance"
        case _model = "model"
        case _explore = "explore"
        case _field_name = "field_name"
        case _message = "message"
        case _severity = "severity"
        case _line_number = "line_number"
        case _lookml_url = "lookml_url"
        case _file_path = "file_path"
    }
    private var _type: AnyString?
    /**
     * A URI reference that identifies the problem type (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Overview of the error (read-only)
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _detail: AnyString?
    /**
     * Detail of the error (read-only)
     */
    public var detail: String? {
        get { _detail?.value }
        set { _detail = newValue.map(AnyString.init) }
    }

    private var _status: AnyString?
    /**
     * The HTTP status code for the problem (read-only)
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    private var _instance: AnyString?
    /**
     * URI reference that identifies the specific occurrence of the problem (read-only)
     */
    public var instance: String? {
        get { _instance?.value }
        set { _instance = newValue.map(AnyString.init) }
    }

    private var _model: AnyString?
    /**
     * LookML model that contains the error (read-only)
     */
    public var model: String? {
        get { _model?.value }
        set { _model = newValue.map(AnyString.init) }
    }

    private var _explore: AnyString?
    /**
     * LookML Explore that contains the error (read-only)
     */
    public var explore: String? {
        get { _explore?.value }
        set { _explore = newValue.map(AnyString.init) }
    }

    private var _field_name: AnyString?
    /**
     * LookML field that caused the error (read-only)
     */
    public var field_name: String? {
        get { _field_name?.value }
        set { _field_name = newValue.map(AnyString.init) }
    }

    private var _message: AnyString?
    /**
     * Message returned by the LookML validator (read-only)
     */
    public var message: String? {
        get { _message?.value }
        set { _message = newValue.map(AnyString.init) }
    }

    private var _severity: AnyString?
    /**
     * Severity of the error (warning, error, fatal, info, success) (read-only)
     */
    public var severity: String? {
        get { _severity?.value }
        set { _severity = newValue.map(AnyString.init) }
    }

    private var _line_number: AnyString?
    /**
     * Line number of the error in the LookML file (read-only)
     */
    public var line_number: String? {
        get { _line_number?.value }
        set { _line_number = newValue.map(AnyString.init) }
    }

    private var _lookml_url: AnyString?
    /**
     * URL to the LookML that caused the error (read-only)
     */
    public var lookml_url: String? {
        get { _lookml_url?.value }
        set { _lookml_url = newValue.map(AnyString.init) }
    }

    private var _file_path: AnyString?
    /**
     * IDE folder path to the LookML file that caused the error (read-only)
     */
    public var file_path: String? {
        get { _file_path?.value }
        set { _file_path = newValue.map(AnyString.init) }
    }

    public init(type: String? = nil, title: String? = nil, detail: String? = nil, status: String? = nil, instance: String? = nil, model: String? = nil, explore: String? = nil, field_name: String? = nil, message: String? = nil, severity: String? = nil, line_number: String? = nil, lookml_url: String? = nil, file_path: String? = nil) {
        self._type = type.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self._detail = detail.map(AnyString.init)
        self._status = status.map(AnyString.init)
        self._instance = instance.map(AnyString.init)
        self._model = model.map(AnyString.init)
        self._explore = explore.map(AnyString.init)
        self._field_name = field_name.map(AnyString.init)
        self._message = message.map(AnyString.init)
        self._severity = severity.map(AnyString.init)
        self._line_number = line_number.map(AnyString.init)
        self._lookml_url = lookml_url.map(AnyString.init)
        self._file_path = file_path.map(AnyString.init)
    }

}

public struct LookMLValidatorErrorItem: SDKModel {
    public var lookml_error: LookMLValidatorError?

    public var generic_error: GenericError?

    public init(lookml_error: LookMLValidatorError? = nil, generic_error: GenericError? = nil) {
        self.lookml_error = lookml_error
        self.generic_error = generic_error
    }

}

public struct LookMLValidatorResult: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _status = "status"
        case _error_count = "error_count"
        case errors
    }
    private var _name: AnyString?
    /**
     * Name of the validator (lookml) (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _status: AnyString?
    /**
     * Status of the validation (unknown, failed, passed, skipped, errored, cancelled, queued, running) (read-only)
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    private var _error_count: AnyInt?
    /**
     * Total number of failed LookML validations (read-only)
     */
    public var error_count: Int64? {
        get { _error_count?.value }
        set { _error_count = newValue.map(AnyInt.init) }
    }

    /**
     * Details of the LookML that failed validation (read-only)
     */
    public var errors: [LookMLValidatorErrorItem]?

    public init(name: String? = nil, status: String? = nil, error_count: Int64? = nil, errors: [LookMLValidatorErrorItem]? = nil) {
        self._name = name.map(AnyString.init)
        self._status = status.map(AnyString.init)
        self._error_count = error_count.map(AnyInt.init)
        self.errors = errors
    }

}

public struct LookModel: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _label = "label"
    }
    private var _id: AnyString?
    /**
     * Model Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _label: AnyString?
    /**
     * Model Label (read-only)
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    public init(id: String? = nil, label: String? = nil) {
        self._id = id.map(AnyString.init)
        self._label = label.map(AnyString.init)
    }

}

public struct LookWithDashboards: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _content_metadata_id = "content_metadata_id"
        case _id = "id"
        case _title = "title"
        case _user_id = "user_id"
        case _content_favorite_id = "content_favorite_id"
        case created_at
        case deleted
        case deleted_at
        case _deleter_id = "deleter_id"
        case _description = "description"
        case _embed_url = "embed_url"
        case _excel_file_url = "excel_file_url"
        case _favorite_count = "favorite_count"
        case _google_spreadsheet_formula = "google_spreadsheet_formula"
        case _image_embed_url = "image_embed_url"
        case is_run_on_load
        case last_accessed_at
        case _last_updater_id = "last_updater_id"
        case last_viewed_at
        case model
        case `public`
        case _public_slug = "public_slug"
        case _public_url = "public_url"
        case _query_id = "query_id"
        case _short_url = "short_url"
        case folder
        case _folder_id = "folder_id"
        case updated_at
        case _user_name = "user_name"
        case _view_count = "view_count"
        case dashboards
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _content_metadata_id: AnyString?
    /**
     * Id of content metadata (read-only)
     */
    public var content_metadata_id: String? {
        get { _content_metadata_id?.value }
        set { _content_metadata_id = newValue.map(AnyString.init) }
    }

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Look Title
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _user_id: AnyString?
    /**
     * User Id
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    private var _content_favorite_id: AnyString?
    /**
     * Content Favorite Id (read-only)
     */
    public var content_favorite_id: String? {
        get { _content_favorite_id?.value }
        set { _content_favorite_id = newValue.map(AnyString.init) }
    }

    /**
     * Time that the Look was created. (read-only)
     */
    public var created_at: Date?

    /**
     * Whether or not a look is 'soft' deleted.
     */
    public var deleted: Bool?

    /**
     * Time that the Look was deleted. (read-only)
     */
    public var deleted_at: Date?

    private var _deleter_id: AnyString?
    /**
     * Id of User that deleted the look. (read-only)
     */
    public var deleter_id: String? {
        get { _deleter_id?.value }
        set { _deleter_id = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * Description
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    private var _embed_url: AnyString?
    /**
     * Embed Url (read-only)
     */
    public var embed_url: String? {
        get { _embed_url?.value }
        set { _embed_url = newValue.map(AnyString.init) }
    }

    private var _excel_file_url: AnyString?
    /**
     * Excel File Url (read-only)
     */
    public var excel_file_url: String? {
        get { _excel_file_url?.value }
        set { _excel_file_url = newValue.map(AnyString.init) }
    }

    private var _favorite_count: AnyInt?
    /**
     * Number of times favorited (read-only)
     */
    public var favorite_count: Int64? {
        get { _favorite_count?.value }
        set { _favorite_count = newValue.map(AnyInt.init) }
    }

    private var _google_spreadsheet_formula: AnyString?
    /**
     * Google Spreadsheet Formula (read-only)
     */
    public var google_spreadsheet_formula: String? {
        get { _google_spreadsheet_formula?.value }
        set { _google_spreadsheet_formula = newValue.map(AnyString.init) }
    }

    private var _image_embed_url: AnyString?
    /**
     * Image Embed Url (read-only)
     */
    public var image_embed_url: String? {
        get { _image_embed_url?.value }
        set { _image_embed_url = newValue.map(AnyString.init) }
    }

    /**
     * auto-run query when Look viewed
     */
    public var is_run_on_load: Bool?

    /**
     * Time that the Look was last accessed by any user (read-only)
     */
    public var last_accessed_at: Date?

    private var _last_updater_id: AnyString?
    /**
     * Id of User that last updated the look. (read-only)
     */
    public var last_updater_id: String? {
        get { _last_updater_id?.value }
        set { _last_updater_id = newValue.map(AnyString.init) }
    }

    /**
     * Time last viewed in the Looker web UI (read-only)
     */
    public var last_viewed_at: Date?

    public var model: LookModel?

    /**
     * Is Public
     */
    public var `public`: Bool?

    private var _public_slug: AnyString?
    /**
     * Public Slug (read-only)
     */
    public var public_slug: String? {
        get { _public_slug?.value }
        set { _public_slug = newValue.map(AnyString.init) }
    }

    private var _public_url: AnyString?
    /**
     * Public Url (read-only)
     */
    public var public_url: String? {
        get { _public_url?.value }
        set { _public_url = newValue.map(AnyString.init) }
    }

    private var _query_id: AnyString?
    /**
     * Query Id
     */
    public var query_id: String? {
        get { _query_id?.value }
        set { _query_id = newValue.map(AnyString.init) }
    }

    private var _short_url: AnyString?
    /**
     * Short Url (read-only)
     */
    public var short_url: String? {
        get { _short_url?.value }
        set { _short_url = newValue.map(AnyString.init) }
    }

    public var folder: FolderBase?

    private var _folder_id: AnyString?
    /**
     * Folder Id
     */
    public var folder_id: String? {
        get { _folder_id?.value }
        set { _folder_id = newValue.map(AnyString.init) }
    }

    /**
     * Time that the Look was updated. (read-only)
     */
    public var updated_at: Date?

    private var _user_name: AnyString?
    /**
     * Name of User that created the look. (read-only)
     */
    public var user_name: String? {
        get { _user_name?.value }
        set { _user_name = newValue.map(AnyString.init) }
    }

    private var _view_count: AnyInt?
    /**
     * Number of times viewed in the Looker web UI (read-only)
     */
    public var view_count: Int64? {
        get { _view_count?.value }
        set { _view_count = newValue.map(AnyInt.init) }
    }

    /**
     * Dashboards (read-only)
     */
    public var dashboards: [DashboardBase]?

    public init(can: StringDictionary<Bool>? = nil, content_metadata_id: String? = nil, id: String? = nil, title: String? = nil, user_id: String? = nil, content_favorite_id: String? = nil, created_at: Date? = nil, deleted: Bool? = nil, deleted_at: Date? = nil, deleter_id: String? = nil, description: String? = nil, embed_url: String? = nil, excel_file_url: String? = nil, favorite_count: Int64? = nil, google_spreadsheet_formula: String? = nil, image_embed_url: String? = nil, is_run_on_load: Bool? = nil, last_accessed_at: Date? = nil, last_updater_id: String? = nil, last_viewed_at: Date? = nil, model: LookModel? = nil, `public`: Bool? = nil, public_slug: String? = nil, public_url: String? = nil, query_id: String? = nil, short_url: String? = nil, folder: FolderBase? = nil, folder_id: String? = nil, updated_at: Date? = nil, user_name: String? = nil, view_count: Int64? = nil, dashboards: [DashboardBase]? = nil) {
        self.can = can
        self._content_metadata_id = content_metadata_id.map(AnyString.init)
        self._id = id.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self._user_id = user_id.map(AnyString.init)
        self._content_favorite_id = content_favorite_id.map(AnyString.init)
        self.created_at = created_at
        self.deleted = deleted
        self.deleted_at = deleted_at
        self._deleter_id = deleter_id.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self._embed_url = embed_url.map(AnyString.init)
        self._excel_file_url = excel_file_url.map(AnyString.init)
        self._favorite_count = favorite_count.map(AnyInt.init)
        self._google_spreadsheet_formula = google_spreadsheet_formula.map(AnyString.init)
        self._image_embed_url = image_embed_url.map(AnyString.init)
        self.is_run_on_load = is_run_on_load
        self.last_accessed_at = last_accessed_at
        self._last_updater_id = last_updater_id.map(AnyString.init)
        self.last_viewed_at = last_viewed_at
        self.model = model
        self.`public` = `public`
        self._public_slug = public_slug.map(AnyString.init)
        self._public_url = public_url.map(AnyString.init)
        self._query_id = query_id.map(AnyString.init)
        self._short_url = short_url.map(AnyString.init)
        self.folder = folder
        self._folder_id = folder_id.map(AnyString.init)
        self.updated_at = updated_at
        self._user_name = user_name.map(AnyString.init)
        self._view_count = view_count.map(AnyInt.init)
        self.dashboards = dashboards
    }

}

public struct LookWithQuery: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _content_metadata_id = "content_metadata_id"
        case _id = "id"
        case _title = "title"
        case _user_id = "user_id"
        case _content_favorite_id = "content_favorite_id"
        case created_at
        case deleted
        case deleted_at
        case _deleter_id = "deleter_id"
        case _description = "description"
        case _embed_url = "embed_url"
        case _excel_file_url = "excel_file_url"
        case _favorite_count = "favorite_count"
        case _google_spreadsheet_formula = "google_spreadsheet_formula"
        case _image_embed_url = "image_embed_url"
        case is_run_on_load
        case last_accessed_at
        case _last_updater_id = "last_updater_id"
        case last_viewed_at
        case model
        case `public`
        case _public_slug = "public_slug"
        case _public_url = "public_url"
        case _query_id = "query_id"
        case _short_url = "short_url"
        case folder
        case _folder_id = "folder_id"
        case updated_at
        case _user_name = "user_name"
        case _view_count = "view_count"
        case query
        case _url = "url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _content_metadata_id: AnyString?
    /**
     * Id of content metadata (read-only)
     */
    public var content_metadata_id: String? {
        get { _content_metadata_id?.value }
        set { _content_metadata_id = newValue.map(AnyString.init) }
    }

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Look Title
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _user_id: AnyString?
    /**
     * User Id
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    private var _content_favorite_id: AnyString?
    /**
     * Content Favorite Id (read-only)
     */
    public var content_favorite_id: String? {
        get { _content_favorite_id?.value }
        set { _content_favorite_id = newValue.map(AnyString.init) }
    }

    /**
     * Time that the Look was created. (read-only)
     */
    public var created_at: Date?

    /**
     * Whether or not a look is 'soft' deleted.
     */
    public var deleted: Bool?

    /**
     * Time that the Look was deleted. (read-only)
     */
    public var deleted_at: Date?

    private var _deleter_id: AnyString?
    /**
     * Id of User that deleted the look. (read-only)
     */
    public var deleter_id: String? {
        get { _deleter_id?.value }
        set { _deleter_id = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * Description
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    private var _embed_url: AnyString?
    /**
     * Embed Url (read-only)
     */
    public var embed_url: String? {
        get { _embed_url?.value }
        set { _embed_url = newValue.map(AnyString.init) }
    }

    private var _excel_file_url: AnyString?
    /**
     * Excel File Url (read-only)
     */
    public var excel_file_url: String? {
        get { _excel_file_url?.value }
        set { _excel_file_url = newValue.map(AnyString.init) }
    }

    private var _favorite_count: AnyInt?
    /**
     * Number of times favorited (read-only)
     */
    public var favorite_count: Int64? {
        get { _favorite_count?.value }
        set { _favorite_count = newValue.map(AnyInt.init) }
    }

    private var _google_spreadsheet_formula: AnyString?
    /**
     * Google Spreadsheet Formula (read-only)
     */
    public var google_spreadsheet_formula: String? {
        get { _google_spreadsheet_formula?.value }
        set { _google_spreadsheet_formula = newValue.map(AnyString.init) }
    }

    private var _image_embed_url: AnyString?
    /**
     * Image Embed Url (read-only)
     */
    public var image_embed_url: String? {
        get { _image_embed_url?.value }
        set { _image_embed_url = newValue.map(AnyString.init) }
    }

    /**
     * auto-run query when Look viewed
     */
    public var is_run_on_load: Bool?

    /**
     * Time that the Look was last accessed by any user (read-only)
     */
    public var last_accessed_at: Date?

    private var _last_updater_id: AnyString?
    /**
     * Id of User that last updated the look. (read-only)
     */
    public var last_updater_id: String? {
        get { _last_updater_id?.value }
        set { _last_updater_id = newValue.map(AnyString.init) }
    }

    /**
     * Time last viewed in the Looker web UI (read-only)
     */
    public var last_viewed_at: Date?

    public var model: LookModel?

    /**
     * Is Public
     */
    public var `public`: Bool?

    private var _public_slug: AnyString?
    /**
     * Public Slug (read-only)
     */
    public var public_slug: String? {
        get { _public_slug?.value }
        set { _public_slug = newValue.map(AnyString.init) }
    }

    private var _public_url: AnyString?
    /**
     * Public Url (read-only)
     */
    public var public_url: String? {
        get { _public_url?.value }
        set { _public_url = newValue.map(AnyString.init) }
    }

    private var _query_id: AnyString?
    /**
     * Query Id
     */
    public var query_id: String? {
        get { _query_id?.value }
        set { _query_id = newValue.map(AnyString.init) }
    }

    private var _short_url: AnyString?
    /**
     * Short Url (read-only)
     */
    public var short_url: String? {
        get { _short_url?.value }
        set { _short_url = newValue.map(AnyString.init) }
    }

    public var folder: FolderBase?

    private var _folder_id: AnyString?
    /**
     * Folder Id
     */
    public var folder_id: String? {
        get { _folder_id?.value }
        set { _folder_id = newValue.map(AnyString.init) }
    }

    /**
     * Time that the Look was updated. (read-only)
     */
    public var updated_at: Date?

    private var _user_name: AnyString?
    /**
     * Name of User that created the look. (read-only)
     */
    public var user_name: String? {
        get { _user_name?.value }
        set { _user_name = newValue.map(AnyString.init) }
    }

    private var _view_count: AnyInt?
    /**
     * Number of times viewed in the Looker web UI (read-only)
     */
    public var view_count: Int64? {
        get { _view_count?.value }
        set { _view_count = newValue.map(AnyInt.init) }
    }

    public var query: Query?

    private var _url: AnyString?
    /**
     * Url (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, content_metadata_id: String? = nil, id: String? = nil, title: String? = nil, user_id: String? = nil, content_favorite_id: String? = nil, created_at: Date? = nil, deleted: Bool? = nil, deleted_at: Date? = nil, deleter_id: String? = nil, description: String? = nil, embed_url: String? = nil, excel_file_url: String? = nil, favorite_count: Int64? = nil, google_spreadsheet_formula: String? = nil, image_embed_url: String? = nil, is_run_on_load: Bool? = nil, last_accessed_at: Date? = nil, last_updater_id: String? = nil, last_viewed_at: Date? = nil, model: LookModel? = nil, `public`: Bool? = nil, public_slug: String? = nil, public_url: String? = nil, query_id: String? = nil, short_url: String? = nil, folder: FolderBase? = nil, folder_id: String? = nil, updated_at: Date? = nil, user_name: String? = nil, view_count: Int64? = nil, query: Query? = nil, url: String? = nil) {
        self.can = can
        self._content_metadata_id = content_metadata_id.map(AnyString.init)
        self._id = id.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self._user_id = user_id.map(AnyString.init)
        self._content_favorite_id = content_favorite_id.map(AnyString.init)
        self.created_at = created_at
        self.deleted = deleted
        self.deleted_at = deleted_at
        self._deleter_id = deleter_id.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self._embed_url = embed_url.map(AnyString.init)
        self._excel_file_url = excel_file_url.map(AnyString.init)
        self._favorite_count = favorite_count.map(AnyInt.init)
        self._google_spreadsheet_formula = google_spreadsheet_formula.map(AnyString.init)
        self._image_embed_url = image_embed_url.map(AnyString.init)
        self.is_run_on_load = is_run_on_load
        self.last_accessed_at = last_accessed_at
        self._last_updater_id = last_updater_id.map(AnyString.init)
        self.last_viewed_at = last_viewed_at
        self.model = model
        self.`public` = `public`
        self._public_slug = public_slug.map(AnyString.init)
        self._public_url = public_url.map(AnyString.init)
        self._query_id = query_id.map(AnyString.init)
        self._short_url = short_url.map(AnyString.init)
        self.folder = folder
        self._folder_id = folder_id.map(AnyString.init)
        self.updated_at = updated_at
        self._user_name = user_name.map(AnyString.init)
        self._view_count = view_count.map(AnyInt.init)
        self.query = query
        self._url = url.map(AnyString.init)
    }

}

public struct Manifest: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _name = "name"
        case imports
        case localization_settings
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _name: AnyString?
    /**
     * Manifest project name (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     * Imports for a project (read-only)
     */
    public var imports: [ImportedProject]?

    public var localization_settings: LocalizationSettings?

    public init(can: StringDictionary<Bool>? = nil, name: String? = nil, imports: [ImportedProject]? = nil, localization_settings: LocalizationSettings? = nil) {
        self.can = can
        self._name = name.map(AnyString.init)
        self.imports = imports
        self.localization_settings = localization_settings
    }

}

public struct MarketplaceAutomation: SDKModel {
    /**
     * Whether marketplace auto installation is enabled
     */
    public var install_enabled: Bool?

    /**
     * Whether marketplace auto update is enabled for looker extensions
     */
    public var update_looker_enabled: Bool?

    /**
     * Whether marketplace auto update is enabled for third party extensions
     */
    public var update_third_party_enabled: Bool?

    public init(install_enabled: Bool? = nil, update_looker_enabled: Bool? = nil, update_third_party_enabled: Bool? = nil) {
        self.install_enabled = install_enabled
        self.update_looker_enabled = update_looker_enabled
        self.update_third_party_enabled = update_third_party_enabled
    }

}

public struct MaterializePDT: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _materialization_id = "materialization_id"
        case _resp_text = "resp_text"
    }
    private var _materialization_id: AnyString?
    /**
     * The ID of the enqueued materialization task (read-only)
     */
    public var materialization_id: String? {
        get { _materialization_id?.value }
        set { _materialization_id = newValue.map(AnyString.init) }
    }

    private var _resp_text: AnyString?
    /**
     * Detailed response in text format (read-only)
     */
    public var resp_text: String? {
        get { _resp_text?.value }
        set { _resp_text = newValue.map(AnyString.init) }
    }

    public init(materialization_id: String? = nil, resp_text: String? = nil) {
        self._materialization_id = materialization_id.map(AnyString.init)
        self._resp_text = resp_text.map(AnyString.init)
    }

}

public struct MergeFields: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _field_name = "field_name"
        case _source_field_name = "source_field_name"
    }
    private var _field_name: AnyString?
    /**
     * Field name to map onto in the merged results
     */
    public var field_name: String? {
        get { _field_name?.value }
        set { _field_name = newValue.map(AnyString.init) }
    }

    private var _source_field_name: AnyString?
    /**
     * Field name from the source query
     */
    public var source_field_name: String? {
        get { _source_field_name?.value }
        set { _source_field_name = newValue.map(AnyString.init) }
    }

    public init(field_name: String? = nil, source_field_name: String? = nil) {
        self._field_name = field_name.map(AnyString.init)
        self._source_field_name = source_field_name.map(AnyString.init)
    }

}

public struct MergeQuery: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _column_limit = "column_limit"
        case _dynamic_fields = "dynamic_fields"
        case _id = "id"
        case _pivots = "pivots"
        case _result_maker_id = "result_maker_id"
        case _sorts = "sorts"
        case source_queries
        case total
        case vis_config
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _column_limit: AnyString?
    /**
     * Column Limit
     */
    public var column_limit: String? {
        get { _column_limit?.value }
        set { _column_limit = newValue.map(AnyString.init) }
    }

    private var _dynamic_fields: AnyString?
    /**
     * Dynamic Fields
     */
    public var dynamic_fields: String? {
        get { _dynamic_fields?.value }
        set { _dynamic_fields = newValue.map(AnyString.init) }
    }

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _pivots: [AnyString]?
    /**
     * Pivots
     */
    public var pivots: [String]? {
        get { if let v = _pivots { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _pivots = v.map { AnyString.init($0) } } else { _pivots = nil } }
    }

    private var _result_maker_id: AnyString?
    /**
     * Unique to get results (read-only)
     */
    public var result_maker_id: String? {
        get { _result_maker_id?.value }
        set { _result_maker_id = newValue.map(AnyString.init) }
    }

    private var _sorts: [AnyString]?
    /**
     * Sorts
     */
    public var sorts: [String]? {
        get { if let v = _sorts { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _sorts = v.map { AnyString.init($0) } } else { _sorts = nil } }
    }

    /**
     * Source Queries defining the results to be merged.
     */
    public var source_queries: [MergeQuerySourceQuery]?

    /**
     * Total
     */
    public var total: Bool?

    /**
     * Visualization Config
     */
    public var vis_config: StringDictionary<AnyCodable>?

    public init(can: StringDictionary<Bool>? = nil, column_limit: String? = nil, dynamic_fields: String? = nil, id: String? = nil, pivots: [String]? = nil, result_maker_id: String? = nil, sorts: [String]? = nil, source_queries: [MergeQuerySourceQuery]? = nil, total: Bool? = nil, vis_config: StringDictionary<AnyCodable>? = nil) {
        self.can = can
        self._column_limit = column_limit.map(AnyString.init)
        self._dynamic_fields = dynamic_fields.map(AnyString.init)
        self._id = id.map(AnyString.init)
        if let v = pivots { _pivots = v.map { AnyString.init($0) } } else { _pivots = nil }
        self._result_maker_id = result_maker_id.map(AnyString.init)
        if let v = sorts { _sorts = v.map { AnyString.init($0) } } else { _sorts = nil }
        self.source_queries = source_queries
        self.total = total
        self.vis_config = vis_config
    }

}

public struct MergeQuerySourceQuery: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case merge_fields
        case _name = "name"
        case _query_id = "query_id"
        case _query_slug = "query_slug"
    }
    /**
     * An array defining which fields of the source query are mapped onto fields of the merge query
     */
    public var merge_fields: [MergeFields]?

    private var _name: AnyString?
    /**
     * Display name
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _query_id: AnyString?
    /**
     * Id of the query to merge
     */
    public var query_id: String? {
        get { _query_id?.value }
        set { _query_id = newValue.map(AnyString.init) }
    }

    private var _query_slug: AnyString?
    /**
     * Slug of the query to merge
     */
    public var query_slug: String? {
        get { _query_slug?.value }
        set { _query_slug = newValue.map(AnyString.init) }
    }

    public init(merge_fields: [MergeFields]? = nil, name: String? = nil, query_id: String? = nil, query_slug: String? = nil) {
        self.merge_fields = merge_fields
        self._name = name.map(AnyString.init)
        self._query_id = query_id.map(AnyString.init)
        self._query_slug = query_slug.map(AnyString.init)
    }

}

public struct MobileFeatureFlags: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _feature_flag_name = "feature_flag_name"
        case feature_flag_state
    }
    private var _feature_flag_name: AnyString?
    /**
     * Specifies the name of feature flag. (read-only)
     */
    public var feature_flag_name: String? {
        get { _feature_flag_name?.value }
        set { _feature_flag_name = newValue.map(AnyString.init) }
    }

    /**
     * Specifies the state of feature flag (read-only)
     */
    public var feature_flag_state: Bool?

    public init(feature_flag_name: String? = nil, feature_flag_state: Bool? = nil) {
        self._feature_flag_name = feature_flag_name.map(AnyString.init)
        self.feature_flag_state = feature_flag_state
    }

}

public struct MobilePayload: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _title = "title"
        case _alert_id = "alert_id"
        case _investigative_content_id = "investigative_content_id"
        case _dashboard_name = "dashboard_name"
        case _dashboard_id = "dashboard_id"
        case _query_slug = "query_slug"
    }
    private var _title: AnyString?
    /**
     * Title of the alert (read-only)
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _alert_id: AnyString
    /**
     * ID of the alert (read-only)
     */
    public var alert_id: String {
        get { _alert_id.value }
        set { _alert_id = AnyString.init(newValue) }
    }

    private var _investigative_content_id: AnyString?
    /**
     * ID of the investigative content (read-only)
     */
    public var investigative_content_id: String? {
        get { _investigative_content_id?.value }
        set { _investigative_content_id = newValue.map(AnyString.init) }
    }

    private var _dashboard_name: AnyString?
    /**
     * Name of the dashboard on which the alert has been set (read-only)
     */
    public var dashboard_name: String? {
        get { _dashboard_name?.value }
        set { _dashboard_name = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString?
    /**
     * ID of the dashboard on which the alert has been set (read-only)
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    private var _query_slug: AnyString?
    /**
     * Slug of the query which runs the alert queries. (read-only)
     */
    public var query_slug: String? {
        get { _query_slug?.value }
        set { _query_slug = newValue.map(AnyString.init) }
    }

    public init(title: String? = nil, alert_id: String, investigative_content_id: String? = nil, dashboard_name: String? = nil, dashboard_id: String? = nil, query_slug: String? = nil) {
        self._title = title.map(AnyString.init)
        self._alert_id = AnyString.init(alert_id)
        self._investigative_content_id = investigative_content_id.map(AnyString.init)
        self._dashboard_name = dashboard_name.map(AnyString.init)
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self._query_slug = query_slug.map(AnyString.init)
    }

    public init(title: String? = nil, _ alert_id: String, investigative_content_id: String? = nil, dashboard_name: String? = nil, dashboard_id: String? = nil, query_slug: String? = nil) {
        self.init(title: title, alert_id: alert_id, investigative_content_id: investigative_content_id, dashboard_name: dashboard_name, dashboard_id: dashboard_id, query_slug: query_slug)
    }

}

public struct MobileSettings: SDKModel {
    /**
     * Specifies whether the force authentication option is enabled for mobile (read-only)
     */
    public var mobile_force_authentication: Bool?

    /**
     * Specifies whether mobile access for this instance is enabled. (read-only)
     */
    public var mobile_app_integration: Bool?

    /**
     * Specifies feature flag and state relevant to mobile. (read-only)
     */
    public var mobile_feature_flags: [MobileFeatureFlags]?

    public init(mobile_force_authentication: Bool? = nil, mobile_app_integration: Bool? = nil, mobile_feature_flags: [MobileFeatureFlags]? = nil) {
        self.mobile_force_authentication = mobile_force_authentication
        self.mobile_app_integration = mobile_app_integration
        self.mobile_feature_flags = mobile_feature_flags
    }

}

public struct MobileToken: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _device_token = "device_token"
        case device_type
    }
    private var _id: AnyString?
    /**
     * Unique ID. (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _device_token: AnyString
    /**
     * Specifies the device token
     */
    public var device_token: String {
        get { _device_token.value }
        set { _device_token = AnyString.init(newValue) }
    }

    /**
     * Specifies type of device. Valid values are: "android", "ios".
     */
    public var device_type: DeviceType

    public init(id: String? = nil, device_token: String, device_type: DeviceType) {
        self._id = id.map(AnyString.init)
        self._device_token = AnyString.init(device_token)
        self.device_type = device_type
    }

    public init(id: String? = nil, _ device_token: String, _ device_type: DeviceType) {
        self.init(id: id, device_token: device_token, device_type: device_type)
    }

}

public struct Model: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _connection = "connection"
        case _name = "name"
        case value_formats
    }
    private var _connection: AnyString?
    /**
     *  (read-only)
     */
    public var connection: String? {
        get { _connection?.value }
        set { _connection = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     *  (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     * Array of named value formats (read-only)
     */
    public var value_formats: [ModelNamedValueFormats]?

    public init(connection: String? = nil, name: String? = nil, value_formats: [ModelNamedValueFormats]? = nil) {
        self._connection = connection.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self.value_formats = value_formats
    }

}

public struct ModelFieldSuggestions: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _suggestions = "suggestions"
        case _error = "error"
        case from_cache
        case hit_limit
        case used_calcite_materialization
    }
    private var _suggestions: [AnyString]?
    /**
     * List of suggestions (read-only)
     */
    public var suggestions: [String]? {
        get { if let v = _suggestions { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _suggestions = v.map { AnyString.init($0) } } else { _suggestions = nil } }
    }

    private var _error: AnyString?
    /**
     * Error message (read-only)
     */
    public var error: String? {
        get { _error?.value }
        set { _error = newValue.map(AnyString.init) }
    }

    /**
     * True if result came from the cache (read-only)
     */
    public var from_cache: Bool?

    /**
     * True if this was a hit limit (read-only)
     */
    public var hit_limit: Bool?

    /**
     * True if calcite was used (read-only)
     */
    public var used_calcite_materialization: Bool?

    public init(suggestions: [String]? = nil, error: String? = nil, from_cache: Bool? = nil, hit_limit: Bool? = nil, used_calcite_materialization: Bool? = nil) {
        if let v = suggestions { _suggestions = v.map { AnyString.init($0) } } else { _suggestions = nil }
        self._error = error.map(AnyString.init)
        self.from_cache = from_cache
        self.hit_limit = hit_limit
        self.used_calcite_materialization = used_calcite_materialization
    }

}

public struct ModelNamedValueFormats: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _format_string = "format_string"
        case _label = "label"
        case _name = "name"
        case strict_value_format
    }
    private var _format_string: AnyString?
    /**
     *  (read-only)
     */
    public var format_string: String? {
        get { _format_string?.value }
        set { _format_string = newValue.map(AnyString.init) }
    }

    private var _label: AnyString?
    /**
     *  (read-only)
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     *  (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     *  (read-only)
     */
    public var strict_value_format: Bool?

    public init(format_string: String? = nil, label: String? = nil, name: String? = nil, strict_value_format: Bool? = nil) {
        self._format_string = format_string.map(AnyString.init)
        self._label = label.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self.strict_value_format = strict_value_format
    }

}

public struct ModelSet: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case all_access
        case built_in
        case _id = "id"
        case _models = "models"
        case _name = "name"
        case _url = "url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    /**
     *  (read-only)
     */
    public var all_access: Bool?

    /**
     *  (read-only)
     */
    public var built_in: Bool?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _models: [AnyString]?
    public var models: [String]? {
        get { if let v = _models { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _models = v.map { AnyString.init($0) } } else { _models = nil } }
    }

    private var _name: AnyString?
    /**
     * Name of ModelSet
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, all_access: Bool? = nil, built_in: Bool? = nil, id: String? = nil, models: [String]? = nil, name: String? = nil, url: String? = nil) {
        self.can = can
        self.all_access = all_access
        self.built_in = built_in
        self._id = id.map(AnyString.init)
        if let v = models { _models = v.map { AnyString.init($0) } } else { _models = nil }
        self._name = name.map(AnyString.init)
        self._url = url.map(AnyString.init)
    }

}

public struct ModelsNotValidated: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _project_file_id = "project_file_id"
    }
    private var _name: AnyString?
    /**
     * Model name (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _project_file_id: AnyString?
    /**
     * Project file (read-only)
     */
    public var project_file_id: String? {
        get { _project_file_id?.value }
        set { _project_file_id = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, project_file_id: String? = nil) {
        self._name = name.map(AnyString.init)
        self._project_file_id = project_file_id.map(AnyString.init)
    }

}

/**
 * The type of time interval this field represents a grouping of. Valid values are: "day", "hour", "minute", "second", "millisecond", "microsecond", "week", "month", "quarter", "year". (Enum defined in LookmlModelExploreFieldTimeInterval)
 */
public enum Name: String, Codable {
    case day = "day"
    case hour = "hour"
    case minute = "minute"
    case second = "second"
    case millisecond = "millisecond"
    case microsecond = "microsecond"
    case week = "week"
    case month = "month"
    case quarter = "quarter"
    case year = "year"
}

public struct OauthClientApp: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _client_guid = "client_guid"
        case _redirect_uri = "redirect_uri"
        case _display_name = "display_name"
        case _description = "description"
        case enabled
        case _group_id = "group_id"
        case tokens_invalid_before
        case activated_users
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _client_guid: AnyString?
    /**
     * The globally unique id of this application (read-only)
     */
    public var client_guid: String? {
        get { _client_guid?.value }
        set { _client_guid = newValue.map(AnyString.init) }
    }

    private var _redirect_uri: AnyString?
    /**
     * The uri with which this application will receive an auth code by browser redirect.
     */
    public var redirect_uri: String? {
        get { _redirect_uri?.value }
        set { _redirect_uri = newValue.map(AnyString.init) }
    }

    private var _display_name: AnyString?
    /**
     * The application's display name
     */
    public var display_name: String? {
        get { _display_name?.value }
        set { _display_name = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * A description of the application that will be displayed to users
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    /**
     * When enabled is true, OAuth2 and API requests will be accepted from this app. When false, all requests from this app will be refused. Setting disabled invalidates existing tokens.
     */
    public var enabled: Bool?

    private var _group_id: AnyString?
    /**
     * If set, only Looker users who are members of this group can use this web app with Looker. If group_id is not set, any Looker user may use this app to access this Looker instance
     */
    public var group_id: String? {
        get { _group_id?.value }
        set { _group_id = newValue.map(AnyString.init) }
    }

    /**
     * All auth codes, access tokens, and refresh tokens issued for this application prior to this date-time for ALL USERS will be invalid. (read-only)
     */
    public var tokens_invalid_before: Date?

    /**
     * All users who have been activated to use this app (read-only)
     */
    public var activated_users: [UserPublic]?

    public init(can: StringDictionary<Bool>? = nil, client_guid: String? = nil, redirect_uri: String? = nil, display_name: String? = nil, description: String? = nil, enabled: Bool? = nil, group_id: String? = nil, tokens_invalid_before: Date? = nil, activated_users: [UserPublic]? = nil) {
        self.can = can
        self._client_guid = client_guid.map(AnyString.init)
        self._redirect_uri = redirect_uri.map(AnyString.init)
        self._display_name = display_name.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self.enabled = enabled
        self._group_id = group_id.map(AnyString.init)
        self.tokens_invalid_before = tokens_invalid_before
        self.activated_users = activated_users
    }

}

public struct OIDCConfig: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case alternate_email_login_allowed
        case _audience = "audience"
        case auth_requires_role
        case _authorization_endpoint = "authorization_endpoint"
        case _default_new_user_group_ids = "default_new_user_group_ids"
        case default_new_user_groups
        case _default_new_user_role_ids = "default_new_user_role_ids"
        case default_new_user_roles
        case enabled
        case groups
        case _groups_attribute = "groups_attribute"
        case groups_with_role_ids
        case _identifier = "identifier"
        case _issuer = "issuer"
        case modified_at
        case _modified_by = "modified_by"
        case _new_user_migration_types = "new_user_migration_types"
        case _scopes = "scopes"
        case _secret = "secret"
        case set_roles_from_groups
        case _test_slug = "test_slug"
        case _token_endpoint = "token_endpoint"
        case _user_attribute_map_email = "user_attribute_map_email"
        case _user_attribute_map_first_name = "user_attribute_map_first_name"
        case _user_attribute_map_last_name = "user_attribute_map_last_name"
        case user_attributes
        case user_attributes_with_ids
        case _userinfo_endpoint = "userinfo_endpoint"
        case allow_normal_group_membership
        case allow_roles_from_normal_groups
        case allow_direct_roles
        case _url = "url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    /**
     * Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
     */
    public var alternate_email_login_allowed: Bool?

    private var _audience: AnyString?
    /**
     * OpenID Provider Audience
     */
    public var audience: String? {
        get { _audience?.value }
        set { _audience = newValue.map(AnyString.init) }
    }

    /**
     * Users will not be allowed to login at all unless a role for them is found in OIDC if set to true
     */
    public var auth_requires_role: Bool?

    private var _authorization_endpoint: AnyString?
    /**
     * OpenID Provider Authorization Url
     */
    public var authorization_endpoint: String? {
        get { _authorization_endpoint?.value }
        set { _authorization_endpoint = newValue.map(AnyString.init) }
    }

    private var _default_new_user_group_ids: [AnyString]?
    /**
     * (Write-Only) Array of ids of groups that will be applied to new users the first time they login via OIDC
     */
    public var default_new_user_group_ids: [String]? {
        get { if let v = _default_new_user_group_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _default_new_user_group_ids = v.map { AnyString.init($0) } } else { _default_new_user_group_ids = nil } }
    }

    /**
     * (Read-only) Groups that will be applied to new users the first time they login via OIDC (read-only)
     */
    public var default_new_user_groups: [LkGroup]?

    private var _default_new_user_role_ids: [AnyString]?
    /**
     * (Write-Only) Array of ids of roles that will be applied to new users the first time they login via OIDC
     */
    public var default_new_user_role_ids: [String]? {
        get { if let v = _default_new_user_role_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _default_new_user_role_ids = v.map { AnyString.init($0) } } else { _default_new_user_role_ids = nil } }
    }

    /**
     * (Read-only) Roles that will be applied to new users the first time they login via OIDC (read-only)
     */
    public var default_new_user_roles: [Role]?

    /**
     * Enable/Disable OIDC authentication for the server
     */
    public var enabled: Bool?

    /**
     * (Read-only) Array of mappings between OIDC Groups and Looker Roles (read-only)
     */
    public var groups: [OIDCGroupRead]?

    private var _groups_attribute: AnyString?
    /**
     * Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
     */
    public var groups_attribute: String? {
        get { _groups_attribute?.value }
        set { _groups_attribute = newValue.map(AnyString.init) }
    }

    /**
     * (Read/Write) Array of mappings between OIDC Groups and arrays of Looker Role ids
     */
    public var groups_with_role_ids: [OIDCGroupWrite]?

    private var _identifier: AnyString?
    /**
     * Relying Party Identifier (provided by OpenID Provider)
     */
    public var identifier: String? {
        get { _identifier?.value }
        set { _identifier = newValue.map(AnyString.init) }
    }

    private var _issuer: AnyString?
    /**
     * OpenID Provider Issuer
     */
    public var issuer: String? {
        get { _issuer?.value }
        set { _issuer = newValue.map(AnyString.init) }
    }

    /**
     * When this config was last modified (read-only)
     */
    public var modified_at: Date?

    private var _modified_by: AnyString?
    /**
     * User id of user who last modified this config (read-only)
     */
    public var modified_by: String? {
        get { _modified_by?.value }
        set { _modified_by = newValue.map(AnyString.init) }
    }

    private var _new_user_migration_types: AnyString?
    /**
     * Merge first-time oidc login to existing user account by email addresses. When a user logs in for the first time via oidc this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
     */
    public var new_user_migration_types: String? {
        get { _new_user_migration_types?.value }
        set { _new_user_migration_types = newValue.map(AnyString.init) }
    }

    private var _scopes: [AnyString]?
    /**
     * Array of scopes to request.
     */
    public var scopes: [String]? {
        get { if let v = _scopes { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _scopes = v.map { AnyString.init($0) } } else { _scopes = nil } }
    }

    private var _secret: AnyString?
    /**
     * (Write-Only) Relying Party Secret (provided by OpenID Provider)
     */
    public var secret: String? {
        get { _secret?.value }
        set { _secret = newValue.map(AnyString.init) }
    }

    /**
     * Set user roles in Looker based on groups from OIDC
     */
    public var set_roles_from_groups: Bool?

    private var _test_slug: AnyString?
    /**
     * Slug to identify configurations that are created in order to run a OIDC config test (read-only)
     */
    public var test_slug: String? {
        get { _test_slug?.value }
        set { _test_slug = newValue.map(AnyString.init) }
    }

    private var _token_endpoint: AnyString?
    /**
     * OpenID Provider Token Url
     */
    public var token_endpoint: String? {
        get { _token_endpoint?.value }
        set { _token_endpoint = newValue.map(AnyString.init) }
    }

    private var _user_attribute_map_email: AnyString?
    /**
     * Name of user record attributes used to indicate email address field
     */
    public var user_attribute_map_email: String? {
        get { _user_attribute_map_email?.value }
        set { _user_attribute_map_email = newValue.map(AnyString.init) }
    }

    private var _user_attribute_map_first_name: AnyString?
    /**
     * Name of user record attributes used to indicate first name
     */
    public var user_attribute_map_first_name: String? {
        get { _user_attribute_map_first_name?.value }
        set { _user_attribute_map_first_name = newValue.map(AnyString.init) }
    }

    private var _user_attribute_map_last_name: AnyString?
    /**
     * Name of user record attributes used to indicate last name
     */
    public var user_attribute_map_last_name: String? {
        get { _user_attribute_map_last_name?.value }
        set { _user_attribute_map_last_name = newValue.map(AnyString.init) }
    }

    /**
     * (Read-only) Array of mappings between OIDC User Attributes and Looker User Attributes (read-only)
     */
    public var user_attributes: [OIDCUserAttributeRead]?

    /**
     * (Read/Write) Array of mappings between OIDC User Attributes and arrays of Looker User Attribute ids
     */
    public var user_attributes_with_ids: [OIDCUserAttributeWrite]?

    private var _userinfo_endpoint: AnyString?
    /**
     * OpenID Provider User Information Url
     */
    public var userinfo_endpoint: String? {
        get { _userinfo_endpoint?.value }
        set { _userinfo_endpoint = newValue.map(AnyString.init) }
    }

    /**
     * Allow OIDC auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.
     */
    public var allow_normal_group_membership: Bool?

    /**
     * OIDC auth'd users will inherit roles from non-reflected Looker groups.
     */
    public var allow_roles_from_normal_groups: Bool?

    /**
     * Allows roles to be directly assigned to OIDC auth'd users.
     */
    public var allow_direct_roles: Bool?

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, alternate_email_login_allowed: Bool? = nil, audience: String? = nil, auth_requires_role: Bool? = nil, authorization_endpoint: String? = nil, default_new_user_group_ids: [String]? = nil, default_new_user_groups: [LkGroup]? = nil, default_new_user_role_ids: [String]? = nil, default_new_user_roles: [Role]? = nil, enabled: Bool? = nil, groups: [OIDCGroupRead]? = nil, groups_attribute: String? = nil, groups_with_role_ids: [OIDCGroupWrite]? = nil, identifier: String? = nil, issuer: String? = nil, modified_at: Date? = nil, modified_by: String? = nil, new_user_migration_types: String? = nil, scopes: [String]? = nil, secret: String? = nil, set_roles_from_groups: Bool? = nil, test_slug: String? = nil, token_endpoint: String? = nil, user_attribute_map_email: String? = nil, user_attribute_map_first_name: String? = nil, user_attribute_map_last_name: String? = nil, user_attributes: [OIDCUserAttributeRead]? = nil, user_attributes_with_ids: [OIDCUserAttributeWrite]? = nil, userinfo_endpoint: String? = nil, allow_normal_group_membership: Bool? = nil, allow_roles_from_normal_groups: Bool? = nil, allow_direct_roles: Bool? = nil, url: String? = nil) {
        self.can = can
        self.alternate_email_login_allowed = alternate_email_login_allowed
        self._audience = audience.map(AnyString.init)
        self.auth_requires_role = auth_requires_role
        self._authorization_endpoint = authorization_endpoint.map(AnyString.init)
        if let v = default_new_user_group_ids { _default_new_user_group_ids = v.map { AnyString.init($0) } } else { _default_new_user_group_ids = nil }
        self.default_new_user_groups = default_new_user_groups
        if let v = default_new_user_role_ids { _default_new_user_role_ids = v.map { AnyString.init($0) } } else { _default_new_user_role_ids = nil }
        self.default_new_user_roles = default_new_user_roles
        self.enabled = enabled
        self.groups = groups
        self._groups_attribute = groups_attribute.map(AnyString.init)
        self.groups_with_role_ids = groups_with_role_ids
        self._identifier = identifier.map(AnyString.init)
        self._issuer = issuer.map(AnyString.init)
        self.modified_at = modified_at
        self._modified_by = modified_by.map(AnyString.init)
        self._new_user_migration_types = new_user_migration_types.map(AnyString.init)
        if let v = scopes { _scopes = v.map { AnyString.init($0) } } else { _scopes = nil }
        self._secret = secret.map(AnyString.init)
        self.set_roles_from_groups = set_roles_from_groups
        self._test_slug = test_slug.map(AnyString.init)
        self._token_endpoint = token_endpoint.map(AnyString.init)
        self._user_attribute_map_email = user_attribute_map_email.map(AnyString.init)
        self._user_attribute_map_first_name = user_attribute_map_first_name.map(AnyString.init)
        self._user_attribute_map_last_name = user_attribute_map_last_name.map(AnyString.init)
        self.user_attributes = user_attributes
        self.user_attributes_with_ids = user_attributes_with_ids
        self._userinfo_endpoint = userinfo_endpoint.map(AnyString.init)
        self.allow_normal_group_membership = allow_normal_group_membership
        self.allow_roles_from_normal_groups = allow_roles_from_normal_groups
        self.allow_direct_roles = allow_direct_roles
        self._url = url.map(AnyString.init)
    }

}

public struct OIDCGroupRead: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _looker_group_id = "looker_group_id"
        case _looker_group_name = "looker_group_name"
        case _name = "name"
        case roles
    }
    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _looker_group_id: AnyString?
    /**
     * Unique Id of group in Looker (read-only)
     */
    public var looker_group_id: String? {
        get { _looker_group_id?.value }
        set { _looker_group_id = newValue.map(AnyString.init) }
    }

    private var _looker_group_name: AnyString?
    /**
     * Name of group in Looker (read-only)
     */
    public var looker_group_name: String? {
        get { _looker_group_name?.value }
        set { _looker_group_name = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Name of group in OIDC (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     * Looker Roles (read-only)
     */
    public var roles: [Role]?

    public init(id: String? = nil, looker_group_id: String? = nil, looker_group_name: String? = nil, name: String? = nil, roles: [Role]? = nil) {
        self._id = id.map(AnyString.init)
        self._looker_group_id = looker_group_id.map(AnyString.init)
        self._looker_group_name = looker_group_name.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self.roles = roles
    }

}

public struct OIDCGroupWrite: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _looker_group_id = "looker_group_id"
        case _looker_group_name = "looker_group_name"
        case _name = "name"
        case _role_ids = "role_ids"
    }
    private var _id: AnyString?
    /**
     * Unique Id
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _looker_group_id: AnyString?
    /**
     * Unique Id of group in Looker (read-only)
     */
    public var looker_group_id: String? {
        get { _looker_group_id?.value }
        set { _looker_group_id = newValue.map(AnyString.init) }
    }

    private var _looker_group_name: AnyString?
    /**
     * Name of group in Looker
     */
    public var looker_group_name: String? {
        get { _looker_group_name?.value }
        set { _looker_group_name = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Name of group in OIDC
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _role_ids: [AnyString]?
    /**
     * Looker Role Ids
     */
    public var role_ids: [String]? {
        get { if let v = _role_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _role_ids = v.map { AnyString.init($0) } } else { _role_ids = nil } }
    }

    public init(id: String? = nil, looker_group_id: String? = nil, looker_group_name: String? = nil, name: String? = nil, role_ids: [String]? = nil) {
        self._id = id.map(AnyString.init)
        self._looker_group_id = looker_group_id.map(AnyString.init)
        self._looker_group_name = looker_group_name.map(AnyString.init)
        self._name = name.map(AnyString.init)
        if let v = role_ids { _role_ids = v.map { AnyString.init($0) } } else { _role_ids = nil }
    }

}

public struct OIDCUserAttributeRead: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case required
        case user_attributes
    }
    private var _name: AnyString?
    /**
     * Name of User Attribute in OIDC (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     * Required to be in OIDC assertion for login to be allowed to succeed (read-only)
     */
    public var required: Bool?

    /**
     * Looker User Attributes (read-only)
     */
    public var user_attributes: [UserAttribute]?

    public init(name: String? = nil, required: Bool? = nil, user_attributes: [UserAttribute]? = nil) {
        self._name = name.map(AnyString.init)
        self.required = required
        self.user_attributes = user_attributes
    }

}

public struct OIDCUserAttributeWrite: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case required
        case _user_attribute_ids = "user_attribute_ids"
    }
    private var _name: AnyString?
    /**
     * Name of User Attribute in OIDC
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     * Required to be in OIDC assertion for login to be allowed to succeed
     */
    public var required: Bool?

    private var _user_attribute_ids: [AnyString]?
    /**
     * Looker User Attribute Ids
     */
    public var user_attribute_ids: [String]? {
        get { if let v = _user_attribute_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _user_attribute_ids = v.map { AnyString.init($0) } } else { _user_attribute_ids = nil } }
    }

    public init(name: String? = nil, required: Bool? = nil, user_attribute_ids: [String]? = nil) {
        self._name = name.map(AnyString.init)
        self.required = required
        if let v = user_attribute_ids { _user_attribute_ids = v.map { AnyString.init($0) } } else { _user_attribute_ids = nil }
    }

}

public struct PasswordConfig: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _min_length = "min_length"
        case require_numeric
        case require_upperlower
        case require_special
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _min_length: AnyInt?
    /**
     * Minimum number of characters required for a new password.  Must be between 7 and 100
     */
    public var min_length: Int64? {
        get { _min_length?.value }
        set { _min_length = newValue.map(AnyInt.init) }
    }

    /**
     * Require at least one numeric character
     */
    public var require_numeric: Bool?

    /**
     * Require at least one uppercase and one lowercase letter
     */
    public var require_upperlower: Bool?

    /**
     * Require at least one special character
     */
    public var require_special: Bool?

    public init(can: StringDictionary<Bool>? = nil, min_length: Int64? = nil, require_numeric: Bool? = nil, require_upperlower: Bool? = nil, require_special: Bool? = nil) {
        self.can = can
        self._min_length = min_length.map(AnyInt.init)
        self.require_numeric = require_numeric
        self.require_upperlower = require_upperlower
        self.require_special = require_special
    }

}

/**
 * Specifies the time frame for the comparison. Valid values are: "year", "fiscal_year", "quarter", "fiscal_quarter", "month", "week", "date". (Enum defined in LookmlModelExploreFieldPeriodOverPeriodParams)
 */
public enum Period: String, Codable {
    case year = "year"
    case fiscal_year = "fiscal_year"
    case quarter = "quarter"
    case fiscal_quarter = "fiscal_quarter"
    case month = "month"
    case week = "week"
    case date = "date"
}

public struct Permission: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _permission = "permission"
        case _parent = "parent"
        case _description = "description"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _permission: AnyString?
    /**
     * Permission symbol (read-only)
     */
    public var permission: String? {
        get { _permission?.value }
        set { _permission = newValue.map(AnyString.init) }
    }

    private var _parent: AnyString?
    /**
     * Dependency parent symbol (read-only)
     */
    public var parent: String? {
        get { _parent?.value }
        set { _parent = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * Description (read-only)
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, permission: String? = nil, parent: String? = nil, description: String? = nil) {
        self.can = can
        self._permission = permission.map(AnyString.init)
        self._parent = parent.map(AnyString.init)
        self._description = description.map(AnyString.init)
    }

}

public struct PermissionSet: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case all_access
        case built_in
        case _id = "id"
        case _name = "name"
        case _permissions = "permissions"
        case _url = "url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    /**
     *  (read-only)
     */
    public var all_access: Bool?

    /**
     *  (read-only)
     */
    public var built_in: Bool?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Name of PermissionSet
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _permissions: [AnyString]?
    public var permissions: [String]? {
        get { if let v = _permissions { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _permissions = v.map { AnyString.init($0) } } else { _permissions = nil } }
    }

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, all_access: Bool? = nil, built_in: Bool? = nil, id: String? = nil, name: String? = nil, permissions: [String]? = nil, url: String? = nil) {
        self.can = can
        self.all_access = all_access
        self.built_in = built_in
        self._id = id.map(AnyString.init)
        self._name = name.map(AnyString.init)
        if let v = permissions { _permissions = v.map { AnyString.init($0) } } else { _permissions = nil }
        self._url = url.map(AnyString.init)
    }

}

/**
 * Type of permission: "view" or "edit" Valid values are: "view", "edit". (Enum defined in ContentMetaGroupUser)
 */
public enum PermissionType: String, Codable {
    case view = "view"
    case edit = "edit"
}

public struct PrivatelabelConfiguration: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _logo_file = "logo_file"
        case _logo_url = "logo_url"
        case _favicon_file = "favicon_file"
        case _favicon_url = "favicon_url"
        case _default_title = "default_title"
        case show_help_menu
        case show_docs
        case show_email_sub_options
        case allow_looker_mentions
        case allow_looker_links
        case custom_welcome_email_advanced
        case setup_mentions
        case alerts_logo
        case alerts_links
        case folders_mentions
    }
    private var _logo_file: AnyString?
    /**
     * Customer logo image. Expected base64 encoded data (write-only)
     */
    public var logo_file: String? {
        get { _logo_file?.value }
        set { _logo_file = newValue.map(AnyString.init) }
    }

    private var _logo_url: AnyString?
    /**
     * Logo image url (read-only) (read-only)
     */
    public var logo_url: String? {
        get { _logo_url?.value }
        set { _logo_url = newValue.map(AnyString.init) }
    }

    private var _favicon_file: AnyString?
    /**
     * Custom favicon image. Expected base64 encoded data (write-only)
     */
    public var favicon_file: String? {
        get { _favicon_file?.value }
        set { _favicon_file = newValue.map(AnyString.init) }
    }

    private var _favicon_url: AnyString?
    /**
     * Favicon image url (read-only) (read-only)
     */
    public var favicon_url: String? {
        get { _favicon_url?.value }
        set { _favicon_url = newValue.map(AnyString.init) }
    }

    private var _default_title: AnyString?
    /**
     * Default page title
     */
    public var default_title: String? {
        get { _default_title?.value }
        set { _default_title = newValue.map(AnyString.init) }
    }

    /**
     * Boolean to toggle showing help menus
     */
    public var show_help_menu: Bool?

    /**
     * Boolean to toggle showing docs
     */
    public var show_docs: Bool?

    /**
     * Boolean to toggle showing email subscription options.
     */
    public var show_email_sub_options: Bool?

    /**
     * Boolean to toggle mentions of Looker in emails
     */
    public var allow_looker_mentions: Bool?

    /**
     * Boolean to toggle links to Looker in emails
     */
    public var allow_looker_links: Bool?

    /**
     * Allow subject line and email heading customization in customized emails
     */
    public var custom_welcome_email_advanced: Bool?

    /**
     * Remove the word Looker from appearing in the account setup page
     */
    public var setup_mentions: Bool?

    /**
     * Remove Looker logo from Alerts
     */
    public var alerts_logo: Bool?

    /**
     * Remove Looker links from Alerts
     */
    public var alerts_links: Bool?

    /**
     * Remove Looker mentions in home folder page when you dont have any items saved
     */
    public var folders_mentions: Bool?

    public init(logo_file: String? = nil, logo_url: String? = nil, favicon_file: String? = nil, favicon_url: String? = nil, default_title: String? = nil, show_help_menu: Bool? = nil, show_docs: Bool? = nil, show_email_sub_options: Bool? = nil, allow_looker_mentions: Bool? = nil, allow_looker_links: Bool? = nil, custom_welcome_email_advanced: Bool? = nil, setup_mentions: Bool? = nil, alerts_logo: Bool? = nil, alerts_links: Bool? = nil, folders_mentions: Bool? = nil) {
        self._logo_file = logo_file.map(AnyString.init)
        self._logo_url = logo_url.map(AnyString.init)
        self._favicon_file = favicon_file.map(AnyString.init)
        self._favicon_url = favicon_url.map(AnyString.init)
        self._default_title = default_title.map(AnyString.init)
        self.show_help_menu = show_help_menu
        self.show_docs = show_docs
        self.show_email_sub_options = show_email_sub_options
        self.allow_looker_mentions = allow_looker_mentions
        self.allow_looker_links = allow_looker_links
        self.custom_welcome_email_advanced = custom_welcome_email_advanced
        self.setup_mentions = setup_mentions
        self.alerts_logo = alerts_logo
        self.alerts_links = alerts_links
        self.folders_mentions = folders_mentions
    }

}

public struct Project: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _name = "name"
        case uses_git
        case _git_remote_url = "git_remote_url"
        case _git_username = "git_username"
        case _git_password = "git_password"
        case _git_production_branch_name = "git_production_branch_name"
        case use_git_cookie_auth
        case _git_username_user_attribute = "git_username_user_attribute"
        case _git_password_user_attribute = "git_password_user_attribute"
        case _git_service_name = "git_service_name"
        case _git_application_server_http_port = "git_application_server_http_port"
        case _git_application_server_http_scheme = "git_application_server_http_scheme"
        case _deploy_secret = "deploy_secret"
        case unset_deploy_secret
        case pull_request_mode
        case validation_required
        case git_release_mgmt_enabled
        case allow_warnings
        case is_example
        case _dependency_status = "dependency_status"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Project Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Project display name
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     * If true the project is configured with a git repository (read-only)
     */
    public var uses_git: Bool?

    private var _git_remote_url: AnyString?
    /**
     * Git remote repository url
     */
    public var git_remote_url: String? {
        get { _git_remote_url?.value }
        set { _git_remote_url = newValue.map(AnyString.init) }
    }

    private var _git_username: AnyString?
    /**
     * Git username for HTTPS authentication. (For production only, if using user attributes.)
     */
    public var git_username: String? {
        get { _git_username?.value }
        set { _git_username = newValue.map(AnyString.init) }
    }

    private var _git_password: AnyString?
    /**
     * (Write-Only) Git password for HTTPS authentication. (For production only, if using user attributes.)
     */
    public var git_password: String? {
        get { _git_password?.value }
        set { _git_password = newValue.map(AnyString.init) }
    }

    private var _git_production_branch_name: AnyString?
    /**
     * Git production branch name. Defaults to master. Supported only in Looker 21.0 and higher.
     */
    public var git_production_branch_name: String? {
        get { _git_production_branch_name?.value }
        set { _git_production_branch_name = newValue.map(AnyString.init) }
    }

    /**
     * If true, the project uses a git cookie for authentication.
     */
    public var use_git_cookie_auth: Bool?

    private var _git_username_user_attribute: AnyString?
    /**
     * User attribute name for username in per-user HTTPS authentication.
     */
    public var git_username_user_attribute: String? {
        get { _git_username_user_attribute?.value }
        set { _git_username_user_attribute = newValue.map(AnyString.init) }
    }

    private var _git_password_user_attribute: AnyString?
    /**
     * User attribute name for password in per-user HTTPS authentication.
     */
    public var git_password_user_attribute: String? {
        get { _git_password_user_attribute?.value }
        set { _git_password_user_attribute = newValue.map(AnyString.init) }
    }

    private var _git_service_name: AnyString?
    /**
     * Name of the git service provider
     */
    public var git_service_name: String? {
        get { _git_service_name?.value }
        set { _git_service_name = newValue.map(AnyString.init) }
    }

    private var _git_application_server_http_port: AnyInt?
    /**
     * Port that HTTP(S) application server is running on (for PRs, file browsing, etc.)
     */
    public var git_application_server_http_port: Int64? {
        get { _git_application_server_http_port?.value }
        set { _git_application_server_http_port = newValue.map(AnyInt.init) }
    }

    private var _git_application_server_http_scheme: AnyString?
    /**
     * Scheme that is running on application server (for PRs, file browsing, etc.)
     */
    public var git_application_server_http_scheme: String? {
        get { _git_application_server_http_scheme?.value }
        set { _git_application_server_http_scheme = newValue.map(AnyString.init) }
    }

    private var _deploy_secret: AnyString?
    /**
     * (Write-Only) Optional secret token with which to authenticate requests to the webhook deploy endpoint. If not set, endpoint is unauthenticated.
     */
    public var deploy_secret: String? {
        get { _deploy_secret?.value }
        set { _deploy_secret = newValue.map(AnyString.init) }
    }

    /**
     * (Write-Only) When true, unsets the deploy secret to allow unauthenticated access to the webhook deploy endpoint.
     */
    public var unset_deploy_secret: Bool?

    /**
     * The git pull request policy for this project. Valid values are: "off", "links", "recommended", "required".
     */
    public var pull_request_mode: PullRequestMode?

    /**
     * Validation policy: If true, the project must pass validation checks before project changes can be committed to the git repository
     */
    public var validation_required: Bool?

    /**
     * If true, advanced git release management is enabled for this project
     */
    public var git_release_mgmt_enabled: Bool?

    /**
     * Validation policy: If true, the project can be committed with warnings when `validation_required` is true. (`allow_warnings` does nothing if `validation_required` is false).
     */
    public var allow_warnings: Bool?

    /**
     * If true the project is an example project and cannot be modified (read-only)
     */
    public var is_example: Bool?

    private var _dependency_status: AnyString?
    /**
     * Status of dependencies in your manifest & lockfile
     */
    public var dependency_status: String? {
        get { _dependency_status?.value }
        set { _dependency_status = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, name: String? = nil, uses_git: Bool? = nil, git_remote_url: String? = nil, git_username: String? = nil, git_password: String? = nil, git_production_branch_name: String? = nil, use_git_cookie_auth: Bool? = nil, git_username_user_attribute: String? = nil, git_password_user_attribute: String? = nil, git_service_name: String? = nil, git_application_server_http_port: Int64? = nil, git_application_server_http_scheme: String? = nil, deploy_secret: String? = nil, unset_deploy_secret: Bool? = nil, pull_request_mode: PullRequestMode? = nil, validation_required: Bool? = nil, git_release_mgmt_enabled: Bool? = nil, allow_warnings: Bool? = nil, is_example: Bool? = nil, dependency_status: String? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self.uses_git = uses_git
        self._git_remote_url = git_remote_url.map(AnyString.init)
        self._git_username = git_username.map(AnyString.init)
        self._git_password = git_password.map(AnyString.init)
        self._git_production_branch_name = git_production_branch_name.map(AnyString.init)
        self.use_git_cookie_auth = use_git_cookie_auth
        self._git_username_user_attribute = git_username_user_attribute.map(AnyString.init)
        self._git_password_user_attribute = git_password_user_attribute.map(AnyString.init)
        self._git_service_name = git_service_name.map(AnyString.init)
        self._git_application_server_http_port = git_application_server_http_port.map(AnyInt.init)
        self._git_application_server_http_scheme = git_application_server_http_scheme.map(AnyString.init)
        self._deploy_secret = deploy_secret.map(AnyString.init)
        self.unset_deploy_secret = unset_deploy_secret
        self.pull_request_mode = pull_request_mode
        self.validation_required = validation_required
        self.git_release_mgmt_enabled = git_release_mgmt_enabled
        self.allow_warnings = allow_warnings
        self.is_example = is_example
        self._dependency_status = dependency_status.map(AnyString.init)
    }

}

public struct ProjectCIRun: SDKModel {
    public var run: CIRun?

    public init(run: CIRun? = nil) {
        self.run = run
    }

}

public struct ProjectError: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _code = "code"
        case _severity = "severity"
        case _kind = "kind"
        case _message = "message"
        case _field_name = "field_name"
        case _file_path = "file_path"
        case _line_number = "line_number"
        case _model_id = "model_id"
        case _explore = "explore"
        case _help_url = "help_url"
        case params
        case _sanitized_message = "sanitized_message"
    }
    private var _code: AnyString?
    /**
     * A stable token that uniquely identifies this class of error, ignoring parameter values. Error message text may vary due to parameters or localization, but error codes do not. For example, a "File not found" error will have the same error code regardless of the filename in question or the user's display language (read-only)
     */
    public var code: String? {
        get { _code?.value }
        set { _code = newValue.map(AnyString.init) }
    }

    private var _severity: AnyString?
    /**
     * Severity: fatal, error, warning, info, success (read-only)
     */
    public var severity: String? {
        get { _severity?.value }
        set { _severity = newValue.map(AnyString.init) }
    }

    private var _kind: AnyString?
    /**
     * Error classification: syntax, deprecation, model_configuration, etc (read-only)
     */
    public var kind: String? {
        get { _kind?.value }
        set { _kind = newValue.map(AnyString.init) }
    }

    private var _message: AnyString?
    /**
     * Error message which may contain information such as dashboard or model names that may be considered sensitive in some use cases. Avoid storing or sending this message outside of Looker (read-only)
     */
    public var message: String? {
        get { _message?.value }
        set { _message = newValue.map(AnyString.init) }
    }

    private var _field_name: AnyString?
    /**
     * The field associated with this error (read-only)
     */
    public var field_name: String? {
        get { _field_name?.value }
        set { _field_name = newValue.map(AnyString.init) }
    }

    private var _file_path: AnyString?
    /**
     * Name of the file containing this error (read-only)
     */
    public var file_path: String? {
        get { _file_path?.value }
        set { _file_path = newValue.map(AnyString.init) }
    }

    private var _line_number: AnyInt?
    /**
     * Line number in the file of this error (read-only)
     */
    public var line_number: Int64? {
        get { _line_number?.value }
        set { _line_number = newValue.map(AnyInt.init) }
    }

    private var _model_id: AnyString?
    /**
     * The model associated with this error (read-only)
     */
    public var model_id: String? {
        get { _model_id?.value }
        set { _model_id = newValue.map(AnyString.init) }
    }

    private var _explore: AnyString?
    /**
     * The explore associated with this error (read-only)
     */
    public var explore: String? {
        get { _explore?.value }
        set { _explore = newValue.map(AnyString.init) }
    }

    private var _help_url: AnyString?
    /**
     * A link to Looker documentation about this error (read-only)
     */
    public var help_url: String? {
        get { _help_url?.value }
        set { _help_url = newValue.map(AnyString.init) }
    }

    /**
     * Error parameters (read-only)
     */
    public var params: StringDictionary<AnyCodable>?

    private var _sanitized_message: AnyString?
    /**
     * A version of the error message that does not contain potentially sensitive information. Suitable for situations in which messages are stored or sent to consumers outside of Looker, such as external logs. Sanitized messages will display "(?)" where sensitive information would appear in the corresponding non-sanitized message (read-only)
     */
    public var sanitized_message: String? {
        get { _sanitized_message?.value }
        set { _sanitized_message = newValue.map(AnyString.init) }
    }

    public init(code: String? = nil, severity: String? = nil, kind: String? = nil, message: String? = nil, field_name: String? = nil, file_path: String? = nil, line_number: Int64? = nil, model_id: String? = nil, explore: String? = nil, help_url: String? = nil, params: StringDictionary<AnyCodable>? = nil, sanitized_message: String? = nil) {
        self._code = code.map(AnyString.init)
        self._severity = severity.map(AnyString.init)
        self._kind = kind.map(AnyString.init)
        self._message = message.map(AnyString.init)
        self._field_name = field_name.map(AnyString.init)
        self._file_path = file_path.map(AnyString.init)
        self._line_number = line_number.map(AnyInt.init)
        self._model_id = model_id.map(AnyString.init)
        self._explore = explore.map(AnyString.init)
        self._help_url = help_url.map(AnyString.init)
        self.params = params
        self._sanitized_message = sanitized_message.map(AnyString.init)
    }

}

public struct ProjectFile: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _path = "path"
        case _title = "title"
        case _type = "type"
        case _extension = "extension"
        case _mime_type = "mime_type"
        case editable
        case git_status
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * An opaque token uniquely identifying a file within a project. Avoid parsing or decomposing the text of this token. This token is stable within a Looker release but may change between Looker releases (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _path: AnyString?
    /**
     * Path, file name, and extension of the file relative to the project root directory (read-only)
     */
    public var path: String? {
        get { _path?.value }
        set { _path = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Display name (read-only)
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * File type: model, view, etc (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _extension: AnyString?
    /**
     * The extension of the file: .view.lkml, .model.lkml, etc (read-only)
     */
    public var `extension`: String? {
        get { _extension?.value }
        set { _extension = newValue.map(AnyString.init) }
    }

    private var _mime_type: AnyString?
    /**
     * File mime type (read-only)
     */
    public var mime_type: String? {
        get { _mime_type?.value }
        set { _mime_type = newValue.map(AnyString.init) }
    }

    /**
     * State of editability for the file. (read-only)
     */
    public var editable: Bool?

    public var git_status: GitStatus?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, path: String? = nil, title: String? = nil, type: String? = nil, `extension`: String? = nil, mime_type: String? = nil, editable: Bool? = nil, git_status: GitStatus? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._path = path.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self._type = type.map(AnyString.init)
        self._extension = `extension`.map(AnyString.init)
        self._mime_type = mime_type.map(AnyString.init)
        self.editable = editable
        self.git_status = git_status
    }

}

public struct ProjectValidation: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case errors
        case _project_digest = "project_digest"
        case models_not_validated
        case computation_time
    }
    /**
     * A list of project errors (read-only)
     */
    public var errors: [ProjectError]?

    private var _project_digest: AnyString?
    /**
     * A hash value computed from the project's current state (read-only)
     */
    public var project_digest: String? {
        get { _project_digest?.value }
        set { _project_digest = newValue.map(AnyString.init) }
    }

    /**
     * A list of models which were not fully validated (read-only)
     */
    public var models_not_validated: [ModelsNotValidated]?

    /**
     * Duration of project validation in seconds (read-only)
     */
    public var computation_time: Float?

    public init(errors: [ProjectError]? = nil, project_digest: String? = nil, models_not_validated: [ModelsNotValidated]? = nil, computation_time: Float? = nil) {
        self.errors = errors
        self._project_digest = project_digest.map(AnyString.init)
        self.models_not_validated = models_not_validated
        self.computation_time = computation_time
    }

}

public struct ProjectValidationCache: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case errors
        case _project_digest = "project_digest"
        case models_not_validated
        case computation_time
        case stale
    }
    /**
     * A list of project errors (read-only)
     */
    public var errors: [ProjectError]?

    private var _project_digest: AnyString?
    /**
     * A hash value computed from the project's current state (read-only)
     */
    public var project_digest: String? {
        get { _project_digest?.value }
        set { _project_digest = newValue.map(AnyString.init) }
    }

    /**
     * A list of models which were not fully validated (read-only)
     */
    public var models_not_validated: [ModelsNotValidated]?

    /**
     * Duration of project validation in seconds (read-only)
     */
    public var computation_time: Float?

    /**
     * If true, the cached project validation results are no longer accurate because the project has changed since the cached results were calculated (read-only)
     */
    public var stale: Bool?

    public init(errors: [ProjectError]? = nil, project_digest: String? = nil, models_not_validated: [ModelsNotValidated]? = nil, computation_time: Float? = nil, stale: Bool? = nil) {
        self.errors = errors
        self._project_digest = project_digest.map(AnyString.init)
        self.models_not_validated = models_not_validated
        self.computation_time = computation_time
        self.stale = stale
    }

}

public struct ProjectWorkspace: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _project_id = "project_id"
        case _workspace_id = "workspace_id"
        case _git_status = "git_status"
        case _git_head = "git_head"
        case dependency_status
        case git_branch
        case _lookml_type = "lookml_type"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _project_id: AnyString?
    /**
     * The id of the project (read-only)
     */
    public var project_id: String? {
        get { _project_id?.value }
        set { _project_id = newValue.map(AnyString.init) }
    }

    private var _workspace_id: AnyString?
    /**
     * The id of the local workspace containing the project files (read-only)
     */
    public var workspace_id: String? {
        get { _workspace_id?.value }
        set { _workspace_id = newValue.map(AnyString.init) }
    }

    private var _git_status: AnyString?
    /**
     * The status of the local git directory (read-only)
     */
    public var git_status: String? {
        get { _git_status?.value }
        set { _git_status = newValue.map(AnyString.init) }
    }

    private var _git_head: AnyString?
    /**
     * Git head revision name (read-only)
     */
    public var git_head: String? {
        get { _git_head?.value }
        set { _git_head = newValue.map(AnyString.init) }
    }

    /**
     * Status of the dependencies in your project. Valid values are: "lock_optional", "lock_required", "lock_error", "install_none". (read-only)
     */
    public var dependency_status: DependencyStatus?

    public var git_branch: GitBranch?

    private var _lookml_type: AnyString?
    /**
     * The lookml syntax used by all files in this project (read-only)
     */
    public var lookml_type: String? {
        get { _lookml_type?.value }
        set { _lookml_type = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, project_id: String? = nil, workspace_id: String? = nil, git_status: String? = nil, git_head: String? = nil, dependency_status: DependencyStatus? = nil, git_branch: GitBranch? = nil, lookml_type: String? = nil) {
        self.can = can
        self._project_id = project_id.map(AnyString.init)
        self._workspace_id = workspace_id.map(AnyString.init)
        self._git_status = git_status.map(AnyString.init)
        self._git_head = git_head.map(AnyString.init)
        self.dependency_status = dependency_status
        self.git_branch = git_branch
        self._lookml_type = lookml_type.map(AnyString.init)
    }

}

/**
 * The git pull request policy for this project. Valid values are: "off", "links", "recommended", "required". (Enum defined in Project)
 */
public enum PullRequestMode: String, Codable {
    case off = "off"
    case links = "links"
    case recommended = "recommended"
    case required = "required"
}

public struct Query: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _model = "model"
        case _view = "view"
        case _fields = "fields"
        case _pivots = "pivots"
        case _fill_fields = "fill_fields"
        case filters
        case _filter_expression = "filter_expression"
        case _sorts = "sorts"
        case _limit = "limit"
        case _column_limit = "column_limit"
        case total
        case _row_total = "row_total"
        case _subtotals = "subtotals"
        case vis_config
        case filter_config
        case _visible_ui_sections = "visible_ui_sections"
        case _slug = "slug"
        case _dynamic_fields = "dynamic_fields"
        case _client_id = "client_id"
        case _share_url = "share_url"
        case _expanded_share_url = "expanded_share_url"
        case _url = "url"
        case _query_timezone = "query_timezone"
        case has_table_calculations
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _model: AnyString
    /**
     * Model
     */
    public var model: String {
        get { _model.value }
        set { _model = AnyString.init(newValue) }
    }

    private var _view: AnyString
    /**
     * Explore Name
     */
    public var view: String {
        get { _view.value }
        set { _view = AnyString.init(newValue) }
    }

    private var _fields: [AnyString]?
    /**
     * Fields
     */
    public var fields: [String]? {
        get { if let v = _fields { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _fields = v.map { AnyString.init($0) } } else { _fields = nil } }
    }

    private var _pivots: [AnyString]?
    /**
     * Pivots
     */
    public var pivots: [String]? {
        get { if let v = _pivots { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _pivots = v.map { AnyString.init($0) } } else { _pivots = nil } }
    }

    private var _fill_fields: [AnyString]?
    /**
     * Fill Fields
     */
    public var fill_fields: [String]? {
        get { if let v = _fill_fields { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _fill_fields = v.map { AnyString.init($0) } } else { _fill_fields = nil } }
    }

    /**
     * Filters will contain data pertaining to complex filters that do not contain "or" conditions. When "or" conditions are present, filter data will be found on the `filter_expression` property.
     */
    public var filters: StringDictionary<AnyCodable>?

    private var _filter_expression: AnyString?
    /**
     * Filter Expression
     */
    public var filter_expression: String? {
        get { _filter_expression?.value }
        set { _filter_expression = newValue.map(AnyString.init) }
    }

    private var _sorts: [AnyString]?
    /**
     * Sorting for the query results. Use the format `["view.field", ...]` to sort on fields in ascending order. Use the format `["view.field desc", ...]` to sort on fields in descending order. Use `["__UNSORTED__"]` (2 underscores before and after) to disable sorting entirely. Empty sorts `[]` will trigger a default sort.
     */
    public var sorts: [String]? {
        get { if let v = _sorts { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _sorts = v.map { AnyString.init($0) } } else { _sorts = nil } }
    }

    private var _limit: AnyString?
    /**
     * Row limit. To download unlimited results, set the limit to -1 (negative one).
     */
    public var limit: String? {
        get { _limit?.value }
        set { _limit = newValue.map(AnyString.init) }
    }

    private var _column_limit: AnyString?
    /**
     * Column Limit
     */
    public var column_limit: String? {
        get { _column_limit?.value }
        set { _column_limit = newValue.map(AnyString.init) }
    }

    /**
     * Total
     */
    public var total: Bool?

    private var _row_total: AnyString?
    /**
     * Raw Total
     */
    public var row_total: String? {
        get { _row_total?.value }
        set { _row_total = newValue.map(AnyString.init) }
    }

    private var _subtotals: [AnyString]?
    /**
     * Fields on which to run subtotals
     */
    public var subtotals: [String]? {
        get { if let v = _subtotals { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _subtotals = v.map { AnyString.init($0) } } else { _subtotals = nil } }
    }

    /**
     * Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
     */
    public var vis_config: StringDictionary<AnyCodable>?

    /**
     * The filter_config represents the state of the filter UI on the explore page for a given query. When running a query via the Looker UI, this parameter takes precedence over "filters". When creating a query or modifying an existing query, "filter_config" should be set to null. Setting it to any other value could cause unexpected filtering behavior. The format should be considered opaque.
     */
    public var filter_config: StringDictionary<AnyCodable>?

    private var _visible_ui_sections: AnyString?
    /**
     * Visible UI Sections
     */
    public var visible_ui_sections: String? {
        get { _visible_ui_sections?.value }
        set { _visible_ui_sections = newValue.map(AnyString.init) }
    }

    private var _slug: AnyString?
    /**
     * Slug (read-only)
     */
    public var slug: String? {
        get { _slug?.value }
        set { _slug = newValue.map(AnyString.init) }
    }

    private var _dynamic_fields: AnyString?
    /**
     * Dynamic Fields
     */
    public var dynamic_fields: String? {
        get { _dynamic_fields?.value }
        set { _dynamic_fields = newValue.map(AnyString.init) }
    }

    private var _client_id: AnyString?
    /**
     * Client Id: used to generate shortened explore URLs. If set by client, must be a unique 22 character alphanumeric string. Otherwise one will be generated.
     */
    public var client_id: String? {
        get { _client_id?.value }
        set { _client_id = newValue.map(AnyString.init) }
    }

    private var _share_url: AnyString?
    /**
     * Share Url (read-only)
     */
    public var share_url: String? {
        get { _share_url?.value }
        set { _share_url = newValue.map(AnyString.init) }
    }

    private var _expanded_share_url: AnyString?
    /**
     * Expanded Share Url (read-only)
     */
    public var expanded_share_url: String? {
        get { _expanded_share_url?.value }
        set { _expanded_share_url = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Expanded Url (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    private var _query_timezone: AnyString?
    /**
     * Query Timezone
     */
    public var query_timezone: String? {
        get { _query_timezone?.value }
        set { _query_timezone = newValue.map(AnyString.init) }
    }

    /**
     * Has Table Calculations (read-only)
     */
    public var has_table_calculations: Bool?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, model: String, view: String, fields: [String]? = nil, pivots: [String]? = nil, fill_fields: [String]? = nil, filters: StringDictionary<AnyCodable>? = nil, filter_expression: String? = nil, sorts: [String]? = nil, limit: String? = nil, column_limit: String? = nil, total: Bool? = nil, row_total: String? = nil, subtotals: [String]? = nil, vis_config: StringDictionary<AnyCodable>? = nil, filter_config: StringDictionary<AnyCodable>? = nil, visible_ui_sections: String? = nil, slug: String? = nil, dynamic_fields: String? = nil, client_id: String? = nil, share_url: String? = nil, expanded_share_url: String? = nil, url: String? = nil, query_timezone: String? = nil, has_table_calculations: Bool? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._model = AnyString.init(model)
        self._view = AnyString.init(view)
        if let v = fields { _fields = v.map { AnyString.init($0) } } else { _fields = nil }
        if let v = pivots { _pivots = v.map { AnyString.init($0) } } else { _pivots = nil }
        if let v = fill_fields { _fill_fields = v.map { AnyString.init($0) } } else { _fill_fields = nil }
        self.filters = filters
        self._filter_expression = filter_expression.map(AnyString.init)
        if let v = sorts { _sorts = v.map { AnyString.init($0) } } else { _sorts = nil }
        self._limit = limit.map(AnyString.init)
        self._column_limit = column_limit.map(AnyString.init)
        self.total = total
        self._row_total = row_total.map(AnyString.init)
        if let v = subtotals { _subtotals = v.map { AnyString.init($0) } } else { _subtotals = nil }
        self.vis_config = vis_config
        self.filter_config = filter_config
        self._visible_ui_sections = visible_ui_sections.map(AnyString.init)
        self._slug = slug.map(AnyString.init)
        self._dynamic_fields = dynamic_fields.map(AnyString.init)
        self._client_id = client_id.map(AnyString.init)
        self._share_url = share_url.map(AnyString.init)
        self._expanded_share_url = expanded_share_url.map(AnyString.init)
        self._url = url.map(AnyString.init)
        self._query_timezone = query_timezone.map(AnyString.init)
        self.has_table_calculations = has_table_calculations
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, _ model: String, _ view: String, fields: [String]? = nil, pivots: [String]? = nil, fill_fields: [String]? = nil, filters: StringDictionary<AnyCodable>? = nil, filter_expression: String? = nil, sorts: [String]? = nil, limit: String? = nil, column_limit: String? = nil, total: Bool? = nil, row_total: String? = nil, subtotals: [String]? = nil, vis_config: StringDictionary<AnyCodable>? = nil, filter_config: StringDictionary<AnyCodable>? = nil, visible_ui_sections: String? = nil, slug: String? = nil, dynamic_fields: String? = nil, client_id: String? = nil, share_url: String? = nil, expanded_share_url: String? = nil, url: String? = nil, query_timezone: String? = nil, has_table_calculations: Bool? = nil) {
        self.init(can: can, id: id, model: model, view: view, fields: fields, pivots: pivots, fill_fields: fill_fields, filters: filters, filter_expression: filter_expression, sorts: sorts, limit: limit, column_limit: column_limit, total: total, row_total: row_total, subtotals: subtotals, vis_config: vis_config, filter_config: filter_config, visible_ui_sections: visible_ui_sections, slug: slug, dynamic_fields: dynamic_fields, client_id: client_id, share_url: share_url, expanded_share_url: expanded_share_url, url: url, query_timezone: query_timezone, has_table_calculations: has_table_calculations)
    }

}

public struct QueryTask: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _query_id = "query_id"
        case query
        case generate_links
        case force_production
        case _path_prefix = "path_prefix"
        case cache
        case server_table_calcs
        case cache_only
        case _cache_key = "cache_key"
        case _status = "status"
        case _source = "source"
        case runtime
        case rebuild_pdts
        case _result_source = "result_source"
        case _look_id = "look_id"
        case _dashboard_id = "dashboard_id"
        case _result_format = "result_format"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _query_id: AnyString?
    /**
     * Id of query
     */
    public var query_id: String? {
        get { _query_id?.value }
        set { _query_id = newValue.map(AnyString.init) }
    }

    public var query: Query?

    /**
     * whether or not to generate links in the query response.
     */
    public var generate_links: Bool?

    /**
     * Use production models to run query (even is user is in dev mode).
     */
    public var force_production: Bool?

    private var _path_prefix: AnyString?
    /**
     * Prefix to use for drill links.
     */
    public var path_prefix: String? {
        get { _path_prefix?.value }
        set { _path_prefix = newValue.map(AnyString.init) }
    }

    /**
     * Whether or not to use the cache
     */
    public var cache: Bool?

    /**
     * Whether or not to run table calculations on the server
     */
    public var server_table_calcs: Bool?

    /**
     * Retrieve any results from cache even if the results have expired.
     */
    public var cache_only: Bool?

    private var _cache_key: AnyString?
    /**
     * cache key used to cache query. (read-only)
     */
    public var cache_key: String? {
        get { _cache_key?.value }
        set { _cache_key = newValue.map(AnyString.init) }
    }

    private var _status: AnyString?
    /**
     * Status of query task.
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    private var _source: AnyString?
    /**
     * Source of query task.
     */
    public var source: String? {
        get { _source?.value }
        set { _source = newValue.map(AnyString.init) }
    }

    /**
     * Runtime of prior queries. (read-only)
     */
    public var runtime: Float?

    /**
     * Rebuild PDTS used in query.
     */
    public var rebuild_pdts: Bool?

    private var _result_source: AnyString?
    /**
     * Source of the results of the query. (read-only)
     */
    public var result_source: String? {
        get { _result_source?.value }
        set { _result_source = newValue.map(AnyString.init) }
    }

    private var _look_id: AnyString?
    /**
     * Id of look associated with query.
     */
    public var look_id: String? {
        get { _look_id?.value }
        set { _look_id = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString?
    /**
     * Id of dashboard associated with query.
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    private var _result_format: AnyString?
    /**
     * The data format of the query results. (read-only)
     */
    public var result_format: String? {
        get { _result_format?.value }
        set { _result_format = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, query_id: String? = nil, query: Query? = nil, generate_links: Bool? = nil, force_production: Bool? = nil, path_prefix: String? = nil, cache: Bool? = nil, server_table_calcs: Bool? = nil, cache_only: Bool? = nil, cache_key: String? = nil, status: String? = nil, source: String? = nil, runtime: Float? = nil, rebuild_pdts: Bool? = nil, result_source: String? = nil, look_id: String? = nil, dashboard_id: String? = nil, result_format: String? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._query_id = query_id.map(AnyString.init)
        self.query = query
        self.generate_links = generate_links
        self.force_production = force_production
        self._path_prefix = path_prefix.map(AnyString.init)
        self.cache = cache
        self.server_table_calcs = server_table_calcs
        self.cache_only = cache_only
        self._cache_key = cache_key.map(AnyString.init)
        self._status = status.map(AnyString.init)
        self._source = source.map(AnyString.init)
        self.runtime = runtime
        self.rebuild_pdts = rebuild_pdts
        self._result_source = result_source.map(AnyString.init)
        self._look_id = look_id.map(AnyString.init)
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self._result_format = result_format.map(AnyString.init)
    }

}

public struct RenderTask: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _created_at = "created_at"
        case _dashboard_filters = "dashboard_filters"
        case _dashboard_id = "dashboard_id"
        case _dashboard_style = "dashboard_style"
        case _finalized_at = "finalized_at"
        case _height = "height"
        case _id = "id"
        case _look_id = "look_id"
        case _lookml_dashboard_id = "lookml_dashboard_id"
        case _query_id = "query_id"
        case _dashboard_element_id = "dashboard_element_id"
        case query_runtime
        case render_runtime
        case _result_format = "result_format"
        case runtime
        case _status = "status"
        case _status_detail = "status_detail"
        case _user_id = "user_id"
        case _width = "width"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _created_at: AnyString?
    /**
     * Date/Time render task was created (read-only)
     */
    public var created_at: String? {
        get { _created_at?.value }
        set { _created_at = newValue.map(AnyString.init) }
    }

    private var _dashboard_filters: AnyString?
    /**
     * Filter values to apply to the dashboard queries, in URL query format (read-only)
     */
    public var dashboard_filters: String? {
        get { _dashboard_filters?.value }
        set { _dashboard_filters = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString?
    /**
     * Id of dashboard to render (read-only)
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    private var _dashboard_style: AnyString?
    /**
     * Dashboard layout style: single_column or tiled (read-only)
     */
    public var dashboard_style: String? {
        get { _dashboard_style?.value }
        set { _dashboard_style = newValue.map(AnyString.init) }
    }

    private var _finalized_at: AnyString?
    /**
     * Date/Time render task was completed (read-only)
     */
    public var finalized_at: String? {
        get { _finalized_at?.value }
        set { _finalized_at = newValue.map(AnyString.init) }
    }

    private var _height: AnyInt?
    /**
     * Output height in pixels. Flowed layouts may ignore this value. (read-only)
     */
    public var height: Int64? {
        get { _height?.value }
        set { _height = newValue.map(AnyInt.init) }
    }

    private var _id: AnyString?
    /**
     * Id of this render task (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _look_id: AnyString?
    /**
     * Id of look to render (read-only)
     */
    public var look_id: String? {
        get { _look_id?.value }
        set { _look_id = newValue.map(AnyString.init) }
    }

    private var _lookml_dashboard_id: AnyString?
    /**
     * Id of lookml dashboard to render (read-only)
     */
    public var lookml_dashboard_id: String? {
        get { _lookml_dashboard_id?.value }
        set { _lookml_dashboard_id = newValue.map(AnyString.init) }
    }

    private var _query_id: AnyString?
    /**
     * Id of query to render (read-only)
     */
    public var query_id: String? {
        get { _query_id?.value }
        set { _query_id = newValue.map(AnyString.init) }
    }

    private var _dashboard_element_id: AnyString?
    /**
     * Id of dashboard element to render: UDD dashboard element would be numeric and LookML dashboard element would be model_name::dashboard_title::lookml_link_id (read-only)
     */
    public var dashboard_element_id: String? {
        get { _dashboard_element_id?.value }
        set { _dashboard_element_id = newValue.map(AnyString.init) }
    }

    /**
     * Number of seconds elapsed running queries (read-only)
     */
    public var query_runtime: Double?

    /**
     * Number of seconds elapsed rendering data (read-only)
     */
    public var render_runtime: Double?

    private var _result_format: AnyString?
    /**
     * Output format: pdf, png, or jpg (read-only)
     */
    public var result_format: String? {
        get { _result_format?.value }
        set { _result_format = newValue.map(AnyString.init) }
    }

    /**
     * Total seconds elapsed for render task (read-only)
     */
    public var runtime: Double?

    private var _status: AnyString?
    /**
     * Render task status: enqueued_for_query, querying, enqueued_for_render, rendering, success, failure (read-only)
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    private var _status_detail: AnyString?
    /**
     * Additional information about the current status (read-only)
     */
    public var status_detail: String? {
        get { _status_detail?.value }
        set { _status_detail = newValue.map(AnyString.init) }
    }

    private var _user_id: AnyString?
    /**
     * The user account permissions in which the render task will execute (read-only)
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    private var _width: AnyInt?
    /**
     * Output width in pixels (read-only)
     */
    public var width: Int64? {
        get { _width?.value }
        set { _width = newValue.map(AnyInt.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, created_at: String? = nil, dashboard_filters: String? = nil, dashboard_id: String? = nil, dashboard_style: String? = nil, finalized_at: String? = nil, height: Int64? = nil, id: String? = nil, look_id: String? = nil, lookml_dashboard_id: String? = nil, query_id: String? = nil, dashboard_element_id: String? = nil, query_runtime: Double? = nil, render_runtime: Double? = nil, result_format: String? = nil, runtime: Double? = nil, status: String? = nil, status_detail: String? = nil, user_id: String? = nil, width: Int64? = nil) {
        self.can = can
        self._created_at = created_at.map(AnyString.init)
        self._dashboard_filters = dashboard_filters.map(AnyString.init)
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self._dashboard_style = dashboard_style.map(AnyString.init)
        self._finalized_at = finalized_at.map(AnyString.init)
        self._height = height.map(AnyInt.init)
        self._id = id.map(AnyString.init)
        self._look_id = look_id.map(AnyString.init)
        self._lookml_dashboard_id = lookml_dashboard_id.map(AnyString.init)
        self._query_id = query_id.map(AnyString.init)
        self._dashboard_element_id = dashboard_element_id.map(AnyString.init)
        self.query_runtime = query_runtime
        self.render_runtime = render_runtime
        self._result_format = result_format.map(AnyString.init)
        self.runtime = runtime
        self._status = status.map(AnyString.init)
        self._status_detail = status_detail.map(AnyString.init)
        self._user_id = user_id.map(AnyString.init)
        self._width = width.map(AnyInt.init)
    }

}

public struct Report: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _title = "title"
        case _user_id = "user_id"
        case created_at
        case updated_at
        case last_viewed_at
        case favorite
        case _favorite_count = "favorite_count"
        case _view_count = "view_count"
        case folder
        case _folder_id = "folder_id"
        case _url = "url"
        case _user_name = "user_name"
        case deleted_at
        case last_accessed_at
        case _deleter_user_id = "deleter_user_id"
        case _deleter_user_name = "deleter_user_name"
        case _schedule_count = "schedule_count"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * ID of the report
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Title of the report
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _user_id: AnyString?
    /**
     * User Id of the owner of the report
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    /**
     * Created at (read-only)
     */
    public var created_at: Date?

    /**
     * Modified at (read-only)
     */
    public var updated_at: Date?

    /**
     * Last viewed at (read-only)
     */
    public var last_viewed_at: Date?

    /**
     * Is favorite report
     */
    public var favorite: Bool?

    private var _favorite_count: AnyInt?
    /**
     * Favorite count (read-only)
     */
    public var favorite_count: Int64? {
        get { _favorite_count?.value }
        set { _favorite_count = newValue.map(AnyInt.init) }
    }

    private var _view_count: AnyInt?
    /**
     * View count (read-only)
     */
    public var view_count: Int64? {
        get { _view_count?.value }
        set { _view_count = newValue.map(AnyInt.init) }
    }

    public var folder: FolderBase?

    private var _folder_id: AnyString?
    /**
     * Id of the folder where the report is stored
     */
    public var folder_id: String? {
        get { _folder_id?.value }
        set { _folder_id = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Relative URL of the report (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    private var _user_name: AnyString?
    /**
     * Name of User that created the Studio Report. (read-only)
     */
    public var user_name: String? {
        get { _user_name?.value }
        set { _user_name = newValue.map(AnyString.init) }
    }

    /**
     * Deleted at (read-only)
     */
    public var deleted_at: Date?

    /**
     * Last Accessed at (read-only)
     */
    public var last_accessed_at: Date?

    private var _deleter_user_id: AnyString?
    /**
     * User Id of the deleter of the report (read-only)
     */
    public var deleter_user_id: String? {
        get { _deleter_user_id?.value }
        set { _deleter_user_id = newValue.map(AnyString.init) }
    }

    private var _deleter_user_name: AnyString?
    /**
     * Name of User that deleted the Report. (read-only)
     */
    public var deleter_user_name: String? {
        get { _deleter_user_name?.value }
        set { _deleter_user_name = newValue.map(AnyString.init) }
    }

    private var _schedule_count: AnyInt?
    /**
     * Count of schedules on the report. (read-only)
     */
    public var schedule_count: Int64? {
        get { _schedule_count?.value }
        set { _schedule_count = newValue.map(AnyInt.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, title: String? = nil, user_id: String? = nil, created_at: Date? = nil, updated_at: Date? = nil, last_viewed_at: Date? = nil, favorite: Bool? = nil, favorite_count: Int64? = nil, view_count: Int64? = nil, folder: FolderBase? = nil, folder_id: String? = nil, url: String? = nil, user_name: String? = nil, deleted_at: Date? = nil, last_accessed_at: Date? = nil, deleter_user_id: String? = nil, deleter_user_name: String? = nil, schedule_count: Int64? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self._user_id = user_id.map(AnyString.init)
        self.created_at = created_at
        self.updated_at = updated_at
        self.last_viewed_at = last_viewed_at
        self.favorite = favorite
        self._favorite_count = favorite_count.map(AnyInt.init)
        self._view_count = view_count.map(AnyInt.init)
        self.folder = folder
        self._folder_id = folder_id.map(AnyString.init)
        self._url = url.map(AnyString.init)
        self._user_name = user_name.map(AnyString.init)
        self.deleted_at = deleted_at
        self.last_accessed_at = last_accessed_at
        self._deleter_user_id = deleter_user_id.map(AnyString.init)
        self._deleter_user_name = deleter_user_name.map(AnyString.init)
        self._schedule_count = schedule_count.map(AnyInt.init)
    }

}

public struct RepositoryCredential: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _root_project_id = "root_project_id"
        case _remote_url = "remote_url"
        case _git_username = "git_username"
        case _git_password = "git_password"
        case _ssh_public_key = "ssh_public_key"
        case is_configured
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _root_project_id: AnyString?
    /**
     * Root project Id (read-only)
     */
    public var root_project_id: String? {
        get { _root_project_id?.value }
        set { _root_project_id = newValue.map(AnyString.init) }
    }

    private var _remote_url: AnyString?
    /**
     * Git remote repository url (read-only)
     */
    public var remote_url: String? {
        get { _remote_url?.value }
        set { _remote_url = newValue.map(AnyString.init) }
    }

    private var _git_username: AnyString?
    /**
     * Git username for HTTPS authentication.
     */
    public var git_username: String? {
        get { _git_username?.value }
        set { _git_username = newValue.map(AnyString.init) }
    }

    private var _git_password: AnyString?
    /**
     * (Write-Only) Git password for HTTPS authentication.
     */
    public var git_password: String? {
        get { _git_password?.value }
        set { _git_password = newValue.map(AnyString.init) }
    }

    private var _ssh_public_key: AnyString?
    /**
     * Public deploy key for SSH authentication.
     */
    public var ssh_public_key: String? {
        get { _ssh_public_key?.value }
        set { _ssh_public_key = newValue.map(AnyString.init) }
    }

    /**
     * Whether the credentials have been configured for the Git Repository. (read-only)
     */
    public var is_configured: Bool?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, root_project_id: String? = nil, remote_url: String? = nil, git_username: String? = nil, git_password: String? = nil, ssh_public_key: String? = nil, is_configured: Bool? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._root_project_id = root_project_id.map(AnyString.init)
        self._remote_url = remote_url.map(AnyString.init)
        self._git_username = git_username.map(AnyString.init)
        self._git_password = git_password.map(AnyString.init)
        self._ssh_public_key = ssh_public_key.map(AnyString.init)
        self.is_configured = is_configured
    }

}

/**
 * Desired async query result format. Valid values are: "inline_json", "json", "json_detail", "json_fe", "json_bi", "csv", "html", "md", "txt", "xlsx", "gsxml", "sql", "odc". (Enum defined in CreateQueryTask)
 */
public enum ResultFormat: String, Codable {
    case inline_json = "inline_json"
    case json = "json"
    case json_detail = "json_detail"
    case json_fe = "json_fe"
    case json_bi = "json_bi"
    case csv = "csv"
    case html = "html"
    case md = "md"
    case txt = "txt"
    case xlsx = "xlsx"
    case gsxml = "gsxml"
    case sql = "sql"
    case odc = "odc"
}

public struct ResultMakerFilterables: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _model = "model"
        case _view = "view"
        case _name = "name"
        case listen
    }
    private var _model: AnyString?
    /**
     * The model this filterable comes from (used for field suggestions). (read-only)
     */
    public var model: String? {
        get { _model?.value }
        set { _model = newValue.map(AnyString.init) }
    }

    private var _view: AnyString?
    /**
     * The view this filterable comes from (used for field suggestions). (read-only)
     */
    public var view: String? {
        get { _view?.value }
        set { _view = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * The name of the filterable thing (Query or Merged Results). (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     * array of dashboard_filter_name: and field: objects. (read-only)
     */
    public var listen: [ResultMakerFilterablesListen]?

    public init(model: String? = nil, view: String? = nil, name: String? = nil, listen: [ResultMakerFilterablesListen]? = nil) {
        self._model = model.map(AnyString.init)
        self._view = view.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self.listen = listen
    }

}

public struct ResultMakerFilterablesListen: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _dashboard_filter_name = "dashboard_filter_name"
        case _field = "field"
    }
    private var _dashboard_filter_name: AnyString?
    /**
     * The name of a dashboard filter to listen to.
     */
    public var dashboard_filter_name: String? {
        get { _dashboard_filter_name?.value }
        set { _dashboard_filter_name = newValue.map(AnyString.init) }
    }

    private var _field: AnyString?
    /**
     * The name of the field in the filterable to filter with the value of the dashboard filter.
     */
    public var field: String? {
        get { _field?.value }
        set { _field = newValue.map(AnyString.init) }
    }

    public init(dashboard_filter_name: String? = nil, field: String? = nil) {
        self._dashboard_filter_name = dashboard_filter_name.map(AnyString.init)
        self._field = field.map(AnyString.init)
    }

}

public struct ResultMakerWithIdVisConfigAndDynamicFields: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _dynamic_fields = "dynamic_fields"
        case filterables
        case _sorts = "sorts"
        case _merge_result_id = "merge_result_id"
        case total
        case _query_id = "query_id"
        case _sql_query_id = "sql_query_id"
        case query
        case vis_config
    }
    private var _id: AnyString?
    /**
     * Unique Id. (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _dynamic_fields: AnyString?
    /**
     * JSON string of dynamic field information. (read-only)
     */
    public var dynamic_fields: String? {
        get { _dynamic_fields?.value }
        set { _dynamic_fields = newValue.map(AnyString.init) }
    }

    /**
     * array of items that can be filtered and information about them. (read-only)
     */
    public var filterables: [ResultMakerFilterables]?

    private var _sorts: [AnyString]?
    /**
     * Sorts of the constituent Look, Query, or Merge Query (read-only)
     */
    public var sorts: [String]? {
        get { if let v = _sorts { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _sorts = v.map { AnyString.init($0) } } else { _sorts = nil } }
    }

    private var _merge_result_id: AnyString?
    /**
     * ID of merge result if this is a merge_result. (read-only)
     */
    public var merge_result_id: String? {
        get { _merge_result_id?.value }
        set { _merge_result_id = newValue.map(AnyString.init) }
    }

    /**
     * Total of the constituent Look, Query, or Merge Query (read-only)
     */
    public var total: Bool?

    private var _query_id: AnyString?
    /**
     * ID of query if this is a query. (read-only)
     */
    public var query_id: String? {
        get { _query_id?.value }
        set { _query_id = newValue.map(AnyString.init) }
    }

    private var _sql_query_id: AnyString?
    /**
     * ID of SQL Query if this is a SQL Runner Query (read-only)
     */
    public var sql_query_id: String? {
        get { _sql_query_id?.value }
        set { _sql_query_id = newValue.map(AnyString.init) }
    }

    public var query: Query?

    /**
     * Vis config of the constituent Query, or Merge Query. (read-only)
     */
    public var vis_config: StringDictionary<AnyCodable>?

    public init(id: String? = nil, dynamic_fields: String? = nil, filterables: [ResultMakerFilterables]? = nil, sorts: [String]? = nil, merge_result_id: String? = nil, total: Bool? = nil, query_id: String? = nil, sql_query_id: String? = nil, query: Query? = nil, vis_config: StringDictionary<AnyCodable>? = nil) {
        self._id = id.map(AnyString.init)
        self._dynamic_fields = dynamic_fields.map(AnyString.init)
        self.filterables = filterables
        if let v = sorts { _sorts = v.map { AnyString.init($0) } } else { _sorts = nil }
        self._merge_result_id = merge_result_id.map(AnyString.init)
        self.total = total
        self._query_id = query_id.map(AnyString.init)
        self._sql_query_id = sql_query_id.map(AnyString.init)
        self.query = query
        self.vis_config = vis_config
    }

}

public struct Role: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _name = "name"
        case permission_set
        case _permission_set_id = "permission_set_id"
        case model_set
        case _model_set_id = "model_set_id"
        case _url = "url"
        case _users_url = "users_url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Name of Role
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    public var permission_set: PermissionSet?

    private var _permission_set_id: AnyString?
    /**
     * (Write-Only) Id of permission set
     */
    public var permission_set_id: String? {
        get { _permission_set_id?.value }
        set { _permission_set_id = newValue.map(AnyString.init) }
    }

    public var model_set: ModelSet?

    private var _model_set_id: AnyString?
    /**
     * (Write-Only) Id of model set
     */
    public var model_set_id: String? {
        get { _model_set_id?.value }
        set { _model_set_id = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    private var _users_url: AnyString?
    /**
     * Link to get list of users with this role (read-only)
     */
    public var users_url: String? {
        get { _users_url?.value }
        set { _users_url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, name: String? = nil, permission_set: PermissionSet? = nil, permission_set_id: String? = nil, model_set: ModelSet? = nil, model_set_id: String? = nil, url: String? = nil, users_url: String? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self.permission_set = permission_set
        self._permission_set_id = permission_set_id.map(AnyString.init)
        self.model_set = model_set
        self._model_set_id = model_set_id.map(AnyString.init)
        self._url = url.map(AnyString.init)
        self._users_url = users_url.map(AnyString.init)
    }

}

public struct RoleSearch: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _name = "name"
        case permission_set
        case _permission_set_id = "permission_set_id"
        case model_set
        case _model_set_id = "model_set_id"
        case _user_count = "user_count"
        case _url = "url"
        case _users_url = "users_url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Name of Role
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    public var permission_set: PermissionSet?

    private var _permission_set_id: AnyString?
    /**
     * (Write-Only) Id of permission set
     */
    public var permission_set_id: String? {
        get { _permission_set_id?.value }
        set { _permission_set_id = newValue.map(AnyString.init) }
    }

    public var model_set: ModelSet?

    private var _model_set_id: AnyString?
    /**
     * (Write-Only) Id of model set
     */
    public var model_set_id: String? {
        get { _model_set_id?.value }
        set { _model_set_id = newValue.map(AnyString.init) }
    }

    private var _user_count: AnyInt?
    /**
     * Count of users with this role (read-only)
     */
    public var user_count: Int64? {
        get { _user_count?.value }
        set { _user_count = newValue.map(AnyInt.init) }
    }

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    private var _users_url: AnyString?
    /**
     * Link to get list of users with this role (read-only)
     */
    public var users_url: String? {
        get { _users_url?.value }
        set { _users_url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, name: String? = nil, permission_set: PermissionSet? = nil, permission_set_id: String? = nil, model_set: ModelSet? = nil, model_set_id: String? = nil, user_count: Int64? = nil, url: String? = nil, users_url: String? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self.permission_set = permission_set
        self._permission_set_id = permission_set_id.map(AnyString.init)
        self.model_set = model_set
        self._model_set_id = model_set_id.map(AnyString.init)
        self._user_count = user_count.map(AnyInt.init)
        self._url = url.map(AnyString.init)
        self._users_url = users_url.map(AnyString.init)
    }

}

public struct RunningQueries: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case user
        case query
        case sql_query
        case look
        case _created_at = "created_at"
        case _completed_at = "completed_at"
        case _query_id = "query_id"
        case _source = "source"
        case _node_id = "node_id"
        case _slug = "slug"
        case _query_task_id = "query_task_id"
        case _cache_key = "cache_key"
        case _connection_name = "connection_name"
        case _dialect = "dialect"
        case _connection_id = "connection_id"
        case _message = "message"
        case _status = "status"
        case runtime
        case _sql = "sql"
        case _sql_interface_sql = "sql_interface_sql"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    public var user: UserPublic?

    public var query: Query?

    public var sql_query: SqlQuery?

    public var look: LookBasic?

    private var _created_at: AnyString?
    /**
     * Date/Time Query was initiated (read-only)
     */
    public var created_at: String? {
        get { _created_at?.value }
        set { _created_at = newValue.map(AnyString.init) }
    }

    private var _completed_at: AnyString?
    /**
     * Date/Time Query was completed (read-only)
     */
    public var completed_at: String? {
        get { _completed_at?.value }
        set { _completed_at = newValue.map(AnyString.init) }
    }

    private var _query_id: AnyString?
    /**
     * Query Id (read-only)
     */
    public var query_id: String? {
        get { _query_id?.value }
        set { _query_id = newValue.map(AnyString.init) }
    }

    private var _source: AnyString?
    /**
     * Source (look, dashboard, queryrunner, explore, etc.) (read-only)
     */
    public var source: String? {
        get { _source?.value }
        set { _source = newValue.map(AnyString.init) }
    }

    private var _node_id: AnyString?
    /**
     * Node Id (read-only)
     */
    public var node_id: String? {
        get { _node_id?.value }
        set { _node_id = newValue.map(AnyString.init) }
    }

    private var _slug: AnyString?
    /**
     * Slug (read-only)
     */
    public var slug: String? {
        get { _slug?.value }
        set { _slug = newValue.map(AnyString.init) }
    }

    private var _query_task_id: AnyString?
    /**
     * ID of a Query Task (read-only)
     */
    public var query_task_id: String? {
        get { _query_task_id?.value }
        set { _query_task_id = newValue.map(AnyString.init) }
    }

    private var _cache_key: AnyString?
    /**
     * Cache Key (read-only)
     */
    public var cache_key: String? {
        get { _cache_key?.value }
        set { _cache_key = newValue.map(AnyString.init) }
    }

    private var _connection_name: AnyString?
    /**
     * Connection (read-only)
     */
    public var connection_name: String? {
        get { _connection_name?.value }
        set { _connection_name = newValue.map(AnyString.init) }
    }

    private var _dialect: AnyString?
    /**
     * Dialect (read-only)
     */
    public var dialect: String? {
        get { _dialect?.value }
        set { _dialect = newValue.map(AnyString.init) }
    }

    private var _connection_id: AnyString?
    /**
     * Connection ID (read-only)
     */
    public var connection_id: String? {
        get { _connection_id?.value }
        set { _connection_id = newValue.map(AnyString.init) }
    }

    private var _message: AnyString?
    /**
     * Additional Information(Error message or verbose status) (read-only)
     */
    public var message: String? {
        get { _message?.value }
        set { _message = newValue.map(AnyString.init) }
    }

    private var _status: AnyString?
    /**
     * Status description (read-only)
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    /**
     * Number of seconds elapsed running the Query (read-only)
     */
    public var runtime: Double?

    private var _sql: AnyString?
    /**
     * SQL text of the query as run (read-only)
     */
    public var sql: String? {
        get { _sql?.value }
        set { _sql = newValue.map(AnyString.init) }
    }

    private var _sql_interface_sql: AnyString?
    /**
     * SQL text of the SQL Interface query as run (read-only)
     */
    public var sql_interface_sql: String? {
        get { _sql_interface_sql?.value }
        set { _sql_interface_sql = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, user: UserPublic? = nil, query: Query? = nil, sql_query: SqlQuery? = nil, look: LookBasic? = nil, created_at: String? = nil, completed_at: String? = nil, query_id: String? = nil, source: String? = nil, node_id: String? = nil, slug: String? = nil, query_task_id: String? = nil, cache_key: String? = nil, connection_name: String? = nil, dialect: String? = nil, connection_id: String? = nil, message: String? = nil, status: String? = nil, runtime: Double? = nil, sql: String? = nil, sql_interface_sql: String? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self.user = user
        self.query = query
        self.sql_query = sql_query
        self.look = look
        self._created_at = created_at.map(AnyString.init)
        self._completed_at = completed_at.map(AnyString.init)
        self._query_id = query_id.map(AnyString.init)
        self._source = source.map(AnyString.init)
        self._node_id = node_id.map(AnyString.init)
        self._slug = slug.map(AnyString.init)
        self._query_task_id = query_task_id.map(AnyString.init)
        self._cache_key = cache_key.map(AnyString.init)
        self._connection_name = connection_name.map(AnyString.init)
        self._dialect = dialect.map(AnyString.init)
        self._connection_id = connection_id.map(AnyString.init)
        self._message = message.map(AnyString.init)
        self._status = status.map(AnyString.init)
        self.runtime = runtime
        self._sql = sql.map(AnyString.init)
        self._sql_interface_sql = sql_interface_sql.map(AnyString.init)
    }

}

public struct SamlConfig: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case enabled
        case _idp_cert = "idp_cert"
        case _idp_url = "idp_url"
        case _idp_issuer = "idp_issuer"
        case _idp_audience = "idp_audience"
        case _allowed_clock_drift = "allowed_clock_drift"
        case _user_attribute_map_email = "user_attribute_map_email"
        case _user_attribute_map_first_name = "user_attribute_map_first_name"
        case _user_attribute_map_last_name = "user_attribute_map_last_name"
        case _new_user_migration_types = "new_user_migration_types"
        case alternate_email_login_allowed
        case _test_slug = "test_slug"
        case _modified_at = "modified_at"
        case _modified_by = "modified_by"
        case default_new_user_roles
        case default_new_user_groups
        case _default_new_user_role_ids = "default_new_user_role_ids"
        case _default_new_user_group_ids = "default_new_user_group_ids"
        case set_roles_from_groups
        case _groups_attribute = "groups_attribute"
        case groups
        case groups_with_role_ids
        case auth_requires_role
        case user_attributes
        case user_attributes_with_ids
        case _groups_finder_type = "groups_finder_type"
        case _groups_member_value = "groups_member_value"
        case bypass_login_page
        case allow_normal_group_membership
        case allow_roles_from_normal_groups
        case allow_direct_roles
        case _url = "url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    /**
     * Enable/Disable Saml authentication for the server
     */
    public var enabled: Bool?

    private var _idp_cert: AnyString?
    /**
     * Identity Provider Certificate (provided by IdP)
     */
    public var idp_cert: String? {
        get { _idp_cert?.value }
        set { _idp_cert = newValue.map(AnyString.init) }
    }

    private var _idp_url: AnyString?
    /**
     * Identity Provider Url (provided by IdP)
     */
    public var idp_url: String? {
        get { _idp_url?.value }
        set { _idp_url = newValue.map(AnyString.init) }
    }

    private var _idp_issuer: AnyString?
    /**
     * Identity Provider Issuer (provided by IdP)
     */
    public var idp_issuer: String? {
        get { _idp_issuer?.value }
        set { _idp_issuer = newValue.map(AnyString.init) }
    }

    private var _idp_audience: AnyString?
    /**
     * Identity Provider Audience (set in IdP config). Optional in Looker. Set this only if you want Looker to validate the audience value returned by the IdP.
     */
    public var idp_audience: String? {
        get { _idp_audience?.value }
        set { _idp_audience = newValue.map(AnyString.init) }
    }

    private var _allowed_clock_drift: AnyInt?
    /**
     * Count of seconds of clock drift to allow when validating timestamps of assertions.
     */
    public var allowed_clock_drift: Int64? {
        get { _allowed_clock_drift?.value }
        set { _allowed_clock_drift = newValue.map(AnyInt.init) }
    }

    private var _user_attribute_map_email: AnyString?
    /**
     * Name of user record attributes used to indicate email address field
     */
    public var user_attribute_map_email: String? {
        get { _user_attribute_map_email?.value }
        set { _user_attribute_map_email = newValue.map(AnyString.init) }
    }

    private var _user_attribute_map_first_name: AnyString?
    /**
     * Name of user record attributes used to indicate first name
     */
    public var user_attribute_map_first_name: String? {
        get { _user_attribute_map_first_name?.value }
        set { _user_attribute_map_first_name = newValue.map(AnyString.init) }
    }

    private var _user_attribute_map_last_name: AnyString?
    /**
     * Name of user record attributes used to indicate last name
     */
    public var user_attribute_map_last_name: String? {
        get { _user_attribute_map_last_name?.value }
        set { _user_attribute_map_last_name = newValue.map(AnyString.init) }
    }

    private var _new_user_migration_types: AnyString?
    /**
     * Merge first-time saml login to existing user account by email addresses. When a user logs in for the first time via saml this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
     */
    public var new_user_migration_types: String? {
        get { _new_user_migration_types?.value }
        set { _new_user_migration_types = newValue.map(AnyString.init) }
    }

    /**
     * Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
     */
    public var alternate_email_login_allowed: Bool?

    private var _test_slug: AnyString?
    /**
     * Slug to identify configurations that are created in order to run a Saml config test (read-only)
     */
    public var test_slug: String? {
        get { _test_slug?.value }
        set { _test_slug = newValue.map(AnyString.init) }
    }

    private var _modified_at: AnyString?
    /**
     * When this config was last modified (read-only)
     */
    public var modified_at: String? {
        get { _modified_at?.value }
        set { _modified_at = newValue.map(AnyString.init) }
    }

    private var _modified_by: AnyString?
    /**
     * User id of user who last modified this config (read-only)
     */
    public var modified_by: String? {
        get { _modified_by?.value }
        set { _modified_by = newValue.map(AnyString.init) }
    }

    /**
     * (Read-only) Roles that will be applied to new users the first time they login via Saml (read-only)
     */
    public var default_new_user_roles: [Role]?

    /**
     * (Read-only) Groups that will be applied to new users the first time they login via Saml (read-only)
     */
    public var default_new_user_groups: [LkGroup]?

    private var _default_new_user_role_ids: [AnyString]?
    /**
     * (Write-Only) Array of ids of roles that will be applied to new users the first time they login via Saml
     */
    public var default_new_user_role_ids: [String]? {
        get { if let v = _default_new_user_role_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _default_new_user_role_ids = v.map { AnyString.init($0) } } else { _default_new_user_role_ids = nil } }
    }

    private var _default_new_user_group_ids: [AnyString]?
    /**
     * (Write-Only) Array of ids of groups that will be applied to new users the first time they login via Saml
     */
    public var default_new_user_group_ids: [String]? {
        get { if let v = _default_new_user_group_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _default_new_user_group_ids = v.map { AnyString.init($0) } } else { _default_new_user_group_ids = nil } }
    }

    /**
     * Set user roles in Looker based on groups from Saml
     */
    public var set_roles_from_groups: Bool?

    private var _groups_attribute: AnyString?
    /**
     * Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
     */
    public var groups_attribute: String? {
        get { _groups_attribute?.value }
        set { _groups_attribute = newValue.map(AnyString.init) }
    }

    /**
     * (Read-only) Array of mappings between Saml Groups and Looker Roles (read-only)
     */
    public var groups: [SamlGroupRead]?

    /**
     * (Read/Write) Array of mappings between Saml Groups and arrays of Looker Role ids
     */
    public var groups_with_role_ids: [SamlGroupWrite]?

    /**
     * Users will not be allowed to login at all unless a role for them is found in Saml if set to true
     */
    public var auth_requires_role: Bool?

    /**
     * (Read-only) Array of mappings between Saml User Attributes and Looker User Attributes (read-only)
     */
    public var user_attributes: [SamlUserAttributeRead]?

    /**
     * (Read/Write) Array of mappings between Saml User Attributes and arrays of Looker User Attribute ids
     */
    public var user_attributes_with_ids: [SamlUserAttributeWrite]?

    private var _groups_finder_type: AnyString?
    /**
     * Identifier for a strategy for how Looker will find groups in the SAML response. One of ['grouped_attribute_values', 'individual_attributes']
     */
    public var groups_finder_type: String? {
        get { _groups_finder_type?.value }
        set { _groups_finder_type = newValue.map(AnyString.init) }
    }

    private var _groups_member_value: AnyString?
    /**
     * Value for group attribute used to indicate membership. Used when 'groups_finder_type' is set to 'individual_attributes'
     */
    public var groups_member_value: String? {
        get { _groups_member_value?.value }
        set { _groups_member_value = newValue.map(AnyString.init) }
    }

    /**
     * Bypass the login page when user authentication is required. Redirect to IdP immediately instead.
     */
    public var bypass_login_page: Bool?

    /**
     * Allow SAML auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.
     */
    public var allow_normal_group_membership: Bool?

    /**
     * SAML auth'd users will inherit roles from non-reflected Looker groups.
     */
    public var allow_roles_from_normal_groups: Bool?

    /**
     * Allows roles to be directly assigned to SAML auth'd users.
     */
    public var allow_direct_roles: Bool?

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, enabled: Bool? = nil, idp_cert: String? = nil, idp_url: String? = nil, idp_issuer: String? = nil, idp_audience: String? = nil, allowed_clock_drift: Int64? = nil, user_attribute_map_email: String? = nil, user_attribute_map_first_name: String? = nil, user_attribute_map_last_name: String? = nil, new_user_migration_types: String? = nil, alternate_email_login_allowed: Bool? = nil, test_slug: String? = nil, modified_at: String? = nil, modified_by: String? = nil, default_new_user_roles: [Role]? = nil, default_new_user_groups: [LkGroup]? = nil, default_new_user_role_ids: [String]? = nil, default_new_user_group_ids: [String]? = nil, set_roles_from_groups: Bool? = nil, groups_attribute: String? = nil, groups: [SamlGroupRead]? = nil, groups_with_role_ids: [SamlGroupWrite]? = nil, auth_requires_role: Bool? = nil, user_attributes: [SamlUserAttributeRead]? = nil, user_attributes_with_ids: [SamlUserAttributeWrite]? = nil, groups_finder_type: String? = nil, groups_member_value: String? = nil, bypass_login_page: Bool? = nil, allow_normal_group_membership: Bool? = nil, allow_roles_from_normal_groups: Bool? = nil, allow_direct_roles: Bool? = nil, url: String? = nil) {
        self.can = can
        self.enabled = enabled
        self._idp_cert = idp_cert.map(AnyString.init)
        self._idp_url = idp_url.map(AnyString.init)
        self._idp_issuer = idp_issuer.map(AnyString.init)
        self._idp_audience = idp_audience.map(AnyString.init)
        self._allowed_clock_drift = allowed_clock_drift.map(AnyInt.init)
        self._user_attribute_map_email = user_attribute_map_email.map(AnyString.init)
        self._user_attribute_map_first_name = user_attribute_map_first_name.map(AnyString.init)
        self._user_attribute_map_last_name = user_attribute_map_last_name.map(AnyString.init)
        self._new_user_migration_types = new_user_migration_types.map(AnyString.init)
        self.alternate_email_login_allowed = alternate_email_login_allowed
        self._test_slug = test_slug.map(AnyString.init)
        self._modified_at = modified_at.map(AnyString.init)
        self._modified_by = modified_by.map(AnyString.init)
        self.default_new_user_roles = default_new_user_roles
        self.default_new_user_groups = default_new_user_groups
        if let v = default_new_user_role_ids { _default_new_user_role_ids = v.map { AnyString.init($0) } } else { _default_new_user_role_ids = nil }
        if let v = default_new_user_group_ids { _default_new_user_group_ids = v.map { AnyString.init($0) } } else { _default_new_user_group_ids = nil }
        self.set_roles_from_groups = set_roles_from_groups
        self._groups_attribute = groups_attribute.map(AnyString.init)
        self.groups = groups
        self.groups_with_role_ids = groups_with_role_ids
        self.auth_requires_role = auth_requires_role
        self.user_attributes = user_attributes
        self.user_attributes_with_ids = user_attributes_with_ids
        self._groups_finder_type = groups_finder_type.map(AnyString.init)
        self._groups_member_value = groups_member_value.map(AnyString.init)
        self.bypass_login_page = bypass_login_page
        self.allow_normal_group_membership = allow_normal_group_membership
        self.allow_roles_from_normal_groups = allow_roles_from_normal_groups
        self.allow_direct_roles = allow_direct_roles
        self._url = url.map(AnyString.init)
    }

}

public struct SamlGroupRead: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _looker_group_id = "looker_group_id"
        case _looker_group_name = "looker_group_name"
        case _name = "name"
        case roles
        case _url = "url"
    }
    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _looker_group_id: AnyString?
    /**
     * Unique Id of group in Looker (read-only)
     */
    public var looker_group_id: String? {
        get { _looker_group_id?.value }
        set { _looker_group_id = newValue.map(AnyString.init) }
    }

    private var _looker_group_name: AnyString?
    /**
     * Name of group in Looker (read-only)
     */
    public var looker_group_name: String? {
        get { _looker_group_name?.value }
        set { _looker_group_name = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Name of group in Saml (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     * Looker Roles (read-only)
     */
    public var roles: [Role]?

    private var _url: AnyString?
    /**
     * Link to saml config (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(id: String? = nil, looker_group_id: String? = nil, looker_group_name: String? = nil, name: String? = nil, roles: [Role]? = nil, url: String? = nil) {
        self._id = id.map(AnyString.init)
        self._looker_group_id = looker_group_id.map(AnyString.init)
        self._looker_group_name = looker_group_name.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self.roles = roles
        self._url = url.map(AnyString.init)
    }

}

public struct SamlGroupWrite: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _looker_group_id = "looker_group_id"
        case _looker_group_name = "looker_group_name"
        case _name = "name"
        case _role_ids = "role_ids"
        case _url = "url"
    }
    private var _id: AnyString?
    /**
     * Unique Id
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _looker_group_id: AnyString?
    /**
     * Unique Id of group in Looker (read-only)
     */
    public var looker_group_id: String? {
        get { _looker_group_id?.value }
        set { _looker_group_id = newValue.map(AnyString.init) }
    }

    private var _looker_group_name: AnyString?
    /**
     * Name of group in Looker
     */
    public var looker_group_name: String? {
        get { _looker_group_name?.value }
        set { _looker_group_name = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Name of group in Saml
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _role_ids: [AnyString]?
    /**
     * Looker Role Ids
     */
    public var role_ids: [String]? {
        get { if let v = _role_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _role_ids = v.map { AnyString.init($0) } } else { _role_ids = nil } }
    }

    private var _url: AnyString?
    /**
     * Link to saml config (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(id: String? = nil, looker_group_id: String? = nil, looker_group_name: String? = nil, name: String? = nil, role_ids: [String]? = nil, url: String? = nil) {
        self._id = id.map(AnyString.init)
        self._looker_group_id = looker_group_id.map(AnyString.init)
        self._looker_group_name = looker_group_name.map(AnyString.init)
        self._name = name.map(AnyString.init)
        if let v = role_ids { _role_ids = v.map { AnyString.init($0) } } else { _role_ids = nil }
        self._url = url.map(AnyString.init)
    }

}

public struct SamlMetadataParseResult: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _idp_issuer = "idp_issuer"
        case _idp_url = "idp_url"
        case _idp_cert = "idp_cert"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _idp_issuer: AnyString?
    /**
     * Identify Provider Issuer (read-only)
     */
    public var idp_issuer: String? {
        get { _idp_issuer?.value }
        set { _idp_issuer = newValue.map(AnyString.init) }
    }

    private var _idp_url: AnyString?
    /**
     * Identify Provider Url (read-only)
     */
    public var idp_url: String? {
        get { _idp_url?.value }
        set { _idp_url = newValue.map(AnyString.init) }
    }

    private var _idp_cert: AnyString?
    /**
     * Identify Provider Certificate (read-only)
     */
    public var idp_cert: String? {
        get { _idp_cert?.value }
        set { _idp_cert = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, idp_issuer: String? = nil, idp_url: String? = nil, idp_cert: String? = nil) {
        self.can = can
        self._idp_issuer = idp_issuer.map(AnyString.init)
        self._idp_url = idp_url.map(AnyString.init)
        self._idp_cert = idp_cert.map(AnyString.init)
    }

}

public struct SamlUserAttributeRead: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case required
        case user_attributes
        case _url = "url"
    }
    private var _name: AnyString?
    /**
     * Name of User Attribute in Saml (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     * Required to be in Saml assertion for login to be allowed to succeed (read-only)
     */
    public var required: Bool?

    /**
     * Looker User Attributes (read-only)
     */
    public var user_attributes: [UserAttribute]?

    private var _url: AnyString?
    /**
     * Link to saml config (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, required: Bool? = nil, user_attributes: [UserAttribute]? = nil, url: String? = nil) {
        self._name = name.map(AnyString.init)
        self.required = required
        self.user_attributes = user_attributes
        self._url = url.map(AnyString.init)
    }

}

public struct SamlUserAttributeWrite: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case required
        case _user_attribute_ids = "user_attribute_ids"
        case _url = "url"
    }
    private var _name: AnyString?
    /**
     * Name of User Attribute in Saml
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     * Required to be in Saml assertion for login to be allowed to succeed
     */
    public var required: Bool?

    private var _user_attribute_ids: [AnyString]?
    /**
     * Looker User Attribute Ids
     */
    public var user_attribute_ids: [String]? {
        get { if let v = _user_attribute_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _user_attribute_ids = v.map { AnyString.init($0) } } else { _user_attribute_ids = nil } }
    }

    private var _url: AnyString?
    /**
     * Link to saml config (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, required: Bool? = nil, user_attribute_ids: [String]? = nil, url: String? = nil) {
        self._name = name.map(AnyString.init)
        self.required = required
        if let v = user_attribute_ids { _user_attribute_ids = v.map { AnyString.init($0) } } else { _user_attribute_ids = nil }
        self._url = url.map(AnyString.init)
    }

}

public struct ScheduledPlan: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _user_id = "user_id"
        case run_as_recipient
        case enabled
        case _look_id = "look_id"
        case _dashboard_id = "dashboard_id"
        case _lookml_dashboard_id = "lookml_dashboard_id"
        case _filters_string = "filters_string"
        case _dashboard_filters = "dashboard_filters"
        case require_results
        case require_no_results
        case require_change
        case send_all_results
        case _crontab = "crontab"
        case _datagroup = "datagroup"
        case _timezone = "timezone"
        case scheduled_plan_destination
        case run_once
        case include_links
        case _custom_url_base = "custom_url_base"
        case _custom_url_params = "custom_url_params"
        case _custom_url_label = "custom_url_label"
        case show_custom_url
        case _pdf_paper_size = "pdf_paper_size"
        case pdf_landscape
        case embed
        case _color_theme = "color_theme"
        case long_tables
        case _inline_table_width = "inline_table_width"
        case _query_id = "query_id"
        case _id = "id"
        case created_at
        case updated_at
        case _title = "title"
        case user
        case next_run_at
        case last_run_at
        case can
    }
    private var _name: AnyString?
    /**
     * Name of this scheduled plan
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _user_id: AnyString?
    /**
     * User Id which owns this scheduled plan
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    /**
     * Whether schedule is run as recipient (only applicable for email recipients)
     */
    public var run_as_recipient: Bool?

    /**
     * Whether the ScheduledPlan is enabled
     */
    public var enabled: Bool?

    private var _look_id: AnyString?
    /**
     * Id of a look
     */
    public var look_id: String? {
        get { _look_id?.value }
        set { _look_id = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString?
    /**
     * Id of a dashboard
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    private var _lookml_dashboard_id: AnyString?
    /**
     * Id of a LookML dashboard
     */
    public var lookml_dashboard_id: String? {
        get { _lookml_dashboard_id?.value }
        set { _lookml_dashboard_id = newValue.map(AnyString.init) }
    }

    private var _filters_string: AnyString?
    /**
     * Query string to run look or dashboard with
     */
    public var filters_string: String? {
        get { _filters_string?.value }
        set { _filters_string = newValue.map(AnyString.init) }
    }

    private var _dashboard_filters: AnyString?
    /**
     * (DEPRECATED) Alias for filters_string field
     */
    public var dashboard_filters: String? {
        get { _dashboard_filters?.value }
        set { _dashboard_filters = newValue.map(AnyString.init) }
    }

    /**
     * Delivery should occur if running the dashboard or look returns results
     */
    public var require_results: Bool?

    /**
     * Delivery should occur if the dashboard look does not return results
     */
    public var require_no_results: Bool?

    /**
     * Delivery should occur if data have changed since the last run
     */
    public var require_change: Bool?

    /**
     * Will run an unlimited query and send all results.
     */
    public var send_all_results: Bool?

    private var _crontab: AnyString?
    /**
     * Vixie-Style crontab specification when to run
     */
    public var crontab: String? {
        get { _crontab?.value }
        set { _crontab = newValue.map(AnyString.init) }
    }

    private var _datagroup: AnyString?
    /**
     * Name of a datagroup; if specified will run when datagroup triggered (can't be used with cron string)
     */
    public var datagroup: String? {
        get { _datagroup?.value }
        set { _datagroup = newValue.map(AnyString.init) }
    }

    private var _timezone: AnyString?
    /**
     * Timezone for interpreting the specified crontab (default is Looker instance timezone)
     */
    public var timezone: String? {
        get { _timezone?.value }
        set { _timezone = newValue.map(AnyString.init) }
    }

    /**
     * Scheduled plan destinations
     */
    public var scheduled_plan_destination: [ScheduledPlanDestination]?

    /**
     * Whether the plan in question should only be run once (usually for testing)
     */
    public var run_once: Bool?

    /**
     * Whether links back to Looker should be included in this ScheduledPlan
     */
    public var include_links: Bool?

    private var _custom_url_base: AnyString?
    /**
     * Custom url domain for the scheduled entity
     */
    public var custom_url_base: String? {
        get { _custom_url_base?.value }
        set { _custom_url_base = newValue.map(AnyString.init) }
    }

    private var _custom_url_params: AnyString?
    /**
     * Custom url path and parameters for the scheduled entity
     */
    public var custom_url_params: String? {
        get { _custom_url_params?.value }
        set { _custom_url_params = newValue.map(AnyString.init) }
    }

    private var _custom_url_label: AnyString?
    /**
     * Custom url label for the scheduled entity
     */
    public var custom_url_label: String? {
        get { _custom_url_label?.value }
        set { _custom_url_label = newValue.map(AnyString.init) }
    }

    /**
     * Whether to show custom link back instead of standard looker link
     */
    public var show_custom_url: Bool?

    private var _pdf_paper_size: AnyString?
    /**
     * The size of paper the PDF should be formatted to fit. Valid values are: "letter", "legal", "tabloid", "a0", "a1", "a2", "a3", "a4", "a5".
     */
    public var pdf_paper_size: String? {
        get { _pdf_paper_size?.value }
        set { _pdf_paper_size = newValue.map(AnyString.init) }
    }

    /**
     * Whether the PDF should be formatted for landscape orientation
     */
    public var pdf_landscape: Bool?

    /**
     * Whether this schedule is in an embed context or not
     */
    public var embed: Bool?

    private var _color_theme: AnyString?
    /**
     * Color scheme of the dashboard if applicable
     */
    public var color_theme: String? {
        get { _color_theme?.value }
        set { _color_theme = newValue.map(AnyString.init) }
    }

    /**
     * Whether or not to expand table vis to full length
     */
    public var long_tables: Bool?

    private var _inline_table_width: AnyInt?
    /**
     * The pixel width at which we render the inline table visualizations
     */
    public var inline_table_width: Int64? {
        get { _inline_table_width?.value }
        set { _inline_table_width = newValue.map(AnyInt.init) }
    }

    private var _query_id: AnyString?
    /**
     * Query id
     */
    public var query_id: String? {
        get { _query_id?.value }
        set { _query_id = newValue.map(AnyString.init) }
    }

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    /**
     * Date and time when ScheduledPlan was created (read-only)
     */
    public var created_at: Date?

    /**
     * Date and time when ScheduledPlan was last updated (read-only)
     */
    public var updated_at: Date?

    private var _title: AnyString?
    /**
     * Title (read-only)
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    public var user: UserPublic?

    /**
     * When the ScheduledPlan will next run (null if running once) (read-only)
     */
    public var next_run_at: Date?

    /**
     * When the ScheduledPlan was last run (read-only)
     */
    public var last_run_at: Date?

    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    public init(name: String? = nil, user_id: String? = nil, run_as_recipient: Bool? = nil, enabled: Bool? = nil, look_id: String? = nil, dashboard_id: String? = nil, lookml_dashboard_id: String? = nil, filters_string: String? = nil, dashboard_filters: String? = nil, require_results: Bool? = nil, require_no_results: Bool? = nil, require_change: Bool? = nil, send_all_results: Bool? = nil, crontab: String? = nil, datagroup: String? = nil, timezone: String? = nil, scheduled_plan_destination: [ScheduledPlanDestination]? = nil, run_once: Bool? = nil, include_links: Bool? = nil, custom_url_base: String? = nil, custom_url_params: String? = nil, custom_url_label: String? = nil, show_custom_url: Bool? = nil, pdf_paper_size: String? = nil, pdf_landscape: Bool? = nil, embed: Bool? = nil, color_theme: String? = nil, long_tables: Bool? = nil, inline_table_width: Int64? = nil, query_id: String? = nil, id: String? = nil, created_at: Date? = nil, updated_at: Date? = nil, title: String? = nil, user: UserPublic? = nil, next_run_at: Date? = nil, last_run_at: Date? = nil, can: StringDictionary<Bool>? = nil) {
        self._name = name.map(AnyString.init)
        self._user_id = user_id.map(AnyString.init)
        self.run_as_recipient = run_as_recipient
        self.enabled = enabled
        self._look_id = look_id.map(AnyString.init)
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self._lookml_dashboard_id = lookml_dashboard_id.map(AnyString.init)
        self._filters_string = filters_string.map(AnyString.init)
        self._dashboard_filters = dashboard_filters.map(AnyString.init)
        self.require_results = require_results
        self.require_no_results = require_no_results
        self.require_change = require_change
        self.send_all_results = send_all_results
        self._crontab = crontab.map(AnyString.init)
        self._datagroup = datagroup.map(AnyString.init)
        self._timezone = timezone.map(AnyString.init)
        self.scheduled_plan_destination = scheduled_plan_destination
        self.run_once = run_once
        self.include_links = include_links
        self._custom_url_base = custom_url_base.map(AnyString.init)
        self._custom_url_params = custom_url_params.map(AnyString.init)
        self._custom_url_label = custom_url_label.map(AnyString.init)
        self.show_custom_url = show_custom_url
        self._pdf_paper_size = pdf_paper_size.map(AnyString.init)
        self.pdf_landscape = pdf_landscape
        self.embed = embed
        self._color_theme = color_theme.map(AnyString.init)
        self.long_tables = long_tables
        self._inline_table_width = inline_table_width.map(AnyInt.init)
        self._query_id = query_id.map(AnyString.init)
        self._id = id.map(AnyString.init)
        self.created_at = created_at
        self.updated_at = updated_at
        self._title = title.map(AnyString.init)
        self.user = user
        self.next_run_at = next_run_at
        self.last_run_at = last_run_at
        self.can = can
    }

}

public struct ScheduledPlanDestination: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _scheduled_plan_id = "scheduled_plan_id"
        case _format = "format"
        case apply_formatting
        case apply_vis
        case _address = "address"
        case looker_recipient
        case _type = "type"
        case _parameters = "parameters"
        case _secret_parameters = "secret_parameters"
        case _message = "message"
    }
    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _scheduled_plan_id: AnyString?
    /**
     * Id of a scheduled plan you own
     */
    public var scheduled_plan_id: String? {
        get { _scheduled_plan_id?.value }
        set { _scheduled_plan_id = newValue.map(AnyString.init) }
    }

    private var _format: AnyString?
    /**
     * The data format to send to the given destination. Supported formats vary by destination, but include: "txt", "csv", "inline_json", "json", "json_detail", "xlsx", "html", "wysiwyg_pdf", "assembled_pdf", "wysiwyg_png"
     */
    public var format: String? {
        get { _format?.value }
        set { _format = newValue.map(AnyString.init) }
    }

    /**
     * Are values formatted? (containing currency symbols, digit separators, etc.
     */
    public var apply_formatting: Bool?

    /**
     * Whether visualization options are applied to the results.
     */
    public var apply_vis: Bool?

    private var _address: AnyString?
    /**
     * Address for recipient. For email e.g. 'user@example.com'. For webhooks e.g. 'https://domain/path'. For Amazon S3 e.g. 's3://bucket-name/path/'. For SFTP e.g. 'sftp://host-name/path/'.
     */
    public var address: String? {
        get { _address?.value }
        set { _address = newValue.map(AnyString.init) }
    }

    /**
     * Whether the recipient is a Looker user on the current instance (only applicable for email recipients) (read-only)
     */
    public var looker_recipient: Bool?

    private var _type: AnyString?
    /**
     * Type of the address ('email', 'webhook', 's3', or 'sftp')
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _parameters: AnyString?
    /**
     * JSON object containing parameters for external scheduling. For Amazon S3, this requires keys and values for access_key_id and region. For SFTP, this requires a key and value for username.
     */
    public var parameters: String? {
        get { _parameters?.value }
        set { _parameters = newValue.map(AnyString.init) }
    }

    private var _secret_parameters: AnyString?
    /**
     * (Write-Only) JSON object containing secret parameters for external scheduling. For Amazon S3, this requires a key and value for secret_access_key. For SFTP, this requires a key and value for password.
     */
    public var secret_parameters: String? {
        get { _secret_parameters?.value }
        set { _secret_parameters = newValue.map(AnyString.init) }
    }

    private var _message: AnyString?
    /**
     * Optional message to be included in scheduled emails
     */
    public var message: String? {
        get { _message?.value }
        set { _message = newValue.map(AnyString.init) }
    }

    public init(id: String? = nil, scheduled_plan_id: String? = nil, format: String? = nil, apply_formatting: Bool? = nil, apply_vis: Bool? = nil, address: String? = nil, looker_recipient: Bool? = nil, type: String? = nil, parameters: String? = nil, secret_parameters: String? = nil, message: String? = nil) {
        self._id = id.map(AnyString.init)
        self._scheduled_plan_id = scheduled_plan_id.map(AnyString.init)
        self._format = format.map(AnyString.init)
        self.apply_formatting = apply_formatting
        self.apply_vis = apply_vis
        self._address = address.map(AnyString.init)
        self.looker_recipient = looker_recipient
        self._type = type.map(AnyString.init)
        self._parameters = parameters.map(AnyString.init)
        self._secret_parameters = secret_parameters.map(AnyString.init)
        self._message = message.map(AnyString.init)
    }

}

public struct Schema: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case is_default
    }
    private var _name: AnyString?
    /**
     * Schema name (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     * True if this is the default schema (read-only)
     */
    public var is_default: Bool?

    public init(name: String? = nil, is_default: Bool? = nil) {
        self._name = name.map(AnyString.init)
        self.is_default = is_default
    }

}

public struct SchemaColumn: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _sql_escaped_name = "sql_escaped_name"
        case _schema_name = "schema_name"
        case _data_type_database = "data_type_database"
        case _data_type = "data_type"
        case _data_type_looker = "data_type_looker"
        case _description = "description"
        case _column_size = "column_size"
        case snippets
    }
    private var _name: AnyString?
    /**
     * Schema item name (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _sql_escaped_name: AnyString?
    /**
     * Full name of item (read-only)
     */
    public var sql_escaped_name: String? {
        get { _sql_escaped_name?.value }
        set { _sql_escaped_name = newValue.map(AnyString.init) }
    }

    private var _schema_name: AnyString?
    /**
     * Name of schema (read-only)
     */
    public var schema_name: String? {
        get { _schema_name?.value }
        set { _schema_name = newValue.map(AnyString.init) }
    }

    private var _data_type_database: AnyString?
    /**
     * SQL dialect data type (read-only)
     */
    public var data_type_database: String? {
        get { _data_type_database?.value }
        set { _data_type_database = newValue.map(AnyString.init) }
    }

    private var _data_type: AnyString?
    /**
     * Data type (read-only)
     */
    public var data_type: String? {
        get { _data_type?.value }
        set { _data_type = newValue.map(AnyString.init) }
    }

    private var _data_type_looker: AnyString?
    /**
     * Looker data type (read-only)
     */
    public var data_type_looker: String? {
        get { _data_type_looker?.value }
        set { _data_type_looker = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * SQL data type (read-only)
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    private var _column_size: AnyInt?
    /**
     * Column data size (read-only)
     */
    public var column_size: Int64? {
        get { _column_size?.value }
        set { _column_size = newValue.map(AnyInt.init) }
    }

    /**
     * SQL Runner snippets for this connection (read-only)
     */
    public var snippets: [Snippet]?

    public init(name: String? = nil, sql_escaped_name: String? = nil, schema_name: String? = nil, data_type_database: String? = nil, data_type: String? = nil, data_type_looker: String? = nil, description: String? = nil, column_size: Int64? = nil, snippets: [Snippet]? = nil) {
        self._name = name.map(AnyString.init)
        self._sql_escaped_name = sql_escaped_name.map(AnyString.init)
        self._schema_name = schema_name.map(AnyString.init)
        self._data_type_database = data_type_database.map(AnyString.init)
        self._data_type = data_type.map(AnyString.init)
        self._data_type_looker = data_type_looker.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self._column_size = column_size.map(AnyInt.init)
        self.snippets = snippets
    }

}

public struct SchemaColumns: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _sql_escaped_name = "sql_escaped_name"
        case _schema_name = "schema_name"
        case columns
    }
    private var _name: AnyString?
    /**
     * Schema item name (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _sql_escaped_name: AnyString?
    /**
     * Full name of item (read-only)
     */
    public var sql_escaped_name: String? {
        get { _sql_escaped_name?.value }
        set { _sql_escaped_name = newValue.map(AnyString.init) }
    }

    private var _schema_name: AnyString?
    /**
     * Name of schema (read-only)
     */
    public var schema_name: String? {
        get { _schema_name?.value }
        set { _schema_name = newValue.map(AnyString.init) }
    }

    /**
     * Columns for this schema (read-only)
     */
    public var columns: [SchemaColumn]?

    public init(name: String? = nil, sql_escaped_name: String? = nil, schema_name: String? = nil, columns: [SchemaColumn]? = nil) {
        self._name = name.map(AnyString.init)
        self._sql_escaped_name = sql_escaped_name.map(AnyString.init)
        self._schema_name = schema_name.map(AnyString.init)
        self.columns = columns
    }

}

public struct SchemaTable: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _sql_escaped_name = "sql_escaped_name"
        case _schema_name = "schema_name"
        case _rows = "rows"
        case _external = "external"
        case snippets
    }
    private var _name: AnyString?
    /**
     * Schema item name (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _sql_escaped_name: AnyString?
    /**
     * Full name of item (read-only)
     */
    public var sql_escaped_name: String? {
        get { _sql_escaped_name?.value }
        set { _sql_escaped_name = newValue.map(AnyString.init) }
    }

    private var _schema_name: AnyString?
    /**
     * Name of schema (read-only)
     */
    public var schema_name: String? {
        get { _schema_name?.value }
        set { _schema_name = newValue.map(AnyString.init) }
    }

    private var _rows: AnyInt?
    /**
     * Number of data rows (read-only)
     */
    public var rows: Int64? {
        get { _rows?.value }
        set { _rows = newValue.map(AnyInt.init) }
    }

    private var _external: AnyString?
    /**
     * External reference??? (read-only)
     */
    public var external: String? {
        get { _external?.value }
        set { _external = newValue.map(AnyString.init) }
    }

    /**
     * SQL Runner snippets for connection (read-only)
     */
    public var snippets: [Snippet]?

    public init(name: String? = nil, sql_escaped_name: String? = nil, schema_name: String? = nil, rows: Int64? = nil, external: String? = nil, snippets: [Snippet]? = nil) {
        self._name = name.map(AnyString.init)
        self._sql_escaped_name = sql_escaped_name.map(AnyString.init)
        self._schema_name = schema_name.map(AnyString.init)
        self._rows = rows.map(AnyInt.init)
        self._external = external.map(AnyString.init)
        self.snippets = snippets
    }

}

public struct SchemaTables: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case is_default
        case tables
        case table_limit_hit
    }
    private var _name: AnyString?
    /**
     * Schema name (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     * True if this is the default schema (read-only)
     */
    public var is_default: Bool?

    /**
     * Tables for this schema (read-only)
     */
    public var tables: [SchemaTable]?

    /**
     * True if the table limit was hit while retrieving tables in this schema (read-only)
     */
    public var table_limit_hit: Bool?

    public init(name: String? = nil, is_default: Bool? = nil, tables: [SchemaTable]? = nil, table_limit_hit: Bool? = nil) {
        self._name = name.map(AnyString.init)
        self.is_default = is_default
        self.tables = tables
        self.table_limit_hit = table_limit_hit
    }

}

/**
 * Field to distinguish between SSO secrets and JWT secrets Valid values are: "SSO", "JWT". (Enum defined in EmbedSecret)
 */
public enum SecretType: String, Codable {
    case SSO = "SSO"
    case JWT = "JWT"
}

public struct Session: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _ip_address = "ip_address"
        case _browser = "browser"
        case _operating_system = "operating_system"
        case _city = "city"
        case _state = "state"
        case _country = "country"
        case _credentials_type = "credentials_type"
        case _extended_at = "extended_at"
        case _extended_count = "extended_count"
        case _sudo_user_id = "sudo_user_id"
        case _created_at = "created_at"
        case _expires_at = "expires_at"
        case _url = "url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _ip_address: AnyString?
    /**
     * IP address of user when this session was initiated (read-only)
     */
    public var ip_address: String? {
        get { _ip_address?.value }
        set { _ip_address = newValue.map(AnyString.init) }
    }

    private var _browser: AnyString?
    /**
     * User's browser type (read-only)
     */
    public var browser: String? {
        get { _browser?.value }
        set { _browser = newValue.map(AnyString.init) }
    }

    private var _operating_system: AnyString?
    /**
     * User's Operating System (read-only)
     */
    public var operating_system: String? {
        get { _operating_system?.value }
        set { _operating_system = newValue.map(AnyString.init) }
    }

    private var _city: AnyString?
    /**
     * City component of user location (derived from IP address) (read-only)
     */
    public var city: String? {
        get { _city?.value }
        set { _city = newValue.map(AnyString.init) }
    }

    private var _state: AnyString?
    /**
     * State component of user location (derived from IP address) (read-only)
     */
    public var state: String? {
        get { _state?.value }
        set { _state = newValue.map(AnyString.init) }
    }

    private var _country: AnyString?
    /**
     * Country component of user location (derived from IP address) (read-only)
     */
    public var country: String? {
        get { _country?.value }
        set { _country = newValue.map(AnyString.init) }
    }

    private var _credentials_type: AnyString?
    /**
     * Type of credentials used for logging in this session (read-only)
     */
    public var credentials_type: String? {
        get { _credentials_type?.value }
        set { _credentials_type = newValue.map(AnyString.init) }
    }

    private var _extended_at: AnyString?
    /**
     * Time when this session was last extended by the user (read-only)
     */
    public var extended_at: String? {
        get { _extended_at?.value }
        set { _extended_at = newValue.map(AnyString.init) }
    }

    private var _extended_count: AnyInt?
    /**
     * Number of times this session was extended (read-only)
     */
    public var extended_count: Int64? {
        get { _extended_count?.value }
        set { _extended_count = newValue.map(AnyInt.init) }
    }

    private var _sudo_user_id: AnyString?
    /**
     * Actual user in the case when this session represents one user sudo'ing as another (read-only)
     */
    public var sudo_user_id: String? {
        get { _sudo_user_id?.value }
        set { _sudo_user_id = newValue.map(AnyString.init) }
    }

    private var _created_at: AnyString?
    /**
     * Time when this session was initiated (read-only)
     */
    public var created_at: String? {
        get { _created_at?.value }
        set { _created_at = newValue.map(AnyString.init) }
    }

    private var _expires_at: AnyString?
    /**
     * Time when this session will expire (read-only)
     */
    public var expires_at: String? {
        get { _expires_at?.value }
        set { _expires_at = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, ip_address: String? = nil, browser: String? = nil, operating_system: String? = nil, city: String? = nil, state: String? = nil, country: String? = nil, credentials_type: String? = nil, extended_at: String? = nil, extended_count: Int64? = nil, sudo_user_id: String? = nil, created_at: String? = nil, expires_at: String? = nil, url: String? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._ip_address = ip_address.map(AnyString.init)
        self._browser = browser.map(AnyString.init)
        self._operating_system = operating_system.map(AnyString.init)
        self._city = city.map(AnyString.init)
        self._state = state.map(AnyString.init)
        self._country = country.map(AnyString.init)
        self._credentials_type = credentials_type.map(AnyString.init)
        self._extended_at = extended_at.map(AnyString.init)
        self._extended_count = extended_count.map(AnyInt.init)
        self._sudo_user_id = sudo_user_id.map(AnyString.init)
        self._created_at = created_at.map(AnyString.init)
        self._expires_at = expires_at.map(AnyString.init)
        self._url = url.map(AnyString.init)
    }

}

public struct SessionConfig: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case allow_persistent_sessions
        case _session_minutes = "session_minutes"
        case unlimited_sessions_per_user
        case use_inactivity_based_logout
        case track_session_location
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    /**
     * Allow users to have persistent sessions when they login
     */
    public var allow_persistent_sessions: Bool?

    private var _session_minutes: AnyInt?
    /**
     * Number of minutes for user sessions.  Must be between 5 and 43200
     */
    public var session_minutes: Int64? {
        get { _session_minutes?.value }
        set { _session_minutes = newValue.map(AnyInt.init) }
    }

    /**
     * Allow users to have an unbounded number of concurrent sessions (otherwise, users will be limited to only one session at a time).
     */
    public var unlimited_sessions_per_user: Bool?

    /**
     * Enforce session logout for sessions that are inactive for 15 minutes.
     */
    public var use_inactivity_based_logout: Bool?

    /**
     * Track location of session when user logs in.
     */
    public var track_session_location: Bool?

    public init(can: StringDictionary<Bool>? = nil, allow_persistent_sessions: Bool? = nil, session_minutes: Int64? = nil, unlimited_sessions_per_user: Bool? = nil, use_inactivity_based_logout: Bool? = nil, track_session_location: Bool? = nil) {
        self.can = can
        self.allow_persistent_sessions = allow_persistent_sessions
        self._session_minutes = session_minutes.map(AnyInt.init)
        self.unlimited_sessions_per_user = unlimited_sessions_per_user
        self.use_inactivity_based_logout = use_inactivity_based_logout
        self.track_session_location = track_session_location
    }

}

public struct Setting: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case instance_config
        case extension_framework_enabled
        case extension_load_url_enabled
        case marketplace_auto_install_enabled
        case marketplace_automation
        case marketplace_enabled
        case _marketplace_site = "marketplace_site"
        case marketplace_terms_accepted
        case privatelabel_configuration
        case custom_welcome_email
        case onboarding_enabled
        case _timezone = "timezone"
        case allow_user_timezones
        case data_connector_default_enabled
        case _host_url = "host_url"
        case override_warnings
        case _email_domain_allowlist = "email_domain_allowlist"
        case embed_cookieless_v2
        case embed_enabled
        case embed_config
        case login_notification_enabled
        case _login_notification_text = "login_notification_text"
        case dashboard_auto_refresh_restriction
        case _dashboard_auto_refresh_minimum_interval = "dashboard_auto_refresh_minimum_interval"
        case _managed_certificate_uri = "managed_certificate_uri"
    }
    public var instance_config: InstanceConfig?

    /**
     * Toggle extension framework on or off
     */
    public var extension_framework_enabled: Bool?

    /**
     * (DEPRECATED) Toggle extension load url on or off. Do not use. This is temporary setting that will eventually become a noop and subsequently deleted.
     */
    public var extension_load_url_enabled: Bool?

    /**
     * (DEPRECATED) Toggle marketplace auto install on or off. Deprecated - do not use. Auto install can now be enabled via marketplace automation settings
     */
    public var marketplace_auto_install_enabled: Bool?

    public var marketplace_automation: MarketplaceAutomation?

    /**
     * Toggle marketplace on or off
     */
    public var marketplace_enabled: Bool?

    private var _marketplace_site: AnyString?
    /**
     * Location of Looker marketplace CDN (read-only)
     */
    public var marketplace_site: String? {
        get { _marketplace_site?.value }
        set { _marketplace_site = newValue.map(AnyString.init) }
    }

    /**
     * Accept marketplace terms by setting this value to true, or get the current status. Marketplace terms CANNOT be declined once accepted. Accepting marketplace terms automatically enables the marketplace. The marketplace can still be disabled after it has been enabled.
     */
    public var marketplace_terms_accepted: Bool?

    public var privatelabel_configuration: PrivatelabelConfiguration?

    public var custom_welcome_email: CustomWelcomeEmail?

    /**
     * Toggle onboarding on or off
     */
    public var onboarding_enabled: Bool?

    private var _timezone: AnyString?
    /**
     * Change instance-wide default timezone
     */
    public var timezone: String? {
        get { _timezone?.value }
        set { _timezone = newValue.map(AnyString.init) }
    }

    /**
     * Toggle user-specific timezones on or off
     */
    public var allow_user_timezones: Bool?

    /**
     * Toggle default future connectors on or off
     */
    public var data_connector_default_enabled: Bool?

    private var _host_url: AnyString?
    /**
     * Change the base portion of your Looker instance URL setting
     */
    public var host_url: String? {
        get { _host_url?.value }
        set { _host_url = newValue.map(AnyString.init) }
    }

    /**
     * (Write-Only) If warnings are preventing a host URL change, this parameter allows for overriding warnings to force update the setting. Does not directly change any Looker settings.
     */
    public var override_warnings: Bool?

    private var _email_domain_allowlist: [AnyString]?
    /**
     * An array of Email Domain Allowlist of type string for Scheduled Content
     */
    public var email_domain_allowlist: [String]? {
        get { if let v = _email_domain_allowlist { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _email_domain_allowlist = v.map { AnyString.init($0) } } else { _email_domain_allowlist = nil } }
    }

    /**
     * (DEPRECATED) Use embed_config.embed_cookieless_v2 instead. If embed_config.embed_cookieless_v2 is specified, it overrides this value.
     */
    public var embed_cookieless_v2: Bool?

    /**
     * True if embedding is enabled https://cloud.google.com/looker/docs/r/looker-core-feature-embed, false otherwise (read-only)
     */
    public var embed_enabled: Bool?

    public var embed_config: EmbedConfig?

    /**
     * Login notification enabled (read-only)
     */
    public var login_notification_enabled: Bool?

    private var _login_notification_text: AnyString?
    /**
     * Login notification text (read-only)
     */
    public var login_notification_text: String? {
        get { _login_notification_text?.value }
        set { _login_notification_text = newValue.map(AnyString.init) }
    }

    /**
     * Toggle Dashboard Auto Refresh restriction
     */
    public var dashboard_auto_refresh_restriction: Bool?

    private var _dashboard_auto_refresh_minimum_interval: AnyString?
    /**
     * Minimum time interval for dashboard element automatic refresh. Examples: (30 seconds, 1 minute)
     */
    public var dashboard_auto_refresh_minimum_interval: String? {
        get { _dashboard_auto_refresh_minimum_interval?.value }
        set { _dashboard_auto_refresh_minimum_interval = newValue.map(AnyString.init) }
    }

    private var _managed_certificate_uri: [AnyString]?
    /**
     * Array of URIs pointing to the location of a root certificate in Secret Manager
     */
    public var managed_certificate_uri: [String]? {
        get { if let v = _managed_certificate_uri { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _managed_certificate_uri = v.map { AnyString.init($0) } } else { _managed_certificate_uri = nil } }
    }

    public init(instance_config: InstanceConfig? = nil, extension_framework_enabled: Bool? = nil, extension_load_url_enabled: Bool? = nil, marketplace_auto_install_enabled: Bool? = nil, marketplace_automation: MarketplaceAutomation? = nil, marketplace_enabled: Bool? = nil, marketplace_site: String? = nil, marketplace_terms_accepted: Bool? = nil, privatelabel_configuration: PrivatelabelConfiguration? = nil, custom_welcome_email: CustomWelcomeEmail? = nil, onboarding_enabled: Bool? = nil, timezone: String? = nil, allow_user_timezones: Bool? = nil, data_connector_default_enabled: Bool? = nil, host_url: String? = nil, override_warnings: Bool? = nil, email_domain_allowlist: [String]? = nil, embed_cookieless_v2: Bool? = nil, embed_enabled: Bool? = nil, embed_config: EmbedConfig? = nil, login_notification_enabled: Bool? = nil, login_notification_text: String? = nil, dashboard_auto_refresh_restriction: Bool? = nil, dashboard_auto_refresh_minimum_interval: String? = nil, managed_certificate_uri: [String]? = nil) {
        self.instance_config = instance_config
        self.extension_framework_enabled = extension_framework_enabled
        self.extension_load_url_enabled = extension_load_url_enabled
        self.marketplace_auto_install_enabled = marketplace_auto_install_enabled
        self.marketplace_automation = marketplace_automation
        self.marketplace_enabled = marketplace_enabled
        self._marketplace_site = marketplace_site.map(AnyString.init)
        self.marketplace_terms_accepted = marketplace_terms_accepted
        self.privatelabel_configuration = privatelabel_configuration
        self.custom_welcome_email = custom_welcome_email
        self.onboarding_enabled = onboarding_enabled
        self._timezone = timezone.map(AnyString.init)
        self.allow_user_timezones = allow_user_timezones
        self.data_connector_default_enabled = data_connector_default_enabled
        self._host_url = host_url.map(AnyString.init)
        self.override_warnings = override_warnings
        if let v = email_domain_allowlist { _email_domain_allowlist = v.map { AnyString.init($0) } } else { _email_domain_allowlist = nil }
        self.embed_cookieless_v2 = embed_cookieless_v2
        self.embed_enabled = embed_enabled
        self.embed_config = embed_config
        self.login_notification_enabled = login_notification_enabled
        self._login_notification_text = login_notification_text.map(AnyString.init)
        self.dashboard_auto_refresh_restriction = dashboard_auto_refresh_restriction
        self._dashboard_auto_refresh_minimum_interval = dashboard_auto_refresh_minimum_interval.map(AnyString.init)
        if let v = managed_certificate_uri { _managed_certificate_uri = v.map { AnyString.init($0) } } else { _managed_certificate_uri = nil }
    }

}

public struct SmtpNodeStatus: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case is_valid
        case _message = "message"
        case _hostname = "hostname"
    }
    /**
     * SMTP status of node (read-only)
     */
    public var is_valid: Bool?

    private var _message: AnyString?
    /**
     * Error message for node (read-only)
     */
    public var message: String? {
        get { _message?.value }
        set { _message = newValue.map(AnyString.init) }
    }

    private var _hostname: AnyString?
    /**
     * Host name of node (read-only)
     */
    public var hostname: String? {
        get { _hostname?.value }
        set { _hostname = newValue.map(AnyString.init) }
    }

    public init(is_valid: Bool? = nil, message: String? = nil, hostname: String? = nil) {
        self.is_valid = is_valid
        self._message = message.map(AnyString.init)
        self._hostname = hostname.map(AnyString.init)
    }

}

public struct SmtpSettings: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _address = "address"
        case _from = "from"
        case _user_name = "user_name"
        case _password = "password"
        case _port = "port"
        case enable_starttls_auto
        case ssl_version
        case default_smtp
    }
    private var _address: AnyString?
    /**
     * SMTP Server url
     */
    public var address: String? {
        get { _address?.value }
        set { _address = newValue.map(AnyString.init) }
    }

    private var _from: AnyString?
    /**
     * From e-mail address
     */
    public var from: String? {
        get { _from?.value }
        set { _from = newValue.map(AnyString.init) }
    }

    private var _user_name: AnyString?
    /**
     * User name
     */
    public var user_name: String? {
        get { _user_name?.value }
        set { _user_name = newValue.map(AnyString.init) }
    }

    private var _password: AnyString?
    /**
     * Password
     */
    public var password: String? {
        get { _password?.value }
        set { _password = newValue.map(AnyString.init) }
    }

    private var _port: AnyInt?
    /**
     * SMTP Server's port
     */
    public var port: Int64? {
        get { _port?.value }
        set { _port = newValue.map(AnyInt.init) }
    }

    /**
     * Is TLS encryption enabled?
     */
    public var enable_starttls_auto: Bool?

    /**
     * TLS version selected Valid values are: "TLSv1_1", "SSLv23", "TLSv1_2".
     */
    public var ssl_version: SslVersion?

    /**
     * Whether to enable built-in Looker SMTP
     */
    public var default_smtp: Bool?

    public init(address: String? = nil, from: String? = nil, user_name: String? = nil, password: String? = nil, port: Int64? = nil, enable_starttls_auto: Bool? = nil, ssl_version: SslVersion? = nil, default_smtp: Bool? = nil) {
        self._address = address.map(AnyString.init)
        self._from = from.map(AnyString.init)
        self._user_name = user_name.map(AnyString.init)
        self._password = password.map(AnyString.init)
        self._port = port.map(AnyInt.init)
        self.enable_starttls_auto = enable_starttls_auto
        self.ssl_version = ssl_version
        self.default_smtp = default_smtp
    }

}

public struct SmtpStatus: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case is_valid
        case _node_count = "node_count"
        case node_status
    }
    /**
     * Overall SMTP status of cluster (read-only)
     */
    public var is_valid: Bool?

    private var _node_count: AnyInt?
    /**
     * Total number of nodes in cluster (read-only)
     */
    public var node_count: Int64? {
        get { _node_count?.value }
        set { _node_count = newValue.map(AnyInt.init) }
    }

    /**
     * array of each node's status containing is_valid, message, hostname (read-only)
     */
    public var node_status: [SmtpNodeStatus]?

    public init(is_valid: Bool? = nil, node_count: Int64? = nil, node_status: [SmtpNodeStatus]? = nil) {
        self.is_valid = is_valid
        self._node_count = node_count.map(AnyInt.init)
        self.node_status = node_status
    }

}

public struct Snippet: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _label = "label"
        case _sql = "sql"
    }
    private var _name: AnyString?
    /**
     * Name of the snippet (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _label: AnyString?
    /**
     * Label of the snippet (read-only)
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    private var _sql: AnyString?
    /**
     * SQL text of the snippet (read-only)
     */
    public var sql: String? {
        get { _sql?.value }
        set { _sql = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, label: String? = nil, sql: String? = nil) {
        self._name = name.map(AnyString.init)
        self._label = label.map(AnyString.init)
        self._sql = sql.map(AnyString.init)
    }

}

public struct SqlInterfaceQuery: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _signature = "signature"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyInt?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64? {
        get { _id?.value }
        set { _id = newValue.map(AnyInt.init) }
    }

    private var _signature: AnyString
    /**
     * Calcite signature (read-only)
     */
    public var signature: String {
        get { _signature.value }
        set { _signature = AnyString.init(newValue) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: Int64? = nil, signature: String) {
        self.can = can
        self._id = id.map(AnyInt.init)
        self._signature = AnyString.init(signature)
    }

    public init(can: StringDictionary<Bool>? = nil, id: Int64? = nil, _ signature: String) {
        self.init(can: can, id: id, signature: signature)
    }

}

public struct SqlInterfaceQueryCreate: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _sql = "sql"
        case jdbc_client
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _sql: AnyString
    /**
     * Original SQL request
     */
    public var sql: String {
        get { _sql.value }
        set { _sql = AnyString.init(newValue) }
    }

    /**
     * Whether the query should be run for use in a JDBC Client. This changes the formatting of some datetime based values.
     */
    public var jdbc_client: Bool?

    public init(can: StringDictionary<Bool>? = nil, sql: String, jdbc_client: Bool? = nil) {
        self.can = can
        self._sql = AnyString.init(sql)
        self.jdbc_client = jdbc_client
    }

    public init(can: StringDictionary<Bool>? = nil, _ sql: String, jdbc_client: Bool? = nil) {
        self.init(can: can, sql: sql, jdbc_client: jdbc_client)
    }

}

public struct SqlInterfaceQueryMetadata: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _results = "results"
    }
    private var _results: AnyString?
    /**
     * JDBC Metadata to inflate Avatica response classes. (read-only)
     */
    public var results: String? {
        get { _results?.value }
        set { _results = newValue.map(AnyString.init) }
    }

    public init(results: String? = nil) {
        self._results = results.map(AnyString.init)
    }

}

public struct SqlQuery: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _slug = "slug"
        case last_runtime
        case _run_count = "run_count"
        case _browser_limit = "browser_limit"
        case _sql = "sql"
        case _last_run_at = "last_run_at"
        case connection
        case _model_name = "model_name"
        case creator
        case _explore_url = "explore_url"
        case plaintext
        case vis_config
        case _result_maker_id = "result_maker_id"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _slug: AnyString?
    /**
     * The identifier of the SQL query (read-only)
     */
    public var slug: String? {
        get { _slug?.value }
        set { _slug = newValue.map(AnyString.init) }
    }

    /**
     * Number of seconds this query took to run the most recent time it was run (read-only)
     */
    public var last_runtime: Float?

    private var _run_count: AnyInt?
    /**
     * Number of times this query has been run (read-only)
     */
    public var run_count: Int64? {
        get { _run_count?.value }
        set { _run_count = newValue.map(AnyInt.init) }
    }

    private var _browser_limit: AnyInt?
    /**
     * Maximum number of rows this query will display on the SQL Runner page (read-only)
     */
    public var browser_limit: Int64? {
        get { _browser_limit?.value }
        set { _browser_limit = newValue.map(AnyInt.init) }
    }

    private var _sql: AnyString?
    /**
     * SQL query text (read-only)
     */
    public var sql: String? {
        get { _sql?.value }
        set { _sql = newValue.map(AnyString.init) }
    }

    private var _last_run_at: AnyString?
    /**
     * The most recent time this query was run (read-only)
     */
    public var last_run_at: String? {
        get { _last_run_at?.value }
        set { _last_run_at = newValue.map(AnyString.init) }
    }

    public var connection: DBConnectionBase?

    private var _model_name: AnyString?
    /**
     * Model name this query uses (read-only)
     */
    public var model_name: String? {
        get { _model_name?.value }
        set { _model_name = newValue.map(AnyString.init) }
    }

    public var creator: UserPublic?

    private var _explore_url: AnyString?
    /**
     * Explore page URL for this SQL query (read-only)
     */
    public var explore_url: String? {
        get { _explore_url?.value }
        set { _explore_url = newValue.map(AnyString.init) }
    }

    /**
     * Should this query be rendered as plain text (read-only)
     */
    public var plaintext: Bool?

    /**
     * Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
     */
    public var vis_config: StringDictionary<AnyCodable>?

    private var _result_maker_id: AnyString?
    /**
     * ID of the ResultMakerLookup entry.
     */
    public var result_maker_id: String? {
        get { _result_maker_id?.value }
        set { _result_maker_id = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, slug: String? = nil, last_runtime: Float? = nil, run_count: Int64? = nil, browser_limit: Int64? = nil, sql: String? = nil, last_run_at: String? = nil, connection: DBConnectionBase? = nil, model_name: String? = nil, creator: UserPublic? = nil, explore_url: String? = nil, plaintext: Bool? = nil, vis_config: StringDictionary<AnyCodable>? = nil, result_maker_id: String? = nil) {
        self.can = can
        self._slug = slug.map(AnyString.init)
        self.last_runtime = last_runtime
        self._run_count = run_count.map(AnyInt.init)
        self._browser_limit = browser_limit.map(AnyInt.init)
        self._sql = sql.map(AnyString.init)
        self._last_run_at = last_run_at.map(AnyString.init)
        self.connection = connection
        self._model_name = model_name.map(AnyString.init)
        self.creator = creator
        self._explore_url = explore_url.map(AnyString.init)
        self.plaintext = plaintext
        self.vis_config = vis_config
        self._result_maker_id = result_maker_id.map(AnyString.init)
    }

}

public struct SqlQueryCreate: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _connection_name = "connection_name"
        case _connection_id = "connection_id"
        case _model_name = "model_name"
        case _sql = "sql"
        case vis_config
    }
    private var _connection_name: AnyString?
    /**
     * Name of the db connection on which to run this query
     */
    public var connection_name: String? {
        get { _connection_name?.value }
        set { _connection_name = newValue.map(AnyString.init) }
    }

    private var _connection_id: AnyString?
    /**
     * (DEPRECATED) Use `connection_name` instead
     */
    public var connection_id: String? {
        get { _connection_id?.value }
        set { _connection_id = newValue.map(AnyString.init) }
    }

    private var _model_name: AnyString?
    /**
     * Name of LookML Model (this or `connection_id` required)
     */
    public var model_name: String? {
        get { _model_name?.value }
        set { _model_name = newValue.map(AnyString.init) }
    }

    private var _sql: AnyString?
    /**
     * SQL query
     */
    public var sql: String? {
        get { _sql?.value }
        set { _sql = newValue.map(AnyString.init) }
    }

    /**
     * Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
     */
    public var vis_config: StringDictionary<AnyCodable>?

    public init(connection_name: String? = nil, connection_id: String? = nil, model_name: String? = nil, sql: String? = nil, vis_config: StringDictionary<AnyCodable>? = nil) {
        self._connection_name = connection_name.map(AnyString.init)
        self._connection_id = connection_id.map(AnyString.init)
        self._model_name = model_name.map(AnyString.init)
        self._sql = sql.map(AnyString.init)
        self.vis_config = vis_config
    }

}

public struct SqlValidatorError: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _type = "type"
        case _title = "title"
        case _detail = "detail"
        case _status = "status"
        case _instance = "instance"
        case _model = "model"
        case _explore = "explore"
        case _message = "message"
        case _explore_url = "explore_url"
        case _lookml_url = "lookml_url"
        case _dimension = "dimension"
        case _line_number = "line_number"
    }
    private var _type: AnyString?
    /**
     * A URI reference that identifies the problem type (read-only)
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Overview of the error (read-only)
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _detail: AnyString?
    /**
     * Detail of the error (read-only)
     */
    public var detail: String? {
        get { _detail?.value }
        set { _detail = newValue.map(AnyString.init) }
    }

    private var _status: AnyString?
    /**
     * The HTTP status code for the problem (read-only)
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    private var _instance: AnyString?
    /**
     * URI reference that identifies the specific occurrence of the problem (read-only)
     */
    public var instance: String? {
        get { _instance?.value }
        set { _instance = newValue.map(AnyString.init) }
    }

    private var _model: AnyString?
    /**
     * LookML model that contains the Explore that failed SQL validation (read-only)
     */
    public var model: String? {
        get { _model?.value }
        set { _model = newValue.map(AnyString.init) }
    }

    private var _explore: AnyString?
    /**
     * LookML Explore that failed SQL validation (read-only)
     */
    public var explore: String? {
        get { _explore?.value }
        set { _explore = newValue.map(AnyString.init) }
    }

    private var _message: AnyString?
    /**
     * Message returned by the SQL validation (read-only)
     */
    public var message: String? {
        get { _message?.value }
        set { _message = newValue.map(AnyString.init) }
    }

    private var _explore_url: AnyString?
    /**
     * URL to the Explore (read-only)
     */
    public var explore_url: String? {
        get { _explore_url?.value }
        set { _explore_url = newValue.map(AnyString.init) }
    }

    private var _lookml_url: AnyString?
    /**
     * URL to the LookML that caused the error (read-only)
     */
    public var lookml_url: String? {
        get { _lookml_url?.value }
        set { _lookml_url = newValue.map(AnyString.init) }
    }

    private var _dimension: AnyString?
    /**
     * LookML dimension that caused the error (read-only)
     */
    public var dimension: String? {
        get { _dimension?.value }
        set { _dimension = newValue.map(AnyString.init) }
    }

    private var _line_number: AnyString?
    /**
     * Line of the error in the LookML file (read-only)
     */
    public var line_number: String? {
        get { _line_number?.value }
        set { _line_number = newValue.map(AnyString.init) }
    }

    public init(type: String? = nil, title: String? = nil, detail: String? = nil, status: String? = nil, instance: String? = nil, model: String? = nil, explore: String? = nil, message: String? = nil, explore_url: String? = nil, lookml_url: String? = nil, dimension: String? = nil, line_number: String? = nil) {
        self._type = type.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self._detail = detail.map(AnyString.init)
        self._status = status.map(AnyString.init)
        self._instance = instance.map(AnyString.init)
        self._model = model.map(AnyString.init)
        self._explore = explore.map(AnyString.init)
        self._message = message.map(AnyString.init)
        self._explore_url = explore_url.map(AnyString.init)
        self._lookml_url = lookml_url.map(AnyString.init)
        self._dimension = dimension.map(AnyString.init)
        self._line_number = line_number.map(AnyString.init)
    }

}

public struct SqlValidatorErrorItem: SDKModel {
    public var sql_error: SqlValidatorError?

    public var generic_error: GenericError?

    public init(sql_error: SqlValidatorError? = nil, generic_error: GenericError? = nil) {
        self.sql_error = sql_error
        self.generic_error = generic_error
    }

}

public struct SqlValidatorResult: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case incremental
        case _status = "status"
        case result
    }
    private var _name: AnyString?
    /**
     * Name of the validator (sql) (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     * Whether the validation was incremental (read-only)
     */
    public var incremental: Bool?

    private var _status: AnyString?
    /**
     * Status of the validation (unknown, failed, passed, skipped, errored, cancelled, queued, running) (read-only)
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    /**
     * The results of tested Explores (read-only)
     */
    public var result: [SqlValidatorTestedExplore]?

    public init(name: String? = nil, incremental: Bool? = nil, status: String? = nil, result: [SqlValidatorTestedExplore]? = nil) {
        self._name = name.map(AnyString.init)
        self.incremental = incremental
        self._status = status.map(AnyString.init)
        self.result = result
    }

}

public struct SqlValidatorTestedExplore: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _model = "model"
        case _explore = "explore"
        case _status = "status"
        case _skip_reason = "skip_reason"
        case _error_count = "error_count"
        case errors
    }
    private var _model: AnyString?
    /**
     * LookML model that was tested (read-only)
     */
    public var model: String? {
        get { _model?.value }
        set { _model = newValue.map(AnyString.init) }
    }

    private var _explore: AnyString?
    /**
     * LookML Explore that was tested (read-only)
     */
    public var explore: String? {
        get { _explore?.value }
        set { _explore = newValue.map(AnyString.init) }
    }

    private var _status: AnyString?
    /**
     * Status of the validation (unknown, failed, passed, skipped, errored, cancelled, queued, running) (read-only)
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    private var _skip_reason: AnyString?
    /**
     * Reason the validation was skipped (read-only)
     */
    public var skip_reason: String? {
        get { _skip_reason?.value }
        set { _skip_reason = newValue.map(AnyString.init) }
    }

    private var _error_count: AnyInt?
    /**
     * Total number of failed validations (read-only)
     */
    public var error_count: Int64? {
        get { _error_count?.value }
        set { _error_count = newValue.map(AnyInt.init) }
    }

    /**
     * Details of the LookML that failed SQL validation (read-only)
     */
    public var errors: [SqlValidatorErrorItem]?

    public init(model: String? = nil, explore: String? = nil, status: String? = nil, skip_reason: String? = nil, error_count: Int64? = nil, errors: [SqlValidatorErrorItem]? = nil) {
        self._model = model.map(AnyString.init)
        self._explore = explore.map(AnyString.init)
        self._status = status.map(AnyString.init)
        self._skip_reason = skip_reason.map(AnyString.init)
        self._error_count = error_count.map(AnyInt.init)
        self.errors = errors
    }

}

public struct SshPublicKey: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _public_key = "public_key"
    }
    private var _public_key: AnyString?
    /**
     * The SSH public key created for this instance (read-only)
     */
    public var public_key: String? {
        get { _public_key?.value }
        set { _public_key = newValue.map(AnyString.init) }
    }

    public init(public_key: String? = nil) {
        self._public_key = public_key.map(AnyString.init)
    }

}

public struct SshServer: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _ssh_server_id = "ssh_server_id"
        case _ssh_server_name = "ssh_server_name"
        case _ssh_server_host = "ssh_server_host"
        case _ssh_server_port = "ssh_server_port"
        case _ssh_server_user = "ssh_server_user"
        case _finger_print = "finger_print"
        case _sha_finger_print = "sha_finger_print"
        case _public_key = "public_key"
        case _status = "status"
    }
    private var _ssh_server_id: AnyString?
    /**
     * A unique id used to identify this SSH Server (read-only)
     */
    public var ssh_server_id: String? {
        get { _ssh_server_id?.value }
        set { _ssh_server_id = newValue.map(AnyString.init) }
    }

    private var _ssh_server_name: AnyString?
    /**
     * The name to identify this SSH Server
     */
    public var ssh_server_name: String? {
        get { _ssh_server_name?.value }
        set { _ssh_server_name = newValue.map(AnyString.init) }
    }

    private var _ssh_server_host: AnyString?
    /**
     * The hostname or ip address of the SSH Server
     */
    public var ssh_server_host: String? {
        get { _ssh_server_host?.value }
        set { _ssh_server_host = newValue.map(AnyString.init) }
    }

    private var _ssh_server_port: AnyInt?
    /**
     * The port to connect to on the SSH Server
     */
    public var ssh_server_port: Int64? {
        get { _ssh_server_port?.value }
        set { _ssh_server_port = newValue.map(AnyInt.init) }
    }

    private var _ssh_server_user: AnyString?
    /**
     * The username used to connect to the SSH Server
     */
    public var ssh_server_user: String? {
        get { _ssh_server_user?.value }
        set { _ssh_server_user = newValue.map(AnyString.init) }
    }

    private var _finger_print: AnyString?
    /**
     * The md5 fingerprint used to identify the SSH Server (read-only)
     */
    public var finger_print: String? {
        get { _finger_print?.value }
        set { _finger_print = newValue.map(AnyString.init) }
    }

    private var _sha_finger_print: AnyString?
    /**
     * The SHA fingerprint used to identify the SSH Server (read-only)
     */
    public var sha_finger_print: String? {
        get { _sha_finger_print?.value }
        set { _sha_finger_print = newValue.map(AnyString.init) }
    }

    private var _public_key: AnyString?
    /**
     * The SSH public key created for this instance (read-only)
     */
    public var public_key: String? {
        get { _public_key?.value }
        set { _public_key = newValue.map(AnyString.init) }
    }

    private var _status: AnyString?
    /**
     * The current connection status to this SSH Server (read-only)
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    public init(ssh_server_id: String? = nil, ssh_server_name: String? = nil, ssh_server_host: String? = nil, ssh_server_port: Int64? = nil, ssh_server_user: String? = nil, finger_print: String? = nil, sha_finger_print: String? = nil, public_key: String? = nil, status: String? = nil) {
        self._ssh_server_id = ssh_server_id.map(AnyString.init)
        self._ssh_server_name = ssh_server_name.map(AnyString.init)
        self._ssh_server_host = ssh_server_host.map(AnyString.init)
        self._ssh_server_port = ssh_server_port.map(AnyInt.init)
        self._ssh_server_user = ssh_server_user.map(AnyString.init)
        self._finger_print = finger_print.map(AnyString.init)
        self._sha_finger_print = sha_finger_print.map(AnyString.init)
        self._public_key = public_key.map(AnyString.init)
        self._status = status.map(AnyString.init)
    }

}

public struct SshTunnel: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _tunnel_id = "tunnel_id"
        case _ssh_server_id = "ssh_server_id"
        case _ssh_server_name = "ssh_server_name"
        case _ssh_server_host = "ssh_server_host"
        case _ssh_server_port = "ssh_server_port"
        case _ssh_server_user = "ssh_server_user"
        case _last_attempt = "last_attempt"
        case _local_host_port = "local_host_port"
        case _database_host = "database_host"
        case _database_port = "database_port"
        case _status = "status"
    }
    private var _tunnel_id: AnyString?
    /**
     * Unique ID for the tunnel (read-only)
     */
    public var tunnel_id: String? {
        get { _tunnel_id?.value }
        set { _tunnel_id = newValue.map(AnyString.init) }
    }

    private var _ssh_server_id: AnyString?
    /**
     * SSH Server ID
     */
    public var ssh_server_id: String? {
        get { _ssh_server_id?.value }
        set { _ssh_server_id = newValue.map(AnyString.init) }
    }

    private var _ssh_server_name: AnyString?
    /**
     * SSH Server name (read-only)
     */
    public var ssh_server_name: String? {
        get { _ssh_server_name?.value }
        set { _ssh_server_name = newValue.map(AnyString.init) }
    }

    private var _ssh_server_host: AnyString?
    /**
     * SSH Server Hostname or IP Address (read-only)
     */
    public var ssh_server_host: String? {
        get { _ssh_server_host?.value }
        set { _ssh_server_host = newValue.map(AnyString.init) }
    }

    private var _ssh_server_port: AnyInt?
    /**
     * SSH Server port (read-only)
     */
    public var ssh_server_port: Int64? {
        get { _ssh_server_port?.value }
        set { _ssh_server_port = newValue.map(AnyInt.init) }
    }

    private var _ssh_server_user: AnyString?
    /**
     * Username used to connect to the SSH Server (read-only)
     */
    public var ssh_server_user: String? {
        get { _ssh_server_user?.value }
        set { _ssh_server_user = newValue.map(AnyString.init) }
    }

    private var _last_attempt: AnyString?
    /**
     * Time of last connect attempt (read-only)
     */
    public var last_attempt: String? {
        get { _last_attempt?.value }
        set { _last_attempt = newValue.map(AnyString.init) }
    }

    private var _local_host_port: AnyInt?
    /**
     * Localhost Port used by the Looker instance to connect to the remote DB
     */
    public var local_host_port: Int64? {
        get { _local_host_port?.value }
        set { _local_host_port = newValue.map(AnyInt.init) }
    }

    private var _database_host: AnyString?
    /**
     * Hostname or IP Address of the Database Server
     */
    public var database_host: String? {
        get { _database_host?.value }
        set { _database_host = newValue.map(AnyString.init) }
    }

    private var _database_port: AnyInt?
    /**
     * Port that the Database Server is listening on
     */
    public var database_port: Int64? {
        get { _database_port?.value }
        set { _database_port = newValue.map(AnyInt.init) }
    }

    private var _status: AnyString?
    /**
     * Current connection status for this Tunnel (read-only)
     */
    public var status: String? {
        get { _status?.value }
        set { _status = newValue.map(AnyString.init) }
    }

    public init(tunnel_id: String? = nil, ssh_server_id: String? = nil, ssh_server_name: String? = nil, ssh_server_host: String? = nil, ssh_server_port: Int64? = nil, ssh_server_user: String? = nil, last_attempt: String? = nil, local_host_port: Int64? = nil, database_host: String? = nil, database_port: Int64? = nil, status: String? = nil) {
        self._tunnel_id = tunnel_id.map(AnyString.init)
        self._ssh_server_id = ssh_server_id.map(AnyString.init)
        self._ssh_server_name = ssh_server_name.map(AnyString.init)
        self._ssh_server_host = ssh_server_host.map(AnyString.init)
        self._ssh_server_port = ssh_server_port.map(AnyInt.init)
        self._ssh_server_user = ssh_server_user.map(AnyString.init)
        self._last_attempt = last_attempt.map(AnyString.init)
        self._local_host_port = local_host_port.map(AnyInt.init)
        self._database_host = database_host.map(AnyString.init)
        self._database_port = database_port.map(AnyInt.init)
        self._status = status.map(AnyString.init)
    }

}

/**
 * TLS version selected Valid values are: "TLSv1_1", "SSLv23", "TLSv1_2". (Enum defined in SmtpSettings)
 */
public enum SslVersion: String, Codable {
    case TLSv1_1 = "TLSv1_1"
    case SSLv23 = "SSLv23"
    case TLSv1_2 = "TLSv1_2"
}

public struct SupportAccessAddEntries: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _emails = "emails"
        case _reason = "reason"
    }
    private var _emails: [AnyString]?
    /**
     * An array of emails to add to the Allowlist
     */
    public var emails: [String]? {
        get { if let v = _emails { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _emails = v.map { AnyString.init($0) } } else { _emails = nil } }
    }

    private var _reason: AnyString?
    /**
     * Reason for adding emails to the Allowlist
     */
    public var reason: String? {
        get { _reason?.value }
        set { _reason = newValue.map(AnyString.init) }
    }

    public init(emails: [String]? = nil, reason: String? = nil) {
        if let v = emails { _emails = v.map { AnyString.init($0) } } else { _emails = nil }
        self._reason = reason.map(AnyString.init)
    }

}

public struct SupportAccessAllowlistEntry: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _email = "email"
        case _full_name = "full_name"
        case _reason = "reason"
        case created_date
    }
    private var _id: AnyString?
    /**
     * Unique ID (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _email: AnyString?
    /**
     * Email address
     */
    public var email: String? {
        get { _email?.value }
        set { _email = newValue.map(AnyString.init) }
    }

    private var _full_name: AnyString?
    /**
     * Full name of allowlisted user (read-only)
     */
    public var full_name: String? {
        get { _full_name?.value }
        set { _full_name = newValue.map(AnyString.init) }
    }

    private var _reason: AnyString?
    /**
     * Reason the Email is included in the Allowlist
     */
    public var reason: String? {
        get { _reason?.value }
        set { _reason = newValue.map(AnyString.init) }
    }

    /**
     * Date the Email was added to the Allowlist (read-only)
     */
    public var created_date: Date?

    public init(id: String? = nil, email: String? = nil, full_name: String? = nil, reason: String? = nil, created_date: Date? = nil) {
        self._id = id.map(AnyString.init)
        self._email = email.map(AnyString.init)
        self._full_name = full_name.map(AnyString.init)
        self._reason = reason.map(AnyString.init)
        self.created_date = created_date
    }

}

public struct SupportAccessEnable: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _duration_in_seconds = "duration_in_seconds"
    }
    private var _duration_in_seconds: AnyInt
    /**
     * Duration Support Access will remain enabled
     */
    public var duration_in_seconds: Int64 {
        get { _duration_in_seconds.value }
        set { _duration_in_seconds = AnyInt.init(newValue) }
    }

    public init(duration_in_seconds: Int64) {
        self._duration_in_seconds = AnyInt.init(duration_in_seconds)
    }

    public init(_ duration_in_seconds: Int64) {
        self.init(duration_in_seconds: duration_in_seconds)
    }

}

public struct SupportAccessStatus: SDKModel {
    /**
     * Whether or not Support Access is open (read-only)
     */
    public var `open`: Bool?

    /**
     * Time that Support Access will expire (read-only)
     */
    public var open_until: Date?

    public init(`open`: Bool? = nil, open_until: Date? = nil) {
        self.`open` = `open`
        self.open_until = open_until
    }

}

/**
 * A list of action types the integration supports. Valid values are: "cell", "query", "dashboard", "none". (Enum defined in Integration)
 */
public enum SupportedActionTypes: String, Codable {
    case cell = "cell"
    case query = "query"
    case dashboard = "dashboard"
    case none = "none"
}

/**
 * A list of all the download mechanisms the integration supports. The order of values is not significant: Looker will select the most appropriate supported download mechanism for a given query. The integration must ensure it can handle any of the mechanisms it claims to support. If unspecified, this defaults to all download setting values. Valid values are: "push", "url". (Enum defined in Integration)
 */
public enum SupportedDownloadSettings: String, Codable {
    case push = "push"
    case url = "url"
}

/**
 * A list of data formats the integration supports. If unspecified, the default is all data formats. Valid values are: "txt", "csv", "inline_json", "json", "json_label", "json_detail", "json_detail_lite_stream", "json_bi", "xlsx", "html", "wysiwyg_pdf", "assembled_pdf", "wysiwyg_png", "csv_zip". (Enum defined in Integration)
 */
public enum SupportedFormats: String, Codable {
    case txt = "txt"
    case csv = "csv"
    case inline_json = "inline_json"
    case json = "json"
    case json_label = "json_label"
    case json_detail = "json_detail"
    case json_detail_lite_stream = "json_detail_lite_stream"
    case json_bi = "json_bi"
    case xlsx = "xlsx"
    case html = "html"
    case wysiwyg_pdf = "wysiwyg_pdf"
    case assembled_pdf = "assembled_pdf"
    case wysiwyg_png = "wysiwyg_png"
    case csv_zip = "csv_zip"
}

/**
 * A list of formatting options the integration supports. If unspecified, defaults to all formats. Valid values are: "formatted", "unformatted". (Enum defined in Integration)
 */
public enum SupportedFormattings: String, Codable {
    case formatted = "formatted"
    case unformatted = "unformatted"
}

/**
 * A list of visualization formatting options the integration supports. If unspecified, defaults to all formats. Valid values are: "apply", "noapply". (Enum defined in Integration)
 */
public enum SupportedVisualizationFormattings: String, Codable {
    case apply = "apply"
    case noapply = "noapply"
}

public struct Theme: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case begin_at
        case end_at
        case _id = "id"
        case _name = "name"
        case settings
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    /**
     * Timestamp for when this theme becomes active. Null=always
     */
    public var begin_at: Date?

    /**
     * Timestamp for when this theme expires. Null=never
     */
    public var end_at: Date?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _name: AnyString?
    /**
     * Name of theme. Can only be alphanumeric and underscores.
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    public var settings: ThemeSettings?

    public init(can: StringDictionary<Bool>? = nil, begin_at: Date? = nil, end_at: Date? = nil, id: String? = nil, name: String? = nil, settings: ThemeSettings? = nil) {
        self.can = can
        self.begin_at = begin_at
        self.end_at = end_at
        self._id = id.map(AnyString.init)
        self._name = name.map(AnyString.init)
        self.settings = settings
    }

}

public struct ThemeSettings: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _background_color = "background_color"
        case _base_font_size = "base_font_size"
        case _color_collection_id = "color_collection_id"
        case _font_color = "font_color"
        case _font_family = "font_family"
        case _font_source = "font_source"
        case _info_button_color = "info_button_color"
        case _primary_button_color = "primary_button_color"
        case show_filters_bar
        case show_title
        case _text_tile_text_color = "text_tile_text_color"
        case _tile_background_color = "tile_background_color"
        case _text_tile_background_color = "text_tile_background_color"
        case _tile_text_color = "tile_text_color"
        case _title_color = "title_color"
        case _warn_button_color = "warn_button_color"
        case _tile_title_alignment = "tile_title_alignment"
        case tile_shadow
        case show_last_updated_indicator
        case show_reload_data_icon
        case show_dashboard_menu
        case show_filters_toggle
        case show_dashboard_header
        case center_dashboard_title
        case _dashboard_title_font_size = "dashboard_title_font_size"
        case _box_shadow = "box_shadow"
        case _page_margin_top = "page_margin_top"
        case _page_margin_bottom = "page_margin_bottom"
        case _page_margin_sides = "page_margin_sides"
        case show_explore_header
        case show_explore_title
        case show_explore_last_run
        case show_explore_timezone
        case show_explore_run_stop_button
        case show_explore_actions_button
        case show_look_header
        case show_look_title
        case show_look_last_run
        case show_look_timezone
        case show_look_run_stop_button
        case show_look_actions_button
        case _tile_title_font_size = "tile_title_font_size"
        case _column_gap_size = "column_gap_size"
        case _row_gap_size = "row_gap_size"
        case _border_radius = "border_radius"
    }
    private var _background_color: AnyString?
    /**
     * Default background color
     */
    public var background_color: String? {
        get { _background_color?.value }
        set { _background_color = newValue.map(AnyString.init) }
    }

    private var _base_font_size: AnyString?
    /**
     * Base font size for scaling fonts (only supported by legacy dashboards)
     */
    public var base_font_size: String? {
        get { _base_font_size?.value }
        set { _base_font_size = newValue.map(AnyString.init) }
    }

    private var _color_collection_id: AnyString?
    /**
     * Optional. ID of color collection to use with the theme. Use an empty string for none.
     */
    public var color_collection_id: String? {
        get { _color_collection_id?.value }
        set { _color_collection_id = newValue.map(AnyString.init) }
    }

    private var _font_color: AnyString?
    /**
     * Default font color
     */
    public var font_color: String? {
        get { _font_color?.value }
        set { _font_color = newValue.map(AnyString.init) }
    }

    private var _font_family: AnyString?
    /**
     * Primary font family
     */
    public var font_family: String? {
        get { _font_family?.value }
        set { _font_family = newValue.map(AnyString.init) }
    }

    private var _font_source: AnyString?
    /**
     * Source specification for font
     */
    public var font_source: String? {
        get { _font_source?.value }
        set { _font_source = newValue.map(AnyString.init) }
    }

    private var _info_button_color: AnyString?
    /**
     * (DEPRECATED) Info button color
     */
    public var info_button_color: String? {
        get { _info_button_color?.value }
        set { _info_button_color = newValue.map(AnyString.init) }
    }

    private var _primary_button_color: AnyString?
    /**
     * Primary button color
     */
    public var primary_button_color: String? {
        get { _primary_button_color?.value }
        set { _primary_button_color = newValue.map(AnyString.init) }
    }

    /**
     * Toggle to show filters. Defaults to true.
     */
    public var show_filters_bar: Bool?

    /**
     * Toggle to show the title. Defaults to true.
     */
    public var show_title: Bool?

    private var _text_tile_text_color: AnyString?
    /**
     * Text color for text tiles
     */
    public var text_tile_text_color: String? {
        get { _text_tile_text_color?.value }
        set { _text_tile_text_color = newValue.map(AnyString.init) }
    }

    private var _tile_background_color: AnyString?
    /**
     * Background color for tiles
     */
    public var tile_background_color: String? {
        get { _tile_background_color?.value }
        set { _tile_background_color = newValue.map(AnyString.init) }
    }

    private var _text_tile_background_color: AnyString?
    /**
     * Background color for text tiles
     */
    public var text_tile_background_color: String? {
        get { _text_tile_background_color?.value }
        set { _text_tile_background_color = newValue.map(AnyString.init) }
    }

    private var _tile_text_color: AnyString?
    /**
     * Text color for tiles
     */
    public var tile_text_color: String? {
        get { _tile_text_color?.value }
        set { _tile_text_color = newValue.map(AnyString.init) }
    }

    private var _title_color: AnyString?
    /**
     * Color for titles
     */
    public var title_color: String? {
        get { _title_color?.value }
        set { _title_color = newValue.map(AnyString.init) }
    }

    private var _warn_button_color: AnyString?
    /**
     * (DEPRECATED) Warning button color
     */
    public var warn_button_color: String? {
        get { _warn_button_color?.value }
        set { _warn_button_color = newValue.map(AnyString.init) }
    }

    private var _tile_title_alignment: AnyString?
    /**
     * The text alignment of tile titles (New Dashboards)
     */
    public var tile_title_alignment: String? {
        get { _tile_title_alignment?.value }
        set { _tile_title_alignment = newValue.map(AnyString.init) }
    }

    /**
     * Toggles the tile shadow (not supported)
     */
    public var tile_shadow: Bool?

    /**
     * Toggle to show the dashboard last updated indicator. Defaults to true.
     */
    public var show_last_updated_indicator: Bool?

    /**
     * Toggle to show reload data icon/button. Defaults to true.
     */
    public var show_reload_data_icon: Bool?

    /**
     * Toggle to show the dashboard actions menu. Defaults to true.
     */
    public var show_dashboard_menu: Bool?

    /**
     * Toggle to show the filters icon/toggle. Defaults to true.
     */
    public var show_filters_toggle: Bool?

    /**
     * Toggle to show the dashboard header. Defaults to true.
     */
    public var show_dashboard_header: Bool?

    /**
     * Toggle to center the dashboard title. Defaults to false.
     */
    public var center_dashboard_title: Bool?

    private var _dashboard_title_font_size: AnyString?
    /**
     * Dashboard title font size.
     */
    public var dashboard_title_font_size: String? {
        get { _dashboard_title_font_size?.value }
        set { _dashboard_title_font_size = newValue.map(AnyString.init) }
    }

    private var _box_shadow: AnyString?
    /**
     * Default box shadow.
     */
    public var box_shadow: String? {
        get { _box_shadow?.value }
        set { _box_shadow = newValue.map(AnyString.init) }
    }

    private var _page_margin_top: AnyString?
    /**
     * Dashboard page margin top.
     */
    public var page_margin_top: String? {
        get { _page_margin_top?.value }
        set { _page_margin_top = newValue.map(AnyString.init) }
    }

    private var _page_margin_bottom: AnyString?
    /**
     * Dashboard page margin bottom.
     */
    public var page_margin_bottom: String? {
        get { _page_margin_bottom?.value }
        set { _page_margin_bottom = newValue.map(AnyString.init) }
    }

    private var _page_margin_sides: AnyString?
    /**
     * Dashboard page margin left and right.
     */
    public var page_margin_sides: String? {
        get { _page_margin_sides?.value }
        set { _page_margin_sides = newValue.map(AnyString.init) }
    }

    /**
     * Toggle to show the explore page header. Defaults to true.
     */
    public var show_explore_header: Bool?

    /**
     * Toggle to show the explore page title. Defaults to true.
     */
    public var show_explore_title: Bool?

    /**
     * Toggle to show the explore page last run. Defaults to true.
     */
    public var show_explore_last_run: Bool?

    /**
     * Toggle to show the explore page timezone. Defaults to true.
     */
    public var show_explore_timezone: Bool?

    /**
     * Toggle to show the explore page run button. Defaults to true.
     */
    public var show_explore_run_stop_button: Bool?

    /**
     * Toggle to show the explore page actions button. Defaults to true.
     */
    public var show_explore_actions_button: Bool?

    /**
     * Toggle to show the look page header. Defaults to true.
     */
    public var show_look_header: Bool?

    /**
     * Toggle to show the look page title. Defaults to true.
     */
    public var show_look_title: Bool?

    /**
     * Toggle to show the look page last run. Defaults to true.
     */
    public var show_look_last_run: Bool?

    /**
     * Toggle to show the look page timezone Defaults to true.
     */
    public var show_look_timezone: Bool?

    /**
     * Toggle to show the look page run button. Defaults to true.
     */
    public var show_look_run_stop_button: Bool?

    /**
     * Toggle to show the look page actions button. Defaults to true.
     */
    public var show_look_actions_button: Bool?

    private var _tile_title_font_size: AnyString?
    /**
     * Font size for tiles.
     */
    public var tile_title_font_size: String? {
        get { _tile_title_font_size?.value }
        set { _tile_title_font_size = newValue.map(AnyString.init) }
    }

    private var _column_gap_size: AnyString?
    /**
     * The vertical gap/gutter size between tiles.
     */
    public var column_gap_size: String? {
        get { _column_gap_size?.value }
        set { _column_gap_size = newValue.map(AnyString.init) }
    }

    private var _row_gap_size: AnyString?
    /**
     * The horizontal gap/gutter size between tiles.
     */
    public var row_gap_size: String? {
        get { _row_gap_size?.value }
        set { _row_gap_size = newValue.map(AnyString.init) }
    }

    private var _border_radius: AnyString?
    /**
     * The border radius for tiles.
     */
    public var border_radius: String? {
        get { _border_radius?.value }
        set { _border_radius = newValue.map(AnyString.init) }
    }

    public init(background_color: String? = nil, base_font_size: String? = nil, color_collection_id: String? = nil, font_color: String? = nil, font_family: String? = nil, font_source: String? = nil, info_button_color: String? = nil, primary_button_color: String? = nil, show_filters_bar: Bool? = nil, show_title: Bool? = nil, text_tile_text_color: String? = nil, tile_background_color: String? = nil, text_tile_background_color: String? = nil, tile_text_color: String? = nil, title_color: String? = nil, warn_button_color: String? = nil, tile_title_alignment: String? = nil, tile_shadow: Bool? = nil, show_last_updated_indicator: Bool? = nil, show_reload_data_icon: Bool? = nil, show_dashboard_menu: Bool? = nil, show_filters_toggle: Bool? = nil, show_dashboard_header: Bool? = nil, center_dashboard_title: Bool? = nil, dashboard_title_font_size: String? = nil, box_shadow: String? = nil, page_margin_top: String? = nil, page_margin_bottom: String? = nil, page_margin_sides: String? = nil, show_explore_header: Bool? = nil, show_explore_title: Bool? = nil, show_explore_last_run: Bool? = nil, show_explore_timezone: Bool? = nil, show_explore_run_stop_button: Bool? = nil, show_explore_actions_button: Bool? = nil, show_look_header: Bool? = nil, show_look_title: Bool? = nil, show_look_last_run: Bool? = nil, show_look_timezone: Bool? = nil, show_look_run_stop_button: Bool? = nil, show_look_actions_button: Bool? = nil, tile_title_font_size: String? = nil, column_gap_size: String? = nil, row_gap_size: String? = nil, border_radius: String? = nil) {
        self._background_color = background_color.map(AnyString.init)
        self._base_font_size = base_font_size.map(AnyString.init)
        self._color_collection_id = color_collection_id.map(AnyString.init)
        self._font_color = font_color.map(AnyString.init)
        self._font_family = font_family.map(AnyString.init)
        self._font_source = font_source.map(AnyString.init)
        self._info_button_color = info_button_color.map(AnyString.init)
        self._primary_button_color = primary_button_color.map(AnyString.init)
        self.show_filters_bar = show_filters_bar
        self.show_title = show_title
        self._text_tile_text_color = text_tile_text_color.map(AnyString.init)
        self._tile_background_color = tile_background_color.map(AnyString.init)
        self._text_tile_background_color = text_tile_background_color.map(AnyString.init)
        self._tile_text_color = tile_text_color.map(AnyString.init)
        self._title_color = title_color.map(AnyString.init)
        self._warn_button_color = warn_button_color.map(AnyString.init)
        self._tile_title_alignment = tile_title_alignment.map(AnyString.init)
        self.tile_shadow = tile_shadow
        self.show_last_updated_indicator = show_last_updated_indicator
        self.show_reload_data_icon = show_reload_data_icon
        self.show_dashboard_menu = show_dashboard_menu
        self.show_filters_toggle = show_filters_toggle
        self.show_dashboard_header = show_dashboard_header
        self.center_dashboard_title = center_dashboard_title
        self._dashboard_title_font_size = dashboard_title_font_size.map(AnyString.init)
        self._box_shadow = box_shadow.map(AnyString.init)
        self._page_margin_top = page_margin_top.map(AnyString.init)
        self._page_margin_bottom = page_margin_bottom.map(AnyString.init)
        self._page_margin_sides = page_margin_sides.map(AnyString.init)
        self.show_explore_header = show_explore_header
        self.show_explore_title = show_explore_title
        self.show_explore_last_run = show_explore_last_run
        self.show_explore_timezone = show_explore_timezone
        self.show_explore_run_stop_button = show_explore_run_stop_button
        self.show_explore_actions_button = show_explore_actions_button
        self.show_look_header = show_look_header
        self.show_look_title = show_look_title
        self.show_look_last_run = show_look_last_run
        self.show_look_timezone = show_look_timezone
        self.show_look_run_stop_button = show_look_run_stop_button
        self.show_look_actions_button = show_look_actions_button
        self._tile_title_font_size = tile_title_font_size.map(AnyString.init)
        self._column_gap_size = column_gap_size.map(AnyString.init)
        self._row_gap_size = row_gap_size.map(AnyString.init)
        self._border_radius = border_radius.map(AnyString.init)
    }

}

public struct Timezone: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _value = "value"
        case _label = "label"
        case _group = "group"
    }
    private var _value: AnyString?
    /**
     * Timezone (read-only)
     */
    public var value: String? {
        get { _value?.value }
        set { _value = newValue.map(AnyString.init) }
    }

    private var _label: AnyString?
    /**
     * Description of timezone (read-only)
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    private var _group: AnyString?
    /**
     * Timezone group (e.g Common, Other, etc.) (read-only)
     */
    public var group: String? {
        get { _group?.value }
        set { _group = newValue.map(AnyString.init) }
    }

    public init(value: String? = nil, label: String? = nil, group: String? = nil) {
        self._value = value.map(AnyString.init)
        self._label = label.map(AnyString.init)
        self._group = group.map(AnyString.init)
    }

}

public struct UpdateArtifact: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _key = "key"
        case _value = "value"
        case _content_type = "content_type"
        case _version = "version"
    }
    private var _key: AnyString
    /**
     * Key of value to store. Namespace + Key must be unique.
     */
    public var key: String {
        get { _key.value }
        set { _key = AnyString.init(newValue) }
    }

    private var _value: AnyString
    /**
     * Value to store.
     */
    public var value: String {
        get { _value.value }
        set { _value = AnyString.init(newValue) }
    }

    private var _content_type: AnyString?
    /**
     * MIME type of content. This can only be used to override content that is detected as text/plain. Needed to set application/json content types, which are analyzed as plain text.
     */
    public var content_type: String? {
        get { _content_type?.value }
        set { _content_type = newValue.map(AnyString.init) }
    }

    private var _version: AnyInt?
    /**
     * Version number of the stored value. The version must be provided for any updates to an existing artifact. (read-only)
     */
    public var version: Int64? {
        get { _version?.value }
        set { _version = newValue.map(AnyInt.init) }
    }

    public init(key: String, value: String, content_type: String? = nil, version: Int64? = nil) {
        self._key = AnyString.init(key)
        self._value = AnyString.init(value)
        self._content_type = content_type.map(AnyString.init)
        self._version = version.map(AnyInt.init)
    }

    public init(_ key: String, _ value: String, content_type: String? = nil, version: Int64? = nil) {
        self.init(key: key, value: value, content_type: content_type, version: version)
    }

}

public struct UpdateFolder: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _parent_id = "parent_id"
    }
    private var _name: AnyString?
    /**
     * Unique Name
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _parent_id: AnyString?
    /**
     * Id of Parent. If the parent id is null, this is a root-level entry
     */
    public var parent_id: String? {
        get { _parent_id?.value }
        set { _parent_id = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, parent_id: String? = nil) {
        self._name = name.map(AnyString.init)
        self._parent_id = parent_id.map(AnyString.init)
    }

}

public struct User: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _avatar_url = "avatar_url"
        case _avatar_url_without_sizing = "avatar_url_without_sizing"
        case credentials_api3
        case credentials_email
        case credentials_embed
        case credentials_google
        case credentials_ldap
        case credentials_looker_openid
        case credentials_oidc
        case credentials_saml
        case credentials_totp
        case _display_name = "display_name"
        case _email = "email"
        case _embed_group_space_id = "embed_group_space_id"
        case _first_name = "first_name"
        case _group_ids = "group_ids"
        case _home_folder_id = "home_folder_id"
        case _id = "id"
        case is_disabled
        case _last_name = "last_name"
        case _locale = "locale"
        case _looker_versions = "looker_versions"
        case models_dir_validated
        case _personal_folder_id = "personal_folder_id"
        case presumed_looker_employee
        case _role_ids = "role_ids"
        case sessions
        case ui_state
        case verified_looker_employee
        case roles_externally_managed
        case allow_direct_roles
        case allow_normal_group_membership
        case allow_roles_from_normal_groups
        case _embed_group_folder_id = "embed_group_folder_id"
        case is_iam_admin
        case _url = "url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _avatar_url: AnyString?
    /**
     * URL for the avatar image (may be generic) (read-only)
     */
    public var avatar_url: String? {
        get { _avatar_url?.value }
        set { _avatar_url = newValue.map(AnyString.init) }
    }

    private var _avatar_url_without_sizing: AnyString?
    /**
     * URL for the avatar image (may be generic), does not specify size (read-only)
     */
    public var avatar_url_without_sizing: String? {
        get { _avatar_url_without_sizing?.value }
        set { _avatar_url_without_sizing = newValue.map(AnyString.init) }
    }

    /**
     * API credentials (read-only)
     */
    public var credentials_api3: [CredentialsApi3]?

    public var credentials_email: CredentialsEmail?

    /**
     * Embed credentials (read-only)
     */
    public var credentials_embed: [CredentialsEmbed]?

    public var credentials_google: CredentialsGoogle?

    public var credentials_ldap: CredentialsLDAP?

    public var credentials_looker_openid: CredentialsLookerOpenid?

    public var credentials_oidc: CredentialsOIDC?

    public var credentials_saml: CredentialsSaml?

    public var credentials_totp: CredentialsTotp?

    private var _display_name: AnyString?
    /**
     * Full name for display (available only if both first_name and last_name are set) (read-only)
     */
    public var display_name: String? {
        get { _display_name?.value }
        set { _display_name = newValue.map(AnyString.init) }
    }

    private var _email: AnyString?
    /**
     * EMail address (read-only)
     */
    public var email: String? {
        get { _email?.value }
        set { _email = newValue.map(AnyString.init) }
    }

    private var _embed_group_space_id: AnyString?
    /**
     * (DEPRECATED) (Embed only) ID of user's group space based on the external_group_id optionally specified during embed user login (read-only)
     */
    public var embed_group_space_id: String? {
        get { _embed_group_space_id?.value }
        set { _embed_group_space_id = newValue.map(AnyString.init) }
    }

    private var _first_name: AnyString?
    /**
     * First name
     */
    public var first_name: String? {
        get { _first_name?.value }
        set { _first_name = newValue.map(AnyString.init) }
    }

    private var _group_ids: [AnyString]?
    /**
     * Array of ids of the groups for this user (read-only)
     */
    public var group_ids: [String]? {
        get { if let v = _group_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _group_ids = v.map { AnyString.init($0) } } else { _group_ids = nil } }
    }

    private var _home_folder_id: AnyString?
    /**
     * ID string for user's home folder
     */
    public var home_folder_id: String? {
        get { _home_folder_id?.value }
        set { _home_folder_id = newValue.map(AnyString.init) }
    }

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    /**
     * Account has been disabled
     */
    public var is_disabled: Bool?

    private var _last_name: AnyString?
    /**
     * Last name
     */
    public var last_name: String? {
        get { _last_name?.value }
        set { _last_name = newValue.map(AnyString.init) }
    }

    private var _locale: AnyString?
    /**
     * User's preferred locale. User locale takes precedence over Looker's system-wide default locale. Locale determines language of display strings and date and numeric formatting in API responses. Locale string must be a 2 letter language code or a combination of language code and region code: 'en' or 'en-US', for example.
     */
    public var locale: String? {
        get { _locale?.value }
        set { _locale = newValue.map(AnyString.init) }
    }

    private var _looker_versions: [AnyString]?
    /**
     * Array of strings representing the Looker versions that this user has used (this only goes back as far as '3.54.0') (read-only)
     */
    public var looker_versions: [String]? {
        get { if let v = _looker_versions { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _looker_versions = v.map { AnyString.init($0) } } else { _looker_versions = nil } }
    }

    /**
     * User's dev workspace has been checked for presence of applicable production projects
     */
    public var models_dir_validated: Bool?

    private var _personal_folder_id: AnyString?
    /**
     * ID of user's personal folder (read-only)
     */
    public var personal_folder_id: String? {
        get { _personal_folder_id?.value }
        set { _personal_folder_id = newValue.map(AnyString.init) }
    }

    /**
     * (DEPRECATED) User is identified as an employee of Looker (read-only)
     */
    public var presumed_looker_employee: Bool?

    private var _role_ids: [AnyString]?
    /**
     * Array of ids of the roles for this user (read-only)
     */
    public var role_ids: [String]? {
        get { if let v = _role_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _role_ids = v.map { AnyString.init($0) } } else { _role_ids = nil } }
    }

    /**
     * Active sessions (read-only)
     */
    public var sessions: [Session]?

    /**
     * Per user dictionary of undocumented state information owned by the Looker UI.
     */
    public var ui_state: StringDictionary<AnyCodable>?

    /**
     * User is identified as an employee of Looker who has been verified via Looker corporate authentication (read-only)
     */
    public var verified_looker_employee: Bool?

    /**
     * User's roles are managed by an external directory like SAML or LDAP and can not be changed directly. (read-only)
     */
    public var roles_externally_managed: Bool?

    /**
     * User can be directly assigned a role. (read-only)
     */
    public var allow_direct_roles: Bool?

    /**
     * User can be a direct member of a normal Looker group. (read-only)
     */
    public var allow_normal_group_membership: Bool?

    /**
     * User can inherit roles from a normal Looker group. (read-only)
     */
    public var allow_roles_from_normal_groups: Bool?

    private var _embed_group_folder_id: AnyString?
    /**
     * (Embed only) ID of user's group folder based on the external_group_id optionally specified during embed user login (read-only)
     */
    public var embed_group_folder_id: String? {
        get { _embed_group_folder_id?.value }
        set { _embed_group_folder_id = newValue.map(AnyString.init) }
    }

    /**
     * User is an IAM Admin - only available in Looker (Google Cloud core) (read-only)
     */
    public var is_iam_admin: Bool?

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, avatar_url: String? = nil, avatar_url_without_sizing: String? = nil, credentials_api3: [CredentialsApi3]? = nil, credentials_email: CredentialsEmail? = nil, credentials_embed: [CredentialsEmbed]? = nil, credentials_google: CredentialsGoogle? = nil, credentials_ldap: CredentialsLDAP? = nil, credentials_looker_openid: CredentialsLookerOpenid? = nil, credentials_oidc: CredentialsOIDC? = nil, credentials_saml: CredentialsSaml? = nil, credentials_totp: CredentialsTotp? = nil, display_name: String? = nil, email: String? = nil, embed_group_space_id: String? = nil, first_name: String? = nil, group_ids: [String]? = nil, home_folder_id: String? = nil, id: String? = nil, is_disabled: Bool? = nil, last_name: String? = nil, locale: String? = nil, looker_versions: [String]? = nil, models_dir_validated: Bool? = nil, personal_folder_id: String? = nil, presumed_looker_employee: Bool? = nil, role_ids: [String]? = nil, sessions: [Session]? = nil, ui_state: StringDictionary<AnyCodable>? = nil, verified_looker_employee: Bool? = nil, roles_externally_managed: Bool? = nil, allow_direct_roles: Bool? = nil, allow_normal_group_membership: Bool? = nil, allow_roles_from_normal_groups: Bool? = nil, embed_group_folder_id: String? = nil, is_iam_admin: Bool? = nil, url: String? = nil) {
        self.can = can
        self._avatar_url = avatar_url.map(AnyString.init)
        self._avatar_url_without_sizing = avatar_url_without_sizing.map(AnyString.init)
        self.credentials_api3 = credentials_api3
        self.credentials_email = credentials_email
        self.credentials_embed = credentials_embed
        self.credentials_google = credentials_google
        self.credentials_ldap = credentials_ldap
        self.credentials_looker_openid = credentials_looker_openid
        self.credentials_oidc = credentials_oidc
        self.credentials_saml = credentials_saml
        self.credentials_totp = credentials_totp
        self._display_name = display_name.map(AnyString.init)
        self._email = email.map(AnyString.init)
        self._embed_group_space_id = embed_group_space_id.map(AnyString.init)
        self._first_name = first_name.map(AnyString.init)
        if let v = group_ids { _group_ids = v.map { AnyString.init($0) } } else { _group_ids = nil }
        self._home_folder_id = home_folder_id.map(AnyString.init)
        self._id = id.map(AnyString.init)
        self.is_disabled = is_disabled
        self._last_name = last_name.map(AnyString.init)
        self._locale = locale.map(AnyString.init)
        if let v = looker_versions { _looker_versions = v.map { AnyString.init($0) } } else { _looker_versions = nil }
        self.models_dir_validated = models_dir_validated
        self._personal_folder_id = personal_folder_id.map(AnyString.init)
        self.presumed_looker_employee = presumed_looker_employee
        if let v = role_ids { _role_ids = v.map { AnyString.init($0) } } else { _role_ids = nil }
        self.sessions = sessions
        self.ui_state = ui_state
        self.verified_looker_employee = verified_looker_employee
        self.roles_externally_managed = roles_externally_managed
        self.allow_direct_roles = allow_direct_roles
        self.allow_normal_group_membership = allow_normal_group_membership
        self.allow_roles_from_normal_groups = allow_roles_from_normal_groups
        self._embed_group_folder_id = embed_group_folder_id.map(AnyString.init)
        self.is_iam_admin = is_iam_admin
        self._url = url.map(AnyString.init)
    }

}

public struct UserAttribute: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _name = "name"
        case _label = "label"
        case _type = "type"
        case _default_value = "default_value"
        case is_system
        case is_permanent
        case value_is_hidden
        case user_can_view
        case user_can_edit
        case _hidden_value_domain_whitelist = "hidden_value_domain_whitelist"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _name: AnyString
    /**
     * Name of user attribute
     */
    public var name: String {
        get { _name.value }
        set { _name = AnyString.init(newValue) }
    }

    private var _label: AnyString
    /**
     * Human-friendly label for user attribute
     */
    public var label: String {
        get { _label.value }
        set { _label = AnyString.init(newValue) }
    }

    private var _type: AnyString
    /**
     * Type of user attribute ("string", "number", "datetime", "yesno", "zipcode", "advanced_filter_string", "advanced_filter_number")
     */
    public var type: String {
        get { _type.value }
        set { _type = AnyString.init(newValue) }
    }

    private var _default_value: AnyString?
    /**
     * Default value for when no value is set on the user
     */
    public var default_value: String? {
        get { _default_value?.value }
        set { _default_value = newValue.map(AnyString.init) }
    }

    /**
     * Attribute is a system default (read-only)
     */
    public var is_system: Bool?

    /**
     * Attribute is permanent and cannot be deleted (read-only)
     */
    public var is_permanent: Bool?

    /**
     * If true, users will not be able to view values of this attribute
     */
    public var value_is_hidden: Bool?

    /**
     * Non-admin users can see the values of their attributes and use them in filters
     */
    public var user_can_view: Bool?

    /**
     * Users can change the value of this attribute for themselves
     */
    public var user_can_edit: Bool?

    private var _hidden_value_domain_whitelist: AnyString?
    /**
     * Destinations to which a hidden attribute may be sent. Once set, cannot be edited.
     */
    public var hidden_value_domain_whitelist: String? {
        get { _hidden_value_domain_whitelist?.value }
        set { _hidden_value_domain_whitelist = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, name: String, label: String, type: String, default_value: String? = nil, is_system: Bool? = nil, is_permanent: Bool? = nil, value_is_hidden: Bool? = nil, user_can_view: Bool? = nil, user_can_edit: Bool? = nil, hidden_value_domain_whitelist: String? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._name = AnyString.init(name)
        self._label = AnyString.init(label)
        self._type = AnyString.init(type)
        self._default_value = default_value.map(AnyString.init)
        self.is_system = is_system
        self.is_permanent = is_permanent
        self.value_is_hidden = value_is_hidden
        self.user_can_view = user_can_view
        self.user_can_edit = user_can_edit
        self._hidden_value_domain_whitelist = hidden_value_domain_whitelist.map(AnyString.init)
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, _ name: String, _ label: String, _ type: String, default_value: String? = nil, is_system: Bool? = nil, is_permanent: Bool? = nil, value_is_hidden: Bool? = nil, user_can_view: Bool? = nil, user_can_edit: Bool? = nil, hidden_value_domain_whitelist: String? = nil) {
        self.init(can: can, id: id, name: name, label: label, type: type, default_value: default_value, is_system: is_system, is_permanent: is_permanent, value_is_hidden: value_is_hidden, user_can_view: user_can_view, user_can_edit: user_can_edit, hidden_value_domain_whitelist: hidden_value_domain_whitelist)
    }

}

/**
 * An array of user attribute types that are allowed to be used in filters on this field. Valid values are: "advanced_filter_string", "advanced_filter_number", "advanced_filter_datetime", "string", "number", "datetime", "relative_url", "yesno", "zipcode". (Enum defined in LookmlModelExploreField)
 */
public enum UserAttributeFilterTypes: String, Codable {
    case advanced_filter_string = "advanced_filter_string"
    case advanced_filter_number = "advanced_filter_number"
    case advanced_filter_datetime = "advanced_filter_datetime"
    case string = "string"
    case number = "number"
    case datetime = "datetime"
    case relative_url = "relative_url"
    case yesno = "yesno"
    case zipcode = "zipcode"
}

/**
 * WARNING: no writeable properties found for POST, PUT, or PATCH
 */
public struct UserAttributeGroupValue: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _group_id = "group_id"
        case _user_attribute_id = "user_attribute_id"
        case value_is_hidden
        case _rank = "rank"
        case _value = "value"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique Id of this group-attribute relation (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _group_id: AnyString?
    /**
     * Id of group (read-only)
     */
    public var group_id: String? {
        get { _group_id?.value }
        set { _group_id = newValue.map(AnyString.init) }
    }

    private var _user_attribute_id: AnyString?
    /**
     * Id of user attribute (read-only)
     */
    public var user_attribute_id: String? {
        get { _user_attribute_id?.value }
        set { _user_attribute_id = newValue.map(AnyString.init) }
    }

    /**
     * If true, the "value" field will be null, because the attribute settings block access to this value (read-only)
     */
    public var value_is_hidden: Bool?

    private var _rank: AnyInt?
    /**
     * Precedence for resolving value for user (read-only)
     */
    public var rank: Int64? {
        get { _rank?.value }
        set { _rank = newValue.map(AnyInt.init) }
    }

    private var _value: AnyString?
    /**
     * Value of user attribute for group (read-only)
     */
    public var value: String? {
        get { _value?.value }
        set { _value = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, group_id: String? = nil, user_attribute_id: String? = nil, value_is_hidden: Bool? = nil, rank: Int64? = nil, value: String? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._group_id = group_id.map(AnyString.init)
        self._user_attribute_id = user_attribute_id.map(AnyString.init)
        self.value_is_hidden = value_is_hidden
        self._rank = rank.map(AnyInt.init)
        self._value = value.map(AnyString.init)
    }

}

public struct UserAttributeWithValue: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _name = "name"
        case _label = "label"
        case _rank = "rank"
        case _value = "value"
        case _user_id = "user_id"
        case user_can_edit
        case value_is_hidden
        case _user_attribute_id = "user_attribute_id"
        case _source = "source"
        case _hidden_value_domain_whitelist = "hidden_value_domain_whitelist"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _name: AnyString?
    /**
     * Name of user attribute (read-only)
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _label: AnyString?
    /**
     * Human-friendly label for user attribute (read-only)
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    private var _rank: AnyInt?
    /**
     * Precedence for setting value on user (lowest wins) (read-only)
     */
    public var rank: Int64? {
        get { _rank?.value }
        set { _rank = newValue.map(AnyInt.init) }
    }

    private var _value: AnyString?
    /**
     * Value of attribute for user
     */
    public var value: String? {
        get { _value?.value }
        set { _value = newValue.map(AnyString.init) }
    }

    private var _user_id: AnyString?
    /**
     * Id of User (read-only)
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    /**
     * Can the user set this value (read-only)
     */
    public var user_can_edit: Bool?

    /**
     * If true, the "value" field will be null, because the attribute settings block access to this value (read-only)
     */
    public var value_is_hidden: Bool?

    private var _user_attribute_id: AnyString?
    /**
     * Id of User Attribute (read-only)
     */
    public var user_attribute_id: String? {
        get { _user_attribute_id?.value }
        set { _user_attribute_id = newValue.map(AnyString.init) }
    }

    private var _source: AnyString?
    /**
     * How user got this value for this attribute (read-only)
     */
    public var source: String? {
        get { _source?.value }
        set { _source = newValue.map(AnyString.init) }
    }

    private var _hidden_value_domain_whitelist: AnyString?
    /**
     * If this user attribute is hidden, allowed list of destinations to which it may be sent. (read-only)
     */
    public var hidden_value_domain_whitelist: String? {
        get { _hidden_value_domain_whitelist?.value }
        set { _hidden_value_domain_whitelist = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, name: String? = nil, label: String? = nil, rank: Int64? = nil, value: String? = nil, user_id: String? = nil, user_can_edit: Bool? = nil, value_is_hidden: Bool? = nil, user_attribute_id: String? = nil, source: String? = nil, hidden_value_domain_whitelist: String? = nil) {
        self.can = can
        self._name = name.map(AnyString.init)
        self._label = label.map(AnyString.init)
        self._rank = rank.map(AnyInt.init)
        self._value = value.map(AnyString.init)
        self._user_id = user_id.map(AnyString.init)
        self.user_can_edit = user_can_edit
        self.value_is_hidden = value_is_hidden
        self._user_attribute_id = user_attribute_id.map(AnyString.init)
        self._source = source.map(AnyString.init)
        self._hidden_value_domain_whitelist = hidden_value_domain_whitelist.map(AnyString.init)
    }

}

public struct UserEmailOnly: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _email = "email"
    }
    private var _email: AnyString
    /**
     * Email Address
     */
    public var email: String {
        get { _email.value }
        set { _email = AnyString.init(newValue) }
    }

    public init(email: String) {
        self._email = AnyString.init(email)
    }

    public init(_ email: String) {
        self.init(email: email)
    }

}

public struct UserLoginLockout: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _key = "key"
        case _auth_type = "auth_type"
        case _ip = "ip"
        case _user_id = "user_id"
        case _remote_id = "remote_id"
        case _full_name = "full_name"
        case _email = "email"
        case _fail_count = "fail_count"
        case lockout_at
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _key: AnyString?
    /**
     * Hash of user's client id (read-only)
     */
    public var key: String? {
        get { _key?.value }
        set { _key = newValue.map(AnyString.init) }
    }

    private var _auth_type: AnyString?
    /**
     * Authentication method for login failures (read-only)
     */
    public var auth_type: String? {
        get { _auth_type?.value }
        set { _auth_type = newValue.map(AnyString.init) }
    }

    private var _ip: AnyString?
    /**
     * IP address of most recent failed attempt (read-only)
     */
    public var ip: String? {
        get { _ip?.value }
        set { _ip = newValue.map(AnyString.init) }
    }

    private var _user_id: AnyString?
    /**
     * User ID (read-only)
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    private var _remote_id: AnyString?
    /**
     * Remote ID of user if using LDAP (read-only)
     */
    public var remote_id: String? {
        get { _remote_id?.value }
        set { _remote_id = newValue.map(AnyString.init) }
    }

    private var _full_name: AnyString?
    /**
     * User's name (read-only)
     */
    public var full_name: String? {
        get { _full_name?.value }
        set { _full_name = newValue.map(AnyString.init) }
    }

    private var _email: AnyString?
    /**
     * Email address associated with the user's account (read-only)
     */
    public var email: String? {
        get { _email?.value }
        set { _email = newValue.map(AnyString.init) }
    }

    private var _fail_count: AnyInt?
    /**
     * Number of failures that triggered the lockout (read-only)
     */
    public var fail_count: Int64? {
        get { _fail_count?.value }
        set { _fail_count = newValue.map(AnyInt.init) }
    }

    /**
     * Time when lockout was triggered (read-only)
     */
    public var lockout_at: Date?

    public init(can: StringDictionary<Bool>? = nil, key: String? = nil, auth_type: String? = nil, ip: String? = nil, user_id: String? = nil, remote_id: String? = nil, full_name: String? = nil, email: String? = nil, fail_count: Int64? = nil, lockout_at: Date? = nil) {
        self.can = can
        self._key = key.map(AnyString.init)
        self._auth_type = auth_type.map(AnyString.init)
        self._ip = ip.map(AnyString.init)
        self._user_id = user_id.map(AnyString.init)
        self._remote_id = remote_id.map(AnyString.init)
        self._full_name = full_name.map(AnyString.init)
        self._email = email.map(AnyString.init)
        self._fail_count = fail_count.map(AnyInt.init)
        self.lockout_at = lockout_at
    }

}

public struct UserPublic: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case _first_name = "first_name"
        case _last_name = "last_name"
        case _display_name = "display_name"
        case _avatar_url = "avatar_url"
        case _url = "url"
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _first_name: AnyString?
    /**
     * First Name (read-only)
     */
    public var first_name: String? {
        get { _first_name?.value }
        set { _first_name = newValue.map(AnyString.init) }
    }

    private var _last_name: AnyString?
    /**
     * Last Name (read-only)
     */
    public var last_name: String? {
        get { _last_name?.value }
        set { _last_name = newValue.map(AnyString.init) }
    }

    private var _display_name: AnyString?
    /**
     * Full name for display (available only if both first_name and last_name are set) (read-only)
     */
    public var display_name: String? {
        get { _display_name?.value }
        set { _display_name = newValue.map(AnyString.init) }
    }

    private var _avatar_url: AnyString?
    /**
     * URL for the avatar image (may be generic) (read-only)
     */
    public var avatar_url: String? {
        get { _avatar_url?.value }
        set { _avatar_url = newValue.map(AnyString.init) }
    }

    private var _url: AnyString?
    /**
     * Link to get this item (read-only)
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, first_name: String? = nil, last_name: String? = nil, display_name: String? = nil, avatar_url: String? = nil, url: String? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self._first_name = first_name.map(AnyString.init)
        self._last_name = last_name.map(AnyString.init)
        self._display_name = display_name.map(AnyString.init)
        self._avatar_url = avatar_url.map(AnyString.init)
        self._url = url.map(AnyString.init)
    }

}

public struct ValidationError: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _message = "message"
        case errors
        case _documentation_url = "documentation_url"
    }
    private var _message: AnyString
    /**
     * Error details (read-only)
     */
    public var message: String {
        get { _message.value }
        set { _message = AnyString.init(newValue) }
    }

    /**
     * Error detail array (read-only)
     */
    public var errors: [ValidationErrorDetail]?

    private var _documentation_url: AnyString
    /**
     * Documentation link (read-only)
     */
    public var documentation_url: String {
        get { _documentation_url.value }
        set { _documentation_url = AnyString.init(newValue) }
    }

    public init(message: String, errors: [ValidationErrorDetail]? = nil, documentation_url: String) {
        self._message = AnyString.init(message)
        self.errors = errors
        self._documentation_url = AnyString.init(documentation_url)
    }

    public init(_ message: String, errors: [ValidationErrorDetail]? = nil, _ documentation_url: String) {
        self.init(message: message, errors: errors, documentation_url: documentation_url)
    }

}

public struct ValidationErrorDetail: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _field = "field"
        case _code = "code"
        case _message = "message"
        case _documentation_url = "documentation_url"
    }
    private var _field: AnyString?
    /**
     * Field with error (read-only)
     */
    public var field: String? {
        get { _field?.value }
        set { _field = newValue.map(AnyString.init) }
    }

    private var _code: AnyString?
    /**
     * Error code (read-only)
     */
    public var code: String? {
        get { _code?.value }
        set { _code = newValue.map(AnyString.init) }
    }

    private var _message: AnyString?
    /**
     * Error info message (read-only)
     */
    public var message: String? {
        get { _message?.value }
        set { _message = newValue.map(AnyString.init) }
    }

    private var _documentation_url: AnyString
    /**
     * Documentation link (read-only)
     */
    public var documentation_url: String {
        get { _documentation_url.value }
        set { _documentation_url = AnyString.init(newValue) }
    }

    public init(field: String? = nil, code: String? = nil, message: String? = nil, documentation_url: String) {
        self._field = field.map(AnyString.init)
        self._code = code.map(AnyString.init)
        self._message = message.map(AnyString.init)
        self._documentation_url = AnyString.init(documentation_url)
    }

    public init(field: String? = nil, code: String? = nil, message: String? = nil, _ documentation_url: String) {
        self.init(field: field, code: code, message: message, documentation_url: documentation_url)
    }

}

/**
 * The name of the starting day of the week. Valid values are: "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday". (Enum defined in LookmlModelExploreField)
 */
public enum WeekStartDay: String, Codable {
    case monday = "monday"
    case tuesday = "tuesday"
    case wednesday = "wednesday"
    case thursday = "thursday"
    case friday = "friday"
    case saturday = "saturday"
    case sunday = "sunday"
}

public struct WelcomeEmailTest: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _content = "content"
        case _subject = "subject"
        case _header = "header"
    }
    private var _content: AnyString?
    /**
     * The content that would be sent in the body of a custom welcome email
     */
    public var content: String? {
        get { _content?.value }
        set { _content = newValue.map(AnyString.init) }
    }

    private var _subject: AnyString?
    /**
     * The subject that would be sent for the custom welcome email
     */
    public var subject: String? {
        get { _subject?.value }
        set { _subject = newValue.map(AnyString.init) }
    }

    private var _header: AnyString?
    /**
     * The header that would be sent in the body of a custom welcome email
     */
    public var header: String? {
        get { _header?.value }
        set { _header = newValue.map(AnyString.init) }
    }

    public init(content: String? = nil, subject: String? = nil, header: String? = nil) {
        self._content = content.map(AnyString.init)
        self._subject = subject.map(AnyString.init)
        self._header = header.map(AnyString.init)
    }

}

public struct WhitelabelConfiguration: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _id = "id"
        case _logo_file = "logo_file"
        case _logo_url = "logo_url"
        case _favicon_file = "favicon_file"
        case _favicon_url = "favicon_url"
        case _default_title = "default_title"
        case show_help_menu
        case show_docs
        case show_email_sub_options
        case allow_looker_mentions
        case allow_looker_links
        case custom_welcome_email_advanced
        case setup_mentions
        case alerts_logo
        case alerts_links
        case folders_mentions
    }
    private var _id: AnyString?
    /**
     * Unique Id (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    private var _logo_file: AnyString?
    /**
     * Customer logo image. Expected base64 encoded data (write-only)
     */
    public var logo_file: String? {
        get { _logo_file?.value }
        set { _logo_file = newValue.map(AnyString.init) }
    }

    private var _logo_url: AnyString?
    /**
     * Logo image url (read-only) (read-only)
     */
    public var logo_url: String? {
        get { _logo_url?.value }
        set { _logo_url = newValue.map(AnyString.init) }
    }

    private var _favicon_file: AnyString?
    /**
     * Custom favicon image. Expected base64 encoded data (write-only)
     */
    public var favicon_file: String? {
        get { _favicon_file?.value }
        set { _favicon_file = newValue.map(AnyString.init) }
    }

    private var _favicon_url: AnyString?
    /**
     * Favicon image url (read-only) (read-only)
     */
    public var favicon_url: String? {
        get { _favicon_url?.value }
        set { _favicon_url = newValue.map(AnyString.init) }
    }

    private var _default_title: AnyString?
    /**
     * Default page title
     */
    public var default_title: String? {
        get { _default_title?.value }
        set { _default_title = newValue.map(AnyString.init) }
    }

    /**
     * Boolean to toggle showing help menus
     */
    public var show_help_menu: Bool?

    /**
     * Boolean to toggle showing docs
     */
    public var show_docs: Bool?

    /**
     * Boolean to toggle showing email subscription options.
     */
    public var show_email_sub_options: Bool?

    /**
     * Boolean to toggle mentions of Looker in emails
     */
    public var allow_looker_mentions: Bool?

    /**
     * Boolean to toggle links to Looker in emails
     */
    public var allow_looker_links: Bool?

    /**
     * Allow subject line and email heading customization in customized emails
     */
    public var custom_welcome_email_advanced: Bool?

    /**
     * Remove the word Looker from appearing in the account setup page
     */
    public var setup_mentions: Bool?

    /**
     * Remove Looker logo from Alerts
     */
    public var alerts_logo: Bool?

    /**
     * Remove Looker links from Alerts
     */
    public var alerts_links: Bool?

    /**
     * Remove Looker mentions in home folder page when you dont have any items saved
     */
    public var folders_mentions: Bool?

    public init(id: String? = nil, logo_file: String? = nil, logo_url: String? = nil, favicon_file: String? = nil, favicon_url: String? = nil, default_title: String? = nil, show_help_menu: Bool? = nil, show_docs: Bool? = nil, show_email_sub_options: Bool? = nil, allow_looker_mentions: Bool? = nil, allow_looker_links: Bool? = nil, custom_welcome_email_advanced: Bool? = nil, setup_mentions: Bool? = nil, alerts_logo: Bool? = nil, alerts_links: Bool? = nil, folders_mentions: Bool? = nil) {
        self._id = id.map(AnyString.init)
        self._logo_file = logo_file.map(AnyString.init)
        self._logo_url = logo_url.map(AnyString.init)
        self._favicon_file = favicon_file.map(AnyString.init)
        self._favicon_url = favicon_url.map(AnyString.init)
        self._default_title = default_title.map(AnyString.init)
        self.show_help_menu = show_help_menu
        self.show_docs = show_docs
        self.show_email_sub_options = show_email_sub_options
        self.allow_looker_mentions = allow_looker_mentions
        self.allow_looker_links = allow_looker_links
        self.custom_welcome_email_advanced = custom_welcome_email_advanced
        self.setup_mentions = setup_mentions
        self.alerts_logo = alerts_logo
        self.alerts_links = alerts_links
        self.folders_mentions = folders_mentions
    }

}

public struct Workspace: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can
        case _id = "id"
        case projects
    }
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    private var _id: AnyString?
    /**
     * The unique id of this user workspace. Predefined workspace ids include "production" and "dev" (read-only)
     */
    public var id: String? {
        get { _id?.value }
        set { _id = newValue.map(AnyString.init) }
    }

    /**
     * The local state of each project in the workspace (read-only)
     */
    public var projects: [Project]?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, projects: [Project]? = nil) {
        self.can = can
        self._id = id.map(AnyString.init)
        self.projects = projects
    }

}

/**
 * Dynamic writeable type for Alert removes:
 * followed, followable, id, investigative_content_title, owner_display_name
 */
public struct WriteAlert: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case applied_dashboard_filters
        case comparison_type
        case _cron = "cron"
        case _custom_url_base = "custom_url_base"
        case _custom_url_params = "custom_url_params"
        case _custom_url_label = "custom_url_label"
        case show_custom_url
        case _custom_title = "custom_title"
        case _dashboard_element_id = "dashboard_element_id"
        case _description = "description"
        case destinations
        case field
        case is_disabled
        case _disabled_reason = "disabled_reason"
        case is_public
        case investigative_content_type
        case _investigative_content_id = "investigative_content_id"
        case _lookml_dashboard_id = "lookml_dashboard_id"
        case _lookml_link_id = "lookml_link_id"
        case _owner_id = "owner_id"
        case threshold
        case time_series_condition_state
    }
    /**
     * Filters coming from the dashboard that are applied. Example `[{ "filter_title": "Name", "field_name": "distribution_centers.name", "filter_value": "Los Angeles CA" }]`
     */
    public var applied_dashboard_filters: [AlertAppliedDashboardFilter]?

    /**
     * This property informs the check what kind of comparison we are performing. Only certain condition types are valid for time series alerts. For details, refer to [Setting Alert Conditions](https://cloud.google.com/looker/docs/sharing-and-publishing/creating-alerts#setting_alert_conditions) Valid values are: "EQUAL_TO", "GREATER_THAN", "GREATER_THAN_OR_EQUAL_TO", "LESS_THAN", "LESS_THAN_OR_EQUAL_TO", "INCREASES_BY", "DECREASES_BY", "CHANGES_BY".
     */
    public var comparison_type: ComparisonType

    private var _cron: AnyString
    /**
     * Vixie-Style crontab specification when to run. At minimum, it has to be longer than 15 minute intervals
     */
    public var cron: String {
        get { _cron.value }
        set { _cron = AnyString.init(newValue) }
    }

    private var _custom_url_base: AnyString?
    /**
     * Domain for the custom url selected by the alert creator from the admin defined domain allowlist
     */
    public var custom_url_base: String? {
        get { _custom_url_base?.value }
        set { _custom_url_base = newValue.map(AnyString.init) }
    }

    private var _custom_url_params: AnyString?
    /**
     * Parameters and path for the custom url defined by the alert creator
     */
    public var custom_url_params: String? {
        get { _custom_url_params?.value }
        set { _custom_url_params = newValue.map(AnyString.init) }
    }

    private var _custom_url_label: AnyString?
    /**
     * Label for the custom url defined by the alert creator
     */
    public var custom_url_label: String? {
        get { _custom_url_label?.value }
        set { _custom_url_label = newValue.map(AnyString.init) }
    }

    /**
     * Boolean to determine if the custom url should be used
     */
    public var show_custom_url: Bool?

    private var _custom_title: AnyString?
    /**
     * An optional, user-defined title for the alert
     */
    public var custom_title: String? {
        get { _custom_title?.value }
        set { _custom_title = newValue.map(AnyString.init) }
    }

    private var _dashboard_element_id: AnyString?
    /**
     * ID of the dashboard element associated with the alert. Refer to [dashboard_element()](#!/Dashboard/DashboardElement)
     */
    public var dashboard_element_id: String? {
        get { _dashboard_element_id?.value }
        set { _dashboard_element_id = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * An optional description for the alert. This supplements the title
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    /**
     * Array of destinations to send alerts to. Must be the same type of destination. Example `[{ "destination_type": "EMAIL", "email_address": "test@test.com" }]`
     */
    public var destinations: [AlertDestination]

    public var field: AlertField

    /**
     * Whether or not the alert is disabled
     */
    public var is_disabled: Bool?

    private var _disabled_reason: AnyString?
    /**
     * Reason for disabling alert
     */
    public var disabled_reason: String? {
        get { _disabled_reason?.value }
        set { _disabled_reason = newValue.map(AnyString.init) }
    }

    /**
     * Whether or not the alert is public
     */
    public var is_public: Bool?

    /**
     * The type of the investigative content Valid values are: "dashboard".
     */
    public var investigative_content_type: InvestigativeContentType?

    private var _investigative_content_id: AnyString?
    /**
     * The ID of the investigative content. For dashboards, this will be the dashboard ID
     */
    public var investigative_content_id: String? {
        get { _investigative_content_id?.value }
        set { _investigative_content_id = newValue.map(AnyString.init) }
    }

    private var _lookml_dashboard_id: AnyString?
    /**
     * ID of the LookML dashboard associated with the alert
     */
    public var lookml_dashboard_id: String? {
        get { _lookml_dashboard_id?.value }
        set { _lookml_dashboard_id = newValue.map(AnyString.init) }
    }

    private var _lookml_link_id: AnyString?
    /**
     * ID of the LookML dashboard element associated with the alert
     */
    public var lookml_link_id: String? {
        get { _lookml_link_id?.value }
        set { _lookml_link_id = newValue.map(AnyString.init) }
    }

    private var _owner_id: AnyString
    /**
     * User id of alert owner
     */
    public var owner_id: String {
        get { _owner_id.value }
        set { _owner_id = AnyString.init(newValue) }
    }

    /**
     * Value of the alert threshold
     */
    public var threshold: Double

    public var time_series_condition_state: AlertConditionState?

    public init(applied_dashboard_filters: [AlertAppliedDashboardFilter]? = nil, comparison_type: ComparisonType, cron: String, custom_url_base: String? = nil, custom_url_params: String? = nil, custom_url_label: String? = nil, show_custom_url: Bool? = nil, custom_title: String? = nil, dashboard_element_id: String? = nil, description: String? = nil, destinations: [AlertDestination], field: AlertField, is_disabled: Bool? = nil, disabled_reason: String? = nil, is_public: Bool? = nil, investigative_content_type: InvestigativeContentType? = nil, investigative_content_id: String? = nil, lookml_dashboard_id: String? = nil, lookml_link_id: String? = nil, owner_id: String, threshold: Double, time_series_condition_state: AlertConditionState? = nil) {
        self.applied_dashboard_filters = applied_dashboard_filters
        self.comparison_type = comparison_type
        self._cron = AnyString.init(cron)
        self._custom_url_base = custom_url_base.map(AnyString.init)
        self._custom_url_params = custom_url_params.map(AnyString.init)
        self._custom_url_label = custom_url_label.map(AnyString.init)
        self.show_custom_url = show_custom_url
        self._custom_title = custom_title.map(AnyString.init)
        self._dashboard_element_id = dashboard_element_id.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self.destinations = destinations
        self.field = field
        self.is_disabled = is_disabled
        self._disabled_reason = disabled_reason.map(AnyString.init)
        self.is_public = is_public
        self.investigative_content_type = investigative_content_type
        self._investigative_content_id = investigative_content_id.map(AnyString.init)
        self._lookml_dashboard_id = lookml_dashboard_id.map(AnyString.init)
        self._lookml_link_id = lookml_link_id.map(AnyString.init)
        self._owner_id = AnyString.init(owner_id)
        self.threshold = threshold
        self.time_series_condition_state = time_series_condition_state
    }

    public init(applied_dashboard_filters: [AlertAppliedDashboardFilter]? = nil, _ comparison_type: ComparisonType, _ cron: String, custom_url_base: String? = nil, custom_url_params: String? = nil, custom_url_label: String? = nil, show_custom_url: Bool? = nil, custom_title: String? = nil, dashboard_element_id: String? = nil, description: String? = nil, _ destinations: [AlertDestination], _ field: AlertField, is_disabled: Bool? = nil, disabled_reason: String? = nil, is_public: Bool? = nil, investigative_content_type: InvestigativeContentType? = nil, investigative_content_id: String? = nil, lookml_dashboard_id: String? = nil, lookml_link_id: String? = nil, _ owner_id: String, _ threshold: Double, time_series_condition_state: AlertConditionState? = nil) {
        self.init(applied_dashboard_filters: applied_dashboard_filters, comparison_type: comparison_type, cron: cron, custom_url_base: custom_url_base, custom_url_params: custom_url_params, custom_url_label: custom_url_label, show_custom_url: show_custom_url, custom_title: custom_title, dashboard_element_id: dashboard_element_id, description: description, destinations: destinations, field: field, is_disabled: is_disabled, disabled_reason: disabled_reason, is_public: is_public, investigative_content_type: investigative_content_type, investigative_content_id: investigative_content_id, lookml_dashboard_id: lookml_dashboard_id, lookml_link_id: lookml_link_id, owner_id: owner_id, threshold: threshold, time_series_condition_state: time_series_condition_state)
    }

}

/**
 * Dynamic writeable type for ApiSession removes:
 * can, sudo_user_id
 */
public struct WriteApiSession: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _workspace_id = "workspace_id"
    }
    private var _workspace_id: AnyString?
    /**
     * The id of active workspace for this session
     */
    public var workspace_id: String? {
        get { _workspace_id?.value }
        set { _workspace_id = newValue.map(AnyString.init) }
    }

    public init(workspace_id: String? = nil) {
        self._workspace_id = workspace_id.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for BackupConfiguration removes:
 * can, url
 */
public struct WriteBackupConfiguration: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _type = "type"
        case _custom_s3_bucket = "custom_s3_bucket"
        case _custom_s3_bucket_region = "custom_s3_bucket_region"
        case _custom_s3_key = "custom_s3_key"
        case _custom_s3_secret = "custom_s3_secret"
    }
    private var _type: AnyString?
    /**
     * Type of backup: looker-s3 or custom-s3
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _custom_s3_bucket: AnyString?
    /**
     * Name of bucket for custom-s3 backups
     */
    public var custom_s3_bucket: String? {
        get { _custom_s3_bucket?.value }
        set { _custom_s3_bucket = newValue.map(AnyString.init) }
    }

    private var _custom_s3_bucket_region: AnyString?
    /**
     * Name of region where the bucket is located
     */
    public var custom_s3_bucket_region: String? {
        get { _custom_s3_bucket_region?.value }
        set { _custom_s3_bucket_region = newValue.map(AnyString.init) }
    }

    private var _custom_s3_key: AnyString?
    /**
     * (Write-Only) AWS S3 key used for custom-s3 backups
     */
    public var custom_s3_key: String? {
        get { _custom_s3_key?.value }
        set { _custom_s3_key = newValue.map(AnyString.init) }
    }

    private var _custom_s3_secret: AnyString?
    /**
     * (Write-Only) AWS S3 secret used for custom-s3 backups
     */
    public var custom_s3_secret: String? {
        get { _custom_s3_secret?.value }
        set { _custom_s3_secret = newValue.map(AnyString.init) }
    }

    public init(type: String? = nil, custom_s3_bucket: String? = nil, custom_s3_bucket_region: String? = nil, custom_s3_key: String? = nil, custom_s3_secret: String? = nil) {
        self._type = type.map(AnyString.init)
        self._custom_s3_bucket = custom_s3_bucket.map(AnyString.init)
        self._custom_s3_bucket_region = custom_s3_bucket_region.map(AnyString.init)
        self._custom_s3_key = custom_s3_key.map(AnyString.init)
        self._custom_s3_secret = custom_s3_secret.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for Board removes:
 * can, content_metadata_id, created_at, board_sections, id, updated_at, user_id, primary_homepage
 */
public struct WriteBoard: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case deleted_at
        case _description = "description"
        case _section_order = "section_order"
        case _title = "title"
    }
    /**
     * Date of board deletion
     */
    public var deleted_at: Date?

    private var _description: AnyString?
    /**
     * Description of the board
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    private var _section_order: [AnyString]?
    /**
     * ids of the board sections in the order they should be displayed
     */
    public var section_order: [String]? {
        get { if let v = _section_order { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _section_order = v.map { AnyString.init($0) } } else { _section_order = nil } }
    }

    private var _title: AnyString?
    /**
     * Title of the board
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    public init(deleted_at: Date? = nil, description: String? = nil, section_order: [String]? = nil, title: String? = nil) {
        self.deleted_at = deleted_at
        self._description = description.map(AnyString.init)
        if let v = section_order { _section_order = v.map { AnyString.init($0) } } else { _section_order = nil }
        self._title = title.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for BoardItem removes:
 * can, content_created_by, content_favorite_id, content_metadata_id, content_updated_at, description, favorite_count, id, image_url, location, title, url, view_count, custom_image_url
 */
public struct WriteBoardItem: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _custom_description = "custom_description"
        case _custom_title = "custom_title"
        case _custom_url = "custom_url"
        case _dashboard_id = "dashboard_id"
        case _board_section_id = "board_section_id"
        case _look_id = "look_id"
        case _lookml_dashboard_id = "lookml_dashboard_id"
        case _order = "order"
        case use_custom_description
        case use_custom_title
        case use_custom_url
        case _custom_image_data_base64 = "custom_image_data_base64"
        case use_custom_image
    }
    private var _custom_description: AnyString?
    /**
     * Custom description entered by the user, if present
     */
    public var custom_description: String? {
        get { _custom_description?.value }
        set { _custom_description = newValue.map(AnyString.init) }
    }

    private var _custom_title: AnyString?
    /**
     * Custom title entered by the user, if present
     */
    public var custom_title: String? {
        get { _custom_title?.value }
        set { _custom_title = newValue.map(AnyString.init) }
    }

    private var _custom_url: AnyString?
    /**
     * Custom url entered by the user, if present
     */
    public var custom_url: String? {
        get { _custom_url?.value }
        set { _custom_url = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString?
    /**
     * Dashboard to base this item on
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    private var _board_section_id: AnyString?
    /**
     * Associated Board Section
     */
    public var board_section_id: String? {
        get { _board_section_id?.value }
        set { _board_section_id = newValue.map(AnyString.init) }
    }

    private var _look_id: AnyString?
    /**
     * Look to base this item on
     */
    public var look_id: String? {
        get { _look_id?.value }
        set { _look_id = newValue.map(AnyString.init) }
    }

    private var _lookml_dashboard_id: AnyString?
    /**
     * LookML Dashboard to base this item on
     */
    public var lookml_dashboard_id: String? {
        get { _lookml_dashboard_id?.value }
        set { _lookml_dashboard_id = newValue.map(AnyString.init) }
    }

    private var _order: AnyInt?
    /**
     * An arbitrary integer representing the sort order within the section
     */
    public var order: Int64? {
        get { _order?.value }
        set { _order = newValue.map(AnyInt.init) }
    }

    /**
     * Whether the custom description should be used instead of the content description, if the item is associated with content
     */
    public var use_custom_description: Bool?

    /**
     * Whether the custom title should be used instead of the content title, if the item is associated with content
     */
    public var use_custom_title: Bool?

    /**
     * Whether the custom url should be used instead of the content url, if the item is associated with content
     */
    public var use_custom_url: Bool?

    private var _custom_image_data_base64: AnyString?
    /**
     * (Write-Only) base64 encoded image data
     */
    public var custom_image_data_base64: String? {
        get { _custom_image_data_base64?.value }
        set { _custom_image_data_base64 = newValue.map(AnyString.init) }
    }

    /**
     * Whether the custom image should be used instead of the content image, if the item is associated with content
     */
    public var use_custom_image: Bool?

    public init(custom_description: String? = nil, custom_title: String? = nil, custom_url: String? = nil, dashboard_id: String? = nil, board_section_id: String? = nil, look_id: String? = nil, lookml_dashboard_id: String? = nil, order: Int64? = nil, use_custom_description: Bool? = nil, use_custom_title: Bool? = nil, use_custom_url: Bool? = nil, custom_image_data_base64: String? = nil, use_custom_image: Bool? = nil) {
        self._custom_description = custom_description.map(AnyString.init)
        self._custom_title = custom_title.map(AnyString.init)
        self._custom_url = custom_url.map(AnyString.init)
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self._board_section_id = board_section_id.map(AnyString.init)
        self._look_id = look_id.map(AnyString.init)
        self._lookml_dashboard_id = lookml_dashboard_id.map(AnyString.init)
        self._order = order.map(AnyInt.init)
        self.use_custom_description = use_custom_description
        self.use_custom_title = use_custom_title
        self.use_custom_url = use_custom_url
        self._custom_image_data_base64 = custom_image_data_base64.map(AnyString.init)
        self.use_custom_image = use_custom_image
    }

}

/**
 * Dynamic writeable type for BoardSection removes:
 * can, created_at, board_items, id, visible_item_order, updated_at
 */
public struct WriteBoardSection: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case deleted_at
        case _description = "description"
        case _board_id = "board_id"
        case _item_order = "item_order"
        case _title = "title"
    }
    /**
     * Time at which this section was deleted.
     */
    public var deleted_at: Date?

    private var _description: AnyString?
    /**
     * Description of the content found in this section.
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    private var _board_id: AnyString?
    /**
     * Id reference to parent board
     */
    public var board_id: String? {
        get { _board_id?.value }
        set { _board_id = newValue.map(AnyString.init) }
    }

    private var _item_order: [AnyString]?
    /**
     * ids of the board items in the order they should be displayed
     */
    public var item_order: [String]? {
        get { if let v = _item_order { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _item_order = v.map { AnyString.init($0) } } else { _item_order = nil } }
    }

    private var _title: AnyString?
    /**
     * Name of row
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    public init(deleted_at: Date? = nil, description: String? = nil, board_id: String? = nil, item_order: [String]? = nil, title: String? = nil) {
        self.deleted_at = deleted_at
        self._description = description.map(AnyString.init)
        self._board_id = board_id.map(AnyString.init)
        if let v = item_order { _item_order = v.map { AnyString.init($0) } } else { _item_order = nil }
        self._title = title.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for ColorCollection removes:
 * id
 */
public struct WriteColorCollection: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _label = "label"
        case categoricalPalettes
        case sequentialPalettes
        case divergingPalettes
    }
    private var _label: AnyString?
    /**
     * Label of color collection
     */
    public var label: String? {
        get { _label?.value }
        set { _label = newValue.map(AnyString.init) }
    }

    /**
     * Array of categorical palette definitions
     */
    public var categoricalPalettes: [DiscretePalette]?

    /**
     * Array of discrete palette definitions
     */
    public var sequentialPalettes: [ContinuousPalette]?

    /**
     * Array of diverging palette definitions
     */
    public var divergingPalettes: [ContinuousPalette]?

    public init(label: String? = nil, categoricalPalettes: [DiscretePalette]? = nil, sequentialPalettes: [ContinuousPalette]? = nil, divergingPalettes: [ContinuousPalette]? = nil) {
        self._label = label.map(AnyString.init)
        self.categoricalPalettes = categoricalPalettes
        self.sequentialPalettes = sequentialPalettes
        self.divergingPalettes = divergingPalettes
    }

}

/**
 * Dynamic writeable type for ContentFavorite removes:
 * id, look_id, dashboard_id, board_id
 */
public struct WriteContentFavorite: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _user_id = "user_id"
        case _content_metadata_id = "content_metadata_id"
        case look
        case dashboard
    }
    private var _user_id: AnyString?
    /**
     * User Id which owns this ContentFavorite
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    private var _content_metadata_id: AnyString?
    /**
     * Content Metadata Id associated with this ContentFavorite
     */
    public var content_metadata_id: String? {
        get { _content_metadata_id?.value }
        set { _content_metadata_id = newValue.map(AnyString.init) }
    }

    /**
     * Dynamic writeable type for LookBasic removes:
     * can, content_metadata_id, id, title
     */
    public var look: WriteLookBasic?

    /**
     * Dynamic writeable type for DashboardBase removes:
     * can, content_favorite_id, content_metadata_id, description, hidden, id, model, query_timezone, readonly, refresh_interval, refresh_interval_to_i, title, user_id, slug, preferred_viewer
     */
    public var dashboard: WriteDashboardBase?

    public init(user_id: String? = nil, content_metadata_id: String? = nil, look: WriteLookBasic? = nil, dashboard: WriteDashboardBase? = nil) {
        self._user_id = user_id.map(AnyString.init)
        self._content_metadata_id = content_metadata_id.map(AnyString.init)
        self.look = look
        self.dashboard = dashboard
    }

}

/**
 * Dynamic writeable type for ContentMeta removes:
 * can, id, name, parent_id, dashboard_id, look_id, folder_id, content_type, inheriting_id, slug
 */
public struct WriteContentMeta: SDKModel {
    /**
     * Whether content inherits its access levels from parent
     */
    public var inherits: Bool?

    public init(inherits: Bool? = nil) {
        self.inherits = inherits
    }

}

/**
 * Dynamic writeable type for CreateDashboardFilter removes:
 * id, field
 */
public struct WriteCreateDashboardFilter: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _dashboard_id = "dashboard_id"
        case _name = "name"
        case _title = "title"
        case _type = "type"
        case _default_value = "default_value"
        case _model = "model"
        case _explore = "explore"
        case _dimension = "dimension"
        case _row = "row"
        case _listens_to_filters = "listens_to_filters"
        case allow_multiple_values
        case required
        case ui_config
    }
    private var _dashboard_id: AnyString
    /**
     * Id of Dashboard
     */
    public var dashboard_id: String {
        get { _dashboard_id.value }
        set { _dashboard_id = AnyString.init(newValue) }
    }

    private var _name: AnyString
    /**
     * Name of filter
     */
    public var name: String {
        get { _name.value }
        set { _name = AnyString.init(newValue) }
    }

    private var _title: AnyString
    /**
     * Title of filter
     */
    public var title: String {
        get { _title.value }
        set { _title = AnyString.init(newValue) }
    }

    private var _type: AnyString
    /**
     * Type of filter: one of date, number, string, or field
     */
    public var type: String {
        get { _type.value }
        set { _type = AnyString.init(newValue) }
    }

    private var _default_value: AnyString?
    /**
     * Default value of filter
     */
    public var default_value: String? {
        get { _default_value?.value }
        set { _default_value = newValue.map(AnyString.init) }
    }

    private var _model: AnyString?
    /**
     * Model of filter (required if type = field)
     */
    public var model: String? {
        get { _model?.value }
        set { _model = newValue.map(AnyString.init) }
    }

    private var _explore: AnyString?
    /**
     * Explore of filter (required if type = field)
     */
    public var explore: String? {
        get { _explore?.value }
        set { _explore = newValue.map(AnyString.init) }
    }

    private var _dimension: AnyString?
    /**
     * Dimension of filter (required if type = field)
     */
    public var dimension: String? {
        get { _dimension?.value }
        set { _dimension = newValue.map(AnyString.init) }
    }

    private var _row: AnyInt?
    /**
     * Display order of this filter relative to other filters
     */
    public var row: Int64? {
        get { _row?.value }
        set { _row = newValue.map(AnyInt.init) }
    }

    private var _listens_to_filters: [AnyString]?
    /**
     * Array of listeners for faceted filters
     */
    public var listens_to_filters: [String]? {
        get { if let v = _listens_to_filters { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _listens_to_filters = v.map { AnyString.init($0) } } else { _listens_to_filters = nil } }
    }

    /**
     * Whether the filter allows multiple filter values (deprecated in the latest version of dashboards)
     */
    public var allow_multiple_values: Bool?

    /**
     * Whether the filter requires a value to run the dashboard
     */
    public var required: Bool?

    /**
     * The visual configuration for this filter. Used to set up how the UI for this filter should appear.
     */
    public var ui_config: StringDictionary<AnyCodable>?

    public init(dashboard_id: String, name: String, title: String, type: String, default_value: String? = nil, model: String? = nil, explore: String? = nil, dimension: String? = nil, row: Int64? = nil, listens_to_filters: [String]? = nil, allow_multiple_values: Bool? = nil, required: Bool? = nil, ui_config: StringDictionary<AnyCodable>? = nil) {
        self._dashboard_id = AnyString.init(dashboard_id)
        self._name = AnyString.init(name)
        self._title = AnyString.init(title)
        self._type = AnyString.init(type)
        self._default_value = default_value.map(AnyString.init)
        self._model = model.map(AnyString.init)
        self._explore = explore.map(AnyString.init)
        self._dimension = dimension.map(AnyString.init)
        self._row = row.map(AnyInt.init)
        if let v = listens_to_filters { _listens_to_filters = v.map { AnyString.init($0) } } else { _listens_to_filters = nil }
        self.allow_multiple_values = allow_multiple_values
        self.required = required
        self.ui_config = ui_config
    }

    public init(_ dashboard_id: String, _ name: String, _ title: String, _ type: String, default_value: String? = nil, model: String? = nil, explore: String? = nil, dimension: String? = nil, row: Int64? = nil, listens_to_filters: [String]? = nil, allow_multiple_values: Bool? = nil, required: Bool? = nil, ui_config: StringDictionary<AnyCodable>? = nil) {
        self.init(dashboard_id: dashboard_id, name: name, title: title, type: type, default_value: default_value, model: model, explore: explore, dimension: dimension, row: row, listens_to_filters: listens_to_filters, allow_multiple_values: allow_multiple_values, required: required, ui_config: ui_config)
    }

}

/**
 * Dynamic writeable type for CreateQueryTask removes:
 * can
 */
public struct WriteCreateQueryTask: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _query_id = "query_id"
        case result_format
        case _source = "source"
        case deferred
        case _look_id = "look_id"
        case _dashboard_id = "dashboard_id"
    }
    private var _query_id: AnyString
    /**
     * Id of query to run
     */
    public var query_id: String {
        get { _query_id.value }
        set { _query_id = AnyString.init(newValue) }
    }

    /**
     * Desired async query result format. Valid values are: "inline_json", "json", "json_detail", "json_fe", "json_bi", "csv", "html", "md", "txt", "xlsx", "gsxml", "sql", "odc".
     */
    public var result_format: ResultFormat

    private var _source: AnyString?
    /**
     * Source of query task
     */
    public var source: String? {
        get { _source?.value }
        set { _source = newValue.map(AnyString.init) }
    }

    /**
     * Create the task but defer execution
     */
    public var deferred: Bool?

    private var _look_id: AnyString?
    /**
     * Id of look associated with query.
     */
    public var look_id: String? {
        get { _look_id?.value }
        set { _look_id = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString?
    /**
     * Id of dashboard associated with query.
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    public init(query_id: String, result_format: ResultFormat, source: String? = nil, deferred: Bool? = nil, look_id: String? = nil, dashboard_id: String? = nil) {
        self._query_id = AnyString.init(query_id)
        self.result_format = result_format
        self._source = source.map(AnyString.init)
        self.deferred = deferred
        self._look_id = look_id.map(AnyString.init)
        self._dashboard_id = dashboard_id.map(AnyString.init)
    }

    public init(_ query_id: String, _ result_format: ResultFormat, source: String? = nil, deferred: Bool? = nil, look_id: String? = nil, dashboard_id: String? = nil) {
        self.init(query_id: query_id, result_format: result_format, source: source, deferred: deferred, look_id: look_id, dashboard_id: dashboard_id)
    }

}

/**
 * Dynamic writeable type for CredentialsEmail removes:
 * can, created_at, user_id, is_disabled, logged_in_at, password_reset_url, account_setup_url, password_reset_url_expired, account_setup_url_expired, type, url, user_url
 */
public struct WriteCredentialsEmail: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _email = "email"
        case forced_password_reset_at_next_login
    }
    private var _email: AnyString?
    /**
     * EMail address used for user login
     */
    public var email: String? {
        get { _email?.value }
        set { _email = newValue.map(AnyString.init) }
    }

    /**
     * Force the user to change their password upon their next login
     */
    public var forced_password_reset_at_next_login: Bool?

    public init(email: String? = nil, forced_password_reset_at_next_login: Bool? = nil) {
        self._email = email.map(AnyString.init)
        self.forced_password_reset_at_next_login = forced_password_reset_at_next_login
    }

}

/**
 * Dynamic writeable type for Dashboard removes:
 * can, content_favorite_id, content_metadata_id, id, model, readonly, refresh_interval_to_i, user_id, created_at, dashboard_elements, dashboard_filters, dashboard_layouts, deleted_at, deleter_id, edit_uri, favorite_count, last_accessed_at, last_viewed_at, updated_at, last_updater_id, last_updater_name, user_name, view_count, url
 */
public struct WriteDashboard: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _description = "description"
        case hidden
        case _query_timezone = "query_timezone"
        case _refresh_interval = "refresh_interval"
        case folder
        case _title = "title"
        case _slug = "slug"
        case _preferred_viewer = "preferred_viewer"
        case alert_sync_with_dashboard_filter_enabled
        case _background_color = "background_color"
        case crossfilter_enabled
        case deleted
        case enable_viz_full_screen
        case filters_bar_collapsed
        case filters_location_top
        case _load_configuration = "load_configuration"
        case _lookml_link_id = "lookml_link_id"
        case show_filters_bar
        case show_title
        case _folder_id = "folder_id"
        case _text_tile_text_color = "text_tile_text_color"
        case _tile_background_color = "tile_background_color"
        case _tile_text_color = "tile_text_color"
        case _title_color = "title_color"
        case appearance
    }
    private var _description: AnyString?
    /**
     * Description
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    /**
     * Is Hidden
     */
    public var hidden: Bool?

    private var _query_timezone: AnyString?
    /**
     * Timezone in which the Dashboard will run by default.
     */
    public var query_timezone: String? {
        get { _query_timezone?.value }
        set { _query_timezone = newValue.map(AnyString.init) }
    }

    private var _refresh_interval: AnyString?
    /**
     * Refresh Interval, as a time duration phrase like "2 hours 30 minutes". A number with no time units will be interpreted as whole seconds.
     */
    public var refresh_interval: String? {
        get { _refresh_interval?.value }
        set { _refresh_interval = newValue.map(AnyString.init) }
    }

    /**
     * Dynamic writeable type for FolderBase removes:
     * id, content_metadata_id, created_at, creator_id, child_count, external_id, is_embed, is_embed_shared_root, is_embed_users_root, is_personal, is_personal_descendant, is_shared_root, is_users_root, can
     */
    public var folder: WriteFolderBase?

    private var _title: AnyString?
    /**
     * Dashboard Title
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _slug: AnyString?
    /**
     * Content Metadata Slug
     */
    public var slug: String? {
        get { _slug?.value }
        set { _slug = newValue.map(AnyString.init) }
    }

    private var _preferred_viewer: AnyString?
    /**
     * The preferred route for viewing this dashboard (ie: dashboards or dashboards-next)
     */
    public var preferred_viewer: String? {
        get { _preferred_viewer?.value }
        set { _preferred_viewer = newValue.map(AnyString.init) }
    }

    /**
     * Enables alerts to keep in sync with dashboard filter changes
     */
    public var alert_sync_with_dashboard_filter_enabled: Bool?

    private var _background_color: AnyString?
    /**
     * Background color
     */
    public var background_color: String? {
        get { _background_color?.value }
        set { _background_color = newValue.map(AnyString.init) }
    }

    /**
     * Enables crossfiltering in dashboards - only available in dashboards-next (beta)
     */
    public var crossfilter_enabled: Bool?

    /**
     * Whether or not a dashboard is 'soft' deleted.
     */
    public var deleted: Bool?

    /**
     * Allow visualizations to be viewed in full screen mode
     */
    public var enable_viz_full_screen: Bool?

    /**
     * Sets the default state of the filters bar to collapsed or open
     */
    public var filters_bar_collapsed: Bool?

    /**
     * Sets the default state of the filters location to top(true) or right(false)
     */
    public var filters_location_top: Bool?

    private var _load_configuration: AnyString?
    /**
     * configuration option that governs how dashboard loading will happen.
     */
    public var load_configuration: String? {
        get { _load_configuration?.value }
        set { _load_configuration = newValue.map(AnyString.init) }
    }

    private var _lookml_link_id: AnyString?
    /**
     * Links this dashboard to a particular LookML dashboard such that calling a **sync** operation on that LookML dashboard will update this dashboard to match.
     */
    public var lookml_link_id: String? {
        get { _lookml_link_id?.value }
        set { _lookml_link_id = newValue.map(AnyString.init) }
    }

    /**
     * Show filters bar.  **Security Note:** This property only affects the *cosmetic* appearance of the dashboard, not a user's ability to access data. Hiding the filters bar does **NOT** prevent users from changing filters by other means. For information on how to set up secure data access control policies, see [Control User Access to Data](https://cloud.google.com/looker/docs/r/api/control-access)
     */
    public var show_filters_bar: Bool?

    /**
     * Show title
     */
    public var show_title: Bool?

    private var _folder_id: AnyString?
    /**
     * Id of folder
     */
    public var folder_id: String? {
        get { _folder_id?.value }
        set { _folder_id = newValue.map(AnyString.init) }
    }

    private var _text_tile_text_color: AnyString?
    /**
     * Color of text on text tiles
     */
    public var text_tile_text_color: String? {
        get { _text_tile_text_color?.value }
        set { _text_tile_text_color = newValue.map(AnyString.init) }
    }

    private var _tile_background_color: AnyString?
    /**
     * Tile background color
     */
    public var tile_background_color: String? {
        get { _tile_background_color?.value }
        set { _tile_background_color = newValue.map(AnyString.init) }
    }

    private var _tile_text_color: AnyString?
    /**
     * Tile text color
     */
    public var tile_text_color: String? {
        get { _tile_text_color?.value }
        set { _tile_text_color = newValue.map(AnyString.init) }
    }

    private var _title_color: AnyString?
    /**
     * Title color
     */
    public var title_color: String? {
        get { _title_color?.value }
        set { _title_color = newValue.map(AnyString.init) }
    }

    public var appearance: DashboardAppearance?

    public init(description: String? = nil, hidden: Bool? = nil, query_timezone: String? = nil, refresh_interval: String? = nil, folder: WriteFolderBase? = nil, title: String? = nil, slug: String? = nil, preferred_viewer: String? = nil, alert_sync_with_dashboard_filter_enabled: Bool? = nil, background_color: String? = nil, crossfilter_enabled: Bool? = nil, deleted: Bool? = nil, enable_viz_full_screen: Bool? = nil, filters_bar_collapsed: Bool? = nil, filters_location_top: Bool? = nil, load_configuration: String? = nil, lookml_link_id: String? = nil, show_filters_bar: Bool? = nil, show_title: Bool? = nil, folder_id: String? = nil, text_tile_text_color: String? = nil, tile_background_color: String? = nil, tile_text_color: String? = nil, title_color: String? = nil, appearance: DashboardAppearance? = nil) {
        self._description = description.map(AnyString.init)
        self.hidden = hidden
        self._query_timezone = query_timezone.map(AnyString.init)
        self._refresh_interval = refresh_interval.map(AnyString.init)
        self.folder = folder
        self._title = title.map(AnyString.init)
        self._slug = slug.map(AnyString.init)
        self._preferred_viewer = preferred_viewer.map(AnyString.init)
        self.alert_sync_with_dashboard_filter_enabled = alert_sync_with_dashboard_filter_enabled
        self._background_color = background_color.map(AnyString.init)
        self.crossfilter_enabled = crossfilter_enabled
        self.deleted = deleted
        self.enable_viz_full_screen = enable_viz_full_screen
        self.filters_bar_collapsed = filters_bar_collapsed
        self.filters_location_top = filters_location_top
        self._load_configuration = load_configuration.map(AnyString.init)
        self._lookml_link_id = lookml_link_id.map(AnyString.init)
        self.show_filters_bar = show_filters_bar
        self.show_title = show_title
        self._folder_id = folder_id.map(AnyString.init)
        self._text_tile_text_color = text_tile_text_color.map(AnyString.init)
        self._tile_background_color = tile_background_color.map(AnyString.init)
        self._tile_text_color = tile_text_color.map(AnyString.init)
        self._title_color = title_color.map(AnyString.init)
        self.appearance = appearance
    }

}

/**
 * Dynamic writeable type for DashboardBase removes:
 * can, content_favorite_id, content_metadata_id, description, hidden, id, model, query_timezone, readonly, refresh_interval, refresh_interval_to_i, title, user_id, slug, preferred_viewer
 */
public struct WriteDashboardBase: SDKModel {
    /**
     * Dynamic writeable type for FolderBase removes:
     * id, content_metadata_id, created_at, creator_id, child_count, external_id, is_embed, is_embed_shared_root, is_embed_users_root, is_personal, is_personal_descendant, is_shared_root, is_users_root, can
     */
    public var folder: WriteFolderBase?

    public init(folder: WriteFolderBase? = nil) {
        self.folder = folder
    }

}

/**
 * Dynamic writeable type for DashboardElement removes:
 * can, body_text_as_html, edit_uri, id, lookml_link_id, note_text_as_html, refresh_interval_to_i, alert_count, title_text_as_html, subtitle_text_as_html
 */
public struct WriteDashboardElement: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _body_text = "body_text"
        case _dashboard_id = "dashboard_id"
        case look
        case _look_id = "look_id"
        case _merge_result_id = "merge_result_id"
        case _note_display = "note_display"
        case _note_state = "note_state"
        case _note_text = "note_text"
        case query
        case _query_id = "query_id"
        case _refresh_interval = "refresh_interval"
        case result_maker
        case _result_maker_id = "result_maker_id"
        case _subtitle_text = "subtitle_text"
        case _title = "title"
        case title_hidden
        case _title_text = "title_text"
        case _type = "type"
        case _rich_content_json = "rich_content_json"
        case _extension_id = "extension_id"
    }
    private var _body_text: AnyString?
    /**
     * Text tile body text
     */
    public var body_text: String? {
        get { _body_text?.value }
        set { _body_text = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString?
    /**
     * Id of Dashboard
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    /**
     * Dynamic writeable type for LookWithQuery removes:
     * can, content_metadata_id, id, content_favorite_id, created_at, deleted_at, deleter_id, embed_url, excel_file_url, favorite_count, google_spreadsheet_formula, image_embed_url, last_accessed_at, last_updater_id, last_viewed_at, model, public_slug, public_url, short_url, updated_at, user_name, view_count, url
     */
    public var look: WriteLookWithQuery?

    private var _look_id: AnyString?
    /**
     * Id Of Look
     */
    public var look_id: String? {
        get { _look_id?.value }
        set { _look_id = newValue.map(AnyString.init) }
    }

    private var _merge_result_id: AnyString?
    /**
     * ID of merge result
     */
    public var merge_result_id: String? {
        get { _merge_result_id?.value }
        set { _merge_result_id = newValue.map(AnyString.init) }
    }

    private var _note_display: AnyString?
    /**
     * Note Display
     */
    public var note_display: String? {
        get { _note_display?.value }
        set { _note_display = newValue.map(AnyString.init) }
    }

    private var _note_state: AnyString?
    /**
     * Note State
     */
    public var note_state: String? {
        get { _note_state?.value }
        set { _note_state = newValue.map(AnyString.init) }
    }

    private var _note_text: AnyString?
    /**
     * Note Text
     */
    public var note_text: String? {
        get { _note_text?.value }
        set { _note_text = newValue.map(AnyString.init) }
    }

    /**
     * Dynamic writeable type for Query removes:
     * can, id, slug, share_url, expanded_share_url, url, has_table_calculations
     */
    public var query: WriteQuery?

    private var _query_id: AnyString?
    /**
     * Id Of Query
     */
    public var query_id: String? {
        get { _query_id?.value }
        set { _query_id = newValue.map(AnyString.init) }
    }

    private var _refresh_interval: AnyString?
    /**
     * Refresh Interval
     */
    public var refresh_interval: String? {
        get { _refresh_interval?.value }
        set { _refresh_interval = newValue.map(AnyString.init) }
    }

    /**
     * Dynamic writeable type for ResultMakerWithIdVisConfigAndDynamicFields removes:
     * id, dynamic_fields, filterables, sorts, merge_result_id, total, query_id, sql_query_id, vis_config
     */
    public var result_maker: WriteResultMakerWithIdVisConfigAndDynamicFields?

    private var _result_maker_id: AnyString?
    /**
     * ID of the ResultMakerLookup entry.
     */
    public var result_maker_id: String? {
        get { _result_maker_id?.value }
        set { _result_maker_id = newValue.map(AnyString.init) }
    }

    private var _subtitle_text: AnyString?
    /**
     * Text tile subtitle text
     */
    public var subtitle_text: String? {
        get { _subtitle_text?.value }
        set { _subtitle_text = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Title of dashboard element
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    /**
     * Whether title is hidden
     */
    public var title_hidden: Bool?

    private var _title_text: AnyString?
    /**
     * Text tile title
     */
    public var title_text: String? {
        get { _title_text?.value }
        set { _title_text = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * Type
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _rich_content_json: AnyString?
    /**
     * JSON with all the properties required for rich editor and buttons elements
     */
    public var rich_content_json: String? {
        get { _rich_content_json?.value }
        set { _rich_content_json = newValue.map(AnyString.init) }
    }

    private var _extension_id: AnyString?
    /**
     * Extension ID
     */
    public var extension_id: String? {
        get { _extension_id?.value }
        set { _extension_id = newValue.map(AnyString.init) }
    }

    public init(body_text: String? = nil, dashboard_id: String? = nil, look: WriteLookWithQuery? = nil, look_id: String? = nil, merge_result_id: String? = nil, note_display: String? = nil, note_state: String? = nil, note_text: String? = nil, query: WriteQuery? = nil, query_id: String? = nil, refresh_interval: String? = nil, result_maker: WriteResultMakerWithIdVisConfigAndDynamicFields? = nil, result_maker_id: String? = nil, subtitle_text: String? = nil, title: String? = nil, title_hidden: Bool? = nil, title_text: String? = nil, type: String? = nil, rich_content_json: String? = nil, extension_id: String? = nil) {
        self._body_text = body_text.map(AnyString.init)
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self.look = look
        self._look_id = look_id.map(AnyString.init)
        self._merge_result_id = merge_result_id.map(AnyString.init)
        self._note_display = note_display.map(AnyString.init)
        self._note_state = note_state.map(AnyString.init)
        self._note_text = note_text.map(AnyString.init)
        self.query = query
        self._query_id = query_id.map(AnyString.init)
        self._refresh_interval = refresh_interval.map(AnyString.init)
        self.result_maker = result_maker
        self._result_maker_id = result_maker_id.map(AnyString.init)
        self._subtitle_text = subtitle_text.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self.title_hidden = title_hidden
        self._title_text = title_text.map(AnyString.init)
        self._type = type.map(AnyString.init)
        self._rich_content_json = rich_content_json.map(AnyString.init)
        self._extension_id = extension_id.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for DashboardFilter removes:
 * can, id, dashboard_id, field
 */
public struct WriteDashboardFilter: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _title = "title"
        case _type = "type"
        case _default_value = "default_value"
        case _model = "model"
        case _explore = "explore"
        case _dimension = "dimension"
        case _row = "row"
        case _listens_to_filters = "listens_to_filters"
        case allow_multiple_values
        case required
        case ui_config
    }
    private var _name: AnyString?
    /**
     * Name of filter
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _title: AnyString?
    /**
     * Title of filter
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * Type of filter: one of date, number, string, or field
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    private var _default_value: AnyString?
    /**
     * Default value of filter
     */
    public var default_value: String? {
        get { _default_value?.value }
        set { _default_value = newValue.map(AnyString.init) }
    }

    private var _model: AnyString?
    /**
     * Model of filter (required if type = field)
     */
    public var model: String? {
        get { _model?.value }
        set { _model = newValue.map(AnyString.init) }
    }

    private var _explore: AnyString?
    /**
     * Explore of filter (required if type = field)
     */
    public var explore: String? {
        get { _explore?.value }
        set { _explore = newValue.map(AnyString.init) }
    }

    private var _dimension: AnyString?
    /**
     * Dimension of filter (required if type = field)
     */
    public var dimension: String? {
        get { _dimension?.value }
        set { _dimension = newValue.map(AnyString.init) }
    }

    private var _row: AnyInt?
    /**
     * Display order of this filter relative to other filters
     */
    public var row: Int64? {
        get { _row?.value }
        set { _row = newValue.map(AnyInt.init) }
    }

    private var _listens_to_filters: [AnyString]?
    /**
     * Array of listeners for faceted filters
     */
    public var listens_to_filters: [String]? {
        get { if let v = _listens_to_filters { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _listens_to_filters = v.map { AnyString.init($0) } } else { _listens_to_filters = nil } }
    }

    /**
     * Whether the filter allows multiple filter values (deprecated in the latest version of dashboards)
     */
    public var allow_multiple_values: Bool?

    /**
     * Whether the filter requires a value to run the dashboard
     */
    public var required: Bool?

    /**
     * The visual configuration for this filter. Used to set up how the UI for this filter should appear.
     */
    public var ui_config: StringDictionary<AnyCodable>?

    public init(name: String? = nil, title: String? = nil, type: String? = nil, default_value: String? = nil, model: String? = nil, explore: String? = nil, dimension: String? = nil, row: Int64? = nil, listens_to_filters: [String]? = nil, allow_multiple_values: Bool? = nil, required: Bool? = nil, ui_config: StringDictionary<AnyCodable>? = nil) {
        self._name = name.map(AnyString.init)
        self._title = title.map(AnyString.init)
        self._type = type.map(AnyString.init)
        self._default_value = default_value.map(AnyString.init)
        self._model = model.map(AnyString.init)
        self._explore = explore.map(AnyString.init)
        self._dimension = dimension.map(AnyString.init)
        self._row = row.map(AnyInt.init)
        if let v = listens_to_filters { _listens_to_filters = v.map { AnyString.init($0) } } else { _listens_to_filters = nil }
        self.allow_multiple_values = allow_multiple_values
        self.required = required
        self.ui_config = ui_config
    }

}

/**
 * Dynamic writeable type for DashboardLayout removes:
 * can, id, deleted, dashboard_title, dashboard_layout_components
 */
public struct WriteDashboardLayout: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _dashboard_id = "dashboard_id"
        case _type = "type"
        case active
        case _column_width = "column_width"
        case _width = "width"
    }
    private var _dashboard_id: AnyString?
    /**
     * Id of Dashboard
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    private var _type: AnyString?
    /**
     * Type
     */
    public var type: String? {
        get { _type?.value }
        set { _type = newValue.map(AnyString.init) }
    }

    /**
     * Is Active
     */
    public var active: Bool?

    private var _column_width: AnyInt?
    /**
     * Column Width
     */
    public var column_width: Int64? {
        get { _column_width?.value }
        set { _column_width = newValue.map(AnyInt.init) }
    }

    private var _width: AnyInt?
    /**
     * Width
     */
    public var width: Int64? {
        get { _width?.value }
        set { _width = newValue.map(AnyInt.init) }
    }

    public init(dashboard_id: String? = nil, type: String? = nil, active: Bool? = nil, column_width: Int64? = nil, width: Int64? = nil) {
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self._type = type.map(AnyString.init)
        self.active = active
        self._column_width = column_width.map(AnyInt.init)
        self._width = width.map(AnyInt.init)
    }

}

/**
 * Dynamic writeable type for DashboardLayoutComponent removes:
 * can, id, deleted, element_title, element_title_hidden, vis_type
 */
public struct WriteDashboardLayoutComponent: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _dashboard_layout_id = "dashboard_layout_id"
        case _dashboard_element_id = "dashboard_element_id"
        case _row = "row"
        case _column = "column"
        case _width = "width"
        case _height = "height"
    }
    private var _dashboard_layout_id: AnyString?
    /**
     * Id of Dashboard Layout
     */
    public var dashboard_layout_id: String? {
        get { _dashboard_layout_id?.value }
        set { _dashboard_layout_id = newValue.map(AnyString.init) }
    }

    private var _dashboard_element_id: AnyString?
    /**
     * Id Of Dashboard Element
     */
    public var dashboard_element_id: String? {
        get { _dashboard_element_id?.value }
        set { _dashboard_element_id = newValue.map(AnyString.init) }
    }

    private var _row: AnyInt?
    /**
     * Row
     */
    public var row: Int64? {
        get { _row?.value }
        set { _row = newValue.map(AnyInt.init) }
    }

    private var _column: AnyInt?
    /**
     * Column
     */
    public var column: Int64? {
        get { _column?.value }
        set { _column = newValue.map(AnyInt.init) }
    }

    private var _width: AnyInt?
    /**
     * Width
     */
    public var width: Int64? {
        get { _width?.value }
        set { _width = newValue.map(AnyInt.init) }
    }

    private var _height: AnyInt?
    /**
     * Height
     */
    public var height: Int64? {
        get { _height?.value }
        set { _height = newValue.map(AnyInt.init) }
    }

    public init(dashboard_layout_id: String? = nil, dashboard_element_id: String? = nil, row: Int64? = nil, column: Int64? = nil, width: Int64? = nil, height: Int64? = nil) {
        self._dashboard_layout_id = dashboard_layout_id.map(AnyString.init)
        self._dashboard_element_id = dashboard_element_id.map(AnyString.init)
        self._row = row.map(AnyInt.init)
        self._column = column.map(AnyInt.init)
        self._width = width.map(AnyInt.init)
        self._height = height.map(AnyInt.init)
    }

}

/**
 * Dynamic writeable type for DashboardLookml removes:
 * dashboard_id
 */
public struct WriteDashboardLookml: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _folder_id = "folder_id"
        case _lookml = "lookml"
    }
    private var _folder_id: AnyString?
    /**
     * (Write-Only) Id of the folder
     */
    public var folder_id: String? {
        get { _folder_id?.value }
        set { _folder_id = newValue.map(AnyString.init) }
    }

    private var _lookml: AnyString?
    /**
     * lookml of UDD
     */
    public var lookml: String? {
        get { _lookml?.value }
        set { _lookml = newValue.map(AnyString.init) }
    }

    public init(folder_id: String? = nil, lookml: String? = nil) {
        self._folder_id = folder_id.map(AnyString.init)
        self._lookml = lookml.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for Datagroup removes:
 * can, created_at, id, model_name, name, trigger_check_at, trigger_error, trigger_value
 */
public struct WriteDatagroup: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _stale_before = "stale_before"
        case _triggered_at = "triggered_at"
    }
    private var _stale_before: AnyInt?
    /**
     * UNIX timestamp before which cache entries are considered stale. Cannot be in the future.
     */
    public var stale_before: Int64? {
        get { _stale_before?.value }
        set { _stale_before = newValue.map(AnyInt.init) }
    }

    private var _triggered_at: AnyInt?
    /**
     * UNIX timestamp at which this entry became triggered. Cannot be in the future.
     */
    public var triggered_at: Int64? {
        get { _triggered_at?.value }
        set { _triggered_at = newValue.map(AnyInt.init) }
    }

    public init(stale_before: Int64? = nil, triggered_at: Int64? = nil) {
        self._stale_before = stale_before.map(AnyInt.init)
        self._triggered_at = triggered_at.map(AnyInt.init)
    }

}

/**
 * Dynamic writeable type for DBConnection removes:
 * can, dialect, snippets, pdts_enabled, named_driver_version_actual, uses_oauth, uses_instance_oauth, supports_data_studio_link, created_at, user_id, example, last_regen_at, last_reap_at, managed, default_bq_connection, p4sa_name
 */
public struct WriteDBConnection: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _named_driver_version_requested = "named_driver_version_requested"
        case _host = "host"
        case _port = "port"
        case _username = "username"
        case _password = "password"
        case uses_key_pair_auth
        case _certificate = "certificate"
        case _file_type = "file_type"
        case _database = "database"
        case _db_timezone = "db_timezone"
        case _query_timezone = "query_timezone"
        case _schema = "schema"
        case _max_connections = "max_connections"
        case _max_queries = "max_queries"
        case _max_queries_per_user = "max_queries_per_user"
        case _max_billing_gigabytes = "max_billing_gigabytes"
        case ssl
        case verify_ssl
        case _tmp_db_name = "tmp_db_name"
        case _tmp_db_host = "tmp_db_host"
        case _jdbc_additional_params = "jdbc_additional_params"
        case _pool_timeout = "pool_timeout"
        case _dialect_name = "dialect_name"
        case user_db_credentials
        case _user_attribute_fields = "user_attribute_fields"
        case _maintenance_cron = "maintenance_cron"
        case sql_runner_precache_tables
        case sql_writing_with_info_schema
        case _after_connect_statements = "after_connect_statements"
        case pdt_context_override
        case _custom_local_port = "custom_local_port"
        case _tunnel_id = "tunnel_id"
        case uses_tns
        case _pdt_concurrency = "pdt_concurrency"
        case disable_context_comment
        case _oauth_application_id = "oauth_application_id"
        case always_retry_failed_builds
        case uses_application_default_credentials
        case _impersonated_service_account = "impersonated_service_account"
        case cost_estimate_enabled
        case pdt_api_control_enabled
        case connection_pooling
        case _bq_storage_project_id = "bq_storage_project_id"
        case bq_roles_verified
        case query_holding_disabled
    }
    private var _name: AnyString?
    /**
     * Name of the connection. Also used as the unique identifier
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _named_driver_version_requested: AnyString?
    /**
     * Requested JDBC driver version name
     */
    public var named_driver_version_requested: String? {
        get { _named_driver_version_requested?.value }
        set { _named_driver_version_requested = newValue.map(AnyString.init) }
    }

    private var _host: AnyString?
    /**
     * Host name/address of server; or the string 'localhost' in case of a connection over an SSH tunnel.
     */
    public var host: String? {
        get { _host?.value }
        set { _host = newValue.map(AnyString.init) }
    }

    private var _port: AnyString?
    /**
     * Port number on server. If the connection is over an SSH tunnel, then the local port associated with the SSH tunnel.
     */
    public var port: String? {
        get { _port?.value }
        set { _port = newValue.map(AnyString.init) }
    }

    private var _username: AnyString?
    /**
     * Username for server authentication
     */
    public var username: String? {
        get { _username?.value }
        set { _username = newValue.map(AnyString.init) }
    }

    private var _password: AnyString?
    /**
     * (Write-Only) Password for server authentication
     */
    public var password: String? {
        get { _password?.value }
        set { _password = newValue.map(AnyString.init) }
    }

    /**
     * Whether the connection uses key-pair for authentication.
     */
    public var uses_key_pair_auth: Bool?

    private var _certificate: AnyString?
    /**
     * (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
     */
    public var certificate: String? {
        get { _certificate?.value }
        set { _certificate = newValue.map(AnyString.init) }
    }

    private var _file_type: AnyString?
    /**
     * (Write-Only) Certificate keyfile type - .json, .p8 or .p12
     */
    public var file_type: String? {
        get { _file_type?.value }
        set { _file_type = newValue.map(AnyString.init) }
    }

    private var _database: AnyString?
    /**
     * Database name
     */
    public var database: String? {
        get { _database?.value }
        set { _database = newValue.map(AnyString.init) }
    }

    private var _db_timezone: AnyString?
    /**
     * Time zone of database
     */
    public var db_timezone: String? {
        get { _db_timezone?.value }
        set { _db_timezone = newValue.map(AnyString.init) }
    }

    private var _query_timezone: AnyString?
    /**
     * Timezone to use in queries
     */
    public var query_timezone: String? {
        get { _query_timezone?.value }
        set { _query_timezone = newValue.map(AnyString.init) }
    }

    private var _schema: AnyString?
    /**
     * Schema name
     */
    public var schema: String? {
        get { _schema?.value }
        set { _schema = newValue.map(AnyString.init) }
    }

    private var _max_connections: AnyInt?
    /**
     * Maximum number of concurrent connection to use
     */
    public var max_connections: Int64? {
        get { _max_connections?.value }
        set { _max_connections = newValue.map(AnyInt.init) }
    }

    private var _max_queries: AnyInt?
    /**
     * Maximum number of concurrent queries to begin on this connection
     */
    public var max_queries: Int64? {
        get { _max_queries?.value }
        set { _max_queries = newValue.map(AnyInt.init) }
    }

    private var _max_queries_per_user: AnyInt?
    /**
     * Maximum number of concurrent queries per user to begin on this connection
     */
    public var max_queries_per_user: Int64? {
        get { _max_queries_per_user?.value }
        set { _max_queries_per_user = newValue.map(AnyInt.init) }
    }

    private var _max_billing_gigabytes: AnyString?
    /**
     * Maximum size of query in GBs (BigQuery only, can be a user_attribute name)
     */
    public var max_billing_gigabytes: String? {
        get { _max_billing_gigabytes?.value }
        set { _max_billing_gigabytes = newValue.map(AnyString.init) }
    }

    /**
     * Use SSL/TLS when connecting to server
     */
    public var ssl: Bool?

    /**
     * Verify the SSL
     */
    public var verify_ssl: Bool?

    private var _tmp_db_name: AnyString?
    /**
     * Name of temporary database (if used)
     */
    public var tmp_db_name: String? {
        get { _tmp_db_name?.value }
        set { _tmp_db_name = newValue.map(AnyString.init) }
    }

    private var _tmp_db_host: AnyString?
    /**
     * Name of temporary host (if used)
     */
    public var tmp_db_host: String? {
        get { _tmp_db_host?.value }
        set { _tmp_db_host = newValue.map(AnyString.init) }
    }

    private var _jdbc_additional_params: AnyString?
    /**
     * Additional params to add to JDBC connection string
     */
    public var jdbc_additional_params: String? {
        get { _jdbc_additional_params?.value }
        set { _jdbc_additional_params = newValue.map(AnyString.init) }
    }

    private var _pool_timeout: AnyInt?
    /**
     * Connection Pool Timeout, in seconds
     */
    public var pool_timeout: Int64? {
        get { _pool_timeout?.value }
        set { _pool_timeout = newValue.map(AnyInt.init) }
    }

    private var _dialect_name: AnyString?
    /**
     * (Read/Write) SQL Dialect name
     */
    public var dialect_name: String? {
        get { _dialect_name?.value }
        set { _dialect_name = newValue.map(AnyString.init) }
    }

    /**
     * (Limited access feature) Are per user db credentials enabled. Enabling will remove previously set username and password
     */
    public var user_db_credentials: Bool?

    private var _user_attribute_fields: [AnyString]?
    /**
     * Fields whose values map to user attribute names
     */
    public var user_attribute_fields: [String]? {
        get { if let v = _user_attribute_fields { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _user_attribute_fields = v.map { AnyString.init($0) } } else { _user_attribute_fields = nil } }
    }

    private var _maintenance_cron: AnyString?
    /**
     * Cron string specifying when maintenance such as PDT trigger checks and drops should be performed
     */
    public var maintenance_cron: String? {
        get { _maintenance_cron?.value }
        set { _maintenance_cron = newValue.map(AnyString.init) }
    }

    /**
     * Precache tables in the SQL Runner
     */
    public var sql_runner_precache_tables: Bool?

    /**
     * Fetch Information Schema For SQL Writing
     */
    public var sql_writing_with_info_schema: Bool?

    private var _after_connect_statements: AnyString?
    /**
     * SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
     */
    public var after_connect_statements: String? {
        get { _after_connect_statements?.value }
        set { _after_connect_statements = newValue.map(AnyString.init) }
    }

    /**
     * Dynamic writeable type for DBConnectionOverride removes:
     * has_password
     */
    public var pdt_context_override: WriteDBConnectionOverride?

    private var _custom_local_port: AnyInt?
    /**
     * This field is only applicable to connections over an SSH Tunnel. The value of this field would be the local port associated with the SSH tunnel if configured manually. Otherwise either enter NULL or exclude this field.
     */
    public var custom_local_port: Int64? {
        get { _custom_local_port?.value }
        set { _custom_local_port = newValue.map(AnyInt.init) }
    }

    private var _tunnel_id: AnyString?
    /**
     * The Id of the ssh tunnel this connection uses
     */
    public var tunnel_id: String? {
        get { _tunnel_id?.value }
        set { _tunnel_id = newValue.map(AnyString.init) }
    }

    /**
     * Enable Transparent Network Substrate (TNS) connections
     */
    public var uses_tns: Bool?

    private var _pdt_concurrency: AnyInt?
    /**
     * Maximum number of threads to use to build PDTs in parallel
     */
    public var pdt_concurrency: Int64? {
        get { _pdt_concurrency?.value }
        set { _pdt_concurrency = newValue.map(AnyInt.init) }
    }

    /**
     * When disable_context_comment is true comment will not be added to SQL
     */
    public var disable_context_comment: Bool?

    private var _oauth_application_id: AnyString?
    /**
     * An External OAuth Application to use for authenticating to the database
     */
    public var oauth_application_id: String? {
        get { _oauth_application_id?.value }
        set { _oauth_application_id = newValue.map(AnyString.init) }
    }

    /**
     * When true, error PDTs will be retried every regenerator cycle
     */
    public var always_retry_failed_builds: Bool?

    /**
     * Whether the connection should authenticate with the Application Default Credentials of the host environment (limited to GCP and certain dialects).
     */
    public var uses_application_default_credentials: Bool?

    private var _impersonated_service_account: AnyString?
    /**
     * An alternative Service Account to use for querying datasets (used primarily with `uses_application_default_credentials`) (limited to GCP and certain dialects).
     */
    public var impersonated_service_account: String? {
        get { _impersonated_service_account?.value }
        set { _impersonated_service_account = newValue.map(AnyString.init) }
    }

    /**
     * When true, query cost estimate will be displayed in explore.
     */
    public var cost_estimate_enabled: Bool?

    /**
     * PDT builds on this connection can be kicked off and cancelled via API.
     */
    public var pdt_api_control_enabled: Bool?

    /**
     * Enable database connection pooling.
     */
    public var connection_pooling: Bool?

    private var _bq_storage_project_id: AnyString?
    /**
     * The project id of the default BigQuery storage project.
     */
    public var bq_storage_project_id: String? {
        get { _bq_storage_project_id?.value }
        set { _bq_storage_project_id = newValue.map(AnyString.init) }
    }

    /**
     * When true, represents that all project roles have been verified.
     */
    public var bq_roles_verified: Bool?

    /**
     * Disable query holding for this connection.
     */
    public var query_holding_disabled: Bool?

    public init(name: String? = nil, named_driver_version_requested: String? = nil, host: String? = nil, port: String? = nil, username: String? = nil, password: String? = nil, uses_key_pair_auth: Bool? = nil, certificate: String? = nil, file_type: String? = nil, database: String? = nil, db_timezone: String? = nil, query_timezone: String? = nil, schema: String? = nil, max_connections: Int64? = nil, max_queries: Int64? = nil, max_queries_per_user: Int64? = nil, max_billing_gigabytes: String? = nil, ssl: Bool? = nil, verify_ssl: Bool? = nil, tmp_db_name: String? = nil, tmp_db_host: String? = nil, jdbc_additional_params: String? = nil, pool_timeout: Int64? = nil, dialect_name: String? = nil, user_db_credentials: Bool? = nil, user_attribute_fields: [String]? = nil, maintenance_cron: String? = nil, sql_runner_precache_tables: Bool? = nil, sql_writing_with_info_schema: Bool? = nil, after_connect_statements: String? = nil, pdt_context_override: WriteDBConnectionOverride? = nil, custom_local_port: Int64? = nil, tunnel_id: String? = nil, uses_tns: Bool? = nil, pdt_concurrency: Int64? = nil, disable_context_comment: Bool? = nil, oauth_application_id: String? = nil, always_retry_failed_builds: Bool? = nil, uses_application_default_credentials: Bool? = nil, impersonated_service_account: String? = nil, cost_estimate_enabled: Bool? = nil, pdt_api_control_enabled: Bool? = nil, connection_pooling: Bool? = nil, bq_storage_project_id: String? = nil, bq_roles_verified: Bool? = nil, query_holding_disabled: Bool? = nil) {
        self._name = name.map(AnyString.init)
        self._named_driver_version_requested = named_driver_version_requested.map(AnyString.init)
        self._host = host.map(AnyString.init)
        self._port = port.map(AnyString.init)
        self._username = username.map(AnyString.init)
        self._password = password.map(AnyString.init)
        self.uses_key_pair_auth = uses_key_pair_auth
        self._certificate = certificate.map(AnyString.init)
        self._file_type = file_type.map(AnyString.init)
        self._database = database.map(AnyString.init)
        self._db_timezone = db_timezone.map(AnyString.init)
        self._query_timezone = query_timezone.map(AnyString.init)
        self._schema = schema.map(AnyString.init)
        self._max_connections = max_connections.map(AnyInt.init)
        self._max_queries = max_queries.map(AnyInt.init)
        self._max_queries_per_user = max_queries_per_user.map(AnyInt.init)
        self._max_billing_gigabytes = max_billing_gigabytes.map(AnyString.init)
        self.ssl = ssl
        self.verify_ssl = verify_ssl
        self._tmp_db_name = tmp_db_name.map(AnyString.init)
        self._tmp_db_host = tmp_db_host.map(AnyString.init)
        self._jdbc_additional_params = jdbc_additional_params.map(AnyString.init)
        self._pool_timeout = pool_timeout.map(AnyInt.init)
        self._dialect_name = dialect_name.map(AnyString.init)
        self.user_db_credentials = user_db_credentials
        if let v = user_attribute_fields { _user_attribute_fields = v.map { AnyString.init($0) } } else { _user_attribute_fields = nil }
        self._maintenance_cron = maintenance_cron.map(AnyString.init)
        self.sql_runner_precache_tables = sql_runner_precache_tables
        self.sql_writing_with_info_schema = sql_writing_with_info_schema
        self._after_connect_statements = after_connect_statements.map(AnyString.init)
        self.pdt_context_override = pdt_context_override
        self._custom_local_port = custom_local_port.map(AnyInt.init)
        self._tunnel_id = tunnel_id.map(AnyString.init)
        self.uses_tns = uses_tns
        self._pdt_concurrency = pdt_concurrency.map(AnyInt.init)
        self.disable_context_comment = disable_context_comment
        self._oauth_application_id = oauth_application_id.map(AnyString.init)
        self.always_retry_failed_builds = always_retry_failed_builds
        self.uses_application_default_credentials = uses_application_default_credentials
        self._impersonated_service_account = impersonated_service_account.map(AnyString.init)
        self.cost_estimate_enabled = cost_estimate_enabled
        self.pdt_api_control_enabled = pdt_api_control_enabled
        self.connection_pooling = connection_pooling
        self._bq_storage_project_id = bq_storage_project_id.map(AnyString.init)
        self.bq_roles_verified = bq_roles_verified
        self.query_holding_disabled = query_holding_disabled
    }

}

/**
 * Dynamic writeable type for DBConnectionOverride removes:
 * has_password
 */
public struct WriteDBConnectionOverride: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _context = "context"
        case _host = "host"
        case _pdt_host = "pdt_host"
        case _port = "port"
        case _pdt_port = "pdt_port"
        case _username = "username"
        case _pdt_username = "pdt_username"
        case _password = "password"
        case _pdt_password = "pdt_password"
        case _certificate = "certificate"
        case _pdt_certificate = "pdt_certificate"
        case _file_type = "file_type"
        case _pdt_file_type = "pdt_file_type"
        case _database = "database"
        case _pdt_database = "pdt_database"
        case _schema = "schema"
        case _pdt_schema = "pdt_schema"
        case _jdbc_additional_params = "jdbc_additional_params"
        case _pdt_jdbc_additional_params = "pdt_jdbc_additional_params"
        case _after_connect_statements = "after_connect_statements"
        case _pdt_after_connect_statements = "pdt_after_connect_statements"
    }
    private var _context: AnyString?
    /**
     * Context in which to override (`pdt` is the only allowed value)
     */
    public var context: String? {
        get { _context?.value }
        set { _context = newValue.map(AnyString.init) }
    }

    private var _host: AnyString?
    /**
     * Host name/address of server
     */
    public var host: String? {
        get { _host?.value }
        set { _host = newValue.map(AnyString.init) }
    }

    private var _pdt_host: AnyString?
    /**
     * Host name/address of server (same as host)
     */
    public var pdt_host: String? {
        get { _pdt_host?.value }
        set { _pdt_host = newValue.map(AnyString.init) }
    }

    private var _port: AnyString?
    /**
     * Port number on server
     */
    public var port: String? {
        get { _port?.value }
        set { _port = newValue.map(AnyString.init) }
    }

    private var _pdt_port: AnyString?
    /**
     * Port number on server (same as port)
     */
    public var pdt_port: String? {
        get { _pdt_port?.value }
        set { _pdt_port = newValue.map(AnyString.init) }
    }

    private var _username: AnyString?
    /**
     * Username for server authentication
     */
    public var username: String? {
        get { _username?.value }
        set { _username = newValue.map(AnyString.init) }
    }

    private var _pdt_username: AnyString?
    /**
     * Username for server authentication (same as username)
     */
    public var pdt_username: String? {
        get { _pdt_username?.value }
        set { _pdt_username = newValue.map(AnyString.init) }
    }

    private var _password: AnyString?
    /**
     * (Write-Only) Password for server authentication
     */
    public var password: String? {
        get { _password?.value }
        set { _password = newValue.map(AnyString.init) }
    }

    private var _pdt_password: AnyString?
    /**
     * (Write-Only) Password for server authentication (same as password)
     */
    public var pdt_password: String? {
        get { _pdt_password?.value }
        set { _pdt_password = newValue.map(AnyString.init) }
    }

    private var _certificate: AnyString?
    /**
     * (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
     */
    public var certificate: String? {
        get { _certificate?.value }
        set { _certificate = newValue.map(AnyString.init) }
    }

    private var _pdt_certificate: AnyString?
    /**
     * (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect) (same as certificate).
     */
    public var pdt_certificate: String? {
        get { _pdt_certificate?.value }
        set { _pdt_certificate = newValue.map(AnyString.init) }
    }

    private var _file_type: AnyString?
    /**
     * (Write-Only) Certificate keyfile type - .json or .p12
     */
    public var file_type: String? {
        get { _file_type?.value }
        set { _file_type = newValue.map(AnyString.init) }
    }

    private var _pdt_file_type: AnyString?
    /**
     * (Write-Only) Certificate keyfile type - .json or .p12 (same as file_type)
     */
    public var pdt_file_type: String? {
        get { _pdt_file_type?.value }
        set { _pdt_file_type = newValue.map(AnyString.init) }
    }

    private var _database: AnyString?
    /**
     * Database name
     */
    public var database: String? {
        get { _database?.value }
        set { _database = newValue.map(AnyString.init) }
    }

    private var _pdt_database: AnyString?
    /**
     * Database name (same as database)
     */
    public var pdt_database: String? {
        get { _pdt_database?.value }
        set { _pdt_database = newValue.map(AnyString.init) }
    }

    private var _schema: AnyString?
    /**
     * Schema name
     */
    public var schema: String? {
        get { _schema?.value }
        set { _schema = newValue.map(AnyString.init) }
    }

    private var _pdt_schema: AnyString?
    /**
     * Schema name (same as schema)
     */
    public var pdt_schema: String? {
        get { _pdt_schema?.value }
        set { _pdt_schema = newValue.map(AnyString.init) }
    }

    private var _jdbc_additional_params: AnyString?
    /**
     * Additional params to add to JDBC connection string
     */
    public var jdbc_additional_params: String? {
        get { _jdbc_additional_params?.value }
        set { _jdbc_additional_params = newValue.map(AnyString.init) }
    }

    private var _pdt_jdbc_additional_params: AnyString?
    /**
     * Additional params to add to JDBC connection string (same as jdbc_additional_params)
     */
    public var pdt_jdbc_additional_params: String? {
        get { _pdt_jdbc_additional_params?.value }
        set { _pdt_jdbc_additional_params = newValue.map(AnyString.init) }
    }

    private var _after_connect_statements: AnyString?
    /**
     * SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
     */
    public var after_connect_statements: String? {
        get { _after_connect_statements?.value }
        set { _after_connect_statements = newValue.map(AnyString.init) }
    }

    private var _pdt_after_connect_statements: AnyString?
    /**
     * SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature (same as after_connect_statements)
     */
    public var pdt_after_connect_statements: String? {
        get { _pdt_after_connect_statements?.value }
        set { _pdt_after_connect_statements = newValue.map(AnyString.init) }
    }

    public init(context: String? = nil, host: String? = nil, pdt_host: String? = nil, port: String? = nil, pdt_port: String? = nil, username: String? = nil, pdt_username: String? = nil, password: String? = nil, pdt_password: String? = nil, certificate: String? = nil, pdt_certificate: String? = nil, file_type: String? = nil, pdt_file_type: String? = nil, database: String? = nil, pdt_database: String? = nil, schema: String? = nil, pdt_schema: String? = nil, jdbc_additional_params: String? = nil, pdt_jdbc_additional_params: String? = nil, after_connect_statements: String? = nil, pdt_after_connect_statements: String? = nil) {
        self._context = context.map(AnyString.init)
        self._host = host.map(AnyString.init)
        self._pdt_host = pdt_host.map(AnyString.init)
        self._port = port.map(AnyString.init)
        self._pdt_port = pdt_port.map(AnyString.init)
        self._username = username.map(AnyString.init)
        self._pdt_username = pdt_username.map(AnyString.init)
        self._password = password.map(AnyString.init)
        self._pdt_password = pdt_password.map(AnyString.init)
        self._certificate = certificate.map(AnyString.init)
        self._pdt_certificate = pdt_certificate.map(AnyString.init)
        self._file_type = file_type.map(AnyString.init)
        self._pdt_file_type = pdt_file_type.map(AnyString.init)
        self._database = database.map(AnyString.init)
        self._pdt_database = pdt_database.map(AnyString.init)
        self._schema = schema.map(AnyString.init)
        self._pdt_schema = pdt_schema.map(AnyString.init)
        self._jdbc_additional_params = jdbc_additional_params.map(AnyString.init)
        self._pdt_jdbc_additional_params = pdt_jdbc_additional_params.map(AnyString.init)
        self._after_connect_statements = after_connect_statements.map(AnyString.init)
        self._pdt_after_connect_statements = pdt_after_connect_statements.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for EmbedConfig removes:
 * embed_enabled
 */
public struct WriteEmbedConfig: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _domain_allowlist = "domain_allowlist"
        case _alert_url_allowlist = "alert_url_allowlist"
        case _alert_url_param_owner = "alert_url_param_owner"
        case _alert_url_label = "alert_url_label"
        case sso_auth_enabled
        case embed_cookieless_v2
        case embed_content_navigation
        case embed_content_management
        case strict_sameorigin_for_login
        case look_filters
        case hide_look_navigation
    }
    private var _domain_allowlist: [AnyString]?
    /**
     * List of domains to allow for embedding
     */
    public var domain_allowlist: [String]? {
        get { if let v = _domain_allowlist { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _domain_allowlist = v.map { AnyString.init($0) } } else { _domain_allowlist = nil } }
    }

    private var _alert_url_allowlist: [AnyString]?
    /**
     * List of base urls to allow for alert/schedule
     */
    public var alert_url_allowlist: [String]? {
        get { if let v = _alert_url_allowlist { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _alert_url_allowlist = v.map { AnyString.init($0) } } else { _alert_url_allowlist = nil } }
    }

    private var _alert_url_param_owner: AnyString?
    /**
     * Owner of who defines the alert/schedule params on the base url
     */
    public var alert_url_param_owner: String? {
        get { _alert_url_param_owner?.value }
        set { _alert_url_param_owner = newValue.map(AnyString.init) }
    }

    private var _alert_url_label: AnyString?
    /**
     * Label for the alert/schedule url
     */
    public var alert_url_label: String? {
        get { _alert_url_label?.value }
        set { _alert_url_label = newValue.map(AnyString.init) }
    }

    /**
     * Is SSO embedding enabled for this Looker
     */
    public var sso_auth_enabled: Bool?

    /**
     * Is Cookieless embedding enabled for this Looker
     */
    public var embed_cookieless_v2: Bool?

    /**
     * Is embed content navigation enabled for this looker
     */
    public var embed_content_navigation: Bool?

    /**
     * Is embed content management enabled for this Looker
     */
    public var embed_content_management: Bool?

    /**
     * When true, prohibits the use of Looker login pages in non-Looker iframes. When false, Looker login pages may be used in non-Looker hosted iframes.
     */
    public var strict_sameorigin_for_login: Bool?

    /**
     * When true, filters are enabled on embedded Looks
     */
    public var look_filters: Bool?

    /**
     * When true, removes navigation to Looks from embedded dashboards and explores.
     */
    public var hide_look_navigation: Bool?

    public init(domain_allowlist: [String]? = nil, alert_url_allowlist: [String]? = nil, alert_url_param_owner: String? = nil, alert_url_label: String? = nil, sso_auth_enabled: Bool? = nil, embed_cookieless_v2: Bool? = nil, embed_content_navigation: Bool? = nil, embed_content_management: Bool? = nil, strict_sameorigin_for_login: Bool? = nil, look_filters: Bool? = nil, hide_look_navigation: Bool? = nil) {
        if let v = domain_allowlist { _domain_allowlist = v.map { AnyString.init($0) } } else { _domain_allowlist = nil }
        if let v = alert_url_allowlist { _alert_url_allowlist = v.map { AnyString.init($0) } } else { _alert_url_allowlist = nil }
        self._alert_url_param_owner = alert_url_param_owner.map(AnyString.init)
        self._alert_url_label = alert_url_label.map(AnyString.init)
        self.sso_auth_enabled = sso_auth_enabled
        self.embed_cookieless_v2 = embed_cookieless_v2
        self.embed_content_navigation = embed_content_navigation
        self.embed_content_management = embed_content_management
        self.strict_sameorigin_for_login = strict_sameorigin_for_login
        self.look_filters = look_filters
        self.hide_look_navigation = hide_look_navigation
    }

}

/**
 * Dynamic writeable type for EmbedSecret removes:
 * created_at, id, secret, user_id
 */
public struct WriteEmbedSecret: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _algorithm = "algorithm"
        case enabled
        case secret_type
    }
    private var _algorithm: AnyString?
    /**
     * Signing algorithm to use with this secret. Either `hmac/sha-256`(default) or `hmac/sha-1`
     */
    public var algorithm: String? {
        get { _algorithm?.value }
        set { _algorithm = newValue.map(AnyString.init) }
    }

    /**
     * Is this secret currently enabled
     */
    public var enabled: Bool?

    /**
     * Field to distinguish between SSO secrets and JWT secrets Valid values are: "SSO", "JWT".
     */
    public var secret_type: SecretType?

    public init(algorithm: String? = nil, enabled: Bool? = nil, secret_type: SecretType? = nil) {
        self._algorithm = algorithm.map(AnyString.init)
        self.enabled = enabled
        self.secret_type = secret_type
    }

}

/**
 * Dynamic writeable type for ExternalOauthApplication removes:
 * can, id, created_at
 */
public struct WriteExternalOauthApplication: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _client_id = "client_id"
        case _client_secret = "client_secret"
        case _tenant_id = "tenant_id"
        case _dialect_name = "dialect_name"
    }
    private var _name: AnyString?
    /**
     * The name of this application.  For Snowflake connections, this should be the name of the host database.
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _client_id: AnyString?
    /**
     * The OAuth Client ID for this application
     */
    public var client_id: String? {
        get { _client_id?.value }
        set { _client_id = newValue.map(AnyString.init) }
    }

    private var _client_secret: AnyString?
    /**
     * (Write-Only) The OAuth Client Secret for this application
     */
    public var client_secret: String? {
        get { _client_secret?.value }
        set { _client_secret = newValue.map(AnyString.init) }
    }

    private var _tenant_id: AnyString?
    /**
     * The OAuth Tenant ID for this application
     */
    public var tenant_id: String? {
        get { _tenant_id?.value }
        set { _tenant_id = newValue.map(AnyString.init) }
    }

    private var _dialect_name: AnyString?
    /**
     * The database dialect for this application.
     */
    public var dialect_name: String? {
        get { _dialect_name?.value }
        set { _dialect_name = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, client_id: String? = nil, client_secret: String? = nil, tenant_id: String? = nil, dialect_name: String? = nil) {
        self._name = name.map(AnyString.init)
        self._client_id = client_id.map(AnyString.init)
        self._client_secret = client_secret.map(AnyString.init)
        self._tenant_id = tenant_id.map(AnyString.init)
        self._dialect_name = dialect_name.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for FolderBase removes:
 * id, content_metadata_id, created_at, creator_id, child_count, external_id, is_embed, is_embed_shared_root, is_embed_users_root, is_personal, is_personal_descendant, is_shared_root, is_users_root, can
 */
public struct WriteFolderBase: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _parent_id = "parent_id"
    }
    private var _name: AnyString
    /**
     * Unique Name
     */
    public var name: String {
        get { _name.value }
        set { _name = AnyString.init(newValue) }
    }

    private var _parent_id: AnyString?
    /**
     * Id of Parent. If the parent id is null, this is a root-level entry
     */
    public var parent_id: String? {
        get { _parent_id?.value }
        set { _parent_id = newValue.map(AnyString.init) }
    }

    public init(name: String, parent_id: String? = nil) {
        self._name = AnyString.init(name)
        self._parent_id = parent_id.map(AnyString.init)
    }

    public init(_ name: String, parent_id: String? = nil) {
        self.init(name: name, parent_id: parent_id)
    }

}

/**
 * Dynamic writeable type for GitBranch removes:
 * can, remote, remote_name, error, message, owner_name, readonly, personal, is_local, is_remote, is_production, ahead_count, behind_count, commit_at, remote_ref
 */
public struct WriteGitBranch: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _ref = "ref"
    }
    private var _name: AnyString?
    /**
     * The short name on the local. Updating `name` results in `git checkout <new_name>`
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _ref: AnyString?
    /**
     * The resolved ref of this branch. Updating `ref` results in `git reset --hard <new_ref>``.
     */
    public var ref: String? {
        get { _ref?.value }
        set { _ref = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, ref: String? = nil) {
        self._name = name.map(AnyString.init)
        self._ref = ref.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for Group removes:
 * can, contains_current_user, external_group_id, externally_managed, id, include_by_default, user_count
 */
public struct WriteGroup: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case can_add_to_content_metadata
        case _name = "name"
    }
    /**
     * Group can be used in content access controls
     */
    public var can_add_to_content_metadata: Bool?

    private var _name: AnyString?
    /**
     * Name of group
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    public init(can_add_to_content_metadata: Bool? = nil, name: String? = nil) {
        self.can_add_to_content_metadata = can_add_to_content_metadata
        self._name = name.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for Integration removes:
 * can, id, integration_hub_id, label, description, supported_formats, supported_action_types, supported_formattings, supported_visualization_formattings, supported_download_settings, icon_url, uses_oauth, required_fields, privacy_link, delegate_oauth
 */
public struct WriteIntegration: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case enabled
        case params
        case _installed_delegate_oauth_targets = "installed_delegate_oauth_targets"
    }
    /**
     * Whether the integration is available to users.
     */
    public var enabled: Bool?

    /**
     * Array of params for the integration.
     */
    public var params: [IntegrationParam]?

    private var _installed_delegate_oauth_targets: [AnyString]?
    /**
     * Whether the integration is available to users.
     */
    public var installed_delegate_oauth_targets: [String]? {
        get { if let v = _installed_delegate_oauth_targets { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _installed_delegate_oauth_targets = v.map { AnyString.init($0) } } else { _installed_delegate_oauth_targets = nil } }
    }

    public init(enabled: Bool? = nil, params: [IntegrationParam]? = nil, installed_delegate_oauth_targets: [String]? = nil) {
        self.enabled = enabled
        self.params = params
        if let v = installed_delegate_oauth_targets { _installed_delegate_oauth_targets = v.map { AnyString.init($0) } } else { _installed_delegate_oauth_targets = nil }
    }

}

/**
 * Dynamic writeable type for IntegrationHub removes:
 * can, id, label, official, fetch_error_message, has_authorization_token, legal_agreement_signed, legal_agreement_required, legal_agreement_text
 */
public struct WriteIntegrationHub: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _url = "url"
        case _authorization_token = "authorization_token"
    }
    private var _url: AnyString?
    /**
     * URL of the hub.
     */
    public var url: String? {
        get { _url?.value }
        set { _url = newValue.map(AnyString.init) }
    }

    private var _authorization_token: AnyString?
    /**
     * (Write-Only) An authorization key that will be sent to the integration hub on every request.
     */
    public var authorization_token: String? {
        get { _authorization_token?.value }
        set { _authorization_token = newValue.map(AnyString.init) }
    }

    public init(url: String? = nil, authorization_token: String? = nil) {
        self._url = url.map(AnyString.init)
        self._authorization_token = authorization_token.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for InternalHelpResources removes:
 * can
 */
public struct WriteInternalHelpResources: SDKModel {
    /**
     * If true and internal help resources content is not blank then the link for internal help resources will be shown in the help menu and the content displayed within Looker
     */
    public var enabled: Bool?

    public init(enabled: Bool? = nil) {
        self.enabled = enabled
    }

}

/**
 * Dynamic writeable type for InternalHelpResourcesContent removes:
 * can
 */
public struct WriteInternalHelpResourcesContent: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _organization_name = "organization_name"
        case _markdown_content = "markdown_content"
    }
    private var _organization_name: AnyString?
    /**
     * Text to display in the help menu item which will display the internal help resources
     */
    public var organization_name: String? {
        get { _organization_name?.value }
        set { _organization_name = newValue.map(AnyString.init) }
    }

    private var _markdown_content: AnyString?
    /**
     * Content to be displayed in the internal help resources page/modal
     */
    public var markdown_content: String? {
        get { _markdown_content?.value }
        set { _markdown_content = newValue.map(AnyString.init) }
    }

    public init(organization_name: String? = nil, markdown_content: String? = nil) {
        self._organization_name = organization_name.map(AnyString.init)
        self._markdown_content = markdown_content.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for LDAPConfig removes:
 * can, default_new_user_groups, default_new_user_roles, groups, has_auth_password, modified_at, modified_by, user_attributes, url
 */
public struct WriteLDAPConfig: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case alternate_email_login_allowed
        case _auth_password = "auth_password"
        case auth_requires_role
        case _auth_username = "auth_username"
        case _connection_host = "connection_host"
        case _connection_port = "connection_port"
        case connection_tls
        case connection_tls_no_verify
        case _default_new_user_group_ids = "default_new_user_group_ids"
        case _default_new_user_role_ids = "default_new_user_role_ids"
        case enabled
        case force_no_page
        case _groups_base_dn = "groups_base_dn"
        case _groups_finder_type = "groups_finder_type"
        case _groups_member_attribute = "groups_member_attribute"
        case _groups_objectclasses = "groups_objectclasses"
        case _groups_user_attribute = "groups_user_attribute"
        case groups_with_role_ids
        case merge_new_users_by_email
        case set_roles_from_groups
        case _test_ldap_password = "test_ldap_password"
        case _test_ldap_user = "test_ldap_user"
        case _user_attribute_map_email = "user_attribute_map_email"
        case _user_attribute_map_first_name = "user_attribute_map_first_name"
        case _user_attribute_map_last_name = "user_attribute_map_last_name"
        case _user_attribute_map_ldap_id = "user_attribute_map_ldap_id"
        case user_attributes_with_ids
        case _user_bind_base_dn = "user_bind_base_dn"
        case _user_custom_filter = "user_custom_filter"
        case _user_id_attribute_names = "user_id_attribute_names"
        case _user_objectclass = "user_objectclass"
        case allow_normal_group_membership
        case allow_roles_from_normal_groups
        case allow_direct_roles
    }
    /**
     * Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
     */
    public var alternate_email_login_allowed: Bool?

    private var _auth_password: AnyString?
    /**
     * (Write-Only)  Password for the LDAP account used to access the LDAP server
     */
    public var auth_password: String? {
        get { _auth_password?.value }
        set { _auth_password = newValue.map(AnyString.init) }
    }

    /**
     * Users will not be allowed to login at all unless a role for them is found in LDAP if set to true
     */
    public var auth_requires_role: Bool?

    private var _auth_username: AnyString?
    /**
     * Distinguished name of LDAP account used to access the LDAP server
     */
    public var auth_username: String? {
        get { _auth_username?.value }
        set { _auth_username = newValue.map(AnyString.init) }
    }

    private var _connection_host: AnyString?
    /**
     * LDAP server hostname
     */
    public var connection_host: String? {
        get { _connection_host?.value }
        set { _connection_host = newValue.map(AnyString.init) }
    }

    private var _connection_port: AnyString?
    /**
     * LDAP host port
     */
    public var connection_port: String? {
        get { _connection_port?.value }
        set { _connection_port = newValue.map(AnyString.init) }
    }

    /**
     * Use Transport Layer Security
     */
    public var connection_tls: Bool?

    /**
     * Do not verify peer when using TLS
     */
    public var connection_tls_no_verify: Bool?

    private var _default_new_user_group_ids: [AnyString]?
    /**
     * (Write-Only)  Array of ids of groups that will be applied to new users the first time they login via LDAP
     */
    public var default_new_user_group_ids: [String]? {
        get { if let v = _default_new_user_group_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _default_new_user_group_ids = v.map { AnyString.init($0) } } else { _default_new_user_group_ids = nil } }
    }

    private var _default_new_user_role_ids: [AnyString]?
    /**
     * (Write-Only)  Array of ids of roles that will be applied to new users the first time they login via LDAP
     */
    public var default_new_user_role_ids: [String]? {
        get { if let v = _default_new_user_role_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _default_new_user_role_ids = v.map { AnyString.init($0) } } else { _default_new_user_role_ids = nil } }
    }

    /**
     * Enable/Disable LDAP authentication for the server
     */
    public var enabled: Bool?

    /**
     * Don't attempt to do LDAP search result paging (RFC 2696) even if the LDAP server claims to support it.
     */
    public var force_no_page: Bool?

    private var _groups_base_dn: AnyString?
    /**
     * Base dn for finding groups in LDAP searches
     */
    public var groups_base_dn: String? {
        get { _groups_base_dn?.value }
        set { _groups_base_dn = newValue.map(AnyString.init) }
    }

    private var _groups_finder_type: AnyString?
    /**
     * Identifier for a strategy for how Looker will search for groups in the LDAP server
     */
    public var groups_finder_type: String? {
        get { _groups_finder_type?.value }
        set { _groups_finder_type = newValue.map(AnyString.init) }
    }

    private var _groups_member_attribute: AnyString?
    /**
     * LDAP Group attribute that signifies the members of the groups. Most commonly 'member'
     */
    public var groups_member_attribute: String? {
        get { _groups_member_attribute?.value }
        set { _groups_member_attribute = newValue.map(AnyString.init) }
    }

    private var _groups_objectclasses: AnyString?
    /**
     * Optional comma-separated list of supported LDAP objectclass for groups when doing groups searches
     */
    public var groups_objectclasses: String? {
        get { _groups_objectclasses?.value }
        set { _groups_objectclasses = newValue.map(AnyString.init) }
    }

    private var _groups_user_attribute: AnyString?
    /**
     * LDAP Group attribute that signifies the user in a group. Most commonly 'dn'
     */
    public var groups_user_attribute: String? {
        get { _groups_user_attribute?.value }
        set { _groups_user_attribute = newValue.map(AnyString.init) }
    }

    /**
     * (Read/Write) Array of mappings between LDAP Groups and arrays of Looker Role ids
     */
    public var groups_with_role_ids: [LDAPGroupWrite]?

    /**
     * Merge first-time ldap login to existing user account by email addresses. When a user logs in for the first time via ldap this option will connect this user into their existing account by finding the account with a matching email address. Otherwise a new user account will be created for the user.
     */
    public var merge_new_users_by_email: Bool?

    /**
     * Set user roles in Looker based on groups from LDAP
     */
    public var set_roles_from_groups: Bool?

    private var _test_ldap_password: AnyString?
    /**
     * (Write-Only)  Test LDAP user password. For ldap tests only.
     */
    public var test_ldap_password: String? {
        get { _test_ldap_password?.value }
        set { _test_ldap_password = newValue.map(AnyString.init) }
    }

    private var _test_ldap_user: AnyString?
    /**
     * (Write-Only)  Test LDAP user login id. For ldap tests only.
     */
    public var test_ldap_user: String? {
        get { _test_ldap_user?.value }
        set { _test_ldap_user = newValue.map(AnyString.init) }
    }

    private var _user_attribute_map_email: AnyString?
    /**
     * Name of user record attributes used to indicate email address field
     */
    public var user_attribute_map_email: String? {
        get { _user_attribute_map_email?.value }
        set { _user_attribute_map_email = newValue.map(AnyString.init) }
    }

    private var _user_attribute_map_first_name: AnyString?
    /**
     * Name of user record attributes used to indicate first name
     */
    public var user_attribute_map_first_name: String? {
        get { _user_attribute_map_first_name?.value }
        set { _user_attribute_map_first_name = newValue.map(AnyString.init) }
    }

    private var _user_attribute_map_last_name: AnyString?
    /**
     * Name of user record attributes used to indicate last name
     */
    public var user_attribute_map_last_name: String? {
        get { _user_attribute_map_last_name?.value }
        set { _user_attribute_map_last_name = newValue.map(AnyString.init) }
    }

    private var _user_attribute_map_ldap_id: AnyString?
    /**
     * Name of user record attributes used to indicate unique record id
     */
    public var user_attribute_map_ldap_id: String? {
        get { _user_attribute_map_ldap_id?.value }
        set { _user_attribute_map_ldap_id = newValue.map(AnyString.init) }
    }

    /**
     * (Read/Write) Array of mappings between LDAP User Attributes and arrays of Looker User Attribute ids
     */
    public var user_attributes_with_ids: [LDAPUserAttributeWrite]?

    private var _user_bind_base_dn: AnyString?
    /**
     * Distinguished name of LDAP node used as the base for user searches
     */
    public var user_bind_base_dn: String? {
        get { _user_bind_base_dn?.value }
        set { _user_bind_base_dn = newValue.map(AnyString.init) }
    }

    private var _user_custom_filter: AnyString?
    /**
     * (Optional) Custom RFC-2254 filter clause for use in finding user during login. Combined via 'and' with the other generated filter clauses.
     */
    public var user_custom_filter: String? {
        get { _user_custom_filter?.value }
        set { _user_custom_filter = newValue.map(AnyString.init) }
    }

    private var _user_id_attribute_names: AnyString?
    /**
     * Name(s) of user record attributes used for matching user login id (comma separated list)
     */
    public var user_id_attribute_names: String? {
        get { _user_id_attribute_names?.value }
        set { _user_id_attribute_names = newValue.map(AnyString.init) }
    }

    private var _user_objectclass: AnyString?
    /**
     * (Optional) Name of user record objectclass used for finding user during login id
     */
    public var user_objectclass: String? {
        get { _user_objectclass?.value }
        set { _user_objectclass = newValue.map(AnyString.init) }
    }

    /**
     * Allow LDAP auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.
     */
    public var allow_normal_group_membership: Bool?

    /**
     * LDAP auth'd users will be able to inherit roles from non-reflected Looker groups.
     */
    public var allow_roles_from_normal_groups: Bool?

    /**
     * Allows roles to be directly assigned to LDAP auth'd users.
     */
    public var allow_direct_roles: Bool?

    public init(alternate_email_login_allowed: Bool? = nil, auth_password: String? = nil, auth_requires_role: Bool? = nil, auth_username: String? = nil, connection_host: String? = nil, connection_port: String? = nil, connection_tls: Bool? = nil, connection_tls_no_verify: Bool? = nil, default_new_user_group_ids: [String]? = nil, default_new_user_role_ids: [String]? = nil, enabled: Bool? = nil, force_no_page: Bool? = nil, groups_base_dn: String? = nil, groups_finder_type: String? = nil, groups_member_attribute: String? = nil, groups_objectclasses: String? = nil, groups_user_attribute: String? = nil, groups_with_role_ids: [LDAPGroupWrite]? = nil, merge_new_users_by_email: Bool? = nil, set_roles_from_groups: Bool? = nil, test_ldap_password: String? = nil, test_ldap_user: String? = nil, user_attribute_map_email: String? = nil, user_attribute_map_first_name: String? = nil, user_attribute_map_last_name: String? = nil, user_attribute_map_ldap_id: String? = nil, user_attributes_with_ids: [LDAPUserAttributeWrite]? = nil, user_bind_base_dn: String? = nil, user_custom_filter: String? = nil, user_id_attribute_names: String? = nil, user_objectclass: String? = nil, allow_normal_group_membership: Bool? = nil, allow_roles_from_normal_groups: Bool? = nil, allow_direct_roles: Bool? = nil) {
        self.alternate_email_login_allowed = alternate_email_login_allowed
        self._auth_password = auth_password.map(AnyString.init)
        self.auth_requires_role = auth_requires_role
        self._auth_username = auth_username.map(AnyString.init)
        self._connection_host = connection_host.map(AnyString.init)
        self._connection_port = connection_port.map(AnyString.init)
        self.connection_tls = connection_tls
        self.connection_tls_no_verify = connection_tls_no_verify
        if let v = default_new_user_group_ids { _default_new_user_group_ids = v.map { AnyString.init($0) } } else { _default_new_user_group_ids = nil }
        if let v = default_new_user_role_ids { _default_new_user_role_ids = v.map { AnyString.init($0) } } else { _default_new_user_role_ids = nil }
        self.enabled = enabled
        self.force_no_page = force_no_page
        self._groups_base_dn = groups_base_dn.map(AnyString.init)
        self._groups_finder_type = groups_finder_type.map(AnyString.init)
        self._groups_member_attribute = groups_member_attribute.map(AnyString.init)
        self._groups_objectclasses = groups_objectclasses.map(AnyString.init)
        self._groups_user_attribute = groups_user_attribute.map(AnyString.init)
        self.groups_with_role_ids = groups_with_role_ids
        self.merge_new_users_by_email = merge_new_users_by_email
        self.set_roles_from_groups = set_roles_from_groups
        self._test_ldap_password = test_ldap_password.map(AnyString.init)
        self._test_ldap_user = test_ldap_user.map(AnyString.init)
        self._user_attribute_map_email = user_attribute_map_email.map(AnyString.init)
        self._user_attribute_map_first_name = user_attribute_map_first_name.map(AnyString.init)
        self._user_attribute_map_last_name = user_attribute_map_last_name.map(AnyString.init)
        self._user_attribute_map_ldap_id = user_attribute_map_ldap_id.map(AnyString.init)
        self.user_attributes_with_ids = user_attributes_with_ids
        self._user_bind_base_dn = user_bind_base_dn.map(AnyString.init)
        self._user_custom_filter = user_custom_filter.map(AnyString.init)
        self._user_id_attribute_names = user_id_attribute_names.map(AnyString.init)
        self._user_objectclass = user_objectclass.map(AnyString.init)
        self.allow_normal_group_membership = allow_normal_group_membership
        self.allow_roles_from_normal_groups = allow_roles_from_normal_groups
        self.allow_direct_roles = allow_direct_roles
    }

}

/**
 * Dynamic writeable type for LegacyFeature removes:
 * can, id, name, description, enabled, disallowed_as_of_version, disable_on_upgrade_to_version, end_of_life_version, documentation_url, approximate_disable_date, approximate_end_of_life_date, has_disabled_on_upgrade
 */
public struct WriteLegacyFeature: SDKModel {
    /**
     * Whether this feature has been enabled by a user
     */
    public var enabled_locally: Bool?

    public init(enabled_locally: Bool? = nil) {
        self.enabled_locally = enabled_locally
    }

}

/**
 * Dynamic writeable type for LookBasic removes:
 * can, content_metadata_id, id, title
 */
public struct WriteLookBasic: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _user_id = "user_id"
    }
    private var _user_id: AnyString?
    /**
     * User Id
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    public init(user_id: String? = nil) {
        self._user_id = user_id.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for LookmlModel removes:
 * can, explores, has_content, label
 */
public struct WriteLookmlModel: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _allowed_db_connection_names = "allowed_db_connection_names"
        case _name = "name"
        case _project_name = "project_name"
        case unlimited_db_connections
    }
    private var _allowed_db_connection_names: [AnyString]?
    /**
     * Array of names of connections this model is allowed to use
     */
    public var allowed_db_connection_names: [String]? {
        get { if let v = _allowed_db_connection_names { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _allowed_db_connection_names = v.map { AnyString.init($0) } } else { _allowed_db_connection_names = nil } }
    }

    private var _name: AnyString?
    /**
     * Name of the model. Also used as the unique identifier
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _project_name: AnyString?
    /**
     * Name of project containing the model
     */
    public var project_name: String? {
        get { _project_name?.value }
        set { _project_name = newValue.map(AnyString.init) }
    }

    /**
     * Is this model allowed to use all current and future connections
     */
    public var unlimited_db_connections: Bool?

    public init(allowed_db_connection_names: [String]? = nil, name: String? = nil, project_name: String? = nil, unlimited_db_connections: Bool? = nil) {
        if let v = allowed_db_connection_names { _allowed_db_connection_names = v.map { AnyString.init($0) } } else { _allowed_db_connection_names = nil }
        self._name = name.map(AnyString.init)
        self._project_name = project_name.map(AnyString.init)
        self.unlimited_db_connections = unlimited_db_connections
    }

}

/**
 * Dynamic writeable type for LookWithQuery removes:
 * can, content_metadata_id, id, content_favorite_id, created_at, deleted_at, deleter_id, embed_url, excel_file_url, favorite_count, google_spreadsheet_formula, image_embed_url, last_accessed_at, last_updater_id, last_viewed_at, model, public_slug, public_url, short_url, updated_at, user_name, view_count, url
 */
public struct WriteLookWithQuery: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _title = "title"
        case _user_id = "user_id"
        case deleted
        case _description = "description"
        case is_run_on_load
        case `public`
        case _query_id = "query_id"
        case folder
        case _folder_id = "folder_id"
        case query
    }
    private var _title: AnyString?
    /**
     * Look Title
     */
    public var title: String? {
        get { _title?.value }
        set { _title = newValue.map(AnyString.init) }
    }

    private var _user_id: AnyString?
    /**
     * User Id
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    /**
     * Whether or not a look is 'soft' deleted.
     */
    public var deleted: Bool?

    private var _description: AnyString?
    /**
     * Description
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    /**
     * auto-run query when Look viewed
     */
    public var is_run_on_load: Bool?

    /**
     * Is Public
     */
    public var `public`: Bool?

    private var _query_id: AnyString?
    /**
     * Query Id
     */
    public var query_id: String? {
        get { _query_id?.value }
        set { _query_id = newValue.map(AnyString.init) }
    }

    /**
     * Dynamic writeable type for FolderBase removes:
     * id, content_metadata_id, created_at, creator_id, child_count, external_id, is_embed, is_embed_shared_root, is_embed_users_root, is_personal, is_personal_descendant, is_shared_root, is_users_root, can
     */
    public var folder: WriteFolderBase?

    private var _folder_id: AnyString?
    /**
     * Folder Id
     */
    public var folder_id: String? {
        get { _folder_id?.value }
        set { _folder_id = newValue.map(AnyString.init) }
    }

    /**
     * Dynamic writeable type for Query removes:
     * can, id, slug, share_url, expanded_share_url, url, has_table_calculations
     */
    public var query: WriteQuery?

    public init(title: String? = nil, user_id: String? = nil, deleted: Bool? = nil, description: String? = nil, is_run_on_load: Bool? = nil, `public`: Bool? = nil, query_id: String? = nil, folder: WriteFolderBase? = nil, folder_id: String? = nil, query: WriteQuery? = nil) {
        self._title = title.map(AnyString.init)
        self._user_id = user_id.map(AnyString.init)
        self.deleted = deleted
        self._description = description.map(AnyString.init)
        self.is_run_on_load = is_run_on_load
        self.`public` = `public`
        self._query_id = query_id.map(AnyString.init)
        self.folder = folder
        self._folder_id = folder_id.map(AnyString.init)
        self.query = query
    }

}

/**
 * Dynamic writeable type for MergeQuery removes:
 * can, id, result_maker_id
 */
public struct WriteMergeQuery: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _column_limit = "column_limit"
        case _dynamic_fields = "dynamic_fields"
        case _pivots = "pivots"
        case _sorts = "sorts"
        case source_queries
        case total
        case vis_config
    }
    private var _column_limit: AnyString?
    /**
     * Column Limit
     */
    public var column_limit: String? {
        get { _column_limit?.value }
        set { _column_limit = newValue.map(AnyString.init) }
    }

    private var _dynamic_fields: AnyString?
    /**
     * Dynamic Fields
     */
    public var dynamic_fields: String? {
        get { _dynamic_fields?.value }
        set { _dynamic_fields = newValue.map(AnyString.init) }
    }

    private var _pivots: [AnyString]?
    /**
     * Pivots
     */
    public var pivots: [String]? {
        get { if let v = _pivots { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _pivots = v.map { AnyString.init($0) } } else { _pivots = nil } }
    }

    private var _sorts: [AnyString]?
    /**
     * Sorts
     */
    public var sorts: [String]? {
        get { if let v = _sorts { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _sorts = v.map { AnyString.init($0) } } else { _sorts = nil } }
    }

    /**
     * Source Queries defining the results to be merged.
     */
    public var source_queries: [MergeQuerySourceQuery]?

    /**
     * Total
     */
    public var total: Bool?

    /**
     * Visualization Config
     */
    public var vis_config: StringDictionary<AnyCodable>?

    public init(column_limit: String? = nil, dynamic_fields: String? = nil, pivots: [String]? = nil, sorts: [String]? = nil, source_queries: [MergeQuerySourceQuery]? = nil, total: Bool? = nil, vis_config: StringDictionary<AnyCodable>? = nil) {
        self._column_limit = column_limit.map(AnyString.init)
        self._dynamic_fields = dynamic_fields.map(AnyString.init)
        if let v = pivots { _pivots = v.map { AnyString.init($0) } } else { _pivots = nil }
        if let v = sorts { _sorts = v.map { AnyString.init($0) } } else { _sorts = nil }
        self.source_queries = source_queries
        self.total = total
        self.vis_config = vis_config
    }

}

/**
 * Dynamic writeable type for MobileToken removes:
 * id
 */
public struct WriteMobileToken: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _device_token = "device_token"
        case device_type
    }
    private var _device_token: AnyString
    /**
     * Specifies the device token
     */
    public var device_token: String {
        get { _device_token.value }
        set { _device_token = AnyString.init(newValue) }
    }

    /**
     * Specifies type of device. Valid values are: "android", "ios".
     */
    public var device_type: DeviceType

    public init(device_token: String, device_type: DeviceType) {
        self._device_token = AnyString.init(device_token)
        self.device_type = device_type
    }

    public init(_ device_token: String, _ device_type: DeviceType) {
        self.init(device_token: device_token, device_type: device_type)
    }

}

/**
 * Dynamic writeable type for ModelSet removes:
 * can, all_access, built_in, id, url
 */
public struct WriteModelSet: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _models = "models"
        case _name = "name"
    }
    private var _models: [AnyString]?
    public var models: [String]? {
        get { if let v = _models { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _models = v.map { AnyString.init($0) } } else { _models = nil } }
    }

    private var _name: AnyString?
    /**
     * Name of ModelSet
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    public init(models: [String]? = nil, name: String? = nil) {
        if let v = models { _models = v.map { AnyString.init($0) } } else { _models = nil }
        self._name = name.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for OauthClientApp removes:
 * can, client_guid, tokens_invalid_before, activated_users
 */
public struct WriteOauthClientApp: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _redirect_uri = "redirect_uri"
        case _display_name = "display_name"
        case _description = "description"
        case enabled
        case _group_id = "group_id"
    }
    private var _redirect_uri: AnyString?
    /**
     * The uri with which this application will receive an auth code by browser redirect.
     */
    public var redirect_uri: String? {
        get { _redirect_uri?.value }
        set { _redirect_uri = newValue.map(AnyString.init) }
    }

    private var _display_name: AnyString?
    /**
     * The application's display name
     */
    public var display_name: String? {
        get { _display_name?.value }
        set { _display_name = newValue.map(AnyString.init) }
    }

    private var _description: AnyString?
    /**
     * A description of the application that will be displayed to users
     */
    public var description: String? {
        get { _description?.value }
        set { _description = newValue.map(AnyString.init) }
    }

    /**
     * When enabled is true, OAuth2 and API requests will be accepted from this app. When false, all requests from this app will be refused. Setting disabled invalidates existing tokens.
     */
    public var enabled: Bool?

    private var _group_id: AnyString?
    /**
     * If set, only Looker users who are members of this group can use this web app with Looker. If group_id is not set, any Looker user may use this app to access this Looker instance
     */
    public var group_id: String? {
        get { _group_id?.value }
        set { _group_id = newValue.map(AnyString.init) }
    }

    public init(redirect_uri: String? = nil, display_name: String? = nil, description: String? = nil, enabled: Bool? = nil, group_id: String? = nil) {
        self._redirect_uri = redirect_uri.map(AnyString.init)
        self._display_name = display_name.map(AnyString.init)
        self._description = description.map(AnyString.init)
        self.enabled = enabled
        self._group_id = group_id.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for OIDCConfig removes:
 * can, default_new_user_groups, default_new_user_roles, groups, modified_at, modified_by, test_slug, user_attributes, url
 */
public struct WriteOIDCConfig: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case alternate_email_login_allowed
        case _audience = "audience"
        case auth_requires_role
        case _authorization_endpoint = "authorization_endpoint"
        case _default_new_user_group_ids = "default_new_user_group_ids"
        case _default_new_user_role_ids = "default_new_user_role_ids"
        case enabled
        case _groups_attribute = "groups_attribute"
        case groups_with_role_ids
        case _identifier = "identifier"
        case _issuer = "issuer"
        case _new_user_migration_types = "new_user_migration_types"
        case _scopes = "scopes"
        case _secret = "secret"
        case set_roles_from_groups
        case _token_endpoint = "token_endpoint"
        case _user_attribute_map_email = "user_attribute_map_email"
        case _user_attribute_map_first_name = "user_attribute_map_first_name"
        case _user_attribute_map_last_name = "user_attribute_map_last_name"
        case user_attributes_with_ids
        case _userinfo_endpoint = "userinfo_endpoint"
        case allow_normal_group_membership
        case allow_roles_from_normal_groups
        case allow_direct_roles
    }
    /**
     * Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
     */
    public var alternate_email_login_allowed: Bool?

    private var _audience: AnyString?
    /**
     * OpenID Provider Audience
     */
    public var audience: String? {
        get { _audience?.value }
        set { _audience = newValue.map(AnyString.init) }
    }

    /**
     * Users will not be allowed to login at all unless a role for them is found in OIDC if set to true
     */
    public var auth_requires_role: Bool?

    private var _authorization_endpoint: AnyString?
    /**
     * OpenID Provider Authorization Url
     */
    public var authorization_endpoint: String? {
        get { _authorization_endpoint?.value }
        set { _authorization_endpoint = newValue.map(AnyString.init) }
    }

    private var _default_new_user_group_ids: [AnyString]?
    /**
     * (Write-Only) Array of ids of groups that will be applied to new users the first time they login via OIDC
     */
    public var default_new_user_group_ids: [String]? {
        get { if let v = _default_new_user_group_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _default_new_user_group_ids = v.map { AnyString.init($0) } } else { _default_new_user_group_ids = nil } }
    }

    private var _default_new_user_role_ids: [AnyString]?
    /**
     * (Write-Only) Array of ids of roles that will be applied to new users the first time they login via OIDC
     */
    public var default_new_user_role_ids: [String]? {
        get { if let v = _default_new_user_role_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _default_new_user_role_ids = v.map { AnyString.init($0) } } else { _default_new_user_role_ids = nil } }
    }

    /**
     * Enable/Disable OIDC authentication for the server
     */
    public var enabled: Bool?

    private var _groups_attribute: AnyString?
    /**
     * Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
     */
    public var groups_attribute: String? {
        get { _groups_attribute?.value }
        set { _groups_attribute = newValue.map(AnyString.init) }
    }

    /**
     * (Read/Write) Array of mappings between OIDC Groups and arrays of Looker Role ids
     */
    public var groups_with_role_ids: [OIDCGroupWrite]?

    private var _identifier: AnyString?
    /**
     * Relying Party Identifier (provided by OpenID Provider)
     */
    public var identifier: String? {
        get { _identifier?.value }
        set { _identifier = newValue.map(AnyString.init) }
    }

    private var _issuer: AnyString?
    /**
     * OpenID Provider Issuer
     */
    public var issuer: String? {
        get { _issuer?.value }
        set { _issuer = newValue.map(AnyString.init) }
    }

    private var _new_user_migration_types: AnyString?
    /**
     * Merge first-time oidc login to existing user account by email addresses. When a user logs in for the first time via oidc this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
     */
    public var new_user_migration_types: String? {
        get { _new_user_migration_types?.value }
        set { _new_user_migration_types = newValue.map(AnyString.init) }
    }

    private var _scopes: [AnyString]?
    /**
     * Array of scopes to request.
     */
    public var scopes: [String]? {
        get { if let v = _scopes { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _scopes = v.map { AnyString.init($0) } } else { _scopes = nil } }
    }

    private var _secret: AnyString?
    /**
     * (Write-Only) Relying Party Secret (provided by OpenID Provider)
     */
    public var secret: String? {
        get { _secret?.value }
        set { _secret = newValue.map(AnyString.init) }
    }

    /**
     * Set user roles in Looker based on groups from OIDC
     */
    public var set_roles_from_groups: Bool?

    private var _token_endpoint: AnyString?
    /**
     * OpenID Provider Token Url
     */
    public var token_endpoint: String? {
        get { _token_endpoint?.value }
        set { _token_endpoint = newValue.map(AnyString.init) }
    }

    private var _user_attribute_map_email: AnyString?
    /**
     * Name of user record attributes used to indicate email address field
     */
    public var user_attribute_map_email: String? {
        get { _user_attribute_map_email?.value }
        set { _user_attribute_map_email = newValue.map(AnyString.init) }
    }

    private var _user_attribute_map_first_name: AnyString?
    /**
     * Name of user record attributes used to indicate first name
     */
    public var user_attribute_map_first_name: String? {
        get { _user_attribute_map_first_name?.value }
        set { _user_attribute_map_first_name = newValue.map(AnyString.init) }
    }

    private var _user_attribute_map_last_name: AnyString?
    /**
     * Name of user record attributes used to indicate last name
     */
    public var user_attribute_map_last_name: String? {
        get { _user_attribute_map_last_name?.value }
        set { _user_attribute_map_last_name = newValue.map(AnyString.init) }
    }

    /**
     * (Read/Write) Array of mappings between OIDC User Attributes and arrays of Looker User Attribute ids
     */
    public var user_attributes_with_ids: [OIDCUserAttributeWrite]?

    private var _userinfo_endpoint: AnyString?
    /**
     * OpenID Provider User Information Url
     */
    public var userinfo_endpoint: String? {
        get { _userinfo_endpoint?.value }
        set { _userinfo_endpoint = newValue.map(AnyString.init) }
    }

    /**
     * Allow OIDC auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.
     */
    public var allow_normal_group_membership: Bool?

    /**
     * OIDC auth'd users will inherit roles from non-reflected Looker groups.
     */
    public var allow_roles_from_normal_groups: Bool?

    /**
     * Allows roles to be directly assigned to OIDC auth'd users.
     */
    public var allow_direct_roles: Bool?

    public init(alternate_email_login_allowed: Bool? = nil, audience: String? = nil, auth_requires_role: Bool? = nil, authorization_endpoint: String? = nil, default_new_user_group_ids: [String]? = nil, default_new_user_role_ids: [String]? = nil, enabled: Bool? = nil, groups_attribute: String? = nil, groups_with_role_ids: [OIDCGroupWrite]? = nil, identifier: String? = nil, issuer: String? = nil, new_user_migration_types: String? = nil, scopes: [String]? = nil, secret: String? = nil, set_roles_from_groups: Bool? = nil, token_endpoint: String? = nil, user_attribute_map_email: String? = nil, user_attribute_map_first_name: String? = nil, user_attribute_map_last_name: String? = nil, user_attributes_with_ids: [OIDCUserAttributeWrite]? = nil, userinfo_endpoint: String? = nil, allow_normal_group_membership: Bool? = nil, allow_roles_from_normal_groups: Bool? = nil, allow_direct_roles: Bool? = nil) {
        self.alternate_email_login_allowed = alternate_email_login_allowed
        self._audience = audience.map(AnyString.init)
        self.auth_requires_role = auth_requires_role
        self._authorization_endpoint = authorization_endpoint.map(AnyString.init)
        if let v = default_new_user_group_ids { _default_new_user_group_ids = v.map { AnyString.init($0) } } else { _default_new_user_group_ids = nil }
        if let v = default_new_user_role_ids { _default_new_user_role_ids = v.map { AnyString.init($0) } } else { _default_new_user_role_ids = nil }
        self.enabled = enabled
        self._groups_attribute = groups_attribute.map(AnyString.init)
        self.groups_with_role_ids = groups_with_role_ids
        self._identifier = identifier.map(AnyString.init)
        self._issuer = issuer.map(AnyString.init)
        self._new_user_migration_types = new_user_migration_types.map(AnyString.init)
        if let v = scopes { _scopes = v.map { AnyString.init($0) } } else { _scopes = nil }
        self._secret = secret.map(AnyString.init)
        self.set_roles_from_groups = set_roles_from_groups
        self._token_endpoint = token_endpoint.map(AnyString.init)
        self._user_attribute_map_email = user_attribute_map_email.map(AnyString.init)
        self._user_attribute_map_first_name = user_attribute_map_first_name.map(AnyString.init)
        self._user_attribute_map_last_name = user_attribute_map_last_name.map(AnyString.init)
        self.user_attributes_with_ids = user_attributes_with_ids
        self._userinfo_endpoint = userinfo_endpoint.map(AnyString.init)
        self.allow_normal_group_membership = allow_normal_group_membership
        self.allow_roles_from_normal_groups = allow_roles_from_normal_groups
        self.allow_direct_roles = allow_direct_roles
    }

}

/**
 * Dynamic writeable type for PasswordConfig removes:
 * can
 */
public struct WritePasswordConfig: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _min_length = "min_length"
        case require_numeric
        case require_upperlower
        case require_special
    }
    private var _min_length: AnyInt?
    /**
     * Minimum number of characters required for a new password.  Must be between 7 and 100
     */
    public var min_length: Int64? {
        get { _min_length?.value }
        set { _min_length = newValue.map(AnyInt.init) }
    }

    /**
     * Require at least one numeric character
     */
    public var require_numeric: Bool?

    /**
     * Require at least one uppercase and one lowercase letter
     */
    public var require_upperlower: Bool?

    /**
     * Require at least one special character
     */
    public var require_special: Bool?

    public init(min_length: Int64? = nil, require_numeric: Bool? = nil, require_upperlower: Bool? = nil, require_special: Bool? = nil) {
        self._min_length = min_length.map(AnyInt.init)
        self.require_numeric = require_numeric
        self.require_upperlower = require_upperlower
        self.require_special = require_special
    }

}

/**
 * Dynamic writeable type for PermissionSet removes:
 * can, all_access, built_in, id, url
 */
public struct WritePermissionSet: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _permissions = "permissions"
    }
    private var _name: AnyString?
    /**
     * Name of PermissionSet
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _permissions: [AnyString]?
    public var permissions: [String]? {
        get { if let v = _permissions { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _permissions = v.map { AnyString.init($0) } } else { _permissions = nil } }
    }

    public init(name: String? = nil, permissions: [String]? = nil) {
        self._name = name.map(AnyString.init)
        if let v = permissions { _permissions = v.map { AnyString.init($0) } } else { _permissions = nil }
    }

}

/**
 * Dynamic writeable type for PrivatelabelConfiguration removes:
 * logo_url, favicon_url
 */
public struct WritePrivatelabelConfiguration: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _logo_file = "logo_file"
        case _favicon_file = "favicon_file"
        case _default_title = "default_title"
        case show_help_menu
        case show_docs
        case show_email_sub_options
        case allow_looker_mentions
        case allow_looker_links
        case custom_welcome_email_advanced
        case setup_mentions
        case alerts_logo
        case alerts_links
        case folders_mentions
    }
    private var _logo_file: AnyString?
    /**
     * Customer logo image. Expected base64 encoded data (write-only)
     */
    public var logo_file: String? {
        get { _logo_file?.value }
        set { _logo_file = newValue.map(AnyString.init) }
    }

    private var _favicon_file: AnyString?
    /**
     * Custom favicon image. Expected base64 encoded data (write-only)
     */
    public var favicon_file: String? {
        get { _favicon_file?.value }
        set { _favicon_file = newValue.map(AnyString.init) }
    }

    private var _default_title: AnyString?
    /**
     * Default page title
     */
    public var default_title: String? {
        get { _default_title?.value }
        set { _default_title = newValue.map(AnyString.init) }
    }

    /**
     * Boolean to toggle showing help menus
     */
    public var show_help_menu: Bool?

    /**
     * Boolean to toggle showing docs
     */
    public var show_docs: Bool?

    /**
     * Boolean to toggle showing email subscription options.
     */
    public var show_email_sub_options: Bool?

    /**
     * Boolean to toggle mentions of Looker in emails
     */
    public var allow_looker_mentions: Bool?

    /**
     * Boolean to toggle links to Looker in emails
     */
    public var allow_looker_links: Bool?

    /**
     * Allow subject line and email heading customization in customized emails
     */
    public var custom_welcome_email_advanced: Bool?

    /**
     * Remove the word Looker from appearing in the account setup page
     */
    public var setup_mentions: Bool?

    /**
     * Remove Looker logo from Alerts
     */
    public var alerts_logo: Bool?

    /**
     * Remove Looker links from Alerts
     */
    public var alerts_links: Bool?

    /**
     * Remove Looker mentions in home folder page when you dont have any items saved
     */
    public var folders_mentions: Bool?

    public init(logo_file: String? = nil, favicon_file: String? = nil, default_title: String? = nil, show_help_menu: Bool? = nil, show_docs: Bool? = nil, show_email_sub_options: Bool? = nil, allow_looker_mentions: Bool? = nil, allow_looker_links: Bool? = nil, custom_welcome_email_advanced: Bool? = nil, setup_mentions: Bool? = nil, alerts_logo: Bool? = nil, alerts_links: Bool? = nil, folders_mentions: Bool? = nil) {
        self._logo_file = logo_file.map(AnyString.init)
        self._favicon_file = favicon_file.map(AnyString.init)
        self._default_title = default_title.map(AnyString.init)
        self.show_help_menu = show_help_menu
        self.show_docs = show_docs
        self.show_email_sub_options = show_email_sub_options
        self.allow_looker_mentions = allow_looker_mentions
        self.allow_looker_links = allow_looker_links
        self.custom_welcome_email_advanced = custom_welcome_email_advanced
        self.setup_mentions = setup_mentions
        self.alerts_logo = alerts_logo
        self.alerts_links = alerts_links
        self.folders_mentions = folders_mentions
    }

}

/**
 * Dynamic writeable type for Project removes:
 * can, id, uses_git, is_example
 */
public struct WriteProject: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _git_remote_url = "git_remote_url"
        case _git_username = "git_username"
        case _git_password = "git_password"
        case _git_production_branch_name = "git_production_branch_name"
        case use_git_cookie_auth
        case _git_username_user_attribute = "git_username_user_attribute"
        case _git_password_user_attribute = "git_password_user_attribute"
        case _git_service_name = "git_service_name"
        case _git_application_server_http_port = "git_application_server_http_port"
        case _git_application_server_http_scheme = "git_application_server_http_scheme"
        case _deploy_secret = "deploy_secret"
        case unset_deploy_secret
        case pull_request_mode
        case validation_required
        case git_release_mgmt_enabled
        case allow_warnings
        case _dependency_status = "dependency_status"
    }
    private var _name: AnyString?
    /**
     * Project display name
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _git_remote_url: AnyString?
    /**
     * Git remote repository url
     */
    public var git_remote_url: String? {
        get { _git_remote_url?.value }
        set { _git_remote_url = newValue.map(AnyString.init) }
    }

    private var _git_username: AnyString?
    /**
     * Git username for HTTPS authentication. (For production only, if using user attributes.)
     */
    public var git_username: String? {
        get { _git_username?.value }
        set { _git_username = newValue.map(AnyString.init) }
    }

    private var _git_password: AnyString?
    /**
     * (Write-Only) Git password for HTTPS authentication. (For production only, if using user attributes.)
     */
    public var git_password: String? {
        get { _git_password?.value }
        set { _git_password = newValue.map(AnyString.init) }
    }

    private var _git_production_branch_name: AnyString?
    /**
     * Git production branch name. Defaults to master. Supported only in Looker 21.0 and higher.
     */
    public var git_production_branch_name: String? {
        get { _git_production_branch_name?.value }
        set { _git_production_branch_name = newValue.map(AnyString.init) }
    }

    /**
     * If true, the project uses a git cookie for authentication.
     */
    public var use_git_cookie_auth: Bool?

    private var _git_username_user_attribute: AnyString?
    /**
     * User attribute name for username in per-user HTTPS authentication.
     */
    public var git_username_user_attribute: String? {
        get { _git_username_user_attribute?.value }
        set { _git_username_user_attribute = newValue.map(AnyString.init) }
    }

    private var _git_password_user_attribute: AnyString?
    /**
     * User attribute name for password in per-user HTTPS authentication.
     */
    public var git_password_user_attribute: String? {
        get { _git_password_user_attribute?.value }
        set { _git_password_user_attribute = newValue.map(AnyString.init) }
    }

    private var _git_service_name: AnyString?
    /**
     * Name of the git service provider
     */
    public var git_service_name: String? {
        get { _git_service_name?.value }
        set { _git_service_name = newValue.map(AnyString.init) }
    }

    private var _git_application_server_http_port: AnyInt?
    /**
     * Port that HTTP(S) application server is running on (for PRs, file browsing, etc.)
     */
    public var git_application_server_http_port: Int64? {
        get { _git_application_server_http_port?.value }
        set { _git_application_server_http_port = newValue.map(AnyInt.init) }
    }

    private var _git_application_server_http_scheme: AnyString?
    /**
     * Scheme that is running on application server (for PRs, file browsing, etc.)
     */
    public var git_application_server_http_scheme: String? {
        get { _git_application_server_http_scheme?.value }
        set { _git_application_server_http_scheme = newValue.map(AnyString.init) }
    }

    private var _deploy_secret: AnyString?
    /**
     * (Write-Only) Optional secret token with which to authenticate requests to the webhook deploy endpoint. If not set, endpoint is unauthenticated.
     */
    public var deploy_secret: String? {
        get { _deploy_secret?.value }
        set { _deploy_secret = newValue.map(AnyString.init) }
    }

    /**
     * (Write-Only) When true, unsets the deploy secret to allow unauthenticated access to the webhook deploy endpoint.
     */
    public var unset_deploy_secret: Bool?

    /**
     * The git pull request policy for this project. Valid values are: "off", "links", "recommended", "required".
     */
    public var pull_request_mode: PullRequestMode?

    /**
     * Validation policy: If true, the project must pass validation checks before project changes can be committed to the git repository
     */
    public var validation_required: Bool?

    /**
     * If true, advanced git release management is enabled for this project
     */
    public var git_release_mgmt_enabled: Bool?

    /**
     * Validation policy: If true, the project can be committed with warnings when `validation_required` is true. (`allow_warnings` does nothing if `validation_required` is false).
     */
    public var allow_warnings: Bool?

    private var _dependency_status: AnyString?
    /**
     * Status of dependencies in your manifest & lockfile
     */
    public var dependency_status: String? {
        get { _dependency_status?.value }
        set { _dependency_status = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, git_remote_url: String? = nil, git_username: String? = nil, git_password: String? = nil, git_production_branch_name: String? = nil, use_git_cookie_auth: Bool? = nil, git_username_user_attribute: String? = nil, git_password_user_attribute: String? = nil, git_service_name: String? = nil, git_application_server_http_port: Int64? = nil, git_application_server_http_scheme: String? = nil, deploy_secret: String? = nil, unset_deploy_secret: Bool? = nil, pull_request_mode: PullRequestMode? = nil, validation_required: Bool? = nil, git_release_mgmt_enabled: Bool? = nil, allow_warnings: Bool? = nil, dependency_status: String? = nil) {
        self._name = name.map(AnyString.init)
        self._git_remote_url = git_remote_url.map(AnyString.init)
        self._git_username = git_username.map(AnyString.init)
        self._git_password = git_password.map(AnyString.init)
        self._git_production_branch_name = git_production_branch_name.map(AnyString.init)
        self.use_git_cookie_auth = use_git_cookie_auth
        self._git_username_user_attribute = git_username_user_attribute.map(AnyString.init)
        self._git_password_user_attribute = git_password_user_attribute.map(AnyString.init)
        self._git_service_name = git_service_name.map(AnyString.init)
        self._git_application_server_http_port = git_application_server_http_port.map(AnyInt.init)
        self._git_application_server_http_scheme = git_application_server_http_scheme.map(AnyString.init)
        self._deploy_secret = deploy_secret.map(AnyString.init)
        self.unset_deploy_secret = unset_deploy_secret
        self.pull_request_mode = pull_request_mode
        self.validation_required = validation_required
        self.git_release_mgmt_enabled = git_release_mgmt_enabled
        self.allow_warnings = allow_warnings
        self._dependency_status = dependency_status.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for Query removes:
 * can, id, slug, share_url, expanded_share_url, url, has_table_calculations
 */
public struct WriteQuery: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _model = "model"
        case _view = "view"
        case _fields = "fields"
        case _pivots = "pivots"
        case _fill_fields = "fill_fields"
        case filters
        case _filter_expression = "filter_expression"
        case _sorts = "sorts"
        case _limit = "limit"
        case _column_limit = "column_limit"
        case total
        case _row_total = "row_total"
        case _subtotals = "subtotals"
        case vis_config
        case filter_config
        case _visible_ui_sections = "visible_ui_sections"
        case _dynamic_fields = "dynamic_fields"
        case _client_id = "client_id"
        case _query_timezone = "query_timezone"
    }
    private var _model: AnyString
    /**
     * Model
     */
    public var model: String {
        get { _model.value }
        set { _model = AnyString.init(newValue) }
    }

    private var _view: AnyString
    /**
     * Explore Name
     */
    public var view: String {
        get { _view.value }
        set { _view = AnyString.init(newValue) }
    }

    private var _fields: [AnyString]?
    /**
     * Fields
     */
    public var fields: [String]? {
        get { if let v = _fields { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _fields = v.map { AnyString.init($0) } } else { _fields = nil } }
    }

    private var _pivots: [AnyString]?
    /**
     * Pivots
     */
    public var pivots: [String]? {
        get { if let v = _pivots { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _pivots = v.map { AnyString.init($0) } } else { _pivots = nil } }
    }

    private var _fill_fields: [AnyString]?
    /**
     * Fill Fields
     */
    public var fill_fields: [String]? {
        get { if let v = _fill_fields { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _fill_fields = v.map { AnyString.init($0) } } else { _fill_fields = nil } }
    }

    /**
     * Filters will contain data pertaining to complex filters that do not contain "or" conditions. When "or" conditions are present, filter data will be found on the `filter_expression` property.
     */
    public var filters: StringDictionary<AnyCodable>?

    private var _filter_expression: AnyString?
    /**
     * Filter Expression
     */
    public var filter_expression: String? {
        get { _filter_expression?.value }
        set { _filter_expression = newValue.map(AnyString.init) }
    }

    private var _sorts: [AnyString]?
    /**
     * Sorting for the query results. Use the format `["view.field", ...]` to sort on fields in ascending order. Use the format `["view.field desc", ...]` to sort on fields in descending order. Use `["__UNSORTED__"]` (2 underscores before and after) to disable sorting entirely. Empty sorts `[]` will trigger a default sort.
     */
    public var sorts: [String]? {
        get { if let v = _sorts { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _sorts = v.map { AnyString.init($0) } } else { _sorts = nil } }
    }

    private var _limit: AnyString?
    /**
     * Row limit. To download unlimited results, set the limit to -1 (negative one).
     */
    public var limit: String? {
        get { _limit?.value }
        set { _limit = newValue.map(AnyString.init) }
    }

    private var _column_limit: AnyString?
    /**
     * Column Limit
     */
    public var column_limit: String? {
        get { _column_limit?.value }
        set { _column_limit = newValue.map(AnyString.init) }
    }

    /**
     * Total
     */
    public var total: Bool?

    private var _row_total: AnyString?
    /**
     * Raw Total
     */
    public var row_total: String? {
        get { _row_total?.value }
        set { _row_total = newValue.map(AnyString.init) }
    }

    private var _subtotals: [AnyString]?
    /**
     * Fields on which to run subtotals
     */
    public var subtotals: [String]? {
        get { if let v = _subtotals { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _subtotals = v.map { AnyString.init($0) } } else { _subtotals = nil } }
    }

    /**
     * Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
     */
    public var vis_config: StringDictionary<AnyCodable>?

    /**
     * The filter_config represents the state of the filter UI on the explore page for a given query. When running a query via the Looker UI, this parameter takes precedence over "filters". When creating a query or modifying an existing query, "filter_config" should be set to null. Setting it to any other value could cause unexpected filtering behavior. The format should be considered opaque.
     */
    public var filter_config: StringDictionary<AnyCodable>?

    private var _visible_ui_sections: AnyString?
    /**
     * Visible UI Sections
     */
    public var visible_ui_sections: String? {
        get { _visible_ui_sections?.value }
        set { _visible_ui_sections = newValue.map(AnyString.init) }
    }

    private var _dynamic_fields: AnyString?
    /**
     * Dynamic Fields
     */
    public var dynamic_fields: String? {
        get { _dynamic_fields?.value }
        set { _dynamic_fields = newValue.map(AnyString.init) }
    }

    private var _client_id: AnyString?
    /**
     * Client Id: used to generate shortened explore URLs. If set by client, must be a unique 22 character alphanumeric string. Otherwise one will be generated.
     */
    public var client_id: String? {
        get { _client_id?.value }
        set { _client_id = newValue.map(AnyString.init) }
    }

    private var _query_timezone: AnyString?
    /**
     * Query Timezone
     */
    public var query_timezone: String? {
        get { _query_timezone?.value }
        set { _query_timezone = newValue.map(AnyString.init) }
    }

    public init(model: String, view: String, fields: [String]? = nil, pivots: [String]? = nil, fill_fields: [String]? = nil, filters: StringDictionary<AnyCodable>? = nil, filter_expression: String? = nil, sorts: [String]? = nil, limit: String? = nil, column_limit: String? = nil, total: Bool? = nil, row_total: String? = nil, subtotals: [String]? = nil, vis_config: StringDictionary<AnyCodable>? = nil, filter_config: StringDictionary<AnyCodable>? = nil, visible_ui_sections: String? = nil, dynamic_fields: String? = nil, client_id: String? = nil, query_timezone: String? = nil) {
        self._model = AnyString.init(model)
        self._view = AnyString.init(view)
        if let v = fields { _fields = v.map { AnyString.init($0) } } else { _fields = nil }
        if let v = pivots { _pivots = v.map { AnyString.init($0) } } else { _pivots = nil }
        if let v = fill_fields { _fill_fields = v.map { AnyString.init($0) } } else { _fill_fields = nil }
        self.filters = filters
        self._filter_expression = filter_expression.map(AnyString.init)
        if let v = sorts { _sorts = v.map { AnyString.init($0) } } else { _sorts = nil }
        self._limit = limit.map(AnyString.init)
        self._column_limit = column_limit.map(AnyString.init)
        self.total = total
        self._row_total = row_total.map(AnyString.init)
        if let v = subtotals { _subtotals = v.map { AnyString.init($0) } } else { _subtotals = nil }
        self.vis_config = vis_config
        self.filter_config = filter_config
        self._visible_ui_sections = visible_ui_sections.map(AnyString.init)
        self._dynamic_fields = dynamic_fields.map(AnyString.init)
        self._client_id = client_id.map(AnyString.init)
        self._query_timezone = query_timezone.map(AnyString.init)
    }

    public init(_ model: String, _ view: String, fields: [String]? = nil, pivots: [String]? = nil, fill_fields: [String]? = nil, filters: StringDictionary<AnyCodable>? = nil, filter_expression: String? = nil, sorts: [String]? = nil, limit: String? = nil, column_limit: String? = nil, total: Bool? = nil, row_total: String? = nil, subtotals: [String]? = nil, vis_config: StringDictionary<AnyCodable>? = nil, filter_config: StringDictionary<AnyCodable>? = nil, visible_ui_sections: String? = nil, dynamic_fields: String? = nil, client_id: String? = nil, query_timezone: String? = nil) {
        self.init(model: model, view: view, fields: fields, pivots: pivots, fill_fields: fill_fields, filters: filters, filter_expression: filter_expression, sorts: sorts, limit: limit, column_limit: column_limit, total: total, row_total: row_total, subtotals: subtotals, vis_config: vis_config, filter_config: filter_config, visible_ui_sections: visible_ui_sections, dynamic_fields: dynamic_fields, client_id: client_id, query_timezone: query_timezone)
    }

}

/**
 * Dynamic writeable type for RepositoryCredential removes:
 * can, id, root_project_id, remote_url, is_configured
 */
public struct WriteRepositoryCredential: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _git_username = "git_username"
        case _git_password = "git_password"
        case _ssh_public_key = "ssh_public_key"
    }
    private var _git_username: AnyString?
    /**
     * Git username for HTTPS authentication.
     */
    public var git_username: String? {
        get { _git_username?.value }
        set { _git_username = newValue.map(AnyString.init) }
    }

    private var _git_password: AnyString?
    /**
     * (Write-Only) Git password for HTTPS authentication.
     */
    public var git_password: String? {
        get { _git_password?.value }
        set { _git_password = newValue.map(AnyString.init) }
    }

    private var _ssh_public_key: AnyString?
    /**
     * Public deploy key for SSH authentication.
     */
    public var ssh_public_key: String? {
        get { _ssh_public_key?.value }
        set { _ssh_public_key = newValue.map(AnyString.init) }
    }

    public init(git_username: String? = nil, git_password: String? = nil, ssh_public_key: String? = nil) {
        self._git_username = git_username.map(AnyString.init)
        self._git_password = git_password.map(AnyString.init)
        self._ssh_public_key = ssh_public_key.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for ResultMakerWithIdVisConfigAndDynamicFields removes:
 * id, dynamic_fields, filterables, sorts, merge_result_id, total, query_id, sql_query_id, vis_config
 */
public struct WriteResultMakerWithIdVisConfigAndDynamicFields: SDKModel {
    /**
     * Dynamic writeable type for Query removes:
     * can, id, slug, share_url, expanded_share_url, url, has_table_calculations
     */
    public var query: WriteQuery?

    public init(query: WriteQuery? = nil) {
        self.query = query
    }

}

/**
 * Dynamic writeable type for Role removes:
 * can, id, url, users_url
 */
public struct WriteRole: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case permission_set
        case _permission_set_id = "permission_set_id"
        case model_set
        case _model_set_id = "model_set_id"
    }
    private var _name: AnyString?
    /**
     * Name of Role
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    /**
     * Dynamic writeable type for PermissionSet removes:
     * can, all_access, built_in, id, url
     */
    public var permission_set: WritePermissionSet?

    private var _permission_set_id: AnyString?
    /**
     * (Write-Only) Id of permission set
     */
    public var permission_set_id: String? {
        get { _permission_set_id?.value }
        set { _permission_set_id = newValue.map(AnyString.init) }
    }

    /**
     * Dynamic writeable type for ModelSet removes:
     * can, all_access, built_in, id, url
     */
    public var model_set: WriteModelSet?

    private var _model_set_id: AnyString?
    /**
     * (Write-Only) Id of model set
     */
    public var model_set_id: String? {
        get { _model_set_id?.value }
        set { _model_set_id = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, permission_set: WritePermissionSet? = nil, permission_set_id: String? = nil, model_set: WriteModelSet? = nil, model_set_id: String? = nil) {
        self._name = name.map(AnyString.init)
        self.permission_set = permission_set
        self._permission_set_id = permission_set_id.map(AnyString.init)
        self.model_set = model_set
        self._model_set_id = model_set_id.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for SamlConfig removes:
 * can, test_slug, modified_at, modified_by, default_new_user_roles, default_new_user_groups, groups, user_attributes, url
 */
public struct WriteSamlConfig: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case enabled
        case _idp_cert = "idp_cert"
        case _idp_url = "idp_url"
        case _idp_issuer = "idp_issuer"
        case _idp_audience = "idp_audience"
        case _allowed_clock_drift = "allowed_clock_drift"
        case _user_attribute_map_email = "user_attribute_map_email"
        case _user_attribute_map_first_name = "user_attribute_map_first_name"
        case _user_attribute_map_last_name = "user_attribute_map_last_name"
        case _new_user_migration_types = "new_user_migration_types"
        case alternate_email_login_allowed
        case _default_new_user_role_ids = "default_new_user_role_ids"
        case _default_new_user_group_ids = "default_new_user_group_ids"
        case set_roles_from_groups
        case _groups_attribute = "groups_attribute"
        case groups_with_role_ids
        case auth_requires_role
        case user_attributes_with_ids
        case _groups_finder_type = "groups_finder_type"
        case _groups_member_value = "groups_member_value"
        case bypass_login_page
        case allow_normal_group_membership
        case allow_roles_from_normal_groups
        case allow_direct_roles
    }
    /**
     * Enable/Disable Saml authentication for the server
     */
    public var enabled: Bool?

    private var _idp_cert: AnyString?
    /**
     * Identity Provider Certificate (provided by IdP)
     */
    public var idp_cert: String? {
        get { _idp_cert?.value }
        set { _idp_cert = newValue.map(AnyString.init) }
    }

    private var _idp_url: AnyString?
    /**
     * Identity Provider Url (provided by IdP)
     */
    public var idp_url: String? {
        get { _idp_url?.value }
        set { _idp_url = newValue.map(AnyString.init) }
    }

    private var _idp_issuer: AnyString?
    /**
     * Identity Provider Issuer (provided by IdP)
     */
    public var idp_issuer: String? {
        get { _idp_issuer?.value }
        set { _idp_issuer = newValue.map(AnyString.init) }
    }

    private var _idp_audience: AnyString?
    /**
     * Identity Provider Audience (set in IdP config). Optional in Looker. Set this only if you want Looker to validate the audience value returned by the IdP.
     */
    public var idp_audience: String? {
        get { _idp_audience?.value }
        set { _idp_audience = newValue.map(AnyString.init) }
    }

    private var _allowed_clock_drift: AnyInt?
    /**
     * Count of seconds of clock drift to allow when validating timestamps of assertions.
     */
    public var allowed_clock_drift: Int64? {
        get { _allowed_clock_drift?.value }
        set { _allowed_clock_drift = newValue.map(AnyInt.init) }
    }

    private var _user_attribute_map_email: AnyString?
    /**
     * Name of user record attributes used to indicate email address field
     */
    public var user_attribute_map_email: String? {
        get { _user_attribute_map_email?.value }
        set { _user_attribute_map_email = newValue.map(AnyString.init) }
    }

    private var _user_attribute_map_first_name: AnyString?
    /**
     * Name of user record attributes used to indicate first name
     */
    public var user_attribute_map_first_name: String? {
        get { _user_attribute_map_first_name?.value }
        set { _user_attribute_map_first_name = newValue.map(AnyString.init) }
    }

    private var _user_attribute_map_last_name: AnyString?
    /**
     * Name of user record attributes used to indicate last name
     */
    public var user_attribute_map_last_name: String? {
        get { _user_attribute_map_last_name?.value }
        set { _user_attribute_map_last_name = newValue.map(AnyString.init) }
    }

    private var _new_user_migration_types: AnyString?
    /**
     * Merge first-time saml login to existing user account by email addresses. When a user logs in for the first time via saml this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
     */
    public var new_user_migration_types: String? {
        get { _new_user_migration_types?.value }
        set { _new_user_migration_types = newValue.map(AnyString.init) }
    }

    /**
     * Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
     */
    public var alternate_email_login_allowed: Bool?

    private var _default_new_user_role_ids: [AnyString]?
    /**
     * (Write-Only) Array of ids of roles that will be applied to new users the first time they login via Saml
     */
    public var default_new_user_role_ids: [String]? {
        get { if let v = _default_new_user_role_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _default_new_user_role_ids = v.map { AnyString.init($0) } } else { _default_new_user_role_ids = nil } }
    }

    private var _default_new_user_group_ids: [AnyString]?
    /**
     * (Write-Only) Array of ids of groups that will be applied to new users the first time they login via Saml
     */
    public var default_new_user_group_ids: [String]? {
        get { if let v = _default_new_user_group_ids { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _default_new_user_group_ids = v.map { AnyString.init($0) } } else { _default_new_user_group_ids = nil } }
    }

    /**
     * Set user roles in Looker based on groups from Saml
     */
    public var set_roles_from_groups: Bool?

    private var _groups_attribute: AnyString?
    /**
     * Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
     */
    public var groups_attribute: String? {
        get { _groups_attribute?.value }
        set { _groups_attribute = newValue.map(AnyString.init) }
    }

    /**
     * (Read/Write) Array of mappings between Saml Groups and arrays of Looker Role ids
     */
    public var groups_with_role_ids: [SamlGroupWrite]?

    /**
     * Users will not be allowed to login at all unless a role for them is found in Saml if set to true
     */
    public var auth_requires_role: Bool?

    /**
     * (Read/Write) Array of mappings between Saml User Attributes and arrays of Looker User Attribute ids
     */
    public var user_attributes_with_ids: [SamlUserAttributeWrite]?

    private var _groups_finder_type: AnyString?
    /**
     * Identifier for a strategy for how Looker will find groups in the SAML response. One of ['grouped_attribute_values', 'individual_attributes']
     */
    public var groups_finder_type: String? {
        get { _groups_finder_type?.value }
        set { _groups_finder_type = newValue.map(AnyString.init) }
    }

    private var _groups_member_value: AnyString?
    /**
     * Value for group attribute used to indicate membership. Used when 'groups_finder_type' is set to 'individual_attributes'
     */
    public var groups_member_value: String? {
        get { _groups_member_value?.value }
        set { _groups_member_value = newValue.map(AnyString.init) }
    }

    /**
     * Bypass the login page when user authentication is required. Redirect to IdP immediately instead.
     */
    public var bypass_login_page: Bool?

    /**
     * Allow SAML auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.
     */
    public var allow_normal_group_membership: Bool?

    /**
     * SAML auth'd users will inherit roles from non-reflected Looker groups.
     */
    public var allow_roles_from_normal_groups: Bool?

    /**
     * Allows roles to be directly assigned to SAML auth'd users.
     */
    public var allow_direct_roles: Bool?

    public init(enabled: Bool? = nil, idp_cert: String? = nil, idp_url: String? = nil, idp_issuer: String? = nil, idp_audience: String? = nil, allowed_clock_drift: Int64? = nil, user_attribute_map_email: String? = nil, user_attribute_map_first_name: String? = nil, user_attribute_map_last_name: String? = nil, new_user_migration_types: String? = nil, alternate_email_login_allowed: Bool? = nil, default_new_user_role_ids: [String]? = nil, default_new_user_group_ids: [String]? = nil, set_roles_from_groups: Bool? = nil, groups_attribute: String? = nil, groups_with_role_ids: [SamlGroupWrite]? = nil, auth_requires_role: Bool? = nil, user_attributes_with_ids: [SamlUserAttributeWrite]? = nil, groups_finder_type: String? = nil, groups_member_value: String? = nil, bypass_login_page: Bool? = nil, allow_normal_group_membership: Bool? = nil, allow_roles_from_normal_groups: Bool? = nil, allow_direct_roles: Bool? = nil) {
        self.enabled = enabled
        self._idp_cert = idp_cert.map(AnyString.init)
        self._idp_url = idp_url.map(AnyString.init)
        self._idp_issuer = idp_issuer.map(AnyString.init)
        self._idp_audience = idp_audience.map(AnyString.init)
        self._allowed_clock_drift = allowed_clock_drift.map(AnyInt.init)
        self._user_attribute_map_email = user_attribute_map_email.map(AnyString.init)
        self._user_attribute_map_first_name = user_attribute_map_first_name.map(AnyString.init)
        self._user_attribute_map_last_name = user_attribute_map_last_name.map(AnyString.init)
        self._new_user_migration_types = new_user_migration_types.map(AnyString.init)
        self.alternate_email_login_allowed = alternate_email_login_allowed
        if let v = default_new_user_role_ids { _default_new_user_role_ids = v.map { AnyString.init($0) } } else { _default_new_user_role_ids = nil }
        if let v = default_new_user_group_ids { _default_new_user_group_ids = v.map { AnyString.init($0) } } else { _default_new_user_group_ids = nil }
        self.set_roles_from_groups = set_roles_from_groups
        self._groups_attribute = groups_attribute.map(AnyString.init)
        self.groups_with_role_ids = groups_with_role_ids
        self.auth_requires_role = auth_requires_role
        self.user_attributes_with_ids = user_attributes_with_ids
        self._groups_finder_type = groups_finder_type.map(AnyString.init)
        self._groups_member_value = groups_member_value.map(AnyString.init)
        self.bypass_login_page = bypass_login_page
        self.allow_normal_group_membership = allow_normal_group_membership
        self.allow_roles_from_normal_groups = allow_roles_from_normal_groups
        self.allow_direct_roles = allow_direct_roles
    }

}

/**
 * Dynamic writeable type for ScheduledPlan removes:
 * id, created_at, updated_at, title, user, next_run_at, last_run_at, can
 */
public struct WriteScheduledPlan: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _user_id = "user_id"
        case run_as_recipient
        case enabled
        case _look_id = "look_id"
        case _dashboard_id = "dashboard_id"
        case _lookml_dashboard_id = "lookml_dashboard_id"
        case _filters_string = "filters_string"
        case _dashboard_filters = "dashboard_filters"
        case require_results
        case require_no_results
        case require_change
        case send_all_results
        case _crontab = "crontab"
        case _datagroup = "datagroup"
        case _timezone = "timezone"
        case scheduled_plan_destination
        case run_once
        case include_links
        case _custom_url_base = "custom_url_base"
        case _custom_url_params = "custom_url_params"
        case _custom_url_label = "custom_url_label"
        case show_custom_url
        case _pdf_paper_size = "pdf_paper_size"
        case pdf_landscape
        case embed
        case _color_theme = "color_theme"
        case long_tables
        case _inline_table_width = "inline_table_width"
        case _query_id = "query_id"
    }
    private var _name: AnyString?
    /**
     * Name of this scheduled plan
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    private var _user_id: AnyString?
    /**
     * User Id which owns this scheduled plan
     */
    public var user_id: String? {
        get { _user_id?.value }
        set { _user_id = newValue.map(AnyString.init) }
    }

    /**
     * Whether schedule is run as recipient (only applicable for email recipients)
     */
    public var run_as_recipient: Bool?

    /**
     * Whether the ScheduledPlan is enabled
     */
    public var enabled: Bool?

    private var _look_id: AnyString?
    /**
     * Id of a look
     */
    public var look_id: String? {
        get { _look_id?.value }
        set { _look_id = newValue.map(AnyString.init) }
    }

    private var _dashboard_id: AnyString?
    /**
     * Id of a dashboard
     */
    public var dashboard_id: String? {
        get { _dashboard_id?.value }
        set { _dashboard_id = newValue.map(AnyString.init) }
    }

    private var _lookml_dashboard_id: AnyString?
    /**
     * Id of a LookML dashboard
     */
    public var lookml_dashboard_id: String? {
        get { _lookml_dashboard_id?.value }
        set { _lookml_dashboard_id = newValue.map(AnyString.init) }
    }

    private var _filters_string: AnyString?
    /**
     * Query string to run look or dashboard with
     */
    public var filters_string: String? {
        get { _filters_string?.value }
        set { _filters_string = newValue.map(AnyString.init) }
    }

    private var _dashboard_filters: AnyString?
    /**
     * (DEPRECATED) Alias for filters_string field
     */
    public var dashboard_filters: String? {
        get { _dashboard_filters?.value }
        set { _dashboard_filters = newValue.map(AnyString.init) }
    }

    /**
     * Delivery should occur if running the dashboard or look returns results
     */
    public var require_results: Bool?

    /**
     * Delivery should occur if the dashboard look does not return results
     */
    public var require_no_results: Bool?

    /**
     * Delivery should occur if data have changed since the last run
     */
    public var require_change: Bool?

    /**
     * Will run an unlimited query and send all results.
     */
    public var send_all_results: Bool?

    private var _crontab: AnyString?
    /**
     * Vixie-Style crontab specification when to run
     */
    public var crontab: String? {
        get { _crontab?.value }
        set { _crontab = newValue.map(AnyString.init) }
    }

    private var _datagroup: AnyString?
    /**
     * Name of a datagroup; if specified will run when datagroup triggered (can't be used with cron string)
     */
    public var datagroup: String? {
        get { _datagroup?.value }
        set { _datagroup = newValue.map(AnyString.init) }
    }

    private var _timezone: AnyString?
    /**
     * Timezone for interpreting the specified crontab (default is Looker instance timezone)
     */
    public var timezone: String? {
        get { _timezone?.value }
        set { _timezone = newValue.map(AnyString.init) }
    }

    /**
     * Scheduled plan destinations
     */
    public var scheduled_plan_destination: [ScheduledPlanDestination]?

    /**
     * Whether the plan in question should only be run once (usually for testing)
     */
    public var run_once: Bool?

    /**
     * Whether links back to Looker should be included in this ScheduledPlan
     */
    public var include_links: Bool?

    private var _custom_url_base: AnyString?
    /**
     * Custom url domain for the scheduled entity
     */
    public var custom_url_base: String? {
        get { _custom_url_base?.value }
        set { _custom_url_base = newValue.map(AnyString.init) }
    }

    private var _custom_url_params: AnyString?
    /**
     * Custom url path and parameters for the scheduled entity
     */
    public var custom_url_params: String? {
        get { _custom_url_params?.value }
        set { _custom_url_params = newValue.map(AnyString.init) }
    }

    private var _custom_url_label: AnyString?
    /**
     * Custom url label for the scheduled entity
     */
    public var custom_url_label: String? {
        get { _custom_url_label?.value }
        set { _custom_url_label = newValue.map(AnyString.init) }
    }

    /**
     * Whether to show custom link back instead of standard looker link
     */
    public var show_custom_url: Bool?

    private var _pdf_paper_size: AnyString?
    /**
     * The size of paper the PDF should be formatted to fit. Valid values are: "letter", "legal", "tabloid", "a0", "a1", "a2", "a3", "a4", "a5".
     */
    public var pdf_paper_size: String? {
        get { _pdf_paper_size?.value }
        set { _pdf_paper_size = newValue.map(AnyString.init) }
    }

    /**
     * Whether the PDF should be formatted for landscape orientation
     */
    public var pdf_landscape: Bool?

    /**
     * Whether this schedule is in an embed context or not
     */
    public var embed: Bool?

    private var _color_theme: AnyString?
    /**
     * Color scheme of the dashboard if applicable
     */
    public var color_theme: String? {
        get { _color_theme?.value }
        set { _color_theme = newValue.map(AnyString.init) }
    }

    /**
     * Whether or not to expand table vis to full length
     */
    public var long_tables: Bool?

    private var _inline_table_width: AnyInt?
    /**
     * The pixel width at which we render the inline table visualizations
     */
    public var inline_table_width: Int64? {
        get { _inline_table_width?.value }
        set { _inline_table_width = newValue.map(AnyInt.init) }
    }

    private var _query_id: AnyString?
    /**
     * Query id
     */
    public var query_id: String? {
        get { _query_id?.value }
        set { _query_id = newValue.map(AnyString.init) }
    }

    public init(name: String? = nil, user_id: String? = nil, run_as_recipient: Bool? = nil, enabled: Bool? = nil, look_id: String? = nil, dashboard_id: String? = nil, lookml_dashboard_id: String? = nil, filters_string: String? = nil, dashboard_filters: String? = nil, require_results: Bool? = nil, require_no_results: Bool? = nil, require_change: Bool? = nil, send_all_results: Bool? = nil, crontab: String? = nil, datagroup: String? = nil, timezone: String? = nil, scheduled_plan_destination: [ScheduledPlanDestination]? = nil, run_once: Bool? = nil, include_links: Bool? = nil, custom_url_base: String? = nil, custom_url_params: String? = nil, custom_url_label: String? = nil, show_custom_url: Bool? = nil, pdf_paper_size: String? = nil, pdf_landscape: Bool? = nil, embed: Bool? = nil, color_theme: String? = nil, long_tables: Bool? = nil, inline_table_width: Int64? = nil, query_id: String? = nil) {
        self._name = name.map(AnyString.init)
        self._user_id = user_id.map(AnyString.init)
        self.run_as_recipient = run_as_recipient
        self.enabled = enabled
        self._look_id = look_id.map(AnyString.init)
        self._dashboard_id = dashboard_id.map(AnyString.init)
        self._lookml_dashboard_id = lookml_dashboard_id.map(AnyString.init)
        self._filters_string = filters_string.map(AnyString.init)
        self._dashboard_filters = dashboard_filters.map(AnyString.init)
        self.require_results = require_results
        self.require_no_results = require_no_results
        self.require_change = require_change
        self.send_all_results = send_all_results
        self._crontab = crontab.map(AnyString.init)
        self._datagroup = datagroup.map(AnyString.init)
        self._timezone = timezone.map(AnyString.init)
        self.scheduled_plan_destination = scheduled_plan_destination
        self.run_once = run_once
        self.include_links = include_links
        self._custom_url_base = custom_url_base.map(AnyString.init)
        self._custom_url_params = custom_url_params.map(AnyString.init)
        self._custom_url_label = custom_url_label.map(AnyString.init)
        self.show_custom_url = show_custom_url
        self._pdf_paper_size = pdf_paper_size.map(AnyString.init)
        self.pdf_landscape = pdf_landscape
        self.embed = embed
        self._color_theme = color_theme.map(AnyString.init)
        self.long_tables = long_tables
        self._inline_table_width = inline_table_width.map(AnyInt.init)
        self._query_id = query_id.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for SessionConfig removes:
 * can
 */
public struct WriteSessionConfig: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case allow_persistent_sessions
        case _session_minutes = "session_minutes"
        case unlimited_sessions_per_user
        case use_inactivity_based_logout
        case track_session_location
    }
    /**
     * Allow users to have persistent sessions when they login
     */
    public var allow_persistent_sessions: Bool?

    private var _session_minutes: AnyInt?
    /**
     * Number of minutes for user sessions.  Must be between 5 and 43200
     */
    public var session_minutes: Int64? {
        get { _session_minutes?.value }
        set { _session_minutes = newValue.map(AnyInt.init) }
    }

    /**
     * Allow users to have an unbounded number of concurrent sessions (otherwise, users will be limited to only one session at a time).
     */
    public var unlimited_sessions_per_user: Bool?

    /**
     * Enforce session logout for sessions that are inactive for 15 minutes.
     */
    public var use_inactivity_based_logout: Bool?

    /**
     * Track location of session when user logs in.
     */
    public var track_session_location: Bool?

    public init(allow_persistent_sessions: Bool? = nil, session_minutes: Int64? = nil, unlimited_sessions_per_user: Bool? = nil, use_inactivity_based_logout: Bool? = nil, track_session_location: Bool? = nil) {
        self.allow_persistent_sessions = allow_persistent_sessions
        self._session_minutes = session_minutes.map(AnyInt.init)
        self.unlimited_sessions_per_user = unlimited_sessions_per_user
        self.use_inactivity_based_logout = use_inactivity_based_logout
        self.track_session_location = track_session_location
    }

}

/**
 * Dynamic writeable type for Setting removes:
 * instance_config, marketplace_site, embed_enabled, login_notification_enabled, login_notification_text
 */
public struct WriteSetting: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case extension_framework_enabled
        case extension_load_url_enabled
        case marketplace_auto_install_enabled
        case marketplace_automation
        case marketplace_enabled
        case marketplace_terms_accepted
        case privatelabel_configuration
        case custom_welcome_email
        case onboarding_enabled
        case _timezone = "timezone"
        case allow_user_timezones
        case data_connector_default_enabled
        case _host_url = "host_url"
        case override_warnings
        case _email_domain_allowlist = "email_domain_allowlist"
        case embed_cookieless_v2
        case embed_config
        case dashboard_auto_refresh_restriction
        case _dashboard_auto_refresh_minimum_interval = "dashboard_auto_refresh_minimum_interval"
        case _managed_certificate_uri = "managed_certificate_uri"
    }
    /**
     * Toggle extension framework on or off
     */
    public var extension_framework_enabled: Bool?

    /**
     * (DEPRECATED) Toggle extension load url on or off. Do not use. This is temporary setting that will eventually become a noop and subsequently deleted.
     */
    public var extension_load_url_enabled: Bool?

    /**
     * (DEPRECATED) Toggle marketplace auto install on or off. Deprecated - do not use. Auto install can now be enabled via marketplace automation settings
     */
    public var marketplace_auto_install_enabled: Bool?

    public var marketplace_automation: MarketplaceAutomation?

    /**
     * Toggle marketplace on or off
     */
    public var marketplace_enabled: Bool?

    /**
     * Accept marketplace terms by setting this value to true, or get the current status. Marketplace terms CANNOT be declined once accepted. Accepting marketplace terms automatically enables the marketplace. The marketplace can still be disabled after it has been enabled.
     */
    public var marketplace_terms_accepted: Bool?

    /**
     * Dynamic writeable type for PrivatelabelConfiguration removes:
     * logo_url, favicon_url
     */
    public var privatelabel_configuration: WritePrivatelabelConfiguration?

    public var custom_welcome_email: CustomWelcomeEmail?

    /**
     * Toggle onboarding on or off
     */
    public var onboarding_enabled: Bool?

    private var _timezone: AnyString?
    /**
     * Change instance-wide default timezone
     */
    public var timezone: String? {
        get { _timezone?.value }
        set { _timezone = newValue.map(AnyString.init) }
    }

    /**
     * Toggle user-specific timezones on or off
     */
    public var allow_user_timezones: Bool?

    /**
     * Toggle default future connectors on or off
     */
    public var data_connector_default_enabled: Bool?

    private var _host_url: AnyString?
    /**
     * Change the base portion of your Looker instance URL setting
     */
    public var host_url: String? {
        get { _host_url?.value }
        set { _host_url = newValue.map(AnyString.init) }
    }

    /**
     * (Write-Only) If warnings are preventing a host URL change, this parameter allows for overriding warnings to force update the setting. Does not directly change any Looker settings.
     */
    public var override_warnings: Bool?

    private var _email_domain_allowlist: [AnyString]?
    /**
     * An array of Email Domain Allowlist of type string for Scheduled Content
     */
    public var email_domain_allowlist: [String]? {
        get { if let v = _email_domain_allowlist { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _email_domain_allowlist = v.map { AnyString.init($0) } } else { _email_domain_allowlist = nil } }
    }

    /**
     * (DEPRECATED) Use embed_config.embed_cookieless_v2 instead. If embed_config.embed_cookieless_v2 is specified, it overrides this value.
     */
    public var embed_cookieless_v2: Bool?

    /**
     * Dynamic writeable type for EmbedConfig removes:
     * embed_enabled
     */
    public var embed_config: WriteEmbedConfig?

    /**
     * Toggle Dashboard Auto Refresh restriction
     */
    public var dashboard_auto_refresh_restriction: Bool?

    private var _dashboard_auto_refresh_minimum_interval: AnyString?
    /**
     * Minimum time interval for dashboard element automatic refresh. Examples: (30 seconds, 1 minute)
     */
    public var dashboard_auto_refresh_minimum_interval: String? {
        get { _dashboard_auto_refresh_minimum_interval?.value }
        set { _dashboard_auto_refresh_minimum_interval = newValue.map(AnyString.init) }
    }

    private var _managed_certificate_uri: [AnyString]?
    /**
     * Array of URIs pointing to the location of a root certificate in Secret Manager
     */
    public var managed_certificate_uri: [String]? {
        get { if let v = _managed_certificate_uri { return v.map { $0.value } } else { return nil } }
        set { if let v = newValue { _managed_certificate_uri = v.map { AnyString.init($0) } } else { _managed_certificate_uri = nil } }
    }

    public init(extension_framework_enabled: Bool? = nil, extension_load_url_enabled: Bool? = nil, marketplace_auto_install_enabled: Bool? = nil, marketplace_automation: MarketplaceAutomation? = nil, marketplace_enabled: Bool? = nil, marketplace_terms_accepted: Bool? = nil, privatelabel_configuration: WritePrivatelabelConfiguration? = nil, custom_welcome_email: CustomWelcomeEmail? = nil, onboarding_enabled: Bool? = nil, timezone: String? = nil, allow_user_timezones: Bool? = nil, data_connector_default_enabled: Bool? = nil, host_url: String? = nil, override_warnings: Bool? = nil, email_domain_allowlist: [String]? = nil, embed_cookieless_v2: Bool? = nil, embed_config: WriteEmbedConfig? = nil, dashboard_auto_refresh_restriction: Bool? = nil, dashboard_auto_refresh_minimum_interval: String? = nil, managed_certificate_uri: [String]? = nil) {
        self.extension_framework_enabled = extension_framework_enabled
        self.extension_load_url_enabled = extension_load_url_enabled
        self.marketplace_auto_install_enabled = marketplace_auto_install_enabled
        self.marketplace_automation = marketplace_automation
        self.marketplace_enabled = marketplace_enabled
        self.marketplace_terms_accepted = marketplace_terms_accepted
        self.privatelabel_configuration = privatelabel_configuration
        self.custom_welcome_email = custom_welcome_email
        self.onboarding_enabled = onboarding_enabled
        self._timezone = timezone.map(AnyString.init)
        self.allow_user_timezones = allow_user_timezones
        self.data_connector_default_enabled = data_connector_default_enabled
        self._host_url = host_url.map(AnyString.init)
        self.override_warnings = override_warnings
        if let v = email_domain_allowlist { _email_domain_allowlist = v.map { AnyString.init($0) } } else { _email_domain_allowlist = nil }
        self.embed_cookieless_v2 = embed_cookieless_v2
        self.embed_config = embed_config
        self.dashboard_auto_refresh_restriction = dashboard_auto_refresh_restriction
        self._dashboard_auto_refresh_minimum_interval = dashboard_auto_refresh_minimum_interval.map(AnyString.init)
        if let v = managed_certificate_uri { _managed_certificate_uri = v.map { AnyString.init($0) } } else { _managed_certificate_uri = nil }
    }

}

/**
 * Dynamic writeable type for SqlInterfaceQueryCreate removes:
 * can
 */
public struct WriteSqlInterfaceQueryCreate: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _sql = "sql"
        case jdbc_client
    }
    private var _sql: AnyString
    /**
     * Original SQL request
     */
    public var sql: String {
        get { _sql.value }
        set { _sql = AnyString.init(newValue) }
    }

    /**
     * Whether the query should be run for use in a JDBC Client. This changes the formatting of some datetime based values.
     */
    public var jdbc_client: Bool?

    public init(sql: String, jdbc_client: Bool? = nil) {
        self._sql = AnyString.init(sql)
        self.jdbc_client = jdbc_client
    }

    public init(_ sql: String, jdbc_client: Bool? = nil) {
        self.init(sql: sql, jdbc_client: jdbc_client)
    }

}

/**
 * Dynamic writeable type for SshServer removes:
 * ssh_server_id, finger_print, sha_finger_print, public_key, status
 */
public struct WriteSshServer: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _ssh_server_name = "ssh_server_name"
        case _ssh_server_host = "ssh_server_host"
        case _ssh_server_port = "ssh_server_port"
        case _ssh_server_user = "ssh_server_user"
    }
    private var _ssh_server_name: AnyString?
    /**
     * The name to identify this SSH Server
     */
    public var ssh_server_name: String? {
        get { _ssh_server_name?.value }
        set { _ssh_server_name = newValue.map(AnyString.init) }
    }

    private var _ssh_server_host: AnyString?
    /**
     * The hostname or ip address of the SSH Server
     */
    public var ssh_server_host: String? {
        get { _ssh_server_host?.value }
        set { _ssh_server_host = newValue.map(AnyString.init) }
    }

    private var _ssh_server_port: AnyInt?
    /**
     * The port to connect to on the SSH Server
     */
    public var ssh_server_port: Int64? {
        get { _ssh_server_port?.value }
        set { _ssh_server_port = newValue.map(AnyInt.init) }
    }

    private var _ssh_server_user: AnyString?
    /**
     * The username used to connect to the SSH Server
     */
    public var ssh_server_user: String? {
        get { _ssh_server_user?.value }
        set { _ssh_server_user = newValue.map(AnyString.init) }
    }

    public init(ssh_server_name: String? = nil, ssh_server_host: String? = nil, ssh_server_port: Int64? = nil, ssh_server_user: String? = nil) {
        self._ssh_server_name = ssh_server_name.map(AnyString.init)
        self._ssh_server_host = ssh_server_host.map(AnyString.init)
        self._ssh_server_port = ssh_server_port.map(AnyInt.init)
        self._ssh_server_user = ssh_server_user.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for SshTunnel removes:
 * tunnel_id, ssh_server_name, ssh_server_host, ssh_server_port, ssh_server_user, last_attempt, status
 */
public struct WriteSshTunnel: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _ssh_server_id = "ssh_server_id"
        case _local_host_port = "local_host_port"
        case _database_host = "database_host"
        case _database_port = "database_port"
    }
    private var _ssh_server_id: AnyString?
    /**
     * SSH Server ID
     */
    public var ssh_server_id: String? {
        get { _ssh_server_id?.value }
        set { _ssh_server_id = newValue.map(AnyString.init) }
    }

    private var _local_host_port: AnyInt?
    /**
     * Localhost Port used by the Looker instance to connect to the remote DB
     */
    public var local_host_port: Int64? {
        get { _local_host_port?.value }
        set { _local_host_port = newValue.map(AnyInt.init) }
    }

    private var _database_host: AnyString?
    /**
     * Hostname or IP Address of the Database Server
     */
    public var database_host: String? {
        get { _database_host?.value }
        set { _database_host = newValue.map(AnyString.init) }
    }

    private var _database_port: AnyInt?
    /**
     * Port that the Database Server is listening on
     */
    public var database_port: Int64? {
        get { _database_port?.value }
        set { _database_port = newValue.map(AnyInt.init) }
    }

    public init(ssh_server_id: String? = nil, local_host_port: Int64? = nil, database_host: String? = nil, database_port: Int64? = nil) {
        self._ssh_server_id = ssh_server_id.map(AnyString.init)
        self._local_host_port = local_host_port.map(AnyInt.init)
        self._database_host = database_host.map(AnyString.init)
        self._database_port = database_port.map(AnyInt.init)
    }

}

/**
 * Dynamic writeable type for Theme removes:
 * can, id
 */
public struct WriteTheme: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case begin_at
        case end_at
        case _name = "name"
        case settings
    }
    /**
     * Timestamp for when this theme becomes active. Null=always
     */
    public var begin_at: Date?

    /**
     * Timestamp for when this theme expires. Null=never
     */
    public var end_at: Date?

    private var _name: AnyString?
    /**
     * Name of theme. Can only be alphanumeric and underscores.
     */
    public var name: String? {
        get { _name?.value }
        set { _name = newValue.map(AnyString.init) }
    }

    public var settings: ThemeSettings?

    public init(begin_at: Date? = nil, end_at: Date? = nil, name: String? = nil, settings: ThemeSettings? = nil) {
        self.begin_at = begin_at
        self.end_at = end_at
        self._name = name.map(AnyString.init)
        self.settings = settings
    }

}

/**
 * Dynamic writeable type for User removes:
 * can, avatar_url, avatar_url_without_sizing, credentials_api3, credentials_embed, credentials_google, credentials_ldap, credentials_looker_openid, credentials_oidc, credentials_saml, credentials_totp, display_name, email, embed_group_space_id, group_ids, id, looker_versions, personal_folder_id, presumed_looker_employee, role_ids, sessions, verified_looker_employee, roles_externally_managed, allow_direct_roles, allow_normal_group_membership, allow_roles_from_normal_groups, embed_group_folder_id, is_iam_admin, url
 */
public struct WriteUser: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case credentials_email
        case _first_name = "first_name"
        case _home_folder_id = "home_folder_id"
        case is_disabled
        case _last_name = "last_name"
        case _locale = "locale"
        case models_dir_validated
        case ui_state
    }
    /**
     * Dynamic writeable type for CredentialsEmail removes:
     * can, created_at, user_id, is_disabled, logged_in_at, password_reset_url, account_setup_url, password_reset_url_expired, account_setup_url_expired, type, url, user_url
     */
    public var credentials_email: WriteCredentialsEmail?

    private var _first_name: AnyString?
    /**
     * First name
     */
    public var first_name: String? {
        get { _first_name?.value }
        set { _first_name = newValue.map(AnyString.init) }
    }

    private var _home_folder_id: AnyString?
    /**
     * ID string for user's home folder
     */
    public var home_folder_id: String? {
        get { _home_folder_id?.value }
        set { _home_folder_id = newValue.map(AnyString.init) }
    }

    /**
     * Account has been disabled
     */
    public var is_disabled: Bool?

    private var _last_name: AnyString?
    /**
     * Last name
     */
    public var last_name: String? {
        get { _last_name?.value }
        set { _last_name = newValue.map(AnyString.init) }
    }

    private var _locale: AnyString?
    /**
     * User's preferred locale. User locale takes precedence over Looker's system-wide default locale. Locale determines language of display strings and date and numeric formatting in API responses. Locale string must be a 2 letter language code or a combination of language code and region code: 'en' or 'en-US', for example.
     */
    public var locale: String? {
        get { _locale?.value }
        set { _locale = newValue.map(AnyString.init) }
    }

    /**
     * User's dev workspace has been checked for presence of applicable production projects
     */
    public var models_dir_validated: Bool?

    /**
     * Per user dictionary of undocumented state information owned by the Looker UI.
     */
    public var ui_state: StringDictionary<AnyCodable>?

    public init(credentials_email: WriteCredentialsEmail? = nil, first_name: String? = nil, home_folder_id: String? = nil, is_disabled: Bool? = nil, last_name: String? = nil, locale: String? = nil, models_dir_validated: Bool? = nil, ui_state: StringDictionary<AnyCodable>? = nil) {
        self.credentials_email = credentials_email
        self._first_name = first_name.map(AnyString.init)
        self._home_folder_id = home_folder_id.map(AnyString.init)
        self.is_disabled = is_disabled
        self._last_name = last_name.map(AnyString.init)
        self._locale = locale.map(AnyString.init)
        self.models_dir_validated = models_dir_validated
        self.ui_state = ui_state
    }

}

/**
 * Dynamic writeable type for UserAttribute removes:
 * can, id, is_system, is_permanent
 */
public struct WriteUserAttribute: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _name = "name"
        case _label = "label"
        case _type = "type"
        case _default_value = "default_value"
        case value_is_hidden
        case user_can_view
        case user_can_edit
        case _hidden_value_domain_whitelist = "hidden_value_domain_whitelist"
    }
    private var _name: AnyString
    /**
     * Name of user attribute
     */
    public var name: String {
        get { _name.value }
        set { _name = AnyString.init(newValue) }
    }

    private var _label: AnyString
    /**
     * Human-friendly label for user attribute
     */
    public var label: String {
        get { _label.value }
        set { _label = AnyString.init(newValue) }
    }

    private var _type: AnyString
    /**
     * Type of user attribute ("string", "number", "datetime", "yesno", "zipcode", "advanced_filter_string", "advanced_filter_number")
     */
    public var type: String {
        get { _type.value }
        set { _type = AnyString.init(newValue) }
    }

    private var _default_value: AnyString?
    /**
     * Default value for when no value is set on the user
     */
    public var default_value: String? {
        get { _default_value?.value }
        set { _default_value = newValue.map(AnyString.init) }
    }

    /**
     * If true, users will not be able to view values of this attribute
     */
    public var value_is_hidden: Bool?

    /**
     * Non-admin users can see the values of their attributes and use them in filters
     */
    public var user_can_view: Bool?

    /**
     * Users can change the value of this attribute for themselves
     */
    public var user_can_edit: Bool?

    private var _hidden_value_domain_whitelist: AnyString?
    /**
     * Destinations to which a hidden attribute may be sent. Once set, cannot be edited.
     */
    public var hidden_value_domain_whitelist: String? {
        get { _hidden_value_domain_whitelist?.value }
        set { _hidden_value_domain_whitelist = newValue.map(AnyString.init) }
    }

    public init(name: String, label: String, type: String, default_value: String? = nil, value_is_hidden: Bool? = nil, user_can_view: Bool? = nil, user_can_edit: Bool? = nil, hidden_value_domain_whitelist: String? = nil) {
        self._name = AnyString.init(name)
        self._label = AnyString.init(label)
        self._type = AnyString.init(type)
        self._default_value = default_value.map(AnyString.init)
        self.value_is_hidden = value_is_hidden
        self.user_can_view = user_can_view
        self.user_can_edit = user_can_edit
        self._hidden_value_domain_whitelist = hidden_value_domain_whitelist.map(AnyString.init)
    }

    public init(_ name: String, _ label: String, _ type: String, default_value: String? = nil, value_is_hidden: Bool? = nil, user_can_view: Bool? = nil, user_can_edit: Bool? = nil, hidden_value_domain_whitelist: String? = nil) {
        self.init(name: name, label: label, type: type, default_value: default_value, value_is_hidden: value_is_hidden, user_can_view: user_can_view, user_can_edit: user_can_edit, hidden_value_domain_whitelist: hidden_value_domain_whitelist)
    }

}

/**
 * Dynamic writeable type for UserAttributeWithValue removes:
 * can, name, label, rank, user_id, user_can_edit, value_is_hidden, user_attribute_id, source, hidden_value_domain_whitelist
 */
public struct WriteUserAttributeWithValue: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _value = "value"
    }
    private var _value: AnyString?
    /**
     * Value of attribute for user
     */
    public var value: String? {
        get { _value?.value }
        set { _value = newValue.map(AnyString.init) }
    }

    public init(value: String? = nil) {
        self._value = value.map(AnyString.init)
    }

}

/**
 * Dynamic writeable type for WhitelabelConfiguration removes:
 * id, logo_url, favicon_url
 */
public struct WriteWhitelabelConfiguration: SDKModel {

    private enum CodingKeys : String, CodingKey {
        case _logo_file = "logo_file"
        case _favicon_file = "favicon_file"
        case _default_title = "default_title"
        case show_help_menu
        case show_docs
        case show_email_sub_options
        case allow_looker_mentions
        case allow_looker_links
        case custom_welcome_email_advanced
        case setup_mentions
        case alerts_logo
        case alerts_links
        case folders_mentions
    }
    private var _logo_file: AnyString?
    /**
     * Customer logo image. Expected base64 encoded data (write-only)
     */
    public var logo_file: String? {
        get { _logo_file?.value }
        set { _logo_file = newValue.map(AnyString.init) }
    }

    private var _favicon_file: AnyString?
    /**
     * Custom favicon image. Expected base64 encoded data (write-only)
     */
    public var favicon_file: String? {
        get { _favicon_file?.value }
        set { _favicon_file = newValue.map(AnyString.init) }
    }

    private var _default_title: AnyString?
    /**
     * Default page title
     */
    public var default_title: String? {
        get { _default_title?.value }
        set { _default_title = newValue.map(AnyString.init) }
    }

    /**
     * Boolean to toggle showing help menus
     */
    public var show_help_menu: Bool?

    /**
     * Boolean to toggle showing docs
     */
    public var show_docs: Bool?

    /**
     * Boolean to toggle showing email subscription options.
     */
    public var show_email_sub_options: Bool?

    /**
     * Boolean to toggle mentions of Looker in emails
     */
    public var allow_looker_mentions: Bool?

    /**
     * Boolean to toggle links to Looker in emails
     */
    public var allow_looker_links: Bool?

    /**
     * Allow subject line and email heading customization in customized emails
     */
    public var custom_welcome_email_advanced: Bool?

    /**
     * Remove the word Looker from appearing in the account setup page
     */
    public var setup_mentions: Bool?

    /**
     * Remove Looker logo from Alerts
     */
    public var alerts_logo: Bool?

    /**
     * Remove Looker links from Alerts
     */
    public var alerts_links: Bool?

    /**
     * Remove Looker mentions in home folder page when you dont have any items saved
     */
    public var folders_mentions: Bool?

    public init(logo_file: String? = nil, favicon_file: String? = nil, default_title: String? = nil, show_help_menu: Bool? = nil, show_docs: Bool? = nil, show_email_sub_options: Bool? = nil, allow_looker_mentions: Bool? = nil, allow_looker_links: Bool? = nil, custom_welcome_email_advanced: Bool? = nil, setup_mentions: Bool? = nil, alerts_logo: Bool? = nil, alerts_links: Bool? = nil, folders_mentions: Bool? = nil) {
        self._logo_file = logo_file.map(AnyString.init)
        self._favicon_file = favicon_file.map(AnyString.init)
        self._default_title = default_title.map(AnyString.init)
        self.show_help_menu = show_help_menu
        self.show_docs = show_docs
        self.show_email_sub_options = show_email_sub_options
        self.allow_looker_mentions = allow_looker_mentions
        self.allow_looker_links = allow_looker_links
        self.custom_welcome_email_advanced = custom_welcome_email_advanced
        self.setup_mentions = setup_mentions
        self.alerts_logo = alerts_logo
        self.alerts_links = alerts_links
        self.folders_mentions = folders_mentions
    }

}

