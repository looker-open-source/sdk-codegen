/**

 MIT License

 Copyright (c) 2019 Looker Data Sciences, Inc.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

 */

/**
 * 275 API models: 202 Spec, 0 Request, 55 Write, 18 Enum
 */


/// NOTE: Do not edit this file generated by Looker SDK Codegen for Looker 7.18 API 4.0

import Foundation

public struct AccessToken: SDKModel {
    /**
     * Access Token used for API calls (read-only)
     */
    public var access_token: String?
    /**
     * Type of Token (read-only)
     */
    public var token_type: String?
    /**
     * Number of seconds before the token expires (read-only)
     */
    public var expires_in: Int64?
    /**
     * Refresh token which can be used to obtain a new access token (read-only)
     */
    public var refresh_token: String?

    public init(access_token: String? = nil, token_type: String? = nil, expires_in: Int64? = nil, refresh_token: String? = nil) {
        self.access_token = access_token
        self.token_type = token_type
        self.expires_in = expires_in
        self.refresh_token = refresh_token
    }

}

/**
 * The appropriate horizontal text alignment the values of this field should be displayed in. Valid values are: "left", "right".
 */
public enum Align: String, Codable {
    case left = "left"
    case right = "right"
}

public struct ApiSession: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * The id of active workspace for this session
     */
    public var workspace_id: String?
    /**
     * The id of the actual user in the case when this session represents one user sudo'ing as another (read-only)
     */
    public var sudo_user_id: Int64?

    public init(can: StringDictionary<Bool>? = nil, workspace_id: String? = nil, sudo_user_id: Int64? = nil) {
        self.can = can
        self.workspace_id = workspace_id
        self.sudo_user_id = sudo_user_id
    }

}

public struct ApiVersion: SDKModel {
    /**
     * Current Looker release version number (read-only)
     */
    public var looker_release_version: String?
    public var current_version: ApiVersionElement?
    /**
     * Array of versions supported by this Looker instance (read-only)
     */
    public var supported_versions: [ApiVersionElement]?

    public init(looker_release_version: String? = nil, current_version: ApiVersionElement? = nil, supported_versions: [ApiVersionElement]? = nil) {
        self.looker_release_version = looker_release_version
        self.current_version = current_version
        self.supported_versions = supported_versions
    }

}

public struct ApiVersionElement: SDKModel {
    /**
     * Version number as it appears in '/api/xxx/' urls (read-only)
     */
    public var version: String?
    /**
     * Full version number including minor version (read-only)
     */
    public var full_version: String?
    /**
     * Status of this version (read-only)
     */
    public var status: String?
    /**
     * Url for swagger.json for this version (read-only)
     */
    public var swagger_url: URI?

    public init(version: String? = nil, full_version: String? = nil, status: String? = nil, swagger_url: URI? = nil) {
        self.version = version
        self.full_version = full_version
        self.status = status
        self.swagger_url = swagger_url
    }

}

public struct BackupConfiguration: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Type of backup: looker-s3 or custom-s3
     */
    public var type: String?
    /**
     * Name of bucket for custom-s3 backups
     */
    public var custom_s3_bucket: String?
    /**
     * Name of region where the bucket is located
     */
    public var custom_s3_bucket_region: String?
    /**
     * (Write-Only) AWS S3 key used for custom-s3 backups
     */
    public var custom_s3_key: String?
    /**
     * (Write-Only) AWS S3 secret used for custom-s3 backups
     */
    public var custom_s3_secret: String?
    /**
     * Link to get this item (read-only)
     */
    public var url: URI?

    public init(can: StringDictionary<Bool>? = nil, type: String? = nil, custom_s3_bucket: String? = nil, custom_s3_bucket_region: String? = nil, custom_s3_key: String? = nil, custom_s3_secret: String? = nil, url: URI? = nil) {
        self.can = can
        self.type = type
        self.custom_s3_bucket = custom_s3_bucket
        self.custom_s3_bucket_region = custom_s3_bucket_region
        self.custom_s3_key = custom_s3_key
        self.custom_s3_secret = custom_s3_secret
        self.url = url
    }

}

public struct Board: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Id of associated content_metadata record (read-only)
     */
    public var content_metadata_id: Int64?
    /**
     * Date of board creation (read-only)
     */
    public var created_at: Date?
    /**
     * Date of board deletion
     */
    public var deleted_at: Date?
    /**
     * Description of the board
     */
    public var description: String?
    /**
     * Sections of the board (read-only)
     */
    public var board_sections: [BoardSection]?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * ids of the board sections in the order they should be displayed
     */
    public var section_order: [Int64]?
    /**
     * Title of the board
     */
    public var title: String?
    /**
     * Date of last board update (read-only)
     */
    public var updated_at: Date?
    /**
     * User id of board creator (read-only)
     */
    public var user_id: Int64?
    /**
     * Whether the board is the primary homepage or not (read-only)
     */
    public var primary_homepage: Bool?

    public init(can: StringDictionary<Bool>? = nil, content_metadata_id: Int64? = nil, created_at: Date? = nil, deleted_at: Date? = nil, description: String? = nil, board_sections: [BoardSection]? = nil, id: Int64? = nil, section_order: [Int64]? = nil, title: String? = nil, updated_at: Date? = nil, user_id: Int64? = nil, primary_homepage: Bool? = nil) {
        self.can = can
        self.content_metadata_id = content_metadata_id
        self.created_at = created_at
        self.deleted_at = deleted_at
        self.description = description
        self.board_sections = board_sections
        self.id = id
        self.section_order = section_order
        self.title = title
        self.updated_at = updated_at
        self.user_id = user_id
        self.primary_homepage = primary_homepage
    }

}

public struct BoardItem: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Name of user who created the content this item is based on (read-only)
     */
    public var content_created_by: String?
    /**
     * Content favorite id associated with the item this content is based on (read-only)
     */
    public var content_favorite_id: Int64?
    /**
     * Content metadata id associated with the item this content is based on (read-only)
     */
    public var content_metadata_id: Int64?
    /**
     * Last time the content that this item is based on was updated (read-only)
     */
    public var content_updated_at: String?
    /**
     * Dashboard to base this item on
     */
    public var dashboard_id: Int64?
    /**
     * The actual description for display (read-only)
     */
    public var description: String?
    /**
     * Number of times content has been favorited, if present (read-only)
     */
    public var favorite_count: Int64?
    /**
     * Associated Board Section
     */
    public var board_section_id: Int64?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * The container folder name of the content (read-only)
     */
    public var location: String?
    /**
     * Look to base this item on
     */
    public var look_id: Int64?
    /**
     * LookML Dashboard to base this item on
     */
    public var lookml_dashboard_id: String?
    /**
     * An arbitrary integer representing the sort order within the section
     */
    public var order: Int64?
    /**
     * The actual title for display (read-only)
     */
    public var title: String?
    /**
     * Relative url for the associated content (read-only)
     */
    public var url: String?
    /**
     * Number of times content has been viewed, if present (read-only)
     */
    public var view_count: Int64?

    public init(can: StringDictionary<Bool>? = nil, content_created_by: String? = nil, content_favorite_id: Int64? = nil, content_metadata_id: Int64? = nil, content_updated_at: String? = nil, dashboard_id: Int64? = nil, description: String? = nil, favorite_count: Int64? = nil, board_section_id: Int64? = nil, id: Int64? = nil, location: String? = nil, look_id: Int64? = nil, lookml_dashboard_id: String? = nil, order: Int64? = nil, title: String? = nil, url: String? = nil, view_count: Int64? = nil) {
        self.can = can
        self.content_created_by = content_created_by
        self.content_favorite_id = content_favorite_id
        self.content_metadata_id = content_metadata_id
        self.content_updated_at = content_updated_at
        self.dashboard_id = dashboard_id
        self.description = description
        self.favorite_count = favorite_count
        self.board_section_id = board_section_id
        self.id = id
        self.location = location
        self.look_id = look_id
        self.lookml_dashboard_id = lookml_dashboard_id
        self.order = order
        self.title = title
        self.url = url
        self.view_count = view_count
    }

}

public struct BoardSection: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Time at which this section was created. (read-only)
     */
    public var created_at: Date?
    /**
     * Time at which this section was deleted.
     */
    public var deleted_at: Date?
    /**
     * Description of the content found in this section.
     */
    public var description: String?
    /**
     * Id reference to parent board
     */
    public var board_id: Int64?
    /**
     * Items in the board section (read-only)
     */
    public var board_items: [BoardItem]?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * ids of the board items in the order they should be displayed
     */
    public var item_order: [Int64]?
    /**
     * Name of row
     */
    public var title: String?
    /**
     * Time at which this section was last updated. (read-only)
     */
    public var updated_at: Date?

    public init(can: StringDictionary<Bool>? = nil, created_at: Date? = nil, deleted_at: Date? = nil, description: String? = nil, board_id: Int64? = nil, board_items: [BoardItem]? = nil, id: Int64? = nil, item_order: [Int64]? = nil, title: String? = nil, updated_at: Date? = nil) {
        self.can = can
        self.created_at = created_at
        self.deleted_at = deleted_at
        self.description = description
        self.board_id = board_id
        self.board_items = board_items
        self.id = id
        self.item_order = item_order
        self.title = title
        self.updated_at = updated_at
    }

}

/**
 * Field category Valid values are: "parameter", "filter", "measure", "dimension".
 */
public enum Category: String, Codable {
    case parameter = "parameter"
    case filter = "filter"
    case measure = "measure"
    case dimension = "dimension"
}

public struct ColorCollection: SDKModel {
    /**
     * Unique Id (read-only)
     */
    public var id: String?
    /**
     * Label of color collection
     */
    public var label: String?
    /**
     * Array of categorical palette definitions
     */
    public var categoricalPalettes: [DiscretePalette]?
    /**
     * Array of discrete palette definitions
     */
    public var sequentialPalettes: [ContinuousPalette]?
    /**
     * Array of diverging palette definitions
     */
    public var divergingPalettes: [ContinuousPalette]?

    public init(id: String? = nil, label: String? = nil, categoricalPalettes: [DiscretePalette]? = nil, sequentialPalettes: [ContinuousPalette]? = nil, divergingPalettes: [ContinuousPalette]? = nil) {
        self.id = id
        self.label = label
        self.categoricalPalettes = categoricalPalettes
        self.sequentialPalettes = sequentialPalettes
        self.divergingPalettes = divergingPalettes
    }

}

public struct ColorStop: SDKModel {
    /**
     * CSS color string
     */
    public var color: String?
    /**
     * Offset in continuous palette (0 to 100)
     */
    public var offset: Int64?

    public init(color: String? = nil, offset: Int64? = nil) {
        self.color = color
        self.offset = offset
    }

}

public struct ColumnSearch: SDKModel {
    /**
     * Name of schema containing the table (read-only)
     */
    public var schema_name: String?
    /**
     * Name of table containing the column (read-only)
     */
    public var table_name: String?
    /**
     * Name of column (read-only)
     */
    public var column_name: String?
    /**
     * Column data type (read-only)
     */
    public var data_type: String?

    public init(schema_name: String? = nil, table_name: String? = nil, column_name: String? = nil, data_type: String? = nil) {
        self.schema_name = schema_name
        self.table_name = table_name
        self.column_name = column_name
        self.data_type = data_type
    }

}

public struct Command: SDKModel {
    /**
     * Id of the command record (read-only)
     */
    public var id: Int64?
    /**
     * Id of the command author (read-only)
     */
    public var author_id: Int64?
    /**
     * Name of the command
     */
    public var name: String?
    /**
     * Description of the command
     */
    public var description: String?
    /**
     * Id of the content associated with the command
     */
    public var linked_content_id: String?
    /**
     * Name of the command Valid values are: "dashboard", "lookml_dashboard".
     */
    public var linked_content_type: LinkedContentType?

    public init(id: Int64? = nil, author_id: Int64? = nil, name: String? = nil, description: String? = nil, linked_content_id: String? = nil, linked_content_type: LinkedContentType? = nil) {
        self.id = id
        self.author_id = author_id
        self.name = name
        self.description = description
        self.linked_content_id = linked_content_id
        self.linked_content_type = linked_content_type
    }

}

public struct ConnectionFeatures: SDKModel {
    /**
     * Name of the dialect for this connection (read-only)
     */
    public var dialect_name: String?
    /**
     * True for cost estimating support (read-only)
     */
    public var cost_estimate: Bool?
    /**
     * True for multiple database support (read-only)
     */
    public var multiple_databases: Bool?
    /**
     * True for cost estimating support (read-only)
     */
    public var column_search: Bool?
    /**
     * True for secondary index support (read-only)
     */
    public var persistent_table_indexes: Bool?
    /**
     * True for persistent derived table support (read-only)
     */
    public var persistent_derived_tables: Bool?
    /**
     * True for turtles support (read-only)
     */
    public var turtles: Bool?
    /**
     * True for percentile support (read-only)
     */
    public var percentile: Bool?
    /**
     * True for distinct percentile support (read-only)
     */
    public var distinct_percentile: Bool?
    /**
     * True for stable views support (read-only)
     */
    public var stable_views: Bool?
    /**
     * True for millisecond support (read-only)
     */
    public var milliseconds: Bool?
    /**
     * True for microsecond support (read-only)
     */
    public var microseconds: Bool?
    /**
     * True for subtotal support (read-only)
     */
    public var subtotals: Bool?
    /**
     * True for geographic location support (read-only)
     */
    public var location: Bool?
    /**
     * True for timezone conversion in query support (read-only)
     */
    public var timezone: Bool?
    /**
     * True for connection pooling support (read-only)
     */
    public var connection_pooling: Bool?

    public init(dialect_name: String? = nil, cost_estimate: Bool? = nil, multiple_databases: Bool? = nil, column_search: Bool? = nil, persistent_table_indexes: Bool? = nil, persistent_derived_tables: Bool? = nil, turtles: Bool? = nil, percentile: Bool? = nil, distinct_percentile: Bool? = nil, stable_views: Bool? = nil, milliseconds: Bool? = nil, microseconds: Bool? = nil, subtotals: Bool? = nil, location: Bool? = nil, timezone: Bool? = nil, connection_pooling: Bool? = nil) {
        self.dialect_name = dialect_name
        self.cost_estimate = cost_estimate
        self.multiple_databases = multiple_databases
        self.column_search = column_search
        self.persistent_table_indexes = persistent_table_indexes
        self.persistent_derived_tables = persistent_derived_tables
        self.turtles = turtles
        self.percentile = percentile
        self.distinct_percentile = distinct_percentile
        self.stable_views = stable_views
        self.milliseconds = milliseconds
        self.microseconds = microseconds
        self.subtotals = subtotals
        self.location = location
        self.timezone = timezone
        self.connection_pooling = connection_pooling
    }

}

public struct ContentFavorite: SDKModel {
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * User Id which owns this ContentFavorite
     */
    public var user_id: Int64?
    /**
     * Content Metadata Id associated with this ContentFavorite
     */
    public var content_metadata_id: Int64?
    /**
     * Id of a look (read-only)
     */
    public var look_id: Int64?
    /**
     * Id of a dashboard (read-only)
     */
    public var dashboard_id: Int64?
    public var look: LookBasic?
    public var dashboard: DashboardBase?
    /**
     * Id of a board (read-only)
     */
    public var board_id: Int64?

    public init(id: Int64? = nil, user_id: Int64? = nil, content_metadata_id: Int64? = nil, look_id: Int64? = nil, dashboard_id: Int64? = nil, look: LookBasic? = nil, dashboard: DashboardBase? = nil, board_id: Int64? = nil) {
        self.id = id
        self.user_id = user_id
        self.content_metadata_id = content_metadata_id
        self.look_id = look_id
        self.dashboard_id = dashboard_id
        self.look = look
        self.dashboard = dashboard
        self.board_id = board_id
    }

}

public struct ContentMeta: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Name or title of underlying content (read-only)
     */
    public var name: String?
    /**
     * Id of Parent Content (read-only)
     */
    public var parent_id: Int64?
    /**
     * Id of associated dashboard when content_type is "dashboard" (read-only)
     */
    public var dashboard_id: String?
    /**
     * Id of associated look when content_type is "look" (read-only)
     */
    public var look_id: Int64?
    /**
     * Id of associated folder when content_type is "space" (read-only)
     */
    public var folder_id: String?
    /**
     * Content Type ("dashboard", "look", or "folder") (read-only)
     */
    public var content_type: String?
    /**
     * Whether content inherits its access levels from parent
     */
    public var inherits: Bool?
    /**
     * Id of Inherited Content (read-only)
     */
    public var inheriting_id: Int64?
    /**
     * Content Slug (read-only)
     */
    public var slug: String?

    public init(can: StringDictionary<Bool>? = nil, id: Int64? = nil, name: String? = nil, parent_id: Int64? = nil, dashboard_id: String? = nil, look_id: Int64? = nil, folder_id: String? = nil, content_type: String? = nil, inherits: Bool? = nil, inheriting_id: Int64? = nil, slug: String? = nil) {
        self.can = can
        self.id = id
        self.name = name
        self.parent_id = parent_id
        self.dashboard_id = dashboard_id
        self.look_id = look_id
        self.folder_id = folder_id
        self.content_type = content_type
        self.inherits = inherits
        self.inheriting_id = inheriting_id
        self.slug = slug
    }

}

public struct ContentMetaGroupUser: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Unique Id (read-only)
     */
    public var id: String?
    /**
     * Id of associated Content Metadata (read-only)
     */
    public var content_metadata_id: String?
    /**
     * Type of permission: "view" or "edit" Valid values are: "view", "edit". (read-only)
     */
    public var permission_type: PermissionType?
    /**
     * ID of associated group (read-only)
     */
    public var group_id: Int64?
    /**
     * ID of associated user (read-only)
     */
    public var user_id: Int64?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, content_metadata_id: String? = nil, permission_type: PermissionType? = nil, group_id: Int64? = nil, user_id: Int64? = nil) {
        self.can = can
        self.id = id
        self.content_metadata_id = content_metadata_id
        self.permission_type = permission_type
        self.group_id = group_id
        self.user_id = user_id
    }

}

public struct ContentValidation: SDKModel {
    /**
     * A list of content errors (read-only)
     */
    public var content_with_errors: [ContentValidatorError]?
    /**
     * Duration of content validation in seconds (read-only)
     */
    public var computation_time: Float?
    /**
     * The number of looks validated (read-only)
     */
    public var total_looks_validated: Int64?
    /**
     * The number of dashboard elements validated (read-only)
     */
    public var total_dashboard_elements_validated: Int64?
    /**
     * The number of dashboard filters validated (read-only)
     */
    public var total_dashboard_filters_validated: Int64?
    /**
     * The number of scheduled plans validated (read-only)
     */
    public var total_scheduled_plans_validated: Int64?
    /**
     * The number of alerts validated (read-only)
     */
    public var total_alerts_validated: Int64?
    /**
     * The number of explores used across all content validated (read-only)
     */
    public var total_explores_validated: Int64?

    public init(content_with_errors: [ContentValidatorError]? = nil, computation_time: Float? = nil, total_looks_validated: Int64? = nil, total_dashboard_elements_validated: Int64? = nil, total_dashboard_filters_validated: Int64? = nil, total_scheduled_plans_validated: Int64? = nil, total_alerts_validated: Int64? = nil, total_explores_validated: Int64? = nil) {
        self.content_with_errors = content_with_errors
        self.computation_time = computation_time
        self.total_looks_validated = total_looks_validated
        self.total_dashboard_elements_validated = total_dashboard_elements_validated
        self.total_dashboard_filters_validated = total_dashboard_filters_validated
        self.total_scheduled_plans_validated = total_scheduled_plans_validated
        self.total_alerts_validated = total_alerts_validated
        self.total_explores_validated = total_explores_validated
    }

}

public struct ContentValidationAlert: SDKModel {
    /**
     * ID of the alert
     */
    public var id: Int64?
    /**
     * ID of the LookML dashboard associated with the alert
     */
    public var lookml_dashboard_id: String?
    /**
     * ID of the LookML dashboard element associated with the alert
     */
    public var lookml_link_id: String?
    /**
     * An optional, user-defined title for the alert
     */
    public var custom_title: String?

    public init(id: Int64? = nil, lookml_dashboard_id: String? = nil, lookml_link_id: String? = nil, custom_title: String? = nil) {
        self.id = id
        self.lookml_dashboard_id = lookml_dashboard_id
        self.lookml_link_id = lookml_link_id
        self.custom_title = custom_title
    }

}

public struct ContentValidationDashboard: SDKModel {
    /**
     * Description
     */
    public var description: String?
    /**
     * Unique Id (read-only)
     */
    public var id: String?
    public var folder: ContentValidationFolder?
    /**
     * Dashboard Title
     */
    public var title: String?

    public init(description: String? = nil, id: String? = nil, folder: ContentValidationFolder? = nil, title: String? = nil) {
        self.description = description
        self.id = id
        self.folder = folder
        self.title = title
    }

}

public struct ContentValidationDashboardElement: SDKModel {
    /**
     * Text tile body text
     */
    public var body_text: String?
    /**
     * Id of Dashboard
     */
    public var dashboard_id: String?
    /**
     * Unique Id (read-only)
     */
    public var id: String?
    /**
     * Id Of Look
     */
    public var look_id: String?
    /**
     * Note Display
     */
    public var note_display: String?
    /**
     * Note State
     */
    public var note_state: String?
    /**
     * Note Text
     */
    public var note_text: String?
    /**
     * Note Text as Html (read-only)
     */
    public var note_text_as_html: String?
    /**
     * Id Of Query
     */
    public var query_id: Int64?
    /**
     * Text tile subtitle text
     */
    public var subtitle_text: String?
    /**
     * Title of dashboard element
     */
    public var title: String?
    /**
     * Whether title is hidden
     */
    public var title_hidden: Bool?
    /**
     * Text tile title
     */
    public var title_text: String?
    /**
     * Type
     */
    public var type: String?

    public init(body_text: String? = nil, dashboard_id: String? = nil, id: String? = nil, look_id: String? = nil, note_display: String? = nil, note_state: String? = nil, note_text: String? = nil, note_text_as_html: String? = nil, query_id: Int64? = nil, subtitle_text: String? = nil, title: String? = nil, title_hidden: Bool? = nil, title_text: String? = nil, type: String? = nil) {
        self.body_text = body_text
        self.dashboard_id = dashboard_id
        self.id = id
        self.look_id = look_id
        self.note_display = note_display
        self.note_state = note_state
        self.note_text = note_text
        self.note_text_as_html = note_text_as_html
        self.query_id = query_id
        self.subtitle_text = subtitle_text
        self.title = title
        self.title_hidden = title_hidden
        self.title_text = title_text
        self.type = type
    }

}

public struct ContentValidationDashboardFilter: SDKModel {
    /**
     * Unique Id (read-only)
     */
    public var id: String?
    /**
     * Id of Dashboard (read-only)
     */
    public var dashboard_id: String?
    /**
     * Name of filter
     */
    public var name: String?
    /**
     * Title of filter
     */
    public var title: String?
    /**
     * Type of filter: one of date, number, string, or field
     */
    public var type: String?
    /**
     * Default value of filter
     */
    public var default_value: String?
    /**
     * Model of filter (required if type = field)
     */
    public var model: String?
    /**
     * Explore of filter (required if type = field)
     */
    public var explore: String?
    /**
     * Dimension of filter (required if type = field)
     */
    public var dimension: String?

    public init(id: String? = nil, dashboard_id: String? = nil, name: String? = nil, title: String? = nil, type: String? = nil, default_value: String? = nil, model: String? = nil, explore: String? = nil, dimension: String? = nil) {
        self.id = id
        self.dashboard_id = dashboard_id
        self.name = name
        self.title = title
        self.type = type
        self.default_value = default_value
        self.model = model
        self.explore = explore
        self.dimension = dimension
    }

}

public struct ContentValidationError: SDKModel {
    /**
     * Error message (read-only)
     */
    public var message: String?
    /**
     * Name of the field involved in the error (read-only)
     */
    public var field_name: String?
    /**
     * Name of the model involved in the error (read-only)
     */
    public var model_name: String?
    /**
     * Name of the explore involved in the error (read-only)
     */
    public var explore_name: String?
    /**
     * Whether this validation error is removable (read-only)
     */
    public var removable: Bool?

    public init(message: String? = nil, field_name: String? = nil, model_name: String? = nil, explore_name: String? = nil, removable: Bool? = nil) {
        self.message = message
        self.field_name = field_name
        self.model_name = model_name
        self.explore_name = explore_name
        self.removable = removable
    }

}

public struct ContentValidationFolder: SDKModel {
    /**
     * Unique Name
     */
    public var name: String
    /**
     * Unique Id (read-only)
     */
    public var id: String?

    public init(name: String, id: String? = nil) {
        self.name = name
        self.id = id
    }

    public init(_ name: String, id: String? = nil) {
        self.init(name: name, id: id)
    }

}

public struct ContentValidationLook: SDKModel {
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Look Title
     */
    public var title: String?
    public var folder: ContentValidationFolder?

    public init(id: Int64? = nil, title: String? = nil, folder: ContentValidationFolder? = nil) {
        self.id = id
        self.title = title
        self.folder = folder
    }

}

public struct ContentValidationLookMLDashboard: SDKModel {
    /**
     * ID of the LookML Dashboard (read-only)
     */
    public var id: String?
    /**
     * Title of the LookML Dashboard (read-only)
     */
    public var title: String?
    /**
     * ID of Space (read-only)
     */
    public var space_id: String?

    public init(id: String? = nil, title: String? = nil, space_id: String? = nil) {
        self.id = id
        self.title = title
        self.space_id = space_id
    }

}

public struct ContentValidationLookMLDashboardElement: SDKModel {
    /**
     * Link ID of the LookML Dashboard Element (read-only)
     */
    public var lookml_link_id: String?
    /**
     * Title of the LookML Dashboard Element (read-only)
     */
    public var title: String?

    public init(lookml_link_id: String? = nil, title: String? = nil) {
        self.lookml_link_id = lookml_link_id
        self.title = title
    }

}

public struct ContentValidationScheduledPlan: SDKModel {
    /**
     * Name of this scheduled plan
     */
    public var name: String?
    /**
     * Id of a look
     */
    public var look_id: Int64?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?

    public init(name: String? = nil, look_id: Int64? = nil, id: Int64? = nil) {
        self.name = name
        self.look_id = look_id
        self.id = id
    }

}

public struct ContentValidatorError: SDKModel {
    public var look: ContentValidationLook?
    public var dashboard: ContentValidationDashboard?
    public var dashboard_element: ContentValidationDashboardElement?
    public var dashboard_filter: ContentValidationDashboardFilter?
    public var scheduled_plan: ContentValidationScheduledPlan?
    public var alert: ContentValidationAlert?
    public var lookml_dashboard: ContentValidationLookMLDashboard?
    public var lookml_dashboard_element: ContentValidationLookMLDashboardElement?
    /**
     * A list of errors found for this piece of content (read-only)
     */
    public var errors: [ContentValidationError]?
    /**
     * An id unique to this piece of content for this validation run (read-only)
     */
    public var id: String?

    public init(look: ContentValidationLook? = nil, dashboard: ContentValidationDashboard? = nil, dashboard_element: ContentValidationDashboardElement? = nil, dashboard_filter: ContentValidationDashboardFilter? = nil, scheduled_plan: ContentValidationScheduledPlan? = nil, alert: ContentValidationAlert? = nil, lookml_dashboard: ContentValidationLookMLDashboard? = nil, lookml_dashboard_element: ContentValidationLookMLDashboardElement? = nil, errors: [ContentValidationError]? = nil, id: String? = nil) {
        self.look = look
        self.dashboard = dashboard
        self.dashboard_element = dashboard_element
        self.dashboard_filter = dashboard_filter
        self.scheduled_plan = scheduled_plan
        self.alert = alert
        self.lookml_dashboard = lookml_dashboard
        self.lookml_dashboard_element = lookml_dashboard_element
        self.errors = errors
        self.id = id
    }

}

public struct ContentView: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Id of viewed Look (read-only)
     */
    public var look_id: Int64?
    /**
     * Id of the viewed Dashboard (read-only)
     */
    public var dashboard_id: Int64?
    /**
     * Content metadata id of the Look or Dashboard (read-only)
     */
    public var content_metadata_id: Int64?
    /**
     * Id of user content was viewed by (read-only)
     */
    public var user_id: Int64?
    /**
     * Id of group content was viewed by (read-only)
     */
    public var group_id: Int64?
    /**
     * Number of times piece of content was viewed (read-only)
     */
    public var view_count: Int64?
    /**
     * Number of times piece of content was favorited (read-only)
     */
    public var favorite_count: Int64?
    /**
     * Date the piece of content was last viewed (read-only)
     */
    public var last_viewed_at: String?
    /**
     * Week start date for the view and favorite count during that given week (read-only)
     */
    public var start_of_week_date: String?

    public init(can: StringDictionary<Bool>? = nil, id: Int64? = nil, look_id: Int64? = nil, dashboard_id: Int64? = nil, content_metadata_id: Int64? = nil, user_id: Int64? = nil, group_id: Int64? = nil, view_count: Int64? = nil, favorite_count: Int64? = nil, last_viewed_at: String? = nil, start_of_week_date: String? = nil) {
        self.can = can
        self.id = id
        self.look_id = look_id
        self.dashboard_id = dashboard_id
        self.content_metadata_id = content_metadata_id
        self.user_id = user_id
        self.group_id = group_id
        self.view_count = view_count
        self.favorite_count = favorite_count
        self.last_viewed_at = last_viewed_at
        self.start_of_week_date = start_of_week_date
    }

}

public struct ContinuousPalette: SDKModel {
    /**
     * Unique identity string (read-only)
     */
    public var id: String?
    /**
     * Label for palette
     */
    public var label: String?
    /**
     * Type of palette
     */
    public var type: String?
    /**
     * Array of ColorStops in the palette
     */
    public var stops: [ColorStop]?

    public init(id: String? = nil, label: String? = nil, type: String? = nil, stops: [ColorStop]? = nil) {
        self.id = id
        self.label = label
        self.type = type
        self.stops = stops
    }

}

public struct CostEstimate: SDKModel {
    /**
     * Cost of SQL statement (read-only)
     */
    public var cost: Int64?
    /**
     * Does the result come from the cache? (read-only)
     */
    public var cache_hit: Bool?
    /**
     * Cost measurement size (read-only)
     */
    public var cost_unit: String?
    /**
     * Human-friendly message (read-only)
     */
    public var message: String?

    public init(cost: Int64? = nil, cache_hit: Bool? = nil, cost_unit: String? = nil, message: String? = nil) {
        self.cost = cost
        self.cache_hit = cache_hit
        self.cost_unit = cost_unit
        self.message = message
    }

}

public struct CreateCostEstimate: SDKModel {
    /**
     * SQL statement to estimate (read-only)
     */
    public var sql: String?

    public init(sql: String? = nil) {
        self.sql = sql
    }

}

public struct CreateDashboardFilter: SDKModel {
    /**
     * Unique Id (read-only)
     */
    public var id: String?
    /**
     * Id of Dashboard
     */
    public var dashboard_id: String
    /**
     * Name of filter
     */
    public var name: String
    /**
     * Title of filter
     */
    public var title: String
    /**
     * Type of filter: one of date, number, string, or field
     */
    public var type: String
    /**
     * Default value of filter
     */
    public var default_value: String?
    /**
     * Model of filter (required if type = field)
     */
    public var model: String?
    /**
     * Explore of filter (required if type = field)
     */
    public var explore: String?
    /**
     * Dimension of filter (required if type = field)
     */
    public var dimension: String?
    /**
     * Field information (read-only)
     */
    public var field: StringDictionary<AnyCodable>?
    /**
     * Display order of this filter relative to other filters
     */
    public var row: Int64?
    /**
     * Array of listeners for faceted filters
     */
    public var listens_to_filters: [String]?
    /**
     * Whether the filter allows multiple filter values
     */
    public var allow_multiple_values: Bool?
    /**
     * Whether the filter requires a value to run the dashboard
     */
    public var required: Bool?
    /**
     * The visual configuration for this filter. Used to set up how the UI for this filter should appear.
     */
    public var ui_config: StringDictionary<AnyCodable>?

    public init(id: String? = nil, dashboard_id: String, name: String, title: String, type: String, default_value: String? = nil, model: String? = nil, explore: String? = nil, dimension: String? = nil, field: StringDictionary<AnyCodable>? = nil, row: Int64? = nil, listens_to_filters: [String]? = nil, allow_multiple_values: Bool? = nil, required: Bool? = nil, ui_config: StringDictionary<AnyCodable>? = nil) {
        self.id = id
        self.dashboard_id = dashboard_id
        self.name = name
        self.title = title
        self.type = type
        self.default_value = default_value
        self.model = model
        self.explore = explore
        self.dimension = dimension
        self.field = field
        self.row = row
        self.listens_to_filters = listens_to_filters
        self.allow_multiple_values = allow_multiple_values
        self.required = required
        self.ui_config = ui_config
    }

    public init(id: String? = nil, _ dashboard_id: String, _ name: String, _ title: String, _ type: String, default_value: String? = nil, model: String? = nil, explore: String? = nil, dimension: String? = nil, field: StringDictionary<AnyCodable>? = nil, row: Int64? = nil, listens_to_filters: [String]? = nil, allow_multiple_values: Bool? = nil, required: Bool? = nil, ui_config: StringDictionary<AnyCodable>? = nil) {
        self.init(id: id, dashboard_id: dashboard_id, name: name, title: title, type: type, default_value: default_value, model: model, explore: explore, dimension: dimension, field: field, row: row, listens_to_filters: listens_to_filters, allow_multiple_values: allow_multiple_values, required: required, ui_config: ui_config)
    }

}

public struct CreateDashboardRenderTask: SDKModel {
    /**
     * Filter values to apply to the dashboard queries, in URL query format
     */
    public var dashboard_filters: String?
    /**
     * Dashboard layout style: single_column or tiled
     */
    public var dashboard_style: String?

    public init(dashboard_filters: String? = nil, dashboard_style: String? = nil) {
        self.dashboard_filters = dashboard_filters
        self.dashboard_style = dashboard_style
    }

}

public struct CreateFolder: SDKModel {
    /**
     * Unique Name
     */
    public var name: String
    /**
     * Id of Parent. If the parent id is null, this is a root-level entry
     */
    public var parent_id: String

    public init(name: String, parent_id: String) {
        self.name = name
        self.parent_id = parent_id
    }

    public init(_ name: String, _ parent_id: String) {
        self.init(name: name, parent_id: parent_id)
    }

}

public struct CreateQueryTask: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Id of query to run
     */
    public var query_id: Int64
    /**
     * Desired async query result format. Valid values are: "inline_json", "json", "json_detail", "json_fe", "csv", "html", "md", "txt", "xlsx", "gsxml".
     */
    public var result_format: ResultFormat
    /**
     * Source of query task
     */
    public var source: String?
    /**
     * Create the task but defer execution
     */
    public var deferred: Bool?
    /**
     * Id of look associated with query.
     */
    public var look_id: Int64?
    /**
     * Id of dashboard associated with query.
     */
    public var dashboard_id: String?

    public init(can: StringDictionary<Bool>? = nil, query_id: Int64, result_format: ResultFormat, source: String? = nil, deferred: Bool? = nil, look_id: Int64? = nil, dashboard_id: String? = nil) {
        self.can = can
        self.query_id = query_id
        self.result_format = result_format
        self.source = source
        self.deferred = deferred
        self.look_id = look_id
        self.dashboard_id = dashboard_id
    }

    public init(can: StringDictionary<Bool>? = nil, _ query_id: Int64, _ result_format: ResultFormat, source: String? = nil, deferred: Bool? = nil, look_id: Int64? = nil, dashboard_id: String? = nil) {
        self.init(can: can, query_id: query_id, result_format: result_format, source: source, deferred: deferred, look_id: look_id, dashboard_id: dashboard_id)
    }

}

public struct CredentialsApi3: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * API key client_id (read-only)
     */
    public var client_id: String?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String?
    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String?
    /**
     * Link to get this item (read-only)
     */
    public var url: URI?

    public init(can: StringDictionary<Bool>? = nil, id: Int64? = nil, client_id: String? = nil, created_at: String? = nil, is_disabled: Bool? = nil, type: String? = nil, url: URI? = nil) {
        self.can = can
        self.id = id
        self.client_id = client_id
        self.created_at = created_at
        self.is_disabled = is_disabled
        self.type = type
        self.url = url
    }

}

public struct CredentialsEmail: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String?
    /**
     * EMail address used for user login
     */
    public var email: String?
    /**
     * Force the user to change their password upon their next login
     */
    public var forced_password_reset_at_next_login: Bool?
    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?
    /**
     * Timestamp for most recent login using credential (read-only)
     */
    public var logged_in_at: String?
    /**
     * Url with one-time use secret token that the user can use to reset password (read-only)
     */
    public var password_reset_url: String?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String?
    /**
     * Link to get this item (read-only)
     */
    public var url: URI?
    /**
     * Link to get this user (read-only)
     */
    public var user_url: URI?

    public init(can: StringDictionary<Bool>? = nil, created_at: String? = nil, email: String? = nil, forced_password_reset_at_next_login: Bool? = nil, is_disabled: Bool? = nil, logged_in_at: String? = nil, password_reset_url: String? = nil, type: String? = nil, url: URI? = nil, user_url: URI? = nil) {
        self.can = can
        self.created_at = created_at
        self.email = email
        self.forced_password_reset_at_next_login = forced_password_reset_at_next_login
        self.is_disabled = is_disabled
        self.logged_in_at = logged_in_at
        self.password_reset_url = password_reset_url
        self.type = type
        self.url = url
        self.user_url = user_url
    }

}

public struct CredentialsEmbed: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String?
    /**
     * Embedder's id for a group to which this user was added during the most recent login (read-only)
     */
    public var external_group_id: String?
    /**
     * Embedder's unique id for the user (read-only)
     */
    public var external_user_id: String?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?
    /**
     * Timestamp for most recent login using credential (read-only)
     */
    public var logged_in_at: String?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String?
    /**
     * Link to get this item (read-only)
     */
    public var url: URI?

    public init(can: StringDictionary<Bool>? = nil, created_at: String? = nil, external_group_id: String? = nil, external_user_id: String? = nil, id: Int64? = nil, is_disabled: Bool? = nil, logged_in_at: String? = nil, type: String? = nil, url: URI? = nil) {
        self.can = can
        self.created_at = created_at
        self.external_group_id = external_group_id
        self.external_user_id = external_user_id
        self.id = id
        self.is_disabled = is_disabled
        self.logged_in_at = logged_in_at
        self.type = type
        self.url = url
    }

}

public struct CredentialsGoogle: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String?
    /**
     * Google domain (read-only)
     */
    public var domain: String?
    /**
     * EMail address (read-only)
     */
    public var email: String?
    /**
     * Google's Unique ID for this user (read-only)
     */
    public var google_user_id: String?
    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?
    /**
     * Timestamp for most recent login using credential (read-only)
     */
    public var logged_in_at: String?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String?
    /**
     * Link to get this item (read-only)
     */
    public var url: URI?

    public init(can: StringDictionary<Bool>? = nil, created_at: String? = nil, domain: String? = nil, email: String? = nil, google_user_id: String? = nil, is_disabled: Bool? = nil, logged_in_at: String? = nil, type: String? = nil, url: URI? = nil) {
        self.can = can
        self.created_at = created_at
        self.domain = domain
        self.email = email
        self.google_user_id = google_user_id
        self.is_disabled = is_disabled
        self.logged_in_at = logged_in_at
        self.type = type
        self.url = url
    }

}

public struct CredentialsLDAP: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String?
    /**
     * EMail address (read-only)
     */
    public var email: String?
    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?
    /**
     * LDAP Distinguished name for this user (as-of the last login) (read-only)
     */
    public var ldap_dn: String?
    /**
     * LDAP Unique ID for this user (read-only)
     */
    public var ldap_id: String?
    /**
     * Timestamp for most recent login using credential (read-only)
     */
    public var logged_in_at: String?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String?
    /**
     * Link to get this item (read-only)
     */
    public var url: URI?

    public init(can: StringDictionary<Bool>? = nil, created_at: String? = nil, email: String? = nil, is_disabled: Bool? = nil, ldap_dn: String? = nil, ldap_id: String? = nil, logged_in_at: String? = nil, type: String? = nil, url: URI? = nil) {
        self.can = can
        self.created_at = created_at
        self.email = email
        self.is_disabled = is_disabled
        self.ldap_dn = ldap_dn
        self.ldap_id = ldap_id
        self.logged_in_at = logged_in_at
        self.type = type
        self.url = url
    }

}

public struct CredentialsLookerOpenid: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String?
    /**
     * EMail address used for user login (read-only)
     */
    public var email: String?
    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?
    /**
     * Timestamp for most recent login using credential (read-only)
     */
    public var logged_in_at: String?
    /**
     * IP address of client for most recent login using credential (read-only)
     */
    public var logged_in_ip: String?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String?
    /**
     * Link to get this item (read-only)
     */
    public var url: URI?
    /**
     * Link to get this user (read-only)
     */
    public var user_url: URI?

    public init(can: StringDictionary<Bool>? = nil, created_at: String? = nil, email: String? = nil, is_disabled: Bool? = nil, logged_in_at: String? = nil, logged_in_ip: String? = nil, type: String? = nil, url: URI? = nil, user_url: URI? = nil) {
        self.can = can
        self.created_at = created_at
        self.email = email
        self.is_disabled = is_disabled
        self.logged_in_at = logged_in_at
        self.logged_in_ip = logged_in_ip
        self.type = type
        self.url = url
        self.user_url = user_url
    }

}

public struct CredentialsOIDC: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String?
    /**
     * EMail address (read-only)
     */
    public var email: String?
    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?
    /**
     * Timestamp for most recent login using credential (read-only)
     */
    public var logged_in_at: String?
    /**
     * OIDC OP's Unique ID for this user (read-only)
     */
    public var oidc_user_id: String?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String?
    /**
     * Link to get this item (read-only)
     */
    public var url: URI?

    public init(can: StringDictionary<Bool>? = nil, created_at: String? = nil, email: String? = nil, is_disabled: Bool? = nil, logged_in_at: String? = nil, oidc_user_id: String? = nil, type: String? = nil, url: URI? = nil) {
        self.can = can
        self.created_at = created_at
        self.email = email
        self.is_disabled = is_disabled
        self.logged_in_at = logged_in_at
        self.oidc_user_id = oidc_user_id
        self.type = type
        self.url = url
    }

}

public struct CredentialsSaml: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String?
    /**
     * EMail address (read-only)
     */
    public var email: String?
    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?
    /**
     * Timestamp for most recent login using credential (read-only)
     */
    public var logged_in_at: String?
    /**
     * Saml IdP's Unique ID for this user (read-only)
     */
    public var saml_user_id: String?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String?
    /**
     * Link to get this item (read-only)
     */
    public var url: URI?

    public init(can: StringDictionary<Bool>? = nil, created_at: String? = nil, email: String? = nil, is_disabled: Bool? = nil, logged_in_at: String? = nil, saml_user_id: String? = nil, type: String? = nil, url: URI? = nil) {
        self.can = can
        self.created_at = created_at
        self.email = email
        self.is_disabled = is_disabled
        self.logged_in_at = logged_in_at
        self.saml_user_id = saml_user_id
        self.type = type
        self.url = url
    }

}

public struct CredentialsTotp: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Timestamp for the creation of this credential (read-only)
     */
    public var created_at: String?
    /**
     * Has this credential been disabled? (read-only)
     */
    public var is_disabled: Bool?
    /**
     * Short name for the type of this kind of credential (read-only)
     */
    public var type: String?
    /**
     * User has verified (read-only)
     */
    public var verified: Bool?
    /**
     * Link to get this item (read-only)
     */
    public var url: URI?

    public init(can: StringDictionary<Bool>? = nil, created_at: String? = nil, is_disabled: Bool? = nil, type: String? = nil, verified: Bool? = nil, url: URI? = nil) {
        self.can = can
        self.created_at = created_at
        self.is_disabled = is_disabled
        self.type = type
        self.verified = verified
        self.url = url
    }

}

public struct CustomWelcomeEmail: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * If true, custom email content will replace the default body of welcome emails
     */
    public var enabled: Bool?
    /**
     * The HTML to use as custom content for welcome emails. Script elements and other potentially dangerous markup will be removed.
     */
    public var content: String?
    /**
     * The text to appear in the email subject line.
     */
    public var subject: String?
    /**
     * The text to appear in the header line of the email body.
     */
    public var header: String?

    public init(can: StringDictionary<Bool>? = nil, enabled: Bool? = nil, content: String? = nil, subject: String? = nil, header: String? = nil) {
        self.can = can
        self.enabled = enabled
        self.content = content
        self.subject = subject
        self.header = header
    }

}

public struct Dashboard: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Content Favorite Id (read-only)
     */
    public var content_favorite_id: Int64?
    /**
     * Id of content metadata (read-only)
     */
    public var content_metadata_id: Int64?
    /**
     * Description
     */
    public var description: String?
    /**
     * Is Hidden
     */
    public var hidden: Bool?
    /**
     * Unique Id (read-only)
     */
    public var id: String?
    public var model: LookModel?
    /**
     * Timezone in which the Dashboard will run by default.
     */
    public var query_timezone: String?
    /**
     * Is Read-only (read-only)
     */
    public var readonly: Bool?
    /**
     * Refresh Interval, as a time duration phrase like "2 hours 30 minutes". A number with no time units will be interpreted as whole seconds.
     */
    public var refresh_interval: String?
    /**
     * Refresh Interval in milliseconds (read-only)
     */
    public var refresh_interval_to_i: Int64?
    public var folder: FolderBase?
    /**
     * Dashboard Title
     */
    public var title: String?
    /**
     * Id of User (read-only)
     */
    public var user_id: Int64?
    /**
     * Background color
     */
    public var background_color: String?
    /**
     * Time that the Dashboard was created. (read-only)
     */
    public var created_at: Date?
    /**
     * Enables crossfiltering in dashboards - only available in dashboards-next (beta)
     */
    public var crossfilter_enabled: Bool?
    /**
     * Elements (read-only)
     */
    public var dashboard_elements: [DashboardElement]?
    /**
     * Filters (read-only)
     */
    public var dashboard_filters: [DashboardFilter]?
    /**
     * Layouts (read-only)
     */
    public var dashboard_layouts: [DashboardLayout]?
    /**
     * Whether or not a dashboard is 'soft' deleted.
     */
    public var deleted: Bool?
    /**
     * Time that the Dashboard was 'soft' deleted. (read-only)
     */
    public var deleted_at: Date?
    /**
     * Id of User that 'soft' deleted the dashboard. (read-only)
     */
    public var deleter_id: Int64?
    /**
     * Relative path of URI of LookML file to edit the dashboard (LookML dashboard only). (read-only)
     */
    public var edit_uri: URI?
    /**
     * Number of times favorited (read-only)
     */
    public var favorite_count: Int64?
    /**
     * Time the dashboard was last accessed (read-only)
     */
    public var last_accessed_at: Date?
    /**
     * Time last viewed in the Looker web UI (read-only)
     */
    public var last_viewed_at: Date?
    /**
     * configuration option that governs how dashboard loading will happen.
     */
    public var load_configuration: String?
    /**
     * Links this dashboard to a particular LookML dashboard such that calling a **sync** operation on that LookML dashboard will update this dashboard to match.
     */
    public var lookml_link_id: String?
    /**
     * Show filters bar.  **Security Note:** This property only affects the *cosmetic* appearance of the dashboard, not a user's ability to access data. Hiding the filters bar does **NOT** prevent users from changing filters by other means. For information on how to set up secure data access control policies, see [Control User Access to Data](https://looker.com/docs/r/api/control-access)
     */
    public var show_filters_bar: Bool?
    /**
     * Show title
     */
    public var show_title: Bool?
    /**
     * Content Metadata Slug
     */
    public var slug: String?
    /**
     * Id of folder
     */
    public var folder_id: String?
    /**
     * Color of text on text tiles
     */
    public var text_tile_text_color: String?
    /**
     * Tile background color
     */
    public var tile_background_color: String?
    /**
     * Tile text color
     */
    public var tile_text_color: String?
    /**
     * Title color
     */
    public var title_color: String?
    /**
     * Number of times viewed in the Looker web UI (read-only)
     */
    public var view_count: Int64?
    public var appearance: DashboardAppearance?
    /**
     * The preferred route for viewing this dashboard (ie: dashboards or dashboards-next)
     */
    public var preferred_viewer: String?

    public init(can: StringDictionary<Bool>? = nil, content_favorite_id: Int64? = nil, content_metadata_id: Int64? = nil, description: String? = nil, hidden: Bool? = nil, id: String? = nil, model: LookModel? = nil, query_timezone: String? = nil, readonly: Bool? = nil, refresh_interval: String? = nil, refresh_interval_to_i: Int64? = nil, folder: FolderBase? = nil, title: String? = nil, user_id: Int64? = nil, background_color: String? = nil, created_at: Date? = nil, crossfilter_enabled: Bool? = nil, dashboard_elements: [DashboardElement]? = nil, dashboard_filters: [DashboardFilter]? = nil, dashboard_layouts: [DashboardLayout]? = nil, deleted: Bool? = nil, deleted_at: Date? = nil, deleter_id: Int64? = nil, edit_uri: URI? = nil, favorite_count: Int64? = nil, last_accessed_at: Date? = nil, last_viewed_at: Date? = nil, load_configuration: String? = nil, lookml_link_id: String? = nil, show_filters_bar: Bool? = nil, show_title: Bool? = nil, slug: String? = nil, folder_id: String? = nil, text_tile_text_color: String? = nil, tile_background_color: String? = nil, tile_text_color: String? = nil, title_color: String? = nil, view_count: Int64? = nil, appearance: DashboardAppearance? = nil, preferred_viewer: String? = nil) {
        self.can = can
        self.content_favorite_id = content_favorite_id
        self.content_metadata_id = content_metadata_id
        self.description = description
        self.hidden = hidden
        self.id = id
        self.model = model
        self.query_timezone = query_timezone
        self.readonly = readonly
        self.refresh_interval = refresh_interval
        self.refresh_interval_to_i = refresh_interval_to_i
        self.folder = folder
        self.title = title
        self.user_id = user_id
        self.background_color = background_color
        self.created_at = created_at
        self.crossfilter_enabled = crossfilter_enabled
        self.dashboard_elements = dashboard_elements
        self.dashboard_filters = dashboard_filters
        self.dashboard_layouts = dashboard_layouts
        self.deleted = deleted
        self.deleted_at = deleted_at
        self.deleter_id = deleter_id
        self.edit_uri = edit_uri
        self.favorite_count = favorite_count
        self.last_accessed_at = last_accessed_at
        self.last_viewed_at = last_viewed_at
        self.load_configuration = load_configuration
        self.lookml_link_id = lookml_link_id
        self.show_filters_bar = show_filters_bar
        self.show_title = show_title
        self.slug = slug
        self.folder_id = folder_id
        self.text_tile_text_color = text_tile_text_color
        self.tile_background_color = tile_background_color
        self.tile_text_color = tile_text_color
        self.title_color = title_color
        self.view_count = view_count
        self.appearance = appearance
        self.preferred_viewer = preferred_viewer
    }

}

public struct DashboardAggregateTableLookml: SDKModel {
    /**
     * Dashboard Id (read-only)
     */
    public var dashboard_id: String?
    /**
     * Aggregate Table LookML (read-only)
     */
    public var aggregate_table_lookml: String?

    public init(dashboard_id: String? = nil, aggregate_table_lookml: String? = nil) {
        self.dashboard_id = dashboard_id
        self.aggregate_table_lookml = aggregate_table_lookml
    }

}

public struct DashboardAppearance: SDKModel {
    /**
     * Page margin (side) width
     */
    public var page_side_margins: Int64?
    /**
     * Background color for the dashboard
     */
    public var page_background_color: String?
    /**
     * Title alignment on dashboard tiles
     */
    public var tile_title_alignment: String?
    /**
     * Space between tiles
     */
    public var tile_space_between: Int64?
    /**
     * Background color for tiles
     */
    public var tile_background_color: String?
    /**
     * Tile shadow on/off
     */
    public var tile_shadow: Bool?
    /**
     * Key color
     */
    public var key_color: String?

    public init(page_side_margins: Int64? = nil, page_background_color: String? = nil, tile_title_alignment: String? = nil, tile_space_between: Int64? = nil, tile_background_color: String? = nil, tile_shadow: Bool? = nil, key_color: String? = nil) {
        self.page_side_margins = page_side_margins
        self.page_background_color = page_background_color
        self.tile_title_alignment = tile_title_alignment
        self.tile_space_between = tile_space_between
        self.tile_background_color = tile_background_color
        self.tile_shadow = tile_shadow
        self.key_color = key_color
    }

}

public struct DashboardBase: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Content Favorite Id (read-only)
     */
    public var content_favorite_id: Int64?
    /**
     * Id of content metadata (read-only)
     */
    public var content_metadata_id: Int64?
    /**
     * Description (read-only)
     */
    public var description: String?
    /**
     * Is Hidden (read-only)
     */
    public var hidden: Bool?
    /**
     * Unique Id (read-only)
     */
    public var id: String?
    public var model: LookModel?
    /**
     * Timezone in which the Dashboard will run by default. (read-only)
     */
    public var query_timezone: String?
    /**
     * Is Read-only (read-only)
     */
    public var readonly: Bool?
    /**
     * Refresh Interval, as a time duration phrase like "2 hours 30 minutes". A number with no time units will be interpreted as whole seconds. (read-only)
     */
    public var refresh_interval: String?
    /**
     * Refresh Interval in milliseconds (read-only)
     */
    public var refresh_interval_to_i: Int64?
    public var folder: FolderBase?
    /**
     * Dashboard Title (read-only)
     */
    public var title: String?
    /**
     * Id of User (read-only)
     */
    public var user_id: Int64?

    public init(can: StringDictionary<Bool>? = nil, content_favorite_id: Int64? = nil, content_metadata_id: Int64? = nil, description: String? = nil, hidden: Bool? = nil, id: String? = nil, model: LookModel? = nil, query_timezone: String? = nil, readonly: Bool? = nil, refresh_interval: String? = nil, refresh_interval_to_i: Int64? = nil, folder: FolderBase? = nil, title: String? = nil, user_id: Int64? = nil) {
        self.can = can
        self.content_favorite_id = content_favorite_id
        self.content_metadata_id = content_metadata_id
        self.description = description
        self.hidden = hidden
        self.id = id
        self.model = model
        self.query_timezone = query_timezone
        self.readonly = readonly
        self.refresh_interval = refresh_interval
        self.refresh_interval_to_i = refresh_interval_to_i
        self.folder = folder
        self.title = title
        self.user_id = user_id
    }

}

public struct DashboardElement: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Text tile body text
     */
    public var body_text: String?
    /**
     * Text tile body text as Html (read-only)
     */
    public var body_text_as_html: String?
    /**
     * Id of Dashboard
     */
    public var dashboard_id: String?
    /**
     * Relative path of URI of LookML file to edit the dashboard element (LookML dashboard only). (read-only)
     */
    public var edit_uri: URI?
    /**
     * Unique Id (read-only)
     */
    public var id: String?
    public var look: LookWithQuery?
    /**
     * Id Of Look
     */
    public var look_id: String?
    /**
     * LookML link ID (read-only)
     */
    public var lookml_link_id: String?
    /**
     * ID of merge result
     */
    public var merge_result_id: String?
    /**
     * Note Display
     */
    public var note_display: String?
    /**
     * Note State
     */
    public var note_state: String?
    /**
     * Note Text
     */
    public var note_text: String?
    /**
     * Note Text as Html (read-only)
     */
    public var note_text_as_html: String?
    public var query: Query?
    /**
     * Id Of Query
     */
    public var query_id: Int64?
    /**
     * Refresh Interval
     */
    public var refresh_interval: String?
    /**
     * Refresh Interval as integer (read-only)
     */
    public var refresh_interval_to_i: Int64?
    public var result_maker: ResultMakerWithIdVisConfigAndDynamicFields?
    /**
     * ID of the ResultMakerLookup entry.
     */
    public var result_maker_id: Int64?
    /**
     * Text tile subtitle text
     */
    public var subtitle_text: String?
    /**
     * Title of dashboard element
     */
    public var title: String?
    /**
     * Whether title is hidden
     */
    public var title_hidden: Bool?
    /**
     * Text tile title
     */
    public var title_text: String?
    /**
     * Type
     */
    public var type: String?
    /**
     * Count of Alerts associated to a dashboard element (read-only)
     */
    public var alert_count: Int64?
    /**
     * Text tile title text as Html (read-only)
     */
    public var title_text_as_html: String?
    /**
     * Text tile subtitle text as Html (read-only)
     */
    public var subtitle_text_as_html: String?

    public init(can: StringDictionary<Bool>? = nil, body_text: String? = nil, body_text_as_html: String? = nil, dashboard_id: String? = nil, edit_uri: URI? = nil, id: String? = nil, look: LookWithQuery? = nil, look_id: String? = nil, lookml_link_id: String? = nil, merge_result_id: String? = nil, note_display: String? = nil, note_state: String? = nil, note_text: String? = nil, note_text_as_html: String? = nil, query: Query? = nil, query_id: Int64? = nil, refresh_interval: String? = nil, refresh_interval_to_i: Int64? = nil, result_maker: ResultMakerWithIdVisConfigAndDynamicFields? = nil, result_maker_id: Int64? = nil, subtitle_text: String? = nil, title: String? = nil, title_hidden: Bool? = nil, title_text: String? = nil, type: String? = nil, alert_count: Int64? = nil, title_text_as_html: String? = nil, subtitle_text_as_html: String? = nil) {
        self.can = can
        self.body_text = body_text
        self.body_text_as_html = body_text_as_html
        self.dashboard_id = dashboard_id
        self.edit_uri = edit_uri
        self.id = id
        self.look = look
        self.look_id = look_id
        self.lookml_link_id = lookml_link_id
        self.merge_result_id = merge_result_id
        self.note_display = note_display
        self.note_state = note_state
        self.note_text = note_text
        self.note_text_as_html = note_text_as_html
        self.query = query
        self.query_id = query_id
        self.refresh_interval = refresh_interval
        self.refresh_interval_to_i = refresh_interval_to_i
        self.result_maker = result_maker
        self.result_maker_id = result_maker_id
        self.subtitle_text = subtitle_text
        self.title = title
        self.title_hidden = title_hidden
        self.title_text = title_text
        self.type = type
        self.alert_count = alert_count
        self.title_text_as_html = title_text_as_html
        self.subtitle_text_as_html = subtitle_text_as_html
    }

}

public struct DashboardFilter: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Unique Id (read-only)
     */
    public var id: String?
    /**
     * Id of Dashboard (read-only)
     */
    public var dashboard_id: String?
    /**
     * Name of filter
     */
    public var name: String?
    /**
     * Title of filter
     */
    public var title: String?
    /**
     * Type of filter: one of date, number, string, or field
     */
    public var type: String?
    /**
     * Default value of filter
     */
    public var default_value: String?
    /**
     * Model of filter (required if type = field)
     */
    public var model: String?
    /**
     * Explore of filter (required if type = field)
     */
    public var explore: String?
    /**
     * Dimension of filter (required if type = field)
     */
    public var dimension: String?
    /**
     * Field information (read-only)
     */
    public var field: StringDictionary<AnyCodable>?
    /**
     * Display order of this filter relative to other filters
     */
    public var row: Int64?
    /**
     * Array of listeners for faceted filters
     */
    public var listens_to_filters: [String]?
    /**
     * Whether the filter allows multiple filter values
     */
    public var allow_multiple_values: Bool?
    /**
     * Whether the filter requires a value to run the dashboard
     */
    public var required: Bool?
    /**
     * The visual configuration for this filter. Used to set up how the UI for this filter should appear.
     */
    public var ui_config: StringDictionary<AnyCodable>?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, dashboard_id: String? = nil, name: String? = nil, title: String? = nil, type: String? = nil, default_value: String? = nil, model: String? = nil, explore: String? = nil, dimension: String? = nil, field: StringDictionary<AnyCodable>? = nil, row: Int64? = nil, listens_to_filters: [String]? = nil, allow_multiple_values: Bool? = nil, required: Bool? = nil, ui_config: StringDictionary<AnyCodable>? = nil) {
        self.can = can
        self.id = id
        self.dashboard_id = dashboard_id
        self.name = name
        self.title = title
        self.type = type
        self.default_value = default_value
        self.model = model
        self.explore = explore
        self.dimension = dimension
        self.field = field
        self.row = row
        self.listens_to_filters = listens_to_filters
        self.allow_multiple_values = allow_multiple_values
        self.required = required
        self.ui_config = ui_config
    }

}

public struct DashboardLayout: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Unique Id (read-only)
     */
    public var id: String?
    /**
     * Id of Dashboard
     */
    public var dashboard_id: String?
    /**
     * Type
     */
    public var type: String?
    /**
     * Is Active
     */
    public var active: Bool?
    /**
     * Column Width
     */
    public var column_width: Int64?
    /**
     * Width
     */
    public var width: Int64?
    /**
     * Whether or not the dashboard layout is deleted. (read-only)
     */
    public var deleted: Bool?
    /**
     * Title extracted from the dashboard this layout represents. (read-only)
     */
    public var dashboard_title: String?
    /**
     * Components (read-only)
     */
    public var dashboard_layout_components: [DashboardLayoutComponent]?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, dashboard_id: String? = nil, type: String? = nil, active: Bool? = nil, column_width: Int64? = nil, width: Int64? = nil, deleted: Bool? = nil, dashboard_title: String? = nil, dashboard_layout_components: [DashboardLayoutComponent]? = nil) {
        self.can = can
        self.id = id
        self.dashboard_id = dashboard_id
        self.type = type
        self.active = active
        self.column_width = column_width
        self.width = width
        self.deleted = deleted
        self.dashboard_title = dashboard_title
        self.dashboard_layout_components = dashboard_layout_components
    }

}

public struct DashboardLayoutComponent: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Unique Id (read-only)
     */
    public var id: String?
    /**
     * Id of Dashboard Layout
     */
    public var dashboard_layout_id: String?
    /**
     * Id Of Dashboard Element
     */
    public var dashboard_element_id: String?
    /**
     * Row
     */
    public var row: Int64?
    /**
     * Column
     */
    public var column: Int64?
    /**
     * Width
     */
    public var width: Int64?
    /**
     * Height
     */
    public var height: Int64?
    /**
     * Whether or not the dashboard layout component is deleted (read-only)
     */
    public var deleted: Bool?
    /**
     * Dashboard element title, extracted from the Dashboard Element. (read-only)
     */
    public var element_title: String?
    /**
     * Whether or not the dashboard element title is displayed. (read-only)
     */
    public var element_title_hidden: Bool?
    /**
     * Visualization type, extracted from a query's vis_config (read-only)
     */
    public var vis_type: String?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, dashboard_layout_id: String? = nil, dashboard_element_id: String? = nil, row: Int64? = nil, column: Int64? = nil, width: Int64? = nil, height: Int64? = nil, deleted: Bool? = nil, element_title: String? = nil, element_title_hidden: Bool? = nil, vis_type: String? = nil) {
        self.can = can
        self.id = id
        self.dashboard_layout_id = dashboard_layout_id
        self.dashboard_element_id = dashboard_element_id
        self.row = row
        self.column = column
        self.width = width
        self.height = height
        self.deleted = deleted
        self.element_title = element_title
        self.element_title_hidden = element_title_hidden
        self.vis_type = vis_type
    }

}

public struct DashboardLookml: SDKModel {
    /**
     * Id of Dashboard (read-only)
     */
    public var dashboard_id: String?
    /**
     * lookml of UDD (read-only)
     */
    public var lookml: String?

    public init(dashboard_id: String? = nil, lookml: String? = nil) {
        self.dashboard_id = dashboard_id
        self.lookml = lookml
    }

}

public struct DataActionForm: SDKModel {
    public var state: DataActionUserState?
    /**
     * Array of form fields. (read-only)
     */
    public var fields: [DataActionFormField]?

    public init(state: DataActionUserState? = nil, fields: [DataActionFormField]? = nil) {
        self.state = state
        self.fields = fields
    }

}

public struct DataActionFormField: SDKModel {
    /**
     * Name (read-only)
     */
    public var name: String?
    /**
     * Human-readable label (read-only)
     */
    public var label: String?
    /**
     * Description of field (read-only)
     */
    public var description: String?
    /**
     * Type of field. (read-only)
     */
    public var type: String?
    /**
     * Default value of the field. (read-only)
     */
    public var `default`: String?
    /**
     * The URL for an oauth link, if type is 'oauth_link'. (read-only)
     */
    public var oauth_url: String?
    /**
     * Whether or not a field supports interactive forms. (read-only)
     */
    public var interactive: Bool?
    /**
     * Whether or not the field is required. This is a user-interface hint. A user interface displaying this form should not submit it without a value for this field. The action server must also perform this validation. (read-only)
     */
    public var required: Bool?
    /**
     * If the form type is 'select', a list of options to be selected from. (read-only)
     */
    public var options: [DataActionFormSelectOption]?

    public init(name: String? = nil, label: String? = nil, description: String? = nil, type: String? = nil, `default`: String? = nil, oauth_url: String? = nil, interactive: Bool? = nil, required: Bool? = nil, options: [DataActionFormSelectOption]? = nil) {
        self.name = name
        self.label = label
        self.description = description
        self.type = type
        self.`default` = `default`
        self.oauth_url = oauth_url
        self.interactive = interactive
        self.required = required
        self.options = options
    }

}

public struct DataActionFormSelectOption: SDKModel {
    /**
     * Name (read-only)
     */
    public var name: String?
    /**
     * Human-readable label (read-only)
     */
    public var label: String?

    public init(name: String? = nil, label: String? = nil) {
        self.name = name
        self.label = label
    }

}

public struct DataActionRequest: SDKModel {
    /**
     * The JSON describing the data action. This JSON should be considered opaque and should be passed through unmodified from the query result it came from.
     */
    public var action: StringDictionary<AnyCodable>?
    /**
     * User input for any form values the data action might use.
     */
    public var form_values: StringDictionary<AnyCodable>?

    public init(action: StringDictionary<AnyCodable>? = nil, form_values: StringDictionary<AnyCodable>? = nil) {
        self.action = action
        self.form_values = form_values
    }

}

public struct DataActionResponse: SDKModel {
    /**
     * ID of the webhook event that sent this data action. In some error conditions, this may be null. (read-only)
     */
    public var webhook_id: String?
    /**
     * Whether the data action was successful. (read-only)
     */
    public var success: Bool?
    /**
     * When true, indicates that the client should refresh (rerun) the source query because the data may have been changed by the action. (read-only)
     */
    public var refresh_query: Bool?
    public var validation_errors: ValidationError?
    /**
     * Optional message returned by the data action server describing the state of the action that took place. This can be used to implement custom failure messages. If a failure is related to a particular form field, the server should send back a validation error instead. The Looker web UI does not currently display any message if the action indicates 'success', but may do so in the future. (read-only)
     */
    public var message: String?

    public init(webhook_id: String? = nil, success: Bool? = nil, refresh_query: Bool? = nil, validation_errors: ValidationError? = nil, message: String? = nil) {
        self.webhook_id = webhook_id
        self.success = success
        self.refresh_query = refresh_query
        self.validation_errors = validation_errors
        self.message = message
    }

}

public struct DataActionUserState: SDKModel {
    /**
     * User state data (read-only)
     */
    public var data: String?
    /**
     * Time in seconds until the state needs to be refreshed (read-only)
     */
    public var refresh_time: Int64?

    public init(data: String? = nil, refresh_time: Int64? = nil) {
        self.data = data
        self.refresh_time = refresh_time
    }

}

public struct Datagroup: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * UNIX timestamp at which this entry was created. (read-only)
     */
    public var created_at: Int64?
    /**
     * Unique ID of the datagroup (read-only)
     */
    public var id: Int64?
    /**
     * Name of the model containing the datagroup. Unique when combined with name. (read-only)
     */
    public var model_name: String?
    /**
     * Name of the datagroup. Unique when combined with model_name. (read-only)
     */
    public var name: String?
    /**
     * UNIX timestamp before which cache entries are considered stale. Cannot be in the future.
     */
    public var stale_before: Int64?
    /**
     * UNIX timestamp at which this entry trigger was last checked. (read-only)
     */
    public var trigger_check_at: Int64?
    /**
     * The message returned with the error of the last trigger check. (read-only)
     */
    public var trigger_error: String?
    /**
     * The value of the trigger when last checked. (read-only)
     */
    public var trigger_value: String?
    /**
     * UNIX timestamp at which this entry became triggered. Cannot be in the future.
     */
    public var triggered_at: Int64?

    public init(can: StringDictionary<Bool>? = nil, created_at: Int64? = nil, id: Int64? = nil, model_name: String? = nil, name: String? = nil, stale_before: Int64? = nil, trigger_check_at: Int64? = nil, trigger_error: String? = nil, trigger_value: String? = nil, triggered_at: Int64? = nil) {
        self.can = can
        self.created_at = created_at
        self.id = id
        self.model_name = model_name
        self.name = name
        self.stale_before = stale_before
        self.trigger_check_at = trigger_check_at
        self.trigger_error = trigger_error
        self.trigger_value = trigger_value
        self.triggered_at = triggered_at
    }

}

public struct DBConnection: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Name of the connection. Also used as the unique identifier
     */
    public var name: String?
    public var dialect: Dialect?
    /**
     * SQL Runner snippets for this connection (read-only)
     */
    public var snippets: [Snippet]?
    /**
     * True if PDTs are enabled on this connection (read-only)
     */
    public var pdts_enabled: Bool?
    /**
     * Host name/address of server
     */
    public var host: String?
    /**
     * Port number on server
     */
    public var port: Int64?
    /**
     * Username for server authentication
     */
    public var username: String?
    /**
     * (Write-Only) Password for server authentication
     */
    public var password: String?
    /**
     * Whether the connection uses OAuth for authentication. (read-only)
     */
    public var uses_oauth: Bool?
    /**
     * (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
     */
    public var certificate: String?
    /**
     * (Write-Only) Certificate keyfile type - .json or .p12
     */
    public var file_type: String?
    /**
     * Database name
     */
    public var database: String?
    /**
     * Time zone of database
     */
    public var db_timezone: String?
    /**
     * Timezone to use in queries
     */
    public var query_timezone: String?
    /**
     * Scheme name
     */
    public var schema: String?
    /**
     * Maximum number of concurrent connection to use
     */
    public var max_connections: Int64?
    /**
     * Maximum size of query in GBs (BigQuery only, can be a user_attribute name)
     */
    public var max_billing_gigabytes: String?
    /**
     * Use SSL/TLS when connecting to server
     */
    public var ssl: Bool?
    /**
     * Verify the SSL
     */
    public var verify_ssl: Bool?
    /**
     * Name of temporary database (if used)
     */
    public var tmp_db_name: String?
    /**
     * Additional params to add to JDBC connection string
     */
    public var jdbc_additional_params: String?
    /**
     * Connection Pool Timeout, in seconds
     */
    public var pool_timeout: Int64?
    /**
     * (Read/Write) SQL Dialect name
     */
    public var dialect_name: String?
    /**
     * Creation date for this connection (read-only)
     */
    public var created_at: String?
    /**
     * Id of user who last modified this connection configuration (read-only)
     */
    public var user_id: String?
    /**
     * Is this an example connection? (read-only)
     */
    public var example: Bool?
    /**
     * (Limited access feature) Are per user db credentials enabled. Enabling will remove previously set username and password
     */
    public var user_db_credentials: Bool?
    /**
     * Fields whose values map to user attribute names
     */
    public var user_attribute_fields: [String]?
    /**
     * Cron string specifying when maintenance such as PDT trigger checks and drops should be performed
     */
    public var maintenance_cron: String?
    /**
     * Unix timestamp at start of last completed PDT trigger check process (read-only)
     */
    public var last_regen_at: String?
    /**
     * Unix timestamp at start of last completed PDT reap process (read-only)
     */
    public var last_reap_at: String?
    /**
     * Precache tables in the SQL Runner
     */
    public var sql_runner_precache_tables: Bool?
    /**
     * SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
     */
    public var after_connect_statements: String?
    public var pdt_context_override: DBConnectionOverride?
    /**
     * Is this connection created and managed by Looker (read-only)
     */
    public var managed: Bool?
    /**
     * The Id of the ssh tunnel this connection uses
     */
    public var tunnel_id: String?
    /**
     * Maximum number of threads to use to build PDTs in parallel
     */
    public var pdt_concurrency: Int64?
    /**
     * When disable_context_comment is true comment will not be added to SQL
     */
    public var disable_context_comment: Bool?

    public init(can: StringDictionary<Bool>? = nil, name: String? = nil, dialect: Dialect? = nil, snippets: [Snippet]? = nil, pdts_enabled: Bool? = nil, host: String? = nil, port: Int64? = nil, username: String? = nil, password: String? = nil, uses_oauth: Bool? = nil, certificate: String? = nil, file_type: String? = nil, database: String? = nil, db_timezone: String? = nil, query_timezone: String? = nil, schema: String? = nil, max_connections: Int64? = nil, max_billing_gigabytes: String? = nil, ssl: Bool? = nil, verify_ssl: Bool? = nil, tmp_db_name: String? = nil, jdbc_additional_params: String? = nil, pool_timeout: Int64? = nil, dialect_name: String? = nil, created_at: String? = nil, user_id: String? = nil, example: Bool? = nil, user_db_credentials: Bool? = nil, user_attribute_fields: [String]? = nil, maintenance_cron: String? = nil, last_regen_at: String? = nil, last_reap_at: String? = nil, sql_runner_precache_tables: Bool? = nil, after_connect_statements: String? = nil, pdt_context_override: DBConnectionOverride? = nil, managed: Bool? = nil, tunnel_id: String? = nil, pdt_concurrency: Int64? = nil, disable_context_comment: Bool? = nil) {
        self.can = can
        self.name = name
        self.dialect = dialect
        self.snippets = snippets
        self.pdts_enabled = pdts_enabled
        self.host = host
        self.port = port
        self.username = username
        self.password = password
        self.uses_oauth = uses_oauth
        self.certificate = certificate
        self.file_type = file_type
        self.database = database
        self.db_timezone = db_timezone
        self.query_timezone = query_timezone
        self.schema = schema
        self.max_connections = max_connections
        self.max_billing_gigabytes = max_billing_gigabytes
        self.ssl = ssl
        self.verify_ssl = verify_ssl
        self.tmp_db_name = tmp_db_name
        self.jdbc_additional_params = jdbc_additional_params
        self.pool_timeout = pool_timeout
        self.dialect_name = dialect_name
        self.created_at = created_at
        self.user_id = user_id
        self.example = example
        self.user_db_credentials = user_db_credentials
        self.user_attribute_fields = user_attribute_fields
        self.maintenance_cron = maintenance_cron
        self.last_regen_at = last_regen_at
        self.last_reap_at = last_reap_at
        self.sql_runner_precache_tables = sql_runner_precache_tables
        self.after_connect_statements = after_connect_statements
        self.pdt_context_override = pdt_context_override
        self.managed = managed
        self.tunnel_id = tunnel_id
        self.pdt_concurrency = pdt_concurrency
        self.disable_context_comment = disable_context_comment
    }

}

public struct DBConnectionBase: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Name of the connection. Also used as the unique identifier (read-only)
     */
    public var name: String?
    public var dialect: Dialect?
    /**
     * SQL Runner snippets for this connection (read-only)
     */
    public var snippets: [Snippet]?
    /**
     * True if PDTs are enabled on this connection (read-only)
     */
    public var pdts_enabled: Bool?

    public init(can: StringDictionary<Bool>? = nil, name: String? = nil, dialect: Dialect? = nil, snippets: [Snippet]? = nil, pdts_enabled: Bool? = nil) {
        self.can = can
        self.name = name
        self.dialect = dialect
        self.snippets = snippets
        self.pdts_enabled = pdts_enabled
    }

}

public struct DBConnectionOverride: SDKModel {
    /**
     * Context in which to override (`pdt` is the only allowed value)
     */
    public var context: String?
    /**
     * Host name/address of server
     */
    public var host: String?
    /**
     * Port number on server
     */
    public var port: String?
    /**
     * Username for server authentication
     */
    public var username: String?
    /**
     * (Write-Only) Password for server authentication
     */
    public var password: String?
    /**
     * Whether or not the password is overridden in this context (read-only)
     */
    public var has_password: Bool?
    /**
     * (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
     */
    public var certificate: String?
    /**
     * (Write-Only) Certificate keyfile type - .json or .p12
     */
    public var file_type: String?
    /**
     * Database name
     */
    public var database: String?
    /**
     * Scheme name
     */
    public var schema: String?
    /**
     * Additional params to add to JDBC connection string
     */
    public var jdbc_additional_params: String?
    /**
     * SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
     */
    public var after_connect_statements: String?

    public init(context: String? = nil, host: String? = nil, port: String? = nil, username: String? = nil, password: String? = nil, has_password: Bool? = nil, certificate: String? = nil, file_type: String? = nil, database: String? = nil, schema: String? = nil, jdbc_additional_params: String? = nil, after_connect_statements: String? = nil) {
        self.context = context
        self.host = host
        self.port = port
        self.username = username
        self.password = password
        self.has_password = has_password
        self.certificate = certificate
        self.file_type = file_type
        self.database = database
        self.schema = schema
        self.jdbc_additional_params = jdbc_additional_params
        self.after_connect_statements = after_connect_statements
    }

}

public struct DBConnectionTestResult: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * JDBC connection string. (only populated in the 'connect' test) (read-only)
     */
    public var connection_string: String?
    /**
     * Result message of test (read-only)
     */
    public var message: String?
    /**
     * Name of test (read-only)
     */
    public var name: String?
    /**
     * Result code of test (read-only)
     */
    public var status: String?

    public init(can: StringDictionary<Bool>? = nil, connection_string: String? = nil, message: String? = nil, name: String? = nil, status: String? = nil) {
        self.can = can
        self.connection_string = connection_string
        self.message = message
        self.name = name
        self.status = status
    }

}

public struct DelegateOauthTest: SDKModel {
    /**
     * Delegate Oauth Connection Name (read-only)
     */
    public var name: String?
    /**
     * The ID of the installation target. For Slack, this would be workspace id. (read-only)
     */
    public var installation_target_id: String?
    /**
     * Installation ID (read-only)
     */
    public var installation_id: Int64?
    /**
     * Whether or not the test was successful (read-only)
     */
    public var success: Bool?

    public init(name: String? = nil, installation_target_id: String? = nil, installation_id: Int64? = nil, success: Bool? = nil) {
        self.name = name
        self.installation_target_id = installation_target_id
        self.installation_id = installation_id
        self.success = success
    }

}

/**
 * Status of the dependencies in your project. Valid values are: "lock_optional", "lock_required", "lock_error", "install_none".
 */
public enum DependencyStatus: String, Codable {
    case lock_optional = "lock_optional"
    case lock_required = "lock_required"
    case lock_error = "lock_error"
    case install_none = "install_none"
}

public struct Dialect: SDKModel {
    /**
     * The name of the dialect (read-only)
     */
    public var name: String?
    /**
     * The human-readable label of the connection (read-only)
     */
    public var label: String?
    /**
     * Whether the dialect supports query cost estimates (read-only)
     */
    public var supports_cost_estimate: Bool?
    /**
     * PDT index columns (read-only)
     */
    public var persistent_table_indexes: String?
    /**
     * PDT sortkey columns (read-only)
     */
    public var persistent_table_sortkeys: String?
    /**
     * PDT distkey column (read-only)
     */
    public var persistent_table_distkey: String?
    /**
     * Suports streaming results (read-only)
     */
    public var supports_streaming: Bool?
    /**
     * Should SQL Runner snippets automatically be run (read-only)
     */
    public var automatically_run_sql_runner_snippets: Bool?
    /**
     * Array of names of the tests that can be run on a connection using this dialect (read-only)
     */
    public var connection_tests: [String]?
    /**
     * Is supported with the inducer (i.e. generate from sql) (read-only)
     */
    public var supports_inducer: Bool?
    /**
     * Can multiple databases be accessed from a connection using this dialect (read-only)
     */
    public var supports_multiple_databases: Bool?
    /**
     * Whether the dialect supports allowing Looker to build persistent derived tables (read-only)
     */
    public var supports_persistent_derived_tables: Bool?
    /**
     * Does the database have client SSL support settable through the JDBC string explicitly? (read-only)
     */
    public var has_ssl_support: Bool?

    public init(name: String? = nil, label: String? = nil, supports_cost_estimate: Bool? = nil, persistent_table_indexes: String? = nil, persistent_table_sortkeys: String? = nil, persistent_table_distkey: String? = nil, supports_streaming: Bool? = nil, automatically_run_sql_runner_snippets: Bool? = nil, connection_tests: [String]? = nil, supports_inducer: Bool? = nil, supports_multiple_databases: Bool? = nil, supports_persistent_derived_tables: Bool? = nil, has_ssl_support: Bool? = nil) {
        self.name = name
        self.label = label
        self.supports_cost_estimate = supports_cost_estimate
        self.persistent_table_indexes = persistent_table_indexes
        self.persistent_table_sortkeys = persistent_table_sortkeys
        self.persistent_table_distkey = persistent_table_distkey
        self.supports_streaming = supports_streaming
        self.automatically_run_sql_runner_snippets = automatically_run_sql_runner_snippets
        self.connection_tests = connection_tests
        self.supports_inducer = supports_inducer
        self.supports_multiple_databases = supports_multiple_databases
        self.supports_persistent_derived_tables = supports_persistent_derived_tables
        self.has_ssl_support = has_ssl_support
    }

}

public struct DialectInfo: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Default number max connections (read-only)
     */
    public var default_max_connections: String?
    /**
     * Default port number (read-only)
     */
    public var default_port: String?
    /**
     * Is the supporting driver installed (read-only)
     */
    public var installed: Bool?
    /**
     * The human-readable label of the connection (read-only)
     */
    public var label: String?
    /**
     * What the dialect calls the equivalent of a normal SQL table (read-only)
     */
    public var label_for_database_equivalent: String?
    /**
     * The name of the dialect (read-only)
     */
    public var name: String?
    public var supported_options: DialectInfoOptions?

    public init(can: StringDictionary<Bool>? = nil, default_max_connections: String? = nil, default_port: String? = nil, installed: Bool? = nil, label: String? = nil, label_for_database_equivalent: String? = nil, name: String? = nil, supported_options: DialectInfoOptions? = nil) {
        self.can = can
        self.default_max_connections = default_max_connections
        self.default_port = default_port
        self.installed = installed
        self.label = label
        self.label_for_database_equivalent = label_for_database_equivalent
        self.name = name
        self.supported_options = supported_options
    }

}

public struct DialectInfoOptions: SDKModel {
    /**
     * Has additional params support (read-only)
     */
    public var additional_params: Bool?
    /**
     * Has auth support (read-only)
     */
    public var auth: Bool?
    /**
     * Has host support (read-only)
     */
    public var host: Bool?
    /**
     * Has support for a service account (read-only)
     */
    public var oauth_credentials: Bool?
    /**
     * Has project name support (read-only)
     */
    public var project_name: Bool?
    /**
     * Has schema support (read-only)
     */
    public var schema: Bool?
    /**
     * Has SSL support (read-only)
     */
    public var ssl: Bool?
    /**
     * Has timezone support (read-only)
     */
    public var timezone: Bool?
    /**
     * Has tmp table support (read-only)
     */
    public var tmp_table: Bool?
    /**
     * Username is required (read-only)
     */
    public var username_required: Bool?

    public init(additional_params: Bool? = nil, auth: Bool? = nil, host: Bool? = nil, oauth_credentials: Bool? = nil, project_name: Bool? = nil, schema: Bool? = nil, ssl: Bool? = nil, timezone: Bool? = nil, tmp_table: Bool? = nil, username_required: Bool? = nil) {
        self.additional_params = additional_params
        self.auth = auth
        self.host = host
        self.oauth_credentials = oauth_credentials
        self.project_name = project_name
        self.schema = schema
        self.ssl = ssl
        self.timezone = timezone
        self.tmp_table = tmp_table
        self.username_required = username_required
    }

}

public struct DigestEmails: SDKModel {
    /**
     * Whether or not digest emails are enabled
     */
    public var is_enabled: Bool?

    public init(is_enabled: Bool? = nil) {
        self.is_enabled = is_enabled
    }

}

public struct DigestEmailSend: SDKModel {
    /**
     * True if content was successfully generated and delivered
     */
    public var configuration_delivered: Bool?

    public init(configuration_delivered: Bool? = nil) {
        self.configuration_delivered = configuration_delivered
    }

}

public struct DiscretePalette: SDKModel {
    /**
     * Unique identity string (read-only)
     */
    public var id: String?
    /**
     * Label for palette
     */
    public var label: String?
    /**
     * Type of palette
     */
    public var type: String?
    /**
     * Array of colors in the palette
     */
    public var colors: [String]?

    public init(id: String? = nil, label: String? = nil, type: String? = nil, colors: [String]? = nil) {
        self.id = id
        self.label = label
        self.type = type
        self.colors = colors
    }

}

public struct EmbedParams: SDKModel {
    /**
     * The complete URL of the Looker UI page to display in the embed context. For example, to display the dashboard with id 34, `target_url` would look like: `https://mycompany.looker.com:9999/dashboards/34`. `target_uri` MUST contain a scheme (HTTPS), domain name, and URL path. Port must be included if it is required to reach the Looker server from browser clients. If the Looker instance is behind a load balancer or other proxy, `target_uri` must be the public-facing domain name and port required to reach the Looker instance, not the actual internal network machine name of the Looker instance.
     */
    public var target_url: URI
    /**
     * Number of seconds the SSO embed session will be valid after the embed session is started. Defaults to 300 seconds. Maximum session length accepted is 2592000 seconds (30 days).
     */
    public var session_length: Int64?
    /**
     * When true, the embed session will purge any residual Looker login state (such as in browser cookies) before creating a new login state with the given embed user info. Defaults to true.
     */
    public var force_logout_login: Bool?

    public init(target_url: URI, session_length: Int64? = nil, force_logout_login: Bool? = nil) {
        self.target_url = target_url
        self.session_length = session_length
        self.force_logout_login = force_logout_login
    }

    public init(_ target_url: URI, session_length: Int64? = nil, force_logout_login: Bool? = nil) {
        self.init(target_url: target_url, session_length: session_length, force_logout_login: force_logout_login)
    }

}

public struct EmbedSsoParams: SDKModel {
    /**
     * The complete URL of the Looker UI page to display in the embed context. For example, to display the dashboard with id 34, `target_url` would look like: `https://mycompany.looker.com:9999/dashboards/34`. `target_uri` MUST contain a scheme (HTTPS), domain name, and URL path. Port must be included if it is required to reach the Looker server from browser clients. If the Looker instance is behind a load balancer or other proxy, `target_uri` must be the public-facing domain name and port required to reach the Looker instance, not the actual internal network machine name of the Looker instance.
     */
    public var target_url: URI
    /**
     * Number of seconds the SSO embed session will be valid after the embed session is started. Defaults to 300 seconds. Maximum session length accepted is 2592000 seconds (30 days).
     */
    public var session_length: Int64?
    /**
     * When true, the embed session will purge any residual Looker login state (such as in browser cookies) before creating a new login state with the given embed user info. Defaults to true.
     */
    public var force_logout_login: Bool?
    /**
     * A value from an external system that uniquely identifies the embed user. Since the user_ids of Looker embed users may change with every embed session, external_user_id provides a way to assign a known, stable user identifier across multiple embed sessions.
     */
    public var external_user_id: String?
    /**
     * First name of the embed user. Defaults to 'Embed' if not specified
     */
    public var first_name: String?
    /**
     * Last name of the embed user. Defaults to 'User' if not specified
     */
    public var last_name: String?
    /**
     * Sets the user timezone for the embed user session, if the User Specific Timezones setting is enabled in the Looker admin settings. A value of `null` forces the embed user to use the Looker Application Default Timezone. You MUST omit this property from the request if the User Specific Timezones setting is disabled. Timezone values are validated against the IANA Timezone standard and can be seen in the Application Time Zone dropdown list on the Looker General Settings admin page.
     */
    public var user_timezone: String?
    /**
     * List of Looker permission names to grant to the embed user. Requested permissions will be filtered to permissions allowed for embed sessions.
     */
    public var permissions: [String]?
    /**
     * List of model names that the embed user may access
     */
    public var models: [String]?
    /**
     * List of Looker group ids in which to enroll the embed user
     */
    public var group_ids: [Int64]?
    /**
     * A unique value identifying an embed-exclusive group. Multiple embed users using the same `external_group_id` value will be able to share Looker content with each other. Content and embed users associated with the `external_group_id` will not be accessible to normal Looker users or embed users not associated with this `external_group_id`.
     */
    public var external_group_id: Int64?
    /**
     * A dictionary of name-value pairs associating a Looker user attribute name with a value.
     */
    public var user_attributes: StringDictionary<AnyCodable>?
    /**
     * Id of the embed secret to use to sign this SSO url. If specified, the value must be an id of a valid (active) secret defined in the Looker instance. If not specified, the URL will be signed with the newest active embed secret defined in the Looker instance.
     */
    public var secret_id: Int64?

    public init(target_url: URI, session_length: Int64? = nil, force_logout_login: Bool? = nil, external_user_id: String? = nil, first_name: String? = nil, last_name: String? = nil, user_timezone: String? = nil, permissions: [String]? = nil, models: [String]? = nil, group_ids: [Int64]? = nil, external_group_id: Int64? = nil, user_attributes: StringDictionary<AnyCodable>? = nil, secret_id: Int64? = nil) {
        self.target_url = target_url
        self.session_length = session_length
        self.force_logout_login = force_logout_login
        self.external_user_id = external_user_id
        self.first_name = first_name
        self.last_name = last_name
        self.user_timezone = user_timezone
        self.permissions = permissions
        self.models = models
        self.group_ids = group_ids
        self.external_group_id = external_group_id
        self.user_attributes = user_attributes
        self.secret_id = secret_id
    }

    public init(_ target_url: URI, session_length: Int64? = nil, force_logout_login: Bool? = nil, external_user_id: String? = nil, first_name: String? = nil, last_name: String? = nil, user_timezone: String? = nil, permissions: [String]? = nil, models: [String]? = nil, group_ids: [Int64]? = nil, external_group_id: Int64? = nil, user_attributes: StringDictionary<AnyCodable>? = nil, secret_id: Int64? = nil) {
        self.init(target_url: target_url, session_length: session_length, force_logout_login: force_logout_login, external_user_id: external_user_id, first_name: first_name, last_name: last_name, user_timezone: user_timezone, permissions: permissions, models: models, group_ids: group_ids, external_group_id: external_group_id, user_attributes: user_attributes, secret_id: secret_id)
    }

}

public struct EmbedUrlResponse: SDKModel {
    /**
     * The embed URL. Any modification to this string will make the URL unusable. (read-only)
     */
    public var url: String?

    public init(url: String? = nil) {
        self.url = url
    }

}

public struct LkError: SDKModel {
    /**
     * Error details (read-only)
     */
    public var message: String
    /**
     * Documentation link (read-only)
     */
    public var documentation_url: URI

    public init(message: String, documentation_url: URI) {
        self.message = message
        self.documentation_url = documentation_url
    }

    public init(_ message: String, _ documentation_url: URI) {
        self.init(message: message, documentation_url: documentation_url)
    }

}

/**
 * The style of dimension fill that is possible for this field. Null if no dimension fill is possible. Valid values are: "enumeration", "range".
 */
public enum FillStyle: String, Codable {
    case enumeration = "enumeration"
    case range = "range"
}

public struct Folder: SDKModel {
    /**
     * Unique Name
     */
    public var name: String
    /**
     * Id of Parent. If the parent id is null, this is a root-level entry
     */
    public var parent_id: String?
    /**
     * Unique Id (read-only)
     */
    public var id: String?
    /**
     * Id of content metadata (read-only)
     */
    public var content_metadata_id: Int64?
    /**
     * Time the space was created (read-only)
     */
    public var created_at: Date?
    /**
     * User Id of Creator (read-only)
     */
    public var creator_id: Int64?
    /**
     * Children Count (read-only)
     */
    public var child_count: Int64?
    /**
     * Embedder's Id if this folder was autogenerated as an embedding shared folder via 'external_group_id' in an SSO embed login (read-only)
     */
    public var external_id: String?
    /**
     * Folder is an embed folder (read-only)
     */
    public var is_embed: Bool?
    /**
     * Folder is the root embed shared folder (read-only)
     */
    public var is_embed_shared_root: Bool?
    /**
     * Folder is the root embed users folder (read-only)
     */
    public var is_embed_users_root: Bool?
    /**
     * Folder is a user's personal folder (read-only)
     */
    public var is_personal: Bool?
    /**
     * Folder is descendant of a user's personal folder (read-only)
     */
    public var is_personal_descendant: Bool?
    /**
     * Folder is the root shared folder (read-only)
     */
    public var is_shared_root: Bool?
    /**
     * Folder is the root user folder (read-only)
     */
    public var is_users_root: Bool?
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Dashboards (read-only)
     */
    public var dashboards: [DashboardBase]?
    /**
     * Looks (read-only)
     */
    public var looks: [LookWithDashboards]?

    public init(name: String, parent_id: String? = nil, id: String? = nil, content_metadata_id: Int64? = nil, created_at: Date? = nil, creator_id: Int64? = nil, child_count: Int64? = nil, external_id: String? = nil, is_embed: Bool? = nil, is_embed_shared_root: Bool? = nil, is_embed_users_root: Bool? = nil, is_personal: Bool? = nil, is_personal_descendant: Bool? = nil, is_shared_root: Bool? = nil, is_users_root: Bool? = nil, can: StringDictionary<Bool>? = nil, dashboards: [DashboardBase]? = nil, looks: [LookWithDashboards]? = nil) {
        self.name = name
        self.parent_id = parent_id
        self.id = id
        self.content_metadata_id = content_metadata_id
        self.created_at = created_at
        self.creator_id = creator_id
        self.child_count = child_count
        self.external_id = external_id
        self.is_embed = is_embed
        self.is_embed_shared_root = is_embed_shared_root
        self.is_embed_users_root = is_embed_users_root
        self.is_personal = is_personal
        self.is_personal_descendant = is_personal_descendant
        self.is_shared_root = is_shared_root
        self.is_users_root = is_users_root
        self.can = can
        self.dashboards = dashboards
        self.looks = looks
    }

    public init(_ name: String, parent_id: String? = nil, id: String? = nil, content_metadata_id: Int64? = nil, created_at: Date? = nil, creator_id: Int64? = nil, child_count: Int64? = nil, external_id: String? = nil, is_embed: Bool? = nil, is_embed_shared_root: Bool? = nil, is_embed_users_root: Bool? = nil, is_personal: Bool? = nil, is_personal_descendant: Bool? = nil, is_shared_root: Bool? = nil, is_users_root: Bool? = nil, can: StringDictionary<Bool>? = nil, dashboards: [DashboardBase]? = nil, looks: [LookWithDashboards]? = nil) {
        self.init(name: name, parent_id: parent_id, id: id, content_metadata_id: content_metadata_id, created_at: created_at, creator_id: creator_id, child_count: child_count, external_id: external_id, is_embed: is_embed, is_embed_shared_root: is_embed_shared_root, is_embed_users_root: is_embed_users_root, is_personal: is_personal, is_personal_descendant: is_personal_descendant, is_shared_root: is_shared_root, is_users_root: is_users_root, can: can, dashboards: dashboards, looks: looks)
    }

}

public struct FolderBase: SDKModel {
    /**
     * Unique Name
     */
    public var name: String
    /**
     * Id of Parent. If the parent id is null, this is a root-level entry
     */
    public var parent_id: String?
    /**
     * Unique Id (read-only)
     */
    public var id: String?
    /**
     * Id of content metadata (read-only)
     */
    public var content_metadata_id: Int64?
    /**
     * Time the folder was created (read-only)
     */
    public var created_at: Date?
    /**
     * User Id of Creator (read-only)
     */
    public var creator_id: Int64?
    /**
     * Children Count (read-only)
     */
    public var child_count: Int64?
    /**
     * Embedder's Id if this folder was autogenerated as an embedding shared folder via 'external_group_id' in an SSO embed login (read-only)
     */
    public var external_id: String?
    /**
     * Folder is an embed folder (read-only)
     */
    public var is_embed: Bool?
    /**
     * Folder is the root embed shared folder (read-only)
     */
    public var is_embed_shared_root: Bool?
    /**
     * Folder is the root embed users folder (read-only)
     */
    public var is_embed_users_root: Bool?
    /**
     * Folder is a user's personal folder (read-only)
     */
    public var is_personal: Bool?
    /**
     * Folder is descendant of a user's personal folder (read-only)
     */
    public var is_personal_descendant: Bool?
    /**
     * Folder is the root shared folder (read-only)
     */
    public var is_shared_root: Bool?
    /**
     * Folder is the root user folder (read-only)
     */
    public var is_users_root: Bool?
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    public init(name: String, parent_id: String? = nil, id: String? = nil, content_metadata_id: Int64? = nil, created_at: Date? = nil, creator_id: Int64? = nil, child_count: Int64? = nil, external_id: String? = nil, is_embed: Bool? = nil, is_embed_shared_root: Bool? = nil, is_embed_users_root: Bool? = nil, is_personal: Bool? = nil, is_personal_descendant: Bool? = nil, is_shared_root: Bool? = nil, is_users_root: Bool? = nil, can: StringDictionary<Bool>? = nil) {
        self.name = name
        self.parent_id = parent_id
        self.id = id
        self.content_metadata_id = content_metadata_id
        self.created_at = created_at
        self.creator_id = creator_id
        self.child_count = child_count
        self.external_id = external_id
        self.is_embed = is_embed
        self.is_embed_shared_root = is_embed_shared_root
        self.is_embed_users_root = is_embed_users_root
        self.is_personal = is_personal
        self.is_personal_descendant = is_personal_descendant
        self.is_shared_root = is_shared_root
        self.is_users_root = is_users_root
        self.can = can
    }

    public init(_ name: String, parent_id: String? = nil, id: String? = nil, content_metadata_id: Int64? = nil, created_at: Date? = nil, creator_id: Int64? = nil, child_count: Int64? = nil, external_id: String? = nil, is_embed: Bool? = nil, is_embed_shared_root: Bool? = nil, is_embed_users_root: Bool? = nil, is_personal: Bool? = nil, is_personal_descendant: Bool? = nil, is_shared_root: Bool? = nil, is_users_root: Bool? = nil, can: StringDictionary<Bool>? = nil) {
        self.init(name: name, parent_id: parent_id, id: id, content_metadata_id: content_metadata_id, created_at: created_at, creator_id: creator_id, child_count: child_count, external_id: external_id, is_embed: is_embed, is_embed_shared_root: is_embed_shared_root, is_embed_users_root: is_embed_users_root, is_personal: is_personal, is_personal_descendant: is_personal_descendant, is_shared_root: is_shared_root, is_users_root: is_users_root, can: can)
    }

}

/**
 * Specifies the data format of the region information. Valid values are: "topojson", "vector_tile_region".
 */
public enum Format: String, Codable {
    case topojson = "topojson"
    case vector_tile_region = "vector_tile_region"
}

/**
 * Scheme that is running on application server (for PRs, file browsing, etc.) Valid values are: "http", "https".
 */
public enum GitApplicationServerHttpScheme: String, Codable {
    case http = "http"
    case https = "https"
}

public struct GitBranch: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * The short name on the local. Updating `name` results in `git checkout <new_name>`
     */
    public var name: String?
    /**
     * The name of the remote (read-only)
     */
    public var remote: String?
    /**
     * The short name on the remote (read-only)
     */
    public var remote_name: String?
    /**
     * Name of error (read-only)
     */
    public var error: String?
    /**
     * Message describing an error if present (read-only)
     */
    public var message: String?
    /**
     * Name of the owner of a personal branch (read-only)
     */
    public var owner_name: String?
    /**
     * Whether or not this branch is readonly (read-only)
     */
    public var readonly: Bool?
    /**
     * Whether or not this branch is a personal branch - readonly for all developers except the owner (read-only)
     */
    public var personal: Bool?
    /**
     * Whether or not a local ref exists for the branch (read-only)
     */
    public var is_local: Bool?
    /**
     * Whether or not a remote ref exists for the branch (read-only)
     */
    public var is_remote: Bool?
    /**
     * Whether or not this is the production branch (read-only)
     */
    public var is_production: Bool?
    /**
     * Number of commits the local branch is ahead of the remote (read-only)
     */
    public var ahead_count: Int64?
    /**
     * Number of commits the local branch is behind the remote (read-only)
     */
    public var behind_count: Int64?
    /**
     * UNIX timestamp at which this branch was last committed. (read-only)
     */
    public var commit_at: Int64?
    /**
     * The resolved ref of this branch. Updating `ref` results in `git reset --hard <new_ref>``.
     */
    public var ref: String?
    /**
     * The resolved ref of this branch remote. (read-only)
     */
    public var remote_ref: String?

    public init(can: StringDictionary<Bool>? = nil, name: String? = nil, remote: String? = nil, remote_name: String? = nil, error: String? = nil, message: String? = nil, owner_name: String? = nil, readonly: Bool? = nil, personal: Bool? = nil, is_local: Bool? = nil, is_remote: Bool? = nil, is_production: Bool? = nil, ahead_count: Int64? = nil, behind_count: Int64? = nil, commit_at: Int64? = nil, ref: String? = nil, remote_ref: String? = nil) {
        self.can = can
        self.name = name
        self.remote = remote
        self.remote_name = remote_name
        self.error = error
        self.message = message
        self.owner_name = owner_name
        self.readonly = readonly
        self.personal = personal
        self.is_local = is_local
        self.is_remote = is_remote
        self.is_production = is_production
        self.ahead_count = ahead_count
        self.behind_count = behind_count
        self.commit_at = commit_at
        self.ref = ref
        self.remote_ref = remote_ref
    }

}

public struct GitConnectionTest: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Human readable string describing the test (read-only)
     */
    public var description: String?
    /**
     * A short string, uniquely naming this test (read-only)
     */
    public var id: String?

    public init(can: StringDictionary<Bool>? = nil, description: String? = nil, id: String? = nil) {
        self.can = can
        self.description = description
        self.id = id
    }

}

public struct GitConnectionTestResult: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * A short string, uniquely naming this test (read-only)
     */
    public var id: String?
    /**
     * Additional data from the test (read-only)
     */
    public var message: String?
    /**
     * Either 'pass' or 'fail' (read-only)
     */
    public var status: String?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, message: String? = nil, status: String? = nil) {
        self.can = can
        self.id = id
        self.message = message
        self.status = status
    }

}

public struct GitStatus: SDKModel {
    /**
     * Git action: add, delete, etc (read-only)
     */
    public var action: String?
    /**
     * When true, changes to the local file conflict with the remote repository (read-only)
     */
    public var conflict: Bool?
    /**
     * When true, the file can be reverted to an earlier state (read-only)
     */
    public var revertable: Bool?
    /**
     * Git description of the action (read-only)
     */
    public var text: String?

    public init(action: String? = nil, conflict: Bool? = nil, revertable: Bool? = nil, text: String? = nil) {
        self.action = action
        self.conflict = conflict
        self.revertable = revertable
        self.text = text
    }

}

public struct LkGroup: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Group can be used in content access controls
     */
    public var can_add_to_content_metadata: Bool?
    /**
     * Currently logged in user is group member (read-only)
     */
    public var contains_current_user: Bool?
    /**
     * External Id group if embed group (read-only)
     */
    public var external_group_id: String?
    /**
     * Group membership controlled outside of Looker (read-only)
     */
    public var externally_managed: Bool?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * New users are added to this group by default (read-only)
     */
    public var include_by_default: Bool?
    /**
     * Name of group
     */
    public var name: String?
    /**
     * Number of users included in this group (read-only)
     */
    public var user_count: Int64?

    public init(can: StringDictionary<Bool>? = nil, can_add_to_content_metadata: Bool? = nil, contains_current_user: Bool? = nil, external_group_id: String? = nil, externally_managed: Bool? = nil, id: Int64? = nil, include_by_default: Bool? = nil, name: String? = nil, user_count: Int64? = nil) {
        self.can = can
        self.can_add_to_content_metadata = can_add_to_content_metadata
        self.contains_current_user = contains_current_user
        self.external_group_id = external_group_id
        self.externally_managed = externally_managed
        self.id = id
        self.include_by_default = include_by_default
        self.name = name
        self.user_count = user_count
    }

}

public struct GroupHierarchy: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Group can be used in content access controls
     */
    public var can_add_to_content_metadata: Bool?
    /**
     * Currently logged in user is group member (read-only)
     */
    public var contains_current_user: Bool?
    /**
     * External Id group if embed group (read-only)
     */
    public var external_group_id: String?
    /**
     * Group membership controlled outside of Looker (read-only)
     */
    public var externally_managed: Bool?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * New users are added to this group by default (read-only)
     */
    public var include_by_default: Bool?
    /**
     * Name of group
     */
    public var name: String?
    /**
     * Number of users included in this group (read-only)
     */
    public var user_count: Int64?
    /**
     * IDs of parents of this group (read-only)
     */
    public var parent_group_ids: [Int64]?
    /**
     * Role IDs assigned to group (read-only)
     */
    public var role_ids: [Int64]?

    public init(can: StringDictionary<Bool>? = nil, can_add_to_content_metadata: Bool? = nil, contains_current_user: Bool? = nil, external_group_id: String? = nil, externally_managed: Bool? = nil, id: Int64? = nil, include_by_default: Bool? = nil, name: String? = nil, user_count: Int64? = nil, parent_group_ids: [Int64]? = nil, role_ids: [Int64]? = nil) {
        self.can = can
        self.can_add_to_content_metadata = can_add_to_content_metadata
        self.contains_current_user = contains_current_user
        self.external_group_id = external_group_id
        self.externally_managed = externally_managed
        self.id = id
        self.include_by_default = include_by_default
        self.name = name
        self.user_count = user_count
        self.parent_group_ids = parent_group_ids
        self.role_ids = role_ids
    }

}

public struct GroupIdForGroupInclusion: SDKModel {
    /**
     * Id of group (read-only)
     */
    public var group_id: Int64?

    public init(group_id: Int64? = nil) {
        self.group_id = group_id
    }

}

public struct GroupIdForGroupUserInclusion: SDKModel {
    /**
     * Id of user (read-only)
     */
    public var user_id: Int64?

    public init(user_id: Int64? = nil) {
        self.user_id = user_id
    }

}

public struct GroupSearch: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Group can be used in content access controls
     */
    public var can_add_to_content_metadata: Bool?
    /**
     * Currently logged in user is group member (read-only)
     */
    public var contains_current_user: Bool?
    /**
     * External Id group if embed group (read-only)
     */
    public var external_group_id: String?
    /**
     * Group membership controlled outside of Looker (read-only)
     */
    public var externally_managed: Bool?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * New users are added to this group by default (read-only)
     */
    public var include_by_default: Bool?
    /**
     * Name of group
     */
    public var name: String?
    /**
     * Number of users included in this group (read-only)
     */
    public var user_count: Int64?
    /**
     * Roles assigned to group (read-only)
     */
    public var roles: [Role]?

    public init(can: StringDictionary<Bool>? = nil, can_add_to_content_metadata: Bool? = nil, contains_current_user: Bool? = nil, external_group_id: String? = nil, externally_managed: Bool? = nil, id: Int64? = nil, include_by_default: Bool? = nil, name: String? = nil, user_count: Int64? = nil, roles: [Role]? = nil) {
        self.can = can
        self.can_add_to_content_metadata = can_add_to_content_metadata
        self.contains_current_user = contains_current_user
        self.external_group_id = external_group_id
        self.externally_managed = externally_managed
        self.id = id
        self.include_by_default = include_by_default
        self.name = name
        self.user_count = user_count
        self.roles = roles
    }

}

public struct HomepageItem: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Name of user who created the content this item is based on (read-only)
     */
    public var content_created_by: String?
    /**
     * Content favorite id associated with the item this content is based on (read-only)
     */
    public var content_favorite_id: Int64?
    /**
     * Content metadata id associated with the item this content is based on (read-only)
     */
    public var content_metadata_id: Int64?
    /**
     * Last time the content that this item is based on was updated (read-only)
     */
    public var content_updated_at: String?
    /**
     * Custom description entered by the user, if present
     */
    public var custom_description: String?
    /**
     * (Write-Only) base64 encoded image data
     */
    public var custom_image_data_base64: String?
    /**
     * Custom image_url entered by the user, if present (read-only)
     */
    public var custom_image_url: String?
    /**
     * Custom title entered by the user, if present
     */
    public var custom_title: String?
    /**
     * Custom url entered by the user, if present
     */
    public var custom_url: String?
    /**
     * Dashboard to base this item on
     */
    public var dashboard_id: Int64?
    /**
     * The actual description for display (read-only)
     */
    public var description: String?
    /**
     * Number of times content has been favorited, if present (read-only)
     */
    public var favorite_count: Int64?
    /**
     * Associated Homepage Section
     */
    public var homepage_section_id: Int64?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * The actual image_url for display (read-only)
     */
    public var image_url: String?
    /**
     * The container folder name of the content (read-only)
     */
    public var location: String?
    /**
     * Look to base this item on
     */
    public var look_id: Int64?
    /**
     * LookML Dashboard to base this item on
     */
    public var lookml_dashboard_id: String?
    /**
     * An arbitrary integer representing the sort order within the section
     */
    public var order: Int64?
    /**
     * Number of seconds it took to fetch the section this item is in (read-only)
     */
    public var section_fetch_time: Float?
    /**
     * The actual title for display (read-only)
     */
    public var title: String?
    /**
     * The actual url for display (read-only)
     */
    public var url: String?
    /**
     * Whether the custom description should be used instead of the content description, if the item is associated with content
     */
    public var use_custom_description: Bool?
    /**
     * Whether the custom image should be used instead of the content image, if the item is associated with content
     */
    public var use_custom_image: Bool?
    /**
     * Whether the custom title should be used instead of the content title, if the item is associated with content
     */
    public var use_custom_title: Bool?
    /**
     * Whether the custom url should be used instead of the content url, if the item is associated with content
     */
    public var use_custom_url: Bool?
    /**
     * Number of times content has been viewed, if present (read-only)
     */
    public var view_count: Int64?

    public init(can: StringDictionary<Bool>? = nil, content_created_by: String? = nil, content_favorite_id: Int64? = nil, content_metadata_id: Int64? = nil, content_updated_at: String? = nil, custom_description: String? = nil, custom_image_data_base64: String? = nil, custom_image_url: String? = nil, custom_title: String? = nil, custom_url: String? = nil, dashboard_id: Int64? = nil, description: String? = nil, favorite_count: Int64? = nil, homepage_section_id: Int64? = nil, id: Int64? = nil, image_url: String? = nil, location: String? = nil, look_id: Int64? = nil, lookml_dashboard_id: String? = nil, order: Int64? = nil, section_fetch_time: Float? = nil, title: String? = nil, url: String? = nil, use_custom_description: Bool? = nil, use_custom_image: Bool? = nil, use_custom_title: Bool? = nil, use_custom_url: Bool? = nil, view_count: Int64? = nil) {
        self.can = can
        self.content_created_by = content_created_by
        self.content_favorite_id = content_favorite_id
        self.content_metadata_id = content_metadata_id
        self.content_updated_at = content_updated_at
        self.custom_description = custom_description
        self.custom_image_data_base64 = custom_image_data_base64
        self.custom_image_url = custom_image_url
        self.custom_title = custom_title
        self.custom_url = custom_url
        self.dashboard_id = dashboard_id
        self.description = description
        self.favorite_count = favorite_count
        self.homepage_section_id = homepage_section_id
        self.id = id
        self.image_url = image_url
        self.location = location
        self.look_id = look_id
        self.lookml_dashboard_id = lookml_dashboard_id
        self.order = order
        self.section_fetch_time = section_fetch_time
        self.title = title
        self.url = url
        self.use_custom_description = use_custom_description
        self.use_custom_image = use_custom_image
        self.use_custom_title = use_custom_title
        self.use_custom_url = use_custom_url
        self.view_count = view_count
    }

}

public struct HomepageSection: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Time at which this section was created. (read-only)
     */
    public var created_at: Date?
    /**
     * Time at which this section was deleted.
     */
    public var deleted_at: Date?
    /**
     * A URL pointing to a page showing further information about the content in the section. (read-only)
     */
    public var detail_url: String?
    /**
     * Id reference to parent homepage
     */
    public var homepage_id: Int64?
    /**
     * Items in the homepage section (read-only)
     */
    public var homepage_items: [HomepageItem]?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Is this a header section (has no items) (read-only)
     */
    public var is_header: Bool?
    /**
     * ids of the homepage items in the order they should be displayed
     */
    public var item_order: [Int64]?
    /**
     * Name of row
     */
    public var title: String?
    /**
     * Time at which this section was last updated. (read-only)
     */
    public var updated_at: Date?
    /**
     * Description of the content found in this section.
     */
    public var description: String?

    public init(can: StringDictionary<Bool>? = nil, created_at: Date? = nil, deleted_at: Date? = nil, detail_url: String? = nil, homepage_id: Int64? = nil, homepage_items: [HomepageItem]? = nil, id: Int64? = nil, is_header: Bool? = nil, item_order: [Int64]? = nil, title: String? = nil, updated_at: Date? = nil, description: String? = nil) {
        self.can = can
        self.created_at = created_at
        self.deleted_at = deleted_at
        self.detail_url = detail_url
        self.homepage_id = homepage_id
        self.homepage_items = homepage_items
        self.id = id
        self.is_header = is_header
        self.item_order = item_order
        self.title = title
        self.updated_at = updated_at
        self.description = description
    }

}

public struct ImportedProject: SDKModel {
    /**
     * Dependency name (read-only)
     */
    public var name: String?
    /**
     * Url for a remote dependency (read-only)
     */
    public var url: String?
    /**
     * Ref for a remote dependency (read-only)
     */
    public var ref: String?
    /**
     * Flag signifying if a dependency is remote or local (read-only)
     */
    public var is_remote: Bool?

    public init(name: String? = nil, url: String? = nil, ref: String? = nil, is_remote: Bool? = nil) {
        self.name = name
        self.url = url
        self.ref = ref
        self.is_remote = is_remote
    }

}

public struct Integration: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * ID of the integration. (read-only)
     */
    public var id: String?
    /**
     * ID of the integration hub. (read-only)
     */
    public var integration_hub_id: Int64?
    /**
     * Label for the integration. (read-only)
     */
    public var label: String?
    /**
     * Description of the integration. (read-only)
     */
    public var description: String?
    /**
     * Whether the integration is available to users.
     */
    public var enabled: Bool?
    /**
     * Array of params for the integration.
     */
    public var params: [IntegrationParam]?
    /**
     * A list of data formats the integration supports. If unspecified, the default is all data formats. Valid values are: "txt", "csv", "inline_json", "json", "json_label", "json_detail", "json_detail_lite_stream", "xlsx", "html", "wysiwyg_pdf", "assembled_pdf", "wysiwyg_png", "csv_zip". (read-only)
     */
    public var supported_formats: [SupportedFormats]?
    /**
     * A list of action types the integration supports. Valid values are: "cell", "query", "dashboard". (read-only)
     */
    public var supported_action_types: [SupportedActionTypes]?
    /**
     * A list of formatting options the integration supports. If unspecified, defaults to all formats. Valid values are: "formatted", "unformatted". (read-only)
     */
    public var supported_formattings: [SupportedFormattings]?
    /**
     * A list of visualization formatting options the integration supports. If unspecified, defaults to all formats. Valid values are: "apply", "noapply". (read-only)
     */
    public var supported_visualization_formattings: [SupportedVisualizationFormattings]?
    /**
     * A list of all the download mechanisms the integration supports. The order of values is not significant: Looker will select the most appropriate supported download mechanism for a given query. The integration must ensure it can handle any of the mechanisms it claims to support. If unspecified, this defaults to all download setting values. Valid values are: "push", "url". (read-only)
     */
    public var supported_download_settings: [SupportedDownloadSettings]?
    /**
     * URL to an icon for the integration. (read-only)
     */
    public var icon_url: String?
    /**
     * Whether the integration uses oauth. (read-only)
     */
    public var uses_oauth: Bool?
    /**
     * A list of descriptions of required fields that this integration is compatible with. If there are multiple entries in this list, the integration requires more than one field. If unspecified, no fields will be required. (read-only)
     */
    public var required_fields: [IntegrationRequiredField]?
    /**
     * Whether the integration uses delegate oauth, which allows federation between an integration installation scope specific entity (like org, group, and team, etc.) and Looker. (read-only)
     */
    public var delegate_oauth: Bool?
    /**
     * Whether the integration is available to users.
     */
    public var installed_delegate_oauth_targets: [Int64]?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, integration_hub_id: Int64? = nil, label: String? = nil, description: String? = nil, enabled: Bool? = nil, params: [IntegrationParam]? = nil, supported_formats: [SupportedFormats]? = nil, supported_action_types: [SupportedActionTypes]? = nil, supported_formattings: [SupportedFormattings]? = nil, supported_visualization_formattings: [SupportedVisualizationFormattings]? = nil, supported_download_settings: [SupportedDownloadSettings]? = nil, icon_url: String? = nil, uses_oauth: Bool? = nil, required_fields: [IntegrationRequiredField]? = nil, delegate_oauth: Bool? = nil, installed_delegate_oauth_targets: [Int64]? = nil) {
        self.can = can
        self.id = id
        self.integration_hub_id = integration_hub_id
        self.label = label
        self.description = description
        self.enabled = enabled
        self.params = params
        self.supported_formats = supported_formats
        self.supported_action_types = supported_action_types
        self.supported_formattings = supported_formattings
        self.supported_visualization_formattings = supported_visualization_formattings
        self.supported_download_settings = supported_download_settings
        self.icon_url = icon_url
        self.uses_oauth = uses_oauth
        self.required_fields = required_fields
        self.delegate_oauth = delegate_oauth
        self.installed_delegate_oauth_targets = installed_delegate_oauth_targets
    }

}

public struct IntegrationHub: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * ID of the hub. (read-only)
     */
    public var id: Int64?
    /**
     * URL of the hub.
     */
    public var url: String?
    /**
     * Label of the hub. (read-only)
     */
    public var label: String?
    /**
     * Whether this hub is a first-party integration hub operated by Looker. (read-only)
     */
    public var official: Bool?
    /**
     * An error message, present if the integration hub metadata could not be fetched. If this is present, the integration hub is unusable. (read-only)
     */
    public var fetch_error_message: String?
    /**
     * (Write-Only) An authorization key that will be sent to the integration hub on every request.
     */
    public var authorization_token: String?
    /**
     * Whether the authorization_token is set for the hub. (read-only)
     */
    public var has_authorization_token: Bool?
    /**
     * Whether the legal agreement message has been signed by the user. This only matters if legal_agreement_required is true. (read-only)
     */
    public var legal_agreement_signed: Bool?
    /**
     * Whether the legal terms for the integration hub are required before use. (read-only)
     */
    public var legal_agreement_required: Bool?
    /**
     * The legal agreement text for this integration hub. (read-only)
     */
    public var legal_agreement_text: String?

    public init(can: StringDictionary<Bool>? = nil, id: Int64? = nil, url: String? = nil, label: String? = nil, official: Bool? = nil, fetch_error_message: String? = nil, authorization_token: String? = nil, has_authorization_token: Bool? = nil, legal_agreement_signed: Bool? = nil, legal_agreement_required: Bool? = nil, legal_agreement_text: String? = nil) {
        self.can = can
        self.id = id
        self.url = url
        self.label = label
        self.official = official
        self.fetch_error_message = fetch_error_message
        self.authorization_token = authorization_token
        self.has_authorization_token = has_authorization_token
        self.legal_agreement_signed = legal_agreement_signed
        self.legal_agreement_required = legal_agreement_required
        self.legal_agreement_text = legal_agreement_text
    }

}

public struct IntegrationParam: SDKModel {
    /**
     * Name of the parameter.
     */
    public var name: String?
    /**
     * Label of the parameter. (read-only)
     */
    public var label: String?
    /**
     * Short description of the parameter. (read-only)
     */
    public var description: String?
    /**
     * Whether the parameter is required to be set to use the destination. If unspecified, this defaults to false. (read-only)
     */
    public var required: Bool?
    /**
     * Whether the parameter has a value set. (read-only)
     */
    public var has_value: Bool?
    /**
     * The current value of the parameter. Always null if the value is sensitive. When writing, null values will be ignored. Set the value to an empty string to clear it.
     */
    public var value: String?
    /**
     * When present, the param's value comes from this user attribute instead of the 'value' parameter. Set to null to use the 'value'.
     */
    public var user_attribute_name: String?
    /**
     * Whether the parameter contains sensitive data like API credentials. If unspecified, this defaults to true. (read-only)
     */
    public var sensitive: Bool?
    /**
     * When true, this parameter must be assigned to a user attribute in the admin panel (instead of a constant value), and that value may be updated by the user as part of the integration flow. (read-only)
     */
    public var per_user: Bool?
    /**
     * When present, the param represents the oauth url the user will be taken to. (read-only)
     */
    public var delegate_oauth_url: String?

    public init(name: String? = nil, label: String? = nil, description: String? = nil, required: Bool? = nil, has_value: Bool? = nil, value: String? = nil, user_attribute_name: String? = nil, sensitive: Bool? = nil, per_user: Bool? = nil, delegate_oauth_url: String? = nil) {
        self.name = name
        self.label = label
        self.description = description
        self.required = required
        self.has_value = has_value
        self.value = value
        self.user_attribute_name = user_attribute_name
        self.sensitive = sensitive
        self.per_user = per_user
        self.delegate_oauth_url = delegate_oauth_url
    }

}

public struct IntegrationRequiredField: SDKModel {
    /**
     * Matches a field that has this tag. (read-only)
     */
    public var tag: String?
    /**
     * If present, supercedes 'tag' and matches a field that has any of the provided tags. (read-only)
     */
    public var any_tag: [String]?
    /**
     * If present, supercedes 'tag' and matches a field that has all of the provided tags. (read-only)
     */
    public var all_tags: [String]?

    public init(tag: String? = nil, any_tag: [String]? = nil, all_tags: [String]? = nil) {
        self.tag = tag
        self.any_tag = any_tag
        self.all_tags = all_tags
    }

}

public struct IntegrationTestResult: SDKModel {
    /**
     * Whether or not the test was successful (read-only)
     */
    public var success: Bool?
    /**
     * A message representing the results of the test. (read-only)
     */
    public var message: String?
    /**
     * An array of connection test result for delegate oauth actions. (read-only)
     */
    public var delegate_oauth_result: [DelegateOauthTest]?

    public init(success: Bool? = nil, message: String? = nil, delegate_oauth_result: [DelegateOauthTest]? = nil) {
        self.success = success
        self.message = message
        self.delegate_oauth_result = delegate_oauth_result
    }

}

public struct InternalHelpResources: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * If true and internal help resources content is not blank then the link for internal help resources will be shown in the help menu and the content displayed within Looker
     */
    public var enabled: Bool?

    public init(can: StringDictionary<Bool>? = nil, enabled: Bool? = nil) {
        self.can = can
        self.enabled = enabled
    }

}

public struct InternalHelpResourcesContent: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Text to display in the help menu item which will display the internal help resources
     */
    public var organization_name: String?
    /**
     * Content to be displayed in the internal help resources page/modal
     */
    public var markdown_content: String?

    public init(can: StringDictionary<Bool>? = nil, organization_name: String? = nil, markdown_content: String? = nil) {
        self.can = can
        self.organization_name = organization_name
        self.markdown_content = markdown_content
    }

}

public struct LDAPConfig: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
     */
    public var alternate_email_login_allowed: Bool?
    /**
     * (Write-Only)  Password for the LDAP account used to access the LDAP server
     */
    public var auth_password: String?
    /**
     * Users will not be allowed to login at all unless a role for them is found in LDAP if set to true
     */
    public var auth_requires_role: Bool?
    /**
     * Distinguished name of LDAP account used to access the LDAP server
     */
    public var auth_username: String?
    /**
     * LDAP server hostname
     */
    public var connection_host: String?
    /**
     * LDAP host port
     */
    public var connection_port: String?
    /**
     * Use Transport Layer Security
     */
    public var connection_tls: Bool?
    /**
     * Do not verify peer when using TLS
     */
    public var connection_tls_no_verify: Bool?
    /**
     * (Write-Only)  Array of ids of groups that will be applied to new users the first time they login via LDAP
     */
    public var default_new_user_group_ids: [Int64]?
    /**
     * (Read-only) Groups that will be applied to new users the first time they login via LDAP (read-only)
     */
    public var default_new_user_groups: [LkGroup]?
    /**
     * (Write-Only)  Array of ids of roles that will be applied to new users the first time they login via LDAP
     */
    public var default_new_user_role_ids: [Int64]?
    /**
     * (Read-only) Roles that will be applied to new users the first time they login via LDAP (read-only)
     */
    public var default_new_user_roles: [Role]?
    /**
     * Enable/Disable LDAP authentication for the server
     */
    public var enabled: Bool?
    /**
     * Don't attempt to do LDAP search result paging (RFC 2696) even if the LDAP server claims to support it.
     */
    public var force_no_page: Bool?
    /**
     * (Read-only) Array of mappings between LDAP Groups and Looker Roles (read-only)
     */
    public var groups: [LDAPGroupRead]?
    /**
     * Base dn for finding groups in LDAP searches
     */
    public var groups_base_dn: String?
    /**
     * Identifier for a strategy for how Looker will search for groups in the LDAP server
     */
    public var groups_finder_type: String?
    /**
     * LDAP Group attribute that signifies the members of the groups. Most commonly 'member'
     */
    public var groups_member_attribute: String?
    /**
     * Optional comma-separated list of supported LDAP objectclass for groups when doing groups searches
     */
    public var groups_objectclasses: String?
    /**
     * LDAP Group attribute that signifies the user in a group. Most commonly 'dn'
     */
    public var groups_user_attribute: String?
    /**
     * (Read/Write) Array of mappings between LDAP Groups and arrays of Looker Role ids
     */
    public var groups_with_role_ids: [LDAPGroupWrite]?
    /**
     * (Read-only) Has the password been set for the LDAP account used to access the LDAP server (read-only)
     */
    public var has_auth_password: Bool?
    /**
     * Merge first-time ldap login to existing user account by email addresses. When a user logs in for the first time via ldap this option will connect this user into their existing account by finding the account with a matching email address. Otherwise a new user account will be created for the user.
     */
    public var merge_new_users_by_email: Bool?
    /**
     * When this config was last modified (read-only)
     */
    public var modified_at: String?
    /**
     * User id of user who last modified this config (read-only)
     */
    public var modified_by: String?
    /**
     * Set user roles in Looker based on groups from LDAP
     */
    public var set_roles_from_groups: Bool?
    /**
     * (Write-Only)  Test LDAP user password. For ldap tests only.
     */
    public var test_ldap_password: String?
    /**
     * (Write-Only)  Test LDAP user login id. For ldap tests only.
     */
    public var test_ldap_user: String?
    /**
     * Name of user record attributes used to indicate email address field
     */
    public var user_attribute_map_email: String?
    /**
     * Name of user record attributes used to indicate first name
     */
    public var user_attribute_map_first_name: String?
    /**
     * Name of user record attributes used to indicate last name
     */
    public var user_attribute_map_last_name: String?
    /**
     * Name of user record attributes used to indicate unique record id
     */
    public var user_attribute_map_ldap_id: String?
    /**
     * (Read-only) Array of mappings between LDAP User Attributes and Looker User Attributes (read-only)
     */
    public var user_attributes: [LDAPUserAttributeRead]?
    /**
     * (Read/Write) Array of mappings between LDAP User Attributes and arrays of Looker User Attribute ids
     */
    public var user_attributes_with_ids: [LDAPUserAttributeWrite]?
    /**
     * Distinguished name of LDAP node used as the base for user searches
     */
    public var user_bind_base_dn: String?
    /**
     * (Optional) Custom RFC-2254 filter clause for use in finding user during login. Combined via 'and' with the other generated filter clauses.
     */
    public var user_custom_filter: String?
    /**
     * Name(s) of user record attributes used for matching user login id (comma separated list)
     */
    public var user_id_attribute_names: String?
    /**
     * (Optional) Name of user record objectclass used for finding user during login id
     */
    public var user_objectclass: String?
    /**
     * Allow LDAP auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.
     */
    public var allow_normal_group_membership: Bool?
    /**
     * LDAP auth'd users will be able to inherit roles from non-reflected Looker groups.
     */
    public var allow_roles_from_normal_groups: Bool?
    /**
     * Allows roles to be directly assigned to LDAP auth'd users.
     */
    public var allow_direct_roles: Bool?
    /**
     * Link to get this item (read-only)
     */
    public var url: URI?

    public init(can: StringDictionary<Bool>? = nil, alternate_email_login_allowed: Bool? = nil, auth_password: String? = nil, auth_requires_role: Bool? = nil, auth_username: String? = nil, connection_host: String? = nil, connection_port: String? = nil, connection_tls: Bool? = nil, connection_tls_no_verify: Bool? = nil, default_new_user_group_ids: [Int64]? = nil, default_new_user_groups: [LkGroup]? = nil, default_new_user_role_ids: [Int64]? = nil, default_new_user_roles: [Role]? = nil, enabled: Bool? = nil, force_no_page: Bool? = nil, groups: [LDAPGroupRead]? = nil, groups_base_dn: String? = nil, groups_finder_type: String? = nil, groups_member_attribute: String? = nil, groups_objectclasses: String? = nil, groups_user_attribute: String? = nil, groups_with_role_ids: [LDAPGroupWrite]? = nil, has_auth_password: Bool? = nil, merge_new_users_by_email: Bool? = nil, modified_at: String? = nil, modified_by: String? = nil, set_roles_from_groups: Bool? = nil, test_ldap_password: String? = nil, test_ldap_user: String? = nil, user_attribute_map_email: String? = nil, user_attribute_map_first_name: String? = nil, user_attribute_map_last_name: String? = nil, user_attribute_map_ldap_id: String? = nil, user_attributes: [LDAPUserAttributeRead]? = nil, user_attributes_with_ids: [LDAPUserAttributeWrite]? = nil, user_bind_base_dn: String? = nil, user_custom_filter: String? = nil, user_id_attribute_names: String? = nil, user_objectclass: String? = nil, allow_normal_group_membership: Bool? = nil, allow_roles_from_normal_groups: Bool? = nil, allow_direct_roles: Bool? = nil, url: URI? = nil) {
        self.can = can
        self.alternate_email_login_allowed = alternate_email_login_allowed
        self.auth_password = auth_password
        self.auth_requires_role = auth_requires_role
        self.auth_username = auth_username
        self.connection_host = connection_host
        self.connection_port = connection_port
        self.connection_tls = connection_tls
        self.connection_tls_no_verify = connection_tls_no_verify
        self.default_new_user_group_ids = default_new_user_group_ids
        self.default_new_user_groups = default_new_user_groups
        self.default_new_user_role_ids = default_new_user_role_ids
        self.default_new_user_roles = default_new_user_roles
        self.enabled = enabled
        self.force_no_page = force_no_page
        self.groups = groups
        self.groups_base_dn = groups_base_dn
        self.groups_finder_type = groups_finder_type
        self.groups_member_attribute = groups_member_attribute
        self.groups_objectclasses = groups_objectclasses
        self.groups_user_attribute = groups_user_attribute
        self.groups_with_role_ids = groups_with_role_ids
        self.has_auth_password = has_auth_password
        self.merge_new_users_by_email = merge_new_users_by_email
        self.modified_at = modified_at
        self.modified_by = modified_by
        self.set_roles_from_groups = set_roles_from_groups
        self.test_ldap_password = test_ldap_password
        self.test_ldap_user = test_ldap_user
        self.user_attribute_map_email = user_attribute_map_email
        self.user_attribute_map_first_name = user_attribute_map_first_name
        self.user_attribute_map_last_name = user_attribute_map_last_name
        self.user_attribute_map_ldap_id = user_attribute_map_ldap_id
        self.user_attributes = user_attributes
        self.user_attributes_with_ids = user_attributes_with_ids
        self.user_bind_base_dn = user_bind_base_dn
        self.user_custom_filter = user_custom_filter
        self.user_id_attribute_names = user_id_attribute_names
        self.user_objectclass = user_objectclass
        self.allow_normal_group_membership = allow_normal_group_membership
        self.allow_roles_from_normal_groups = allow_roles_from_normal_groups
        self.allow_direct_roles = allow_direct_roles
        self.url = url
    }

}

public struct LDAPConfigTestIssue: SDKModel {
    /**
     * Severity of the issue. Error or Warning (read-only)
     */
    public var severity: String?
    /**
     * Message describing the issue (read-only)
     */
    public var message: String?

    public init(severity: String? = nil, message: String? = nil) {
        self.severity = severity
        self.message = message
    }

}

public struct LDAPConfigTestResult: SDKModel {
    /**
     * Additional details for error cases (read-only)
     */
    public var details: String?
    /**
     * Array of issues/considerations about the result (read-only)
     */
    public var issues: [LDAPConfigTestIssue]?
    /**
     * Short human readable test about the result (read-only)
     */
    public var message: String?
    /**
     * Test status code: always 'success' or 'error' (read-only)
     */
    public var status: String?
    /**
     * A more detailed trace of incremental results during auth tests (read-only)
     */
    public var trace: String?
    public var user: LDAPUser?
    /**
     * Link to ldap config (read-only)
     */
    public var url: URI?

    public init(details: String? = nil, issues: [LDAPConfigTestIssue]? = nil, message: String? = nil, status: String? = nil, trace: String? = nil, user: LDAPUser? = nil, url: URI? = nil) {
        self.details = details
        self.issues = issues
        self.message = message
        self.status = status
        self.trace = trace
        self.user = user
        self.url = url
    }

}

public struct LDAPGroupRead: SDKModel {
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Unique Id of group in Looker (read-only)
     */
    public var looker_group_id: Int64?
    /**
     * Name of group in Looker (read-only)
     */
    public var looker_group_name: String?
    /**
     * Name of group in LDAP (read-only)
     */
    public var name: String?
    /**
     * Looker Roles (read-only)
     */
    public var roles: [Role]?
    /**
     * Link to ldap config (read-only)
     */
    public var url: URI?

    public init(id: Int64? = nil, looker_group_id: Int64? = nil, looker_group_name: String? = nil, name: String? = nil, roles: [Role]? = nil, url: URI? = nil) {
        self.id = id
        self.looker_group_id = looker_group_id
        self.looker_group_name = looker_group_name
        self.name = name
        self.roles = roles
        self.url = url
    }

}

public struct LDAPGroupWrite: SDKModel {
    /**
     * Unique Id
     */
    public var id: Int64?
    /**
     * Unique Id of group in Looker (read-only)
     */
    public var looker_group_id: Int64?
    /**
     * Name of group in Looker
     */
    public var looker_group_name: String?
    /**
     * Name of group in LDAP
     */
    public var name: String?
    /**
     * Looker Role Ids
     */
    public var role_ids: [Int64]?
    /**
     * Link to ldap config (read-only)
     */
    public var url: URI?

    public init(id: Int64? = nil, looker_group_id: Int64? = nil, looker_group_name: String? = nil, name: String? = nil, role_ids: [Int64]? = nil, url: URI? = nil) {
        self.id = id
        self.looker_group_id = looker_group_id
        self.looker_group_name = looker_group_name
        self.name = name
        self.role_ids = role_ids
        self.url = url
    }

}

public struct LDAPUser: SDKModel {
    /**
     * Array of user's email addresses and aliases for use in migration (read-only)
     */
    public var all_emails: [String]?
    /**
     * Dictionary of user's attributes (name/value) (read-only)
     */
    public var attributes: StringDictionary<AnyCodable>?
    /**
     * Primary email address (read-only)
     */
    public var email: String?
    /**
     * First name (read-only)
     */
    public var first_name: String?
    /**
     * Array of user's groups (group names only) (read-only)
     */
    public var groups: [String]?
    /**
     * Last Name (read-only)
     */
    public var last_name: String?
    /**
     * LDAP's distinguished name for the user record (read-only)
     */
    public var ldap_dn: String?
    /**
     * LDAP's Unique ID for the user (read-only)
     */
    public var ldap_id: String?
    /**
     * Array of user's roles (role names only) (read-only)
     */
    public var roles: [String]?
    /**
     * Link to ldap config (read-only)
     */
    public var url: URI?

    public init(all_emails: [String]? = nil, attributes: StringDictionary<AnyCodable>? = nil, email: String? = nil, first_name: String? = nil, groups: [String]? = nil, last_name: String? = nil, ldap_dn: String? = nil, ldap_id: String? = nil, roles: [String]? = nil, url: URI? = nil) {
        self.all_emails = all_emails
        self.attributes = attributes
        self.email = email
        self.first_name = first_name
        self.groups = groups
        self.last_name = last_name
        self.ldap_dn = ldap_dn
        self.ldap_id = ldap_id
        self.roles = roles
        self.url = url
    }

}

public struct LDAPUserAttributeRead: SDKModel {
    /**
     * Name of User Attribute in LDAP (read-only)
     */
    public var name: String?
    /**
     * Required to be in LDAP assertion for login to be allowed to succeed (read-only)
     */
    public var required: Bool?
    /**
     * Looker User Attributes (read-only)
     */
    public var user_attributes: [UserAttribute]?
    /**
     * Link to ldap config (read-only)
     */
    public var url: URI?

    public init(name: String? = nil, required: Bool? = nil, user_attributes: [UserAttribute]? = nil, url: URI? = nil) {
        self.name = name
        self.required = required
        self.user_attributes = user_attributes
        self.url = url
    }

}

public struct LDAPUserAttributeWrite: SDKModel {
    /**
     * Name of User Attribute in LDAP
     */
    public var name: String?
    /**
     * Required to be in LDAP assertion for login to be allowed to succeed
     */
    public var required: Bool?
    /**
     * Looker User Attribute Ids
     */
    public var user_attribute_ids: [Int64]?
    /**
     * Link to ldap config (read-only)
     */
    public var url: URI?

    public init(name: String? = nil, required: Bool? = nil, user_attribute_ids: [Int64]? = nil, url: URI? = nil) {
        self.name = name
        self.required = required
        self.user_attribute_ids = user_attribute_ids
        self.url = url
    }

}

public struct LegacyFeature: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Unique Id (read-only)
     */
    public var id: String?
    /**
     * Name (read-only)
     */
    public var name: String?
    /**
     * Description (read-only)
     */
    public var description: String?
    /**
     * Whether this feature has been enabled by a user
     */
    public var enabled_locally: Bool?
    /**
     * Whether this feature is currently enabled (read-only)
     */
    public var enabled: Bool?
    /**
     * Looker version where this feature became a legacy feature (read-only)
     */
    public var disallowed_as_of_version: String?
    /**
     * Looker version where this feature will be automatically disabled (read-only)
     */
    public var disable_on_upgrade_to_version: String?
    /**
     * Future Looker version where this feature will be removed (read-only)
     */
    public var end_of_life_version: String?
    /**
     * URL for documentation about this feature (read-only)
     */
    public var documentation_url: String?
    /**
     * Approximate date that this feature will be automatically disabled. (read-only)
     */
    public var approximate_disable_date: Date?
    /**
     * Approximate date that this feature will be removed. (read-only)
     */
    public var approximate_end_of_life_date: Date?
    /**
     * Whether this legacy feature may have been automatically disabled when upgrading to the current version. (read-only)
     */
    public var has_disabled_on_upgrade: Bool?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, name: String? = nil, description: String? = nil, enabled_locally: Bool? = nil, enabled: Bool? = nil, disallowed_as_of_version: String? = nil, disable_on_upgrade_to_version: String? = nil, end_of_life_version: String? = nil, documentation_url: String? = nil, approximate_disable_date: Date? = nil, approximate_end_of_life_date: Date? = nil, has_disabled_on_upgrade: Bool? = nil) {
        self.can = can
        self.id = id
        self.name = name
        self.description = description
        self.enabled_locally = enabled_locally
        self.enabled = enabled
        self.disallowed_as_of_version = disallowed_as_of_version
        self.disable_on_upgrade_to_version = disable_on_upgrade_to_version
        self.end_of_life_version = end_of_life_version
        self.documentation_url = documentation_url
        self.approximate_disable_date = approximate_disable_date
        self.approximate_end_of_life_date = approximate_end_of_life_date
        self.has_disabled_on_upgrade = has_disabled_on_upgrade
    }

}

/**
 * Name of the command Valid values are: "dashboard", "lookml_dashboard".
 */
public enum LinkedContentType: String, Codable {
    case dashboard = "dashboard"
    case lookml_dashboard = "lookml_dashboard"
}

public struct LkLocale: SDKModel {
    /**
     * Code for Locale (read-only)
     */
    public var code: String?
    /**
     * Name of Locale in its own language (read-only)
     */
    public var native_name: String?
    /**
     * Name of Locale in English (read-only)
     */
    public var english_name: String?

    public init(code: String? = nil, native_name: String? = nil, english_name: String? = nil) {
        self.code = code
        self.native_name = native_name
        self.english_name = english_name
    }

}

public struct LocalizationSettings: SDKModel {
    /**
     * Default locale for localization (read-only)
     */
    public var default_locale: String?
    /**
     * Localization level - strict or permissive (read-only)
     */
    public var localization_level: String?

    public init(default_locale: String? = nil, localization_level: String? = nil) {
        self.default_locale = default_locale
        self.localization_level = localization_level
    }

}

public struct Look: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Id of content metadata (read-only)
     */
    public var content_metadata_id: Int64?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Look Title
     */
    public var title: String?
    /**
     * User Id
     */
    public var user_id: Int64?
    /**
     * Content Favorite Id (read-only)
     */
    public var content_favorite_id: Int64?
    /**
     * Time that the Look was created. (read-only)
     */
    public var created_at: Date?
    /**
     * Whether or not a look is 'soft' deleted.
     */
    public var deleted: Bool?
    /**
     * Time that the Look was deleted. (read-only)
     */
    public var deleted_at: Date?
    /**
     * Id of User that deleted the look. (read-only)
     */
    public var deleter_id: Int64?
    /**
     * Description
     */
    public var description: String?
    /**
     * Embed Url (read-only)
     */
    public var embed_url: String?
    /**
     * Excel File Url (read-only)
     */
    public var excel_file_url: String?
    /**
     * Number of times favorited (read-only)
     */
    public var favorite_count: Int64?
    /**
     * Google Spreadsheet Formula (read-only)
     */
    public var google_spreadsheet_formula: String?
    /**
     * Image Embed Url (read-only)
     */
    public var image_embed_url: String?
    /**
     * auto-run query when Look viewed
     */
    public var is_run_on_load: Bool?
    /**
     * Time that the Look was last accessed by any user (read-only)
     */
    public var last_accessed_at: Date?
    /**
     * Id of User that last updated the look. (read-only)
     */
    public var last_updater_id: Int64?
    /**
     * Time last viewed in the Looker web UI (read-only)
     */
    public var last_viewed_at: Date?
    public var model: LookModel?
    /**
     * Is Public
     */
    public var `public`: Bool?
    /**
     * Public Slug (read-only)
     */
    public var public_slug: String?
    /**
     * Public Url (read-only)
     */
    public var public_url: String?
    /**
     * Query Id
     */
    public var query_id: Int64?
    /**
     * Short Url (read-only)
     */
    public var short_url: String?
    public var folder: FolderBase?
    /**
     * Folder Id
     */
    public var folder_id: String?
    /**
     * Time that the Look was updated. (read-only)
     */
    public var updated_at: Date?
    /**
     * Number of times viewed in the Looker web UI (read-only)
     */
    public var view_count: Int64?

    public init(can: StringDictionary<Bool>? = nil, content_metadata_id: Int64? = nil, id: Int64? = nil, title: String? = nil, user_id: Int64? = nil, content_favorite_id: Int64? = nil, created_at: Date? = nil, deleted: Bool? = nil, deleted_at: Date? = nil, deleter_id: Int64? = nil, description: String? = nil, embed_url: String? = nil, excel_file_url: String? = nil, favorite_count: Int64? = nil, google_spreadsheet_formula: String? = nil, image_embed_url: String? = nil, is_run_on_load: Bool? = nil, last_accessed_at: Date? = nil, last_updater_id: Int64? = nil, last_viewed_at: Date? = nil, model: LookModel? = nil, `public`: Bool? = nil, public_slug: String? = nil, public_url: String? = nil, query_id: Int64? = nil, short_url: String? = nil, folder: FolderBase? = nil, folder_id: String? = nil, updated_at: Date? = nil, view_count: Int64? = nil) {
        self.can = can
        self.content_metadata_id = content_metadata_id
        self.id = id
        self.title = title
        self.user_id = user_id
        self.content_favorite_id = content_favorite_id
        self.created_at = created_at
        self.deleted = deleted
        self.deleted_at = deleted_at
        self.deleter_id = deleter_id
        self.description = description
        self.embed_url = embed_url
        self.excel_file_url = excel_file_url
        self.favorite_count = favorite_count
        self.google_spreadsheet_formula = google_spreadsheet_formula
        self.image_embed_url = image_embed_url
        self.is_run_on_load = is_run_on_load
        self.last_accessed_at = last_accessed_at
        self.last_updater_id = last_updater_id
        self.last_viewed_at = last_viewed_at
        self.model = model
        self.`public` = `public`
        self.public_slug = public_slug
        self.public_url = public_url
        self.query_id = query_id
        self.short_url = short_url
        self.folder = folder
        self.folder_id = folder_id
        self.updated_at = updated_at
        self.view_count = view_count
    }

}

public struct LookBasic: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Id of content metadata (read-only)
     */
    public var content_metadata_id: Int64?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Look Title (read-only)
     */
    public var title: String?
    /**
     * User Id
     */
    public var user_id: Int64?

    public init(can: StringDictionary<Bool>? = nil, content_metadata_id: Int64? = nil, id: Int64? = nil, title: String? = nil, user_id: Int64? = nil) {
        self.can = can
        self.content_metadata_id = content_metadata_id
        self.id = id
        self.title = title
        self.user_id = user_id
    }

}

public struct LookmlModel: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Array of names of connections this model is allowed to use
     */
    public var allowed_db_connection_names: [String]?
    /**
     * Array of explores (if has_content) (read-only)
     */
    public var explores: [LookmlModelNavExplore]?
    /**
     * Does this model declaration have have lookml content? (read-only)
     */
    public var has_content: Bool?
    /**
     * UI-friendly name for this model (read-only)
     */
    public var label: String?
    /**
     * Name of the model. Also used as the unique identifier
     */
    public var name: String?
    /**
     * Name of project containing the model
     */
    public var project_name: String?
    /**
     * Is this model allowed to use all current and future connections
     */
    public var unlimited_db_connections: Bool?

    public init(can: StringDictionary<Bool>? = nil, allowed_db_connection_names: [String]? = nil, explores: [LookmlModelNavExplore]? = nil, has_content: Bool? = nil, label: String? = nil, name: String? = nil, project_name: String? = nil, unlimited_db_connections: Bool? = nil) {
        self.can = can
        self.allowed_db_connection_names = allowed_db_connection_names
        self.explores = explores
        self.has_content = has_content
        self.label = label
        self.name = name
        self.project_name = project_name
        self.unlimited_db_connections = unlimited_db_connections
    }

}

public struct LookmlModelExplore: SDKModel {
    /**
     * Fully qualified explore name (model name plus explore name) (read-only)
     */
    public var id: String?
    /**
     * Explore name (read-only)
     */
    public var name: String?
    /**
     * Description (read-only)
     */
    public var description: String?
    /**
     * Label (read-only)
     */
    public var label: String?
    /**
     * Explore title (read-only)
     */
    public var title: String?
    /**
     * Scopes (read-only)
     */
    public var scopes: [String]?
    /**
     * Can Total (read-only)
     */
    public var can_total: Bool?
    /**
     * Can Develop LookML (read-only)
     */
    public var can_develop: Bool?
    /**
     * Can See LookML (read-only)
     */
    public var can_see_lookml: Bool?
    /**
     * A URL linking to the definition of this explore in the LookML IDE. (read-only)
     */
    public var lookml_link: String?
    /**
     * Can Save (read-only)
     */
    public var can_save: Bool?
    /**
     * Can Explain (read-only)
     */
    public var can_explain: Bool?
    /**
     * Can pivot in the DB (read-only)
     */
    public var can_pivot_in_db: Bool?
    /**
     * Can use subtotals (read-only)
     */
    public var can_subtotal: Bool?
    /**
     * Has timezone support (read-only)
     */
    public var has_timezone_support: Bool?
    /**
     * Cost estimates supported (read-only)
     */
    public var supports_cost_estimate: Bool?
    /**
     * Connection name (read-only)
     */
    public var connection_name: String?
    /**
     * How nulls are sorted, possible values are "low", "high", "first" and "last" (read-only)
     */
    public var null_sort_treatment: String?
    /**
     * List of model source files (read-only)
     */
    public var files: [String]?
    /**
     * Primary source_file file (read-only)
     */
    public var source_file: String?
    /**
     * Name of project (read-only)
     */
    public var project_name: String?
    /**
     * Name of model (read-only)
     */
    public var model_name: String?
    /**
     * Name of view (read-only)
     */
    public var view_name: String?
    /**
     * Is hidden (read-only)
     */
    public var hidden: Bool?
    /**
     * A sql_table_name expression that defines what sql table the view/explore maps onto. Example: "prod_orders2 AS orders" in a view named orders. (read-only)
     */
    public var sql_table_name: String?
    /**
     * (DEPRECATED) Array of access filter field names (read-only)
     */
    public var access_filter_fields: [String]?
    /**
     * Access filters (read-only)
     */
    public var access_filters: [LookmlModelExploreAccessFilter]?
    /**
     * Aliases (read-only)
     */
    public var aliases: [LookmlModelExploreAlias]?
    /**
     * Always filter (read-only)
     */
    public var always_filter: [LookmlModelExploreAlwaysFilter]?
    /**
     * Conditionally filter (read-only)
     */
    public var conditionally_filter: [LookmlModelExploreConditionallyFilter]?
    /**
     * Array of index fields (read-only)
     */
    public var index_fields: [String]?
    /**
     * Sets (read-only)
     */
    public var sets: [LookmlModelExploreSet]?
    /**
     * An array of arbitrary string tags provided in the model for this explore. (read-only)
     */
    public var tags: [String]?
    /**
     * Errors (read-only)
     */
    public var errors: [LookmlModelExploreError]?
    public var fields: LookmlModelExploreFieldset?
    /**
     * Views joined into this explore (read-only)
     */
    public var joins: [LookmlModelExploreJoins]?
    /**
     * Label used to group explores in the navigation menus (read-only)
     */
    public var group_label: String?
    /**
     * An array of items describing which custom measure types are supported for creating a custom measure 'based_on' each possible dimension type. (read-only)
     */
    public var supported_measure_types: [LookmlModelExploreSupportedMeasureType]?

    public init(id: String? = nil, name: String? = nil, description: String? = nil, label: String? = nil, title: String? = nil, scopes: [String]? = nil, can_total: Bool? = nil, can_develop: Bool? = nil, can_see_lookml: Bool? = nil, lookml_link: String? = nil, can_save: Bool? = nil, can_explain: Bool? = nil, can_pivot_in_db: Bool? = nil, can_subtotal: Bool? = nil, has_timezone_support: Bool? = nil, supports_cost_estimate: Bool? = nil, connection_name: String? = nil, null_sort_treatment: String? = nil, files: [String]? = nil, source_file: String? = nil, project_name: String? = nil, model_name: String? = nil, view_name: String? = nil, hidden: Bool? = nil, sql_table_name: String? = nil, access_filter_fields: [String]? = nil, access_filters: [LookmlModelExploreAccessFilter]? = nil, aliases: [LookmlModelExploreAlias]? = nil, always_filter: [LookmlModelExploreAlwaysFilter]? = nil, conditionally_filter: [LookmlModelExploreConditionallyFilter]? = nil, index_fields: [String]? = nil, sets: [LookmlModelExploreSet]? = nil, tags: [String]? = nil, errors: [LookmlModelExploreError]? = nil, fields: LookmlModelExploreFieldset? = nil, joins: [LookmlModelExploreJoins]? = nil, group_label: String? = nil, supported_measure_types: [LookmlModelExploreSupportedMeasureType]? = nil) {
        self.id = id
        self.name = name
        self.description = description
        self.label = label
        self.title = title
        self.scopes = scopes
        self.can_total = can_total
        self.can_develop = can_develop
        self.can_see_lookml = can_see_lookml
        self.lookml_link = lookml_link
        self.can_save = can_save
        self.can_explain = can_explain
        self.can_pivot_in_db = can_pivot_in_db
        self.can_subtotal = can_subtotal
        self.has_timezone_support = has_timezone_support
        self.supports_cost_estimate = supports_cost_estimate
        self.connection_name = connection_name
        self.null_sort_treatment = null_sort_treatment
        self.files = files
        self.source_file = source_file
        self.project_name = project_name
        self.model_name = model_name
        self.view_name = view_name
        self.hidden = hidden
        self.sql_table_name = sql_table_name
        self.access_filter_fields = access_filter_fields
        self.access_filters = access_filters
        self.aliases = aliases
        self.always_filter = always_filter
        self.conditionally_filter = conditionally_filter
        self.index_fields = index_fields
        self.sets = sets
        self.tags = tags
        self.errors = errors
        self.fields = fields
        self.joins = joins
        self.group_label = group_label
        self.supported_measure_types = supported_measure_types
    }

}

public struct LookmlModelExploreAccessFilter: SDKModel {
    /**
     * Field to be filtered (read-only)
     */
    public var field: String?
    /**
     * User attribute name (read-only)
     */
    public var user_attribute: String?

    public init(field: String? = nil, user_attribute: String? = nil) {
        self.field = field
        self.user_attribute = user_attribute
    }

}

public struct LookmlModelExploreAlias: SDKModel {
    /**
     * Name (read-only)
     */
    public var name: String?
    /**
     * Value (read-only)
     */
    public var value: String?

    public init(name: String? = nil, value: String? = nil) {
        self.name = name
        self.value = value
    }

}

public struct LookmlModelExploreAlwaysFilter: SDKModel {
    /**
     * Name (read-only)
     */
    public var name: String?
    /**
     * Value (read-only)
     */
    public var value: String?

    public init(name: String? = nil, value: String? = nil) {
        self.name = name
        self.value = value
    }

}

public struct LookmlModelExploreConditionallyFilter: SDKModel {
    /**
     * Name (read-only)
     */
    public var name: String?
    /**
     * Value (read-only)
     */
    public var value: String?

    public init(name: String? = nil, value: String? = nil) {
        self.name = name
        self.value = value
    }

}

public struct LookmlModelExploreError: SDKModel {
    /**
     * Error Message (read-only)
     */
    public var message: String?
    /**
     * Details (read-only)
     */
    public var details: AnyCodable?
    /**
     * Error source location (read-only)
     */
    public var error_pos: String?
    /**
     * Is this a field error (read-only)
     */
    public var field_error: Bool?

    public init(message: String? = nil, details: AnyCodable? = nil, error_pos: String? = nil, field_error: Bool? = nil) {
        self.message = message
        self.details = details
        self.error_pos = error_pos
        self.field_error = field_error
    }

}

public struct LookmlModelExploreField: SDKModel {
    /**
     * The appropriate horizontal text alignment the values of this field should be displayed in. Valid values are: "left", "right". (read-only)
     */
    public var align: Align?
    /**
     * Whether it's possible to filter on this field. (read-only)
     */
    public var can_filter: Bool?
    /**
     * Field category Valid values are: "parameter", "filter", "measure", "dimension". (read-only)
     */
    public var category: Category?
    /**
     * The default value that this field uses when filtering. Null if there is no default value. (read-only)
     */
    public var default_filter_value: String?
    /**
     * Description (read-only)
     */
    public var description: String?
    /**
     * An array enumerating all the possible values that this field can contain. When null, there is no limit to the set of possible values this field can contain. (read-only)
     */
    public var enumerations: [LookmlModelExploreFieldEnumeration]?
    /**
     * An error message indicating a problem with the definition of this field. If there are no errors, this will be null. (read-only)
     */
    public var error: String?
    /**
     * A label creating a grouping of fields. All fields with this label should be presented together when displayed in a UI. (read-only)
     */
    public var field_group_label: String?
    /**
     * When presented in a field group via field_group_label, a shorter name of the field to be displayed in that context. (read-only)
     */
    public var field_group_variant: String?
    /**
     * The style of dimension fill that is possible for this field. Null if no dimension fill is possible. Valid values are: "enumeration", "range". (read-only)
     */
    public var fill_style: FillStyle?
    /**
     * An offset (in months) from the calendar start month to the fiscal start month defined in the LookML model this field belongs to. (read-only)
     */
    public var fiscal_month_offset: Int64?
    /**
     * Whether this field has a set of allowed_values specified in LookML. (read-only)
     */
    public var has_allowed_values: Bool?
    /**
     * Whether this field should be hidden from the user interface. (read-only)
     */
    public var hidden: Bool?
    /**
     * Whether this field is a filter. (read-only)
     */
    public var is_filter: Bool?
    /**
     * Whether this field represents a fiscal time value. (read-only)
     */
    public var is_fiscal: Bool?
    /**
     * Whether this field is of a type that represents a numeric value. (read-only)
     */
    public var is_numeric: Bool?
    /**
     * Whether this field is of a type that represents a time value. (read-only)
     */
    public var is_timeframe: Bool?
    /**
     * Whether this field can be time filtered. (read-only)
     */
    public var can_time_filter: Bool?
    public var time_interval: LookmlModelExploreFieldTimeInterval?
    /**
     * Fully-qualified human-readable label of the field. (read-only)
     */
    public var label: String?
    /**
     * The name of the parameter that will provide a parameterized label for this field, if available in the current context. (read-only)
     */
    public var label_from_parameter: String?
    /**
     * The human-readable label of the field, without the view label. (read-only)
     */
    public var label_short: String?
    /**
     * A URL linking to the definition of this field in the LookML IDE. (read-only)
     */
    public var lookml_link: String?
    public var map_layer: LookmlModelExploreFieldMapLayer?
    /**
     * Whether this field is a measure. (read-only)
     */
    public var measure: Bool?
    /**
     * Fully-qualified name of the field. (read-only)
     */
    public var name: String?
    /**
     * If yes, the field will not be localized with the user attribute number_format. Defaults to no (read-only)
     */
    public var strict_value_format: Bool?
    /**
     * Whether this field is a parameter. (read-only)
     */
    public var parameter: Bool?
    /**
     * Whether this field can be removed from a query. (read-only)
     */
    public var permanent: Bool?
    /**
     * Whether or not the field represents a primary key. (read-only)
     */
    public var primary_key: Bool?
    /**
     * The name of the project this field is defined in. (read-only)
     */
    public var project_name: String?
    /**
     * When true, it's not possible to re-sort this field's values without re-running the SQL query, due to database logic that affects the sort. (read-only)
     */
    public var requires_refresh_on_sort: Bool?
    /**
     * The LookML scope this field belongs to. The scope is typically the field's view. (read-only)
     */
    public var scope: String?
    /**
     * Whether this field can be sorted. (read-only)
     */
    public var sortable: Bool?
    /**
     * The path portion of source_file_path. (read-only)
     */
    public var source_file: String?
    /**
     * The fully-qualified path of the project file this field is defined in. (read-only)
     */
    public var source_file_path: String?
    /**
     * SQL expression as defined in the LookML model. The SQL syntax shown here is a representation intended for auditability, and is not neccessarily an exact match for what will ultimately be run in the database. It may contain special LookML syntax or annotations that are not valid SQL. This will be null if the current user does not have the see_lookml permission for the field's model. (read-only)
     */
    public var sql: String?
    /**
     * An array of conditions and values that make up a SQL Case expression, as defined in the LookML model. The SQL syntax shown here is a representation intended for auditability, and is not neccessarily an exact match for what will ultimately be run in the database. It may contain special LookML syntax or annotations that are not valid SQL. This will be null if the current user does not have the see_lookml permission for the field's model. (read-only)
     */
    public var sql_case: [LookmlModelExploreFieldSqlCase]?
    /**
     * Array of filter conditions defined for the measure in LookML. (read-only)
     */
    public var filters: [LookmlModelExploreFieldMeasureFilters]?
    /**
     * The name of the dimension to base suggest queries from. (read-only)
     */
    public var suggest_dimension: String?
    /**
     * The name of the explore to base suggest queries from. (read-only)
     */
    public var suggest_explore: String?
    /**
     * Whether or not suggestions are possible for this field. (read-only)
     */
    public var suggestable: Bool?
    /**
     * If available, a list of suggestions for this field. For most fields, a suggest query is a more appropriate way to get an up-to-date list of suggestions. Or use enumerations to list all the possible values. (read-only)
     */
    public var suggestions: [String]?
    /**
     * An array of arbitrary string tags provided in the model for this field. (read-only)
     */
    public var tags: [String]?
    /**
     * The LookML type of the field. (read-only)
     */
    public var type: String?
    /**
     * An array of user attribute types that are allowed to be used in filters on this field. Valid values are: "advanced_filter_string", "advanced_filter_number", "advanced_filter_datetime", "string", "number", "datetime", "relative_url", "yesno", "zipcode". (read-only)
     */
    public var user_attribute_filter_types: [UserAttributeFilterTypes]?
    /**
     * If specified, the LookML value format string for formatting values of this field. (read-only)
     */
    public var value_format: String?
    /**
     * The name of the view this field belongs to. (read-only)
     */
    public var view: String?
    /**
     * The human-readable label of the view the field belongs to. (read-only)
     */
    public var view_label: String?
    /**
     * Whether this field was specified in "dynamic_fields" and is not part of the model. (read-only)
     */
    public var `dynamic`: Bool?
    /**
     * The name of the starting day of the week. Valid values are: "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday". (read-only)
     */
    public var week_start_day: WeekStartDay?
    /**
     * The number of times this field has been used in queries (read-only)
     */
    public var times_used: Int64?

    public init(align: Align? = nil, can_filter: Bool? = nil, category: Category? = nil, default_filter_value: String? = nil, description: String? = nil, enumerations: [LookmlModelExploreFieldEnumeration]? = nil, error: String? = nil, field_group_label: String? = nil, field_group_variant: String? = nil, fill_style: FillStyle? = nil, fiscal_month_offset: Int64? = nil, has_allowed_values: Bool? = nil, hidden: Bool? = nil, is_filter: Bool? = nil, is_fiscal: Bool? = nil, is_numeric: Bool? = nil, is_timeframe: Bool? = nil, can_time_filter: Bool? = nil, time_interval: LookmlModelExploreFieldTimeInterval? = nil, label: String? = nil, label_from_parameter: String? = nil, label_short: String? = nil, lookml_link: String? = nil, map_layer: LookmlModelExploreFieldMapLayer? = nil, measure: Bool? = nil, name: String? = nil, strict_value_format: Bool? = nil, parameter: Bool? = nil, permanent: Bool? = nil, primary_key: Bool? = nil, project_name: String? = nil, requires_refresh_on_sort: Bool? = nil, scope: String? = nil, sortable: Bool? = nil, source_file: String? = nil, source_file_path: String? = nil, sql: String? = nil, sql_case: [LookmlModelExploreFieldSqlCase]? = nil, filters: [LookmlModelExploreFieldMeasureFilters]? = nil, suggest_dimension: String? = nil, suggest_explore: String? = nil, suggestable: Bool? = nil, suggestions: [String]? = nil, tags: [String]? = nil, type: String? = nil, user_attribute_filter_types: [UserAttributeFilterTypes]? = nil, value_format: String? = nil, view: String? = nil, view_label: String? = nil, `dynamic`: Bool? = nil, week_start_day: WeekStartDay? = nil, times_used: Int64? = nil) {
        self.align = align
        self.can_filter = can_filter
        self.category = category
        self.default_filter_value = default_filter_value
        self.description = description
        self.enumerations = enumerations
        self.error = error
        self.field_group_label = field_group_label
        self.field_group_variant = field_group_variant
        self.fill_style = fill_style
        self.fiscal_month_offset = fiscal_month_offset
        self.has_allowed_values = has_allowed_values
        self.hidden = hidden
        self.is_filter = is_filter
        self.is_fiscal = is_fiscal
        self.is_numeric = is_numeric
        self.is_timeframe = is_timeframe
        self.can_time_filter = can_time_filter
        self.time_interval = time_interval
        self.label = label
        self.label_from_parameter = label_from_parameter
        self.label_short = label_short
        self.lookml_link = lookml_link
        self.map_layer = map_layer
        self.measure = measure
        self.name = name
        self.strict_value_format = strict_value_format
        self.parameter = parameter
        self.permanent = permanent
        self.primary_key = primary_key
        self.project_name = project_name
        self.requires_refresh_on_sort = requires_refresh_on_sort
        self.scope = scope
        self.sortable = sortable
        self.source_file = source_file
        self.source_file_path = source_file_path
        self.sql = sql
        self.sql_case = sql_case
        self.filters = filters
        self.suggest_dimension = suggest_dimension
        self.suggest_explore = suggest_explore
        self.suggestable = suggestable
        self.suggestions = suggestions
        self.tags = tags
        self.type = type
        self.user_attribute_filter_types = user_attribute_filter_types
        self.value_format = value_format
        self.view = view
        self.view_label = view_label
        self.`dynamic` = `dynamic`
        self.week_start_day = week_start_day
        self.times_used = times_used
    }

}

public struct LookmlModelExploreFieldEnumeration: SDKModel {
    /**
     * Label (read-only)
     */
    public var label: String?
    /**
     * Value (read-only)
     */
    public var value: AnyCodable?

    public init(label: String? = nil, value: AnyCodable? = nil) {
        self.label = label
        self.value = value
    }

}

public struct LookmlModelExploreFieldMapLayer: SDKModel {
    /**
     * URL to the map layer resource. (read-only)
     */
    public var url: String?
    /**
     * Name of the map layer, as defined in LookML. (read-only)
     */
    public var name: String?
    /**
     * Specifies the name of the TopoJSON object that the map layer references. If not specified, use the first object.. (read-only)
     */
    public var feature_key: String?
    /**
     * Selects which property from the TopoJSON data to plot against. TopoJSON supports arbitrary metadata for each region. When null, the first matching property should be used. (read-only)
     */
    public var property_key: String?
    /**
     * Which property from the TopoJSON data to use to label the region. When null, property_key should be used. (read-only)
     */
    public var property_label_key: String?
    /**
     * The preferred geographic projection of the map layer when displayed in a visualization that supports multiple geographic projections. (read-only)
     */
    public var projection: String?
    /**
     * Specifies the data format of the region information. Valid values are: "topojson", "vector_tile_region". (read-only)
     */
    public var format: Format?
    /**
     * Specifies the URL to a JSON file that defines the geographic extents of each region available in the map layer. This data is used to automatically center the map on the available data for visualization purposes. The JSON file must be a JSON object where the keys are the mapping value of the feature (as specified by property_key) and the values are arrays of four numbers representing the west longitude, south latitude, east longitude, and north latitude extents of the region. The object must include a key for every possible value of property_key. (read-only)
     */
    public var extents_json_url: String?
    /**
     * The minimum zoom level that the map layer may be displayed at, for visualizations that support zooming. (read-only)
     */
    public var max_zoom_level: Int64?
    /**
     * The maximum zoom level that the map layer may be displayed at, for visualizations that support zooming. (read-only)
     */
    public var min_zoom_level: Int64?

    public init(url: String? = nil, name: String? = nil, feature_key: String? = nil, property_key: String? = nil, property_label_key: String? = nil, projection: String? = nil, format: Format? = nil, extents_json_url: String? = nil, max_zoom_level: Int64? = nil, min_zoom_level: Int64? = nil) {
        self.url = url
        self.name = name
        self.feature_key = feature_key
        self.property_key = property_key
        self.property_label_key = property_label_key
        self.projection = projection
        self.format = format
        self.extents_json_url = extents_json_url
        self.max_zoom_level = max_zoom_level
        self.min_zoom_level = min_zoom_level
    }

}

public struct LookmlModelExploreFieldMeasureFilters: SDKModel {
    /**
     * Filter field name (read-only)
     */
    public var field: String?
    /**
     * Filter condition value (read-only)
     */
    public var condition: String?

    public init(field: String? = nil, condition: String? = nil) {
        self.field = field
        self.condition = condition
    }

}

public struct LookmlModelExploreFieldset: SDKModel {
    /**
     * Array of dimensions (read-only)
     */
    public var dimensions: [LookmlModelExploreField]?
    /**
     * Array of measures (read-only)
     */
    public var measures: [LookmlModelExploreField]?
    /**
     * Array of filters (read-only)
     */
    public var filters: [LookmlModelExploreField]?
    /**
     * Array of parameters (read-only)
     */
    public var parameters: [LookmlModelExploreField]?

    public init(dimensions: [LookmlModelExploreField]? = nil, measures: [LookmlModelExploreField]? = nil, filters: [LookmlModelExploreField]? = nil, parameters: [LookmlModelExploreField]? = nil) {
        self.dimensions = dimensions
        self.measures = measures
        self.filters = filters
        self.parameters = parameters
    }

}

public struct LookmlModelExploreFieldSqlCase: SDKModel {
    /**
     * SQL Case label value (read-only)
     */
    public var value: String?
    /**
     * SQL Case condition expression (read-only)
     */
    public var condition: String?

    public init(value: String? = nil, condition: String? = nil) {
        self.value = value
        self.condition = condition
    }

}

public struct LookmlModelExploreFieldTimeInterval: SDKModel {
    /**
     * The type of time interval this field represents a grouping of. Valid values are: "day", "hour", "minute", "second", "millisecond", "microsecond", "week", "month", "quarter", "year". (read-only)
     */
    public var name: Name?
    /**
     * The number of intervals this field represents a grouping of. (read-only)
     */
    public var count: Int64?

    public init(name: Name? = nil, count: Int64? = nil) {
        self.name = name
        self.count = count
    }

}

public struct LookmlModelExploreJoins: SDKModel {
    /**
     * Name of this join (and name of the view to join) (read-only)
     */
    public var name: String?
    /**
     * Fields referenced by the join (read-only)
     */
    public var dependent_fields: [String]?
    /**
     * Fields of the joined view to pull into this explore (read-only)
     */
    public var fields: [String]?
    /**
     * Name of the dimension in this explore whose value is in the primary key of the joined view (read-only)
     */
    public var foreign_key: String?
    /**
     * Name of view to join (read-only)
     */
    public var from: String?
    /**
     * Specifies whether all queries must use an outer join (read-only)
     */
    public var outer_only: Bool?
    /**
     * many_to_one, one_to_one, one_to_many, many_to_many (read-only)
     */
    public var relationship: String?
    /**
     * Names of joins that must always be included in SQL queries (read-only)
     */
    public var required_joins: [String]?
    /**
     * SQL expression that produces a foreign key (read-only)
     */
    public var sql_foreign_key: String?
    /**
     * SQL ON expression describing the join condition (read-only)
     */
    public var sql_on: String?
    /**
     * SQL table name to join (read-only)
     */
    public var sql_table_name: String?
    /**
     * The join type: left_outer, full_outer, inner, or cross (read-only)
     */
    public var type: String?
    /**
     * Label to display in UI selectors (read-only)
     */
    public var view_label: String?

    public init(name: String? = nil, dependent_fields: [String]? = nil, fields: [String]? = nil, foreign_key: String? = nil, from: String? = nil, outer_only: Bool? = nil, relationship: String? = nil, required_joins: [String]? = nil, sql_foreign_key: String? = nil, sql_on: String? = nil, sql_table_name: String? = nil, type: String? = nil, view_label: String? = nil) {
        self.name = name
        self.dependent_fields = dependent_fields
        self.fields = fields
        self.foreign_key = foreign_key
        self.from = from
        self.outer_only = outer_only
        self.relationship = relationship
        self.required_joins = required_joins
        self.sql_foreign_key = sql_foreign_key
        self.sql_on = sql_on
        self.sql_table_name = sql_table_name
        self.type = type
        self.view_label = view_label
    }

}

public struct LookmlModelExploreSet: SDKModel {
    /**
     * Name (read-only)
     */
    public var name: String?
    /**
     * Value set (read-only)
     */
    public var value: [String]?

    public init(name: String? = nil, value: [String]? = nil) {
        self.name = name
        self.value = value
    }

}

public struct LookmlModelExploreSupportedMeasureType: SDKModel {
    /**
     * (read-only)
     */
    public var dimension_type: String?
    /**
     * (read-only)
     */
    public var measure_types: [String]?

    public init(dimension_type: String? = nil, measure_types: [String]? = nil) {
        self.dimension_type = dimension_type
        self.measure_types = measure_types
    }

}

public struct LookmlModelNavExplore: SDKModel {
    /**
     * Name of the explore (read-only)
     */
    public var name: String?
    /**
     * Description for the explore (read-only)
     */
    public var description: String?
    /**
     * Label for the explore (read-only)
     */
    public var label: String?
    /**
     * Is this explore marked as hidden (read-only)
     */
    public var hidden: Bool?
    /**
     * Label used to group explores in the navigation menus (read-only)
     */
    public var group_label: String?

    public init(name: String? = nil, description: String? = nil, label: String? = nil, hidden: Bool? = nil, group_label: String? = nil) {
        self.name = name
        self.description = description
        self.label = label
        self.hidden = hidden
        self.group_label = group_label
    }

}

public struct LookmlTest: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Name of model containing this test. (read-only)
     */
    public var model_name: String?
    /**
     * Name of this test. (read-only)
     */
    public var name: String?
    /**
     * Name of the explore this test runs a query against (read-only)
     */
    public var explore_name: String?
    /**
     * The url parameters that can be used to reproduce this test's query on an explore. (read-only)
     */
    public var query_url_params: String?
    /**
     * Name of the LookML file containing this test. (read-only)
     */
    public var file: String?
    /**
     * Line number of this test in LookML. (read-only)
     */
    public var line: Int64?

    public init(can: StringDictionary<Bool>? = nil, model_name: String? = nil, name: String? = nil, explore_name: String? = nil, query_url_params: String? = nil, file: String? = nil, line: Int64? = nil) {
        self.can = can
        self.model_name = model_name
        self.name = name
        self.explore_name = explore_name
        self.query_url_params = query_url_params
        self.file = file
        self.line = line
    }

}

public struct LookmlTestResult: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Name of model containing this test. (read-only)
     */
    public var model_name: String?
    /**
     * Name of this test. (read-only)
     */
    public var test_name: String?
    /**
     * Number of assertions in this test (read-only)
     */
    public var assertions_count: Int64?
    /**
     * Number of assertions passed in this test (read-only)
     */
    public var assertions_failed: Int64?
    /**
     * A list of any errors encountered by the test. (read-only)
     */
    public var errors: [ProjectError]?
    /**
     * A list of any warnings encountered by the test. (read-only)
     */
    public var warnings: [ProjectError]?
    /**
     * True if this test passsed without errors. (read-only)
     */
    public var success: Bool?

    public init(can: StringDictionary<Bool>? = nil, model_name: String? = nil, test_name: String? = nil, assertions_count: Int64? = nil, assertions_failed: Int64? = nil, errors: [ProjectError]? = nil, warnings: [ProjectError]? = nil, success: Bool? = nil) {
        self.can = can
        self.model_name = model_name
        self.test_name = test_name
        self.assertions_count = assertions_count
        self.assertions_failed = assertions_failed
        self.errors = errors
        self.warnings = warnings
        self.success = success
    }

}

public struct LookModel: SDKModel {
    /**
     * Model Id (read-only)
     */
    public var id: String?
    /**
     * Model Label (read-only)
     */
    public var label: String?

    public init(id: String? = nil, label: String? = nil) {
        self.id = id
        self.label = label
    }

}

public struct LookWithDashboards: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Id of content metadata (read-only)
     */
    public var content_metadata_id: Int64?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Look Title
     */
    public var title: String?
    /**
     * User Id
     */
    public var user_id: Int64?
    /**
     * Content Favorite Id (read-only)
     */
    public var content_favorite_id: Int64?
    /**
     * Time that the Look was created. (read-only)
     */
    public var created_at: Date?
    /**
     * Whether or not a look is 'soft' deleted.
     */
    public var deleted: Bool?
    /**
     * Time that the Look was deleted. (read-only)
     */
    public var deleted_at: Date?
    /**
     * Id of User that deleted the look. (read-only)
     */
    public var deleter_id: Int64?
    /**
     * Description
     */
    public var description: String?
    /**
     * Embed Url (read-only)
     */
    public var embed_url: String?
    /**
     * Excel File Url (read-only)
     */
    public var excel_file_url: String?
    /**
     * Number of times favorited (read-only)
     */
    public var favorite_count: Int64?
    /**
     * Google Spreadsheet Formula (read-only)
     */
    public var google_spreadsheet_formula: String?
    /**
     * Image Embed Url (read-only)
     */
    public var image_embed_url: String?
    /**
     * auto-run query when Look viewed
     */
    public var is_run_on_load: Bool?
    /**
     * Time that the Look was last accessed by any user (read-only)
     */
    public var last_accessed_at: Date?
    /**
     * Id of User that last updated the look. (read-only)
     */
    public var last_updater_id: Int64?
    /**
     * Time last viewed in the Looker web UI (read-only)
     */
    public var last_viewed_at: Date?
    public var model: LookModel?
    /**
     * Is Public
     */
    public var `public`: Bool?
    /**
     * Public Slug (read-only)
     */
    public var public_slug: String?
    /**
     * Public Url (read-only)
     */
    public var public_url: String?
    /**
     * Query Id
     */
    public var query_id: Int64?
    /**
     * Short Url (read-only)
     */
    public var short_url: String?
    public var folder: FolderBase?
    /**
     * Folder Id
     */
    public var folder_id: String?
    /**
     * Time that the Look was updated. (read-only)
     */
    public var updated_at: Date?
    /**
     * Number of times viewed in the Looker web UI (read-only)
     */
    public var view_count: Int64?
    /**
     * Dashboards (read-only)
     */
    public var dashboards: [DashboardBase]?

    public init(can: StringDictionary<Bool>? = nil, content_metadata_id: Int64? = nil, id: Int64? = nil, title: String? = nil, user_id: Int64? = nil, content_favorite_id: Int64? = nil, created_at: Date? = nil, deleted: Bool? = nil, deleted_at: Date? = nil, deleter_id: Int64? = nil, description: String? = nil, embed_url: String? = nil, excel_file_url: String? = nil, favorite_count: Int64? = nil, google_spreadsheet_formula: String? = nil, image_embed_url: String? = nil, is_run_on_load: Bool? = nil, last_accessed_at: Date? = nil, last_updater_id: Int64? = nil, last_viewed_at: Date? = nil, model: LookModel? = nil, `public`: Bool? = nil, public_slug: String? = nil, public_url: String? = nil, query_id: Int64? = nil, short_url: String? = nil, folder: FolderBase? = nil, folder_id: String? = nil, updated_at: Date? = nil, view_count: Int64? = nil, dashboards: [DashboardBase]? = nil) {
        self.can = can
        self.content_metadata_id = content_metadata_id
        self.id = id
        self.title = title
        self.user_id = user_id
        self.content_favorite_id = content_favorite_id
        self.created_at = created_at
        self.deleted = deleted
        self.deleted_at = deleted_at
        self.deleter_id = deleter_id
        self.description = description
        self.embed_url = embed_url
        self.excel_file_url = excel_file_url
        self.favorite_count = favorite_count
        self.google_spreadsheet_formula = google_spreadsheet_formula
        self.image_embed_url = image_embed_url
        self.is_run_on_load = is_run_on_load
        self.last_accessed_at = last_accessed_at
        self.last_updater_id = last_updater_id
        self.last_viewed_at = last_viewed_at
        self.model = model
        self.`public` = `public`
        self.public_slug = public_slug
        self.public_url = public_url
        self.query_id = query_id
        self.short_url = short_url
        self.folder = folder
        self.folder_id = folder_id
        self.updated_at = updated_at
        self.view_count = view_count
        self.dashboards = dashboards
    }

}

public struct LookWithQuery: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Id of content metadata (read-only)
     */
    public var content_metadata_id: Int64?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Look Title
     */
    public var title: String?
    /**
     * User Id
     */
    public var user_id: Int64?
    /**
     * Content Favorite Id (read-only)
     */
    public var content_favorite_id: Int64?
    /**
     * Time that the Look was created. (read-only)
     */
    public var created_at: Date?
    /**
     * Whether or not a look is 'soft' deleted.
     */
    public var deleted: Bool?
    /**
     * Time that the Look was deleted. (read-only)
     */
    public var deleted_at: Date?
    /**
     * Id of User that deleted the look. (read-only)
     */
    public var deleter_id: Int64?
    /**
     * Description
     */
    public var description: String?
    /**
     * Embed Url (read-only)
     */
    public var embed_url: String?
    /**
     * Excel File Url (read-only)
     */
    public var excel_file_url: String?
    /**
     * Number of times favorited (read-only)
     */
    public var favorite_count: Int64?
    /**
     * Google Spreadsheet Formula (read-only)
     */
    public var google_spreadsheet_formula: String?
    /**
     * Image Embed Url (read-only)
     */
    public var image_embed_url: String?
    /**
     * auto-run query when Look viewed
     */
    public var is_run_on_load: Bool?
    /**
     * Time that the Look was last accessed by any user (read-only)
     */
    public var last_accessed_at: Date?
    /**
     * Id of User that last updated the look. (read-only)
     */
    public var last_updater_id: Int64?
    /**
     * Time last viewed in the Looker web UI (read-only)
     */
    public var last_viewed_at: Date?
    public var model: LookModel?
    /**
     * Is Public
     */
    public var `public`: Bool?
    /**
     * Public Slug (read-only)
     */
    public var public_slug: String?
    /**
     * Public Url (read-only)
     */
    public var public_url: String?
    /**
     * Query Id
     */
    public var query_id: Int64?
    /**
     * Short Url (read-only)
     */
    public var short_url: String?
    public var folder: FolderBase?
    /**
     * Folder Id
     */
    public var folder_id: String?
    /**
     * Time that the Look was updated. (read-only)
     */
    public var updated_at: Date?
    /**
     * Number of times viewed in the Looker web UI (read-only)
     */
    public var view_count: Int64?
    public var query: Query?
    /**
     * Url (read-only)
     */
    public var url: String?

    public init(can: StringDictionary<Bool>? = nil, content_metadata_id: Int64? = nil, id: Int64? = nil, title: String? = nil, user_id: Int64? = nil, content_favorite_id: Int64? = nil, created_at: Date? = nil, deleted: Bool? = nil, deleted_at: Date? = nil, deleter_id: Int64? = nil, description: String? = nil, embed_url: String? = nil, excel_file_url: String? = nil, favorite_count: Int64? = nil, google_spreadsheet_formula: String? = nil, image_embed_url: String? = nil, is_run_on_load: Bool? = nil, last_accessed_at: Date? = nil, last_updater_id: Int64? = nil, last_viewed_at: Date? = nil, model: LookModel? = nil, `public`: Bool? = nil, public_slug: String? = nil, public_url: String? = nil, query_id: Int64? = nil, short_url: String? = nil, folder: FolderBase? = nil, folder_id: String? = nil, updated_at: Date? = nil, view_count: Int64? = nil, query: Query? = nil, url: String? = nil) {
        self.can = can
        self.content_metadata_id = content_metadata_id
        self.id = id
        self.title = title
        self.user_id = user_id
        self.content_favorite_id = content_favorite_id
        self.created_at = created_at
        self.deleted = deleted
        self.deleted_at = deleted_at
        self.deleter_id = deleter_id
        self.description = description
        self.embed_url = embed_url
        self.excel_file_url = excel_file_url
        self.favorite_count = favorite_count
        self.google_spreadsheet_formula = google_spreadsheet_formula
        self.image_embed_url = image_embed_url
        self.is_run_on_load = is_run_on_load
        self.last_accessed_at = last_accessed_at
        self.last_updater_id = last_updater_id
        self.last_viewed_at = last_viewed_at
        self.model = model
        self.`public` = `public`
        self.public_slug = public_slug
        self.public_url = public_url
        self.query_id = query_id
        self.short_url = short_url
        self.folder = folder
        self.folder_id = folder_id
        self.updated_at = updated_at
        self.view_count = view_count
        self.query = query
        self.url = url
    }

}

public struct Manifest: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Manifest project name (read-only)
     */
    public var name: String?
    /**
     * Imports for a project (read-only)
     */
    public var imports: [ImportedProject]?
    public var localization_settings: LocalizationSettings?

    public init(can: StringDictionary<Bool>? = nil, name: String? = nil, imports: [ImportedProject]? = nil, localization_settings: LocalizationSettings? = nil) {
        self.can = can
        self.name = name
        self.imports = imports
        self.localization_settings = localization_settings
    }

}

public struct MergeFields: SDKModel {
    /**
     * Field name to map onto in the merged results
     */
    public var field_name: String?
    /**
     * Field name from the source query
     */
    public var source_field_name: String?

    public init(field_name: String? = nil, source_field_name: String? = nil) {
        self.field_name = field_name
        self.source_field_name = source_field_name
    }

}

public struct MergeQuery: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Column Limit
     */
    public var column_limit: String?
    /**
     * Dynamic Fields
     */
    public var dynamic_fields: String?
    /**
     * Unique Id (read-only)
     */
    public var id: String?
    /**
     * Pivots
     */
    public var pivots: [String]?
    /**
     * Unique to get results (read-only)
     */
    public var result_maker_id: Int64?
    /**
     * Sorts
     */
    public var sorts: [String]?
    /**
     * Source Queries defining the results to be merged.
     */
    public var source_queries: [MergeQuerySourceQuery]?
    /**
     * Total
     */
    public var total: Bool?
    /**
     * Visualization Config
     */
    public var vis_config: StringDictionary<AnyCodable>?

    public init(can: StringDictionary<Bool>? = nil, column_limit: String? = nil, dynamic_fields: String? = nil, id: String? = nil, pivots: [String]? = nil, result_maker_id: Int64? = nil, sorts: [String]? = nil, source_queries: [MergeQuerySourceQuery]? = nil, total: Bool? = nil, vis_config: StringDictionary<AnyCodable>? = nil) {
        self.can = can
        self.column_limit = column_limit
        self.dynamic_fields = dynamic_fields
        self.id = id
        self.pivots = pivots
        self.result_maker_id = result_maker_id
        self.sorts = sorts
        self.source_queries = source_queries
        self.total = total
        self.vis_config = vis_config
    }

}

public struct MergeQuerySourceQuery: SDKModel {
    /**
     * An array defining which fields of the source query are mapped onto fields of the merge query
     */
    public var merge_fields: [MergeFields]?
    /**
     * Display name
     */
    public var name: String?
    /**
     * Id of the query to merge
     */
    public var query_id: Int64?

    public init(merge_fields: [MergeFields]? = nil, name: String? = nil, query_id: Int64? = nil) {
        self.merge_fields = merge_fields
        self.name = name
        self.query_id = query_id
    }

}

public struct ModelFieldSuggestions: SDKModel {
    /**
     * List of suggestions (read-only)
     */
    public var suggestions: [String]?
    /**
     * Error message (read-only)
     */
    public var error: String?
    /**
     * True if result came from the cache (read-only)
     */
    public var from_cache: Bool?
    /**
     * True if this was a hit limit (read-only)
     */
    public var hit_limit: Bool?
    /**
     * True if calcite was used (read-only)
     */
    public var used_calcite_materialization: Bool?

    public init(suggestions: [String]? = nil, error: String? = nil, from_cache: Bool? = nil, hit_limit: Bool? = nil, used_calcite_materialization: Bool? = nil) {
        self.suggestions = suggestions
        self.error = error
        self.from_cache = from_cache
        self.hit_limit = hit_limit
        self.used_calcite_materialization = used_calcite_materialization
    }

}

public struct ModelSet: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * (read-only)
     */
    public var all_access: Bool?
    /**
     * (read-only)
     */
    public var built_in: Bool?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    public var models: [String]?
    /**
     * Name of ModelSet
     */
    public var name: String?
    /**
     * Link to get this item (read-only)
     */
    public var url: URI?

    public init(can: StringDictionary<Bool>? = nil, all_access: Bool? = nil, built_in: Bool? = nil, id: Int64? = nil, models: [String]? = nil, name: String? = nil, url: URI? = nil) {
        self.can = can
        self.all_access = all_access
        self.built_in = built_in
        self.id = id
        self.models = models
        self.name = name
        self.url = url
    }

}

public struct ModelsNotValidated: SDKModel {
    /**
     * Model name (read-only)
     */
    public var name: String?
    /**
     * Project file (read-only)
     */
    public var project_file_id: String?

    public init(name: String? = nil, project_file_id: String? = nil) {
        self.name = name
        self.project_file_id = project_file_id
    }

}

/**
 * The type of time interval this field represents a grouping of. Valid values are: "day", "hour", "minute", "second", "millisecond", "microsecond", "week", "month", "quarter", "year".
 */
public enum Name: String, Codable {
    case day = "day"
    case hour = "hour"
    case minute = "minute"
    case second = "second"
    case millisecond = "millisecond"
    case microsecond = "microsecond"
    case week = "week"
    case month = "month"
    case quarter = "quarter"
    case year = "year"
}

public struct OauthClientApp: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * The globally unique id of this application (read-only)
     */
    public var client_guid: String?
    /**
     * The uri with which this application will receive an auth code by browser redirect.
     */
    public var redirect_uri: String?
    /**
     * The application's display name
     */
    public var display_name: String?
    /**
     * A description of the application that will be displayed to users
     */
    public var description: String?
    /**
     * When enabled is true, OAuth2 and API requests will be accepted from this app. When false, all requests from this app will be refused.
     */
    public var enabled: Bool?
    /**
     * If set, only Looker users who are members of this group can use this web app with Looker. If group_id is not set, any Looker user may use this app to access this Looker instance
     */
    public var group_id: Int64?
    /**
     * All auth codes, access tokens, and refresh tokens issued for this application prior to this date-time for ALL USERS will be invalid. (read-only)
     */
    public var tokens_invalid_before: Date?
    /**
     * All users who have been activated to use this app (read-only)
     */
    public var activated_users: [UserPublic]?

    public init(can: StringDictionary<Bool>? = nil, client_guid: String? = nil, redirect_uri: String? = nil, display_name: String? = nil, description: String? = nil, enabled: Bool? = nil, group_id: Int64? = nil, tokens_invalid_before: Date? = nil, activated_users: [UserPublic]? = nil) {
        self.can = can
        self.client_guid = client_guid
        self.redirect_uri = redirect_uri
        self.display_name = display_name
        self.description = description
        self.enabled = enabled
        self.group_id = group_id
        self.tokens_invalid_before = tokens_invalid_before
        self.activated_users = activated_users
    }

}

public struct OIDCConfig: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
     */
    public var alternate_email_login_allowed: Bool?
    /**
     * OpenID Provider Audience
     */
    public var audience: String?
    /**
     * Users will not be allowed to login at all unless a role for them is found in OIDC if set to true
     */
    public var auth_requires_role: Bool?
    /**
     * OpenID Provider Authorization Url
     */
    public var authorization_endpoint: URI?
    /**
     * (Write-Only) Array of ids of groups that will be applied to new users the first time they login via OIDC
     */
    public var default_new_user_group_ids: [Int64]?
    /**
     * (Read-only) Groups that will be applied to new users the first time they login via OIDC (read-only)
     */
    public var default_new_user_groups: [LkGroup]?
    /**
     * (Write-Only) Array of ids of roles that will be applied to new users the first time they login via OIDC
     */
    public var default_new_user_role_ids: [Int64]?
    /**
     * (Read-only) Roles that will be applied to new users the first time they login via OIDC (read-only)
     */
    public var default_new_user_roles: [Role]?
    /**
     * Enable/Disable OIDC authentication for the server
     */
    public var enabled: Bool?
    /**
     * (Read-only) Array of mappings between OIDC Groups and Looker Roles (read-only)
     */
    public var groups: [OIDCGroupRead]?
    /**
     * Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
     */
    public var groups_attribute: String?
    /**
     * (Read/Write) Array of mappings between OIDC Groups and arrays of Looker Role ids
     */
    public var groups_with_role_ids: [OIDCGroupWrite]?
    /**
     * Relying Party Identifier (provided by OpenID Provider)
     */
    public var identifier: String?
    /**
     * OpenID Provider Issuer
     */
    public var issuer: String?
    /**
     * When this config was last modified (read-only)
     */
    public var modified_at: Date?
    /**
     * User id of user who last modified this config (read-only)
     */
    public var modified_by: Int64?
    /**
     * Merge first-time oidc login to existing user account by email addresses. When a user logs in for the first time via oidc this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
     */
    public var new_user_migration_types: String?
    /**
     * Array of scopes to request.
     */
    public var scopes: [String]?
    /**
     * (Write-Only) Relying Party Secret (provided by OpenID Provider)
     */
    public var secret: String?
    /**
     * Set user roles in Looker based on groups from OIDC
     */
    public var set_roles_from_groups: Bool?
    /**
     * Slug to identify configurations that are created in order to run a OIDC config test (read-only)
     */
    public var test_slug: String?
    /**
     * OpenID Provider Token Url
     */
    public var token_endpoint: String?
    /**
     * Name of user record attributes used to indicate email address field
     */
    public var user_attribute_map_email: String?
    /**
     * Name of user record attributes used to indicate first name
     */
    public var user_attribute_map_first_name: String?
    /**
     * Name of user record attributes used to indicate last name
     */
    public var user_attribute_map_last_name: String?
    /**
     * (Read-only) Array of mappings between OIDC User Attributes and Looker User Attributes (read-only)
     */
    public var user_attributes: [OIDCUserAttributeRead]?
    /**
     * (Read/Write) Array of mappings between OIDC User Attributes and arrays of Looker User Attribute ids
     */
    public var user_attributes_with_ids: [OIDCUserAttributeWrite]?
    /**
     * OpenID Provider User Information Url
     */
    public var userinfo_endpoint: URI?
    /**
     * Allow OIDC auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.
     */
    public var allow_normal_group_membership: Bool?
    /**
     * OIDC auth'd users will inherit roles from non-reflected Looker groups.
     */
    public var allow_roles_from_normal_groups: Bool?
    /**
     * Allows roles to be directly assigned to OIDC auth'd users.
     */
    public var allow_direct_roles: Bool?
    /**
     * Link to get this item (read-only)
     */
    public var url: URI?

    public init(can: StringDictionary<Bool>? = nil, alternate_email_login_allowed: Bool? = nil, audience: String? = nil, auth_requires_role: Bool? = nil, authorization_endpoint: URI? = nil, default_new_user_group_ids: [Int64]? = nil, default_new_user_groups: [LkGroup]? = nil, default_new_user_role_ids: [Int64]? = nil, default_new_user_roles: [Role]? = nil, enabled: Bool? = nil, groups: [OIDCGroupRead]? = nil, groups_attribute: String? = nil, groups_with_role_ids: [OIDCGroupWrite]? = nil, identifier: String? = nil, issuer: String? = nil, modified_at: Date? = nil, modified_by: Int64? = nil, new_user_migration_types: String? = nil, scopes: [String]? = nil, secret: String? = nil, set_roles_from_groups: Bool? = nil, test_slug: String? = nil, token_endpoint: String? = nil, user_attribute_map_email: String? = nil, user_attribute_map_first_name: String? = nil, user_attribute_map_last_name: String? = nil, user_attributes: [OIDCUserAttributeRead]? = nil, user_attributes_with_ids: [OIDCUserAttributeWrite]? = nil, userinfo_endpoint: URI? = nil, allow_normal_group_membership: Bool? = nil, allow_roles_from_normal_groups: Bool? = nil, allow_direct_roles: Bool? = nil, url: URI? = nil) {
        self.can = can
        self.alternate_email_login_allowed = alternate_email_login_allowed
        self.audience = audience
        self.auth_requires_role = auth_requires_role
        self.authorization_endpoint = authorization_endpoint
        self.default_new_user_group_ids = default_new_user_group_ids
        self.default_new_user_groups = default_new_user_groups
        self.default_new_user_role_ids = default_new_user_role_ids
        self.default_new_user_roles = default_new_user_roles
        self.enabled = enabled
        self.groups = groups
        self.groups_attribute = groups_attribute
        self.groups_with_role_ids = groups_with_role_ids
        self.identifier = identifier
        self.issuer = issuer
        self.modified_at = modified_at
        self.modified_by = modified_by
        self.new_user_migration_types = new_user_migration_types
        self.scopes = scopes
        self.secret = secret
        self.set_roles_from_groups = set_roles_from_groups
        self.test_slug = test_slug
        self.token_endpoint = token_endpoint
        self.user_attribute_map_email = user_attribute_map_email
        self.user_attribute_map_first_name = user_attribute_map_first_name
        self.user_attribute_map_last_name = user_attribute_map_last_name
        self.user_attributes = user_attributes
        self.user_attributes_with_ids = user_attributes_with_ids
        self.userinfo_endpoint = userinfo_endpoint
        self.allow_normal_group_membership = allow_normal_group_membership
        self.allow_roles_from_normal_groups = allow_roles_from_normal_groups
        self.allow_direct_roles = allow_direct_roles
        self.url = url
    }

}

public struct OIDCGroupRead: SDKModel {
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Unique Id of group in Looker (read-only)
     */
    public var looker_group_id: Int64?
    /**
     * Name of group in Looker (read-only)
     */
    public var looker_group_name: String?
    /**
     * Name of group in OIDC (read-only)
     */
    public var name: String?
    /**
     * Looker Roles (read-only)
     */
    public var roles: [Role]?

    public init(id: Int64? = nil, looker_group_id: Int64? = nil, looker_group_name: String? = nil, name: String? = nil, roles: [Role]? = nil) {
        self.id = id
        self.looker_group_id = looker_group_id
        self.looker_group_name = looker_group_name
        self.name = name
        self.roles = roles
    }

}

public struct OIDCGroupWrite: SDKModel {
    /**
     * Unique Id
     */
    public var id: Int64?
    /**
     * Unique Id of group in Looker (read-only)
     */
    public var looker_group_id: Int64?
    /**
     * Name of group in Looker
     */
    public var looker_group_name: String?
    /**
     * Name of group in OIDC
     */
    public var name: String?
    /**
     * Looker Role Ids
     */
    public var role_ids: [Int64]?

    public init(id: Int64? = nil, looker_group_id: Int64? = nil, looker_group_name: String? = nil, name: String? = nil, role_ids: [Int64]? = nil) {
        self.id = id
        self.looker_group_id = looker_group_id
        self.looker_group_name = looker_group_name
        self.name = name
        self.role_ids = role_ids
    }

}

public struct OIDCUserAttributeRead: SDKModel {
    /**
     * Name of User Attribute in OIDC (read-only)
     */
    public var name: String?
    /**
     * Required to be in OIDC assertion for login to be allowed to succeed (read-only)
     */
    public var required: Bool?
    /**
     * Looker User Attributes (read-only)
     */
    public var user_attributes: [UserAttribute]?

    public init(name: String? = nil, required: Bool? = nil, user_attributes: [UserAttribute]? = nil) {
        self.name = name
        self.required = required
        self.user_attributes = user_attributes
    }

}

public struct OIDCUserAttributeWrite: SDKModel {
    /**
     * Name of User Attribute in OIDC
     */
    public var name: String?
    /**
     * Required to be in OIDC assertion for login to be allowed to succeed
     */
    public var required: Bool?
    /**
     * Looker User Attribute Ids
     */
    public var user_attribute_ids: [Int64]?

    public init(name: String? = nil, required: Bool? = nil, user_attribute_ids: [Int64]? = nil) {
        self.name = name
        self.required = required
        self.user_attribute_ids = user_attribute_ids
    }

}

public struct PasswordConfig: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Minimum number of characters required for a new password.  Must be between 7 and 100
     */
    public var min_length: Int64?
    /**
     * Require at least one numeric character
     */
    public var require_numeric: Bool?
    /**
     * Require at least one uppercase and one lowercase letter
     */
    public var require_upperlower: Bool?
    /**
     * Require at least one special character
     */
    public var require_special: Bool?

    public init(can: StringDictionary<Bool>? = nil, min_length: Int64? = nil, require_numeric: Bool? = nil, require_upperlower: Bool? = nil, require_special: Bool? = nil) {
        self.can = can
        self.min_length = min_length
        self.require_numeric = require_numeric
        self.require_upperlower = require_upperlower
        self.require_special = require_special
    }

}

public struct Permission: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Permission symbol (read-only)
     */
    public var permission: String?
    /**
     * Dependency parent symbol (read-only)
     */
    public var parent: String?
    /**
     * Description (read-only)
     */
    public var description: String?

    public init(can: StringDictionary<Bool>? = nil, permission: String? = nil, parent: String? = nil, description: String? = nil) {
        self.can = can
        self.permission = permission
        self.parent = parent
        self.description = description
    }

}

public struct PermissionSet: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * (read-only)
     */
    public var all_access: Bool?
    /**
     * (read-only)
     */
    public var built_in: Bool?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Name of PermissionSet
     */
    public var name: String?
    public var permissions: [String]?
    /**
     * Link to get this item (read-only)
     */
    public var url: URI?

    public init(can: StringDictionary<Bool>? = nil, all_access: Bool? = nil, built_in: Bool? = nil, id: Int64? = nil, name: String? = nil, permissions: [String]? = nil, url: URI? = nil) {
        self.can = can
        self.all_access = all_access
        self.built_in = built_in
        self.id = id
        self.name = name
        self.permissions = permissions
        self.url = url
    }

}

/**
 * Type of permission: "view" or "edit" Valid values are: "view", "edit".
 */
public enum PermissionType: String, Codable {
    case view = "view"
    case edit = "edit"
}

public struct Project: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Project Id (read-only)
     */
    public var id: String?
    /**
     * Project display name
     */
    public var name: String?
    /**
     * If true the project is configured with a git repository (read-only)
     */
    public var uses_git: Bool?
    /**
     * Git remote repository url
     */
    public var git_remote_url: String?
    /**
     * Git username for HTTPS authentication. (For production only, if using user attributes.)
     */
    public var git_username: String?
    /**
     * (Write-Only) Git password for HTTPS authentication. (For production only, if using user attributes.)
     */
    public var git_password: String?
    /**
     * User attribute name for username in per-user HTTPS authentication.
     */
    public var git_username_user_attribute: String?
    /**
     * User attribute name for password in per-user HTTPS authentication.
     */
    public var git_password_user_attribute: String?
    /**
     * Name of the git service provider
     */
    public var git_service_name: String?
    /**
     * Port that HTTP(S) application server is running on (for PRs, file browsing, etc.)
     */
    public var git_application_server_http_port: Int64?
    /**
     * Scheme that is running on application server (for PRs, file browsing, etc.) Valid values are: "http", "https".
     */
    public var git_application_server_http_scheme: GitApplicationServerHttpScheme?
    /**
     * (Write-Only) Optional secret token with which to authenticate requests to the webhook deploy endpoint. If not set, endpoint is unauthenticated.
     */
    public var deploy_secret: String?
    /**
     * (Write-Only) When true, unsets the deploy secret to allow unauthenticated access to the webhook deploy endpoint.
     */
    public var unset_deploy_secret: Bool?
    /**
     * The git pull request policy for this project. Valid values are: "off", "links", "recommended", "required".
     */
    public var pull_request_mode: PullRequestMode?
    /**
     * Validation policy: If true, the project must pass validation checks before project changes can be committed to the git repository
     */
    public var validation_required: Bool?
    /**
     * If true, advanced git release management is enabled for this project
     */
    public var git_release_mgmt_enabled: Bool?
    /**
     * Validation policy: If true, the project can be committed with warnings when `validation_required` is true. (`allow_warnings` does nothing if `validation_required` is false).
     */
    public var allow_warnings: Bool?
    /**
     * If true the project is an example project and cannot be modified (read-only)
     */
    public var is_example: Bool?
    /**
     * Status of dependencies in your manifest & lockfile
     */
    public var dependency_status: String?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, name: String? = nil, uses_git: Bool? = nil, git_remote_url: String? = nil, git_username: String? = nil, git_password: String? = nil, git_username_user_attribute: String? = nil, git_password_user_attribute: String? = nil, git_service_name: String? = nil, git_application_server_http_port: Int64? = nil, git_application_server_http_scheme: GitApplicationServerHttpScheme? = nil, deploy_secret: String? = nil, unset_deploy_secret: Bool? = nil, pull_request_mode: PullRequestMode? = nil, validation_required: Bool? = nil, git_release_mgmt_enabled: Bool? = nil, allow_warnings: Bool? = nil, is_example: Bool? = nil, dependency_status: String? = nil) {
        self.can = can
        self.id = id
        self.name = name
        self.uses_git = uses_git
        self.git_remote_url = git_remote_url
        self.git_username = git_username
        self.git_password = git_password
        self.git_username_user_attribute = git_username_user_attribute
        self.git_password_user_attribute = git_password_user_attribute
        self.git_service_name = git_service_name
        self.git_application_server_http_port = git_application_server_http_port
        self.git_application_server_http_scheme = git_application_server_http_scheme
        self.deploy_secret = deploy_secret
        self.unset_deploy_secret = unset_deploy_secret
        self.pull_request_mode = pull_request_mode
        self.validation_required = validation_required
        self.git_release_mgmt_enabled = git_release_mgmt_enabled
        self.allow_warnings = allow_warnings
        self.is_example = is_example
        self.dependency_status = dependency_status
    }

}

public struct ProjectError: SDKModel {
    /**
     * A stable token that uniquely identifies this class of error, ignoring parameter values. Error message text may vary due to parameters or localization, but error codes do not. For example, a "File not found" error will have the same error code regardless of the filename in question or the user's display language (read-only)
     */
    public var code: String?
    /**
     * Severity: fatal, error, warning, info, success (read-only)
     */
    public var severity: String?
    /**
     * Error classification: syntax, deprecation, model_configuration, etc (read-only)
     */
    public var kind: String?
    /**
     * Error message which may contain information such as dashboard or model names that may be considered sensitive in some use cases. Avoid storing or sending this message outside of Looker (read-only)
     */
    public var message: String?
    /**
     * The field associated with this error (read-only)
     */
    public var field_name: String?
    /**
     * Name of the file containing this error (read-only)
     */
    public var file_path: String?
    /**
     * Line number in the file of this error (read-only)
     */
    public var line_number: Int64?
    /**
     * The model associated with this error (read-only)
     */
    public var model_id: String?
    /**
     * The explore associated with this error (read-only)
     */
    public var explore: String?
    /**
     * A link to Looker documentation about this error (read-only)
     */
    public var help_url: String?
    /**
     * Error parameters (read-only)
     */
    public var params: StringDictionary<AnyCodable>?
    /**
     * A version of the error message that does not contain potentially sensitive information. Suitable for situations in which messages are stored or sent to consumers outside of Looker, such as external logs. Sanitized messages will display "(?)" where sensitive information would appear in the corresponding non-sanitized message (read-only)
     */
    public var sanitized_message: String?

    public init(code: String? = nil, severity: String? = nil, kind: String? = nil, message: String? = nil, field_name: String? = nil, file_path: String? = nil, line_number: Int64? = nil, model_id: String? = nil, explore: String? = nil, help_url: String? = nil, params: StringDictionary<AnyCodable>? = nil, sanitized_message: String? = nil) {
        self.code = code
        self.severity = severity
        self.kind = kind
        self.message = message
        self.field_name = field_name
        self.file_path = file_path
        self.line_number = line_number
        self.model_id = model_id
        self.explore = explore
        self.help_url = help_url
        self.params = params
        self.sanitized_message = sanitized_message
    }

}

public struct ProjectFile: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * An opaque token uniquely identifying a file within a project. Avoid parsing or decomposing the text of this token. This token is stable within a Looker release but may change between Looker releases (read-only)
     */
    public var id: String?
    /**
     * Path, file name, and extension of the file relative to the project root directory (read-only)
     */
    public var path: String?
    /**
     * Display name (read-only)
     */
    public var title: String?
    /**
     * File type: model, view, etc (read-only)
     */
    public var type: String?
    /**
     * The extension of the file: .view.lkml, .model.lkml, etc (read-only)
     */
    public var `extension`: String?
    /**
     * File mime type (read-only)
     */
    public var mime_type: String?
    /**
     * State of editability for the file. (read-only)
     */
    public var editable: Bool?
    public var git_status: GitStatus?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, path: String? = nil, title: String? = nil, type: String? = nil, `extension`: String? = nil, mime_type: String? = nil, editable: Bool? = nil, git_status: GitStatus? = nil) {
        self.can = can
        self.id = id
        self.path = path
        self.title = title
        self.type = type
        self.`extension` = `extension`
        self.mime_type = mime_type
        self.editable = editable
        self.git_status = git_status
    }

}

public struct ProjectValidation: SDKModel {
    /**
     * A list of project errors (read-only)
     */
    public var errors: [ProjectError]?
    /**
     * A hash value computed from the project's current state (read-only)
     */
    public var project_digest: String?
    /**
     * A list of models which were not fully validated (read-only)
     */
    public var models_not_validated: [ModelsNotValidated]?
    /**
     * Duration of project validation in seconds (read-only)
     */
    public var computation_time: Float?

    public init(errors: [ProjectError]? = nil, project_digest: String? = nil, models_not_validated: [ModelsNotValidated]? = nil, computation_time: Float? = nil) {
        self.errors = errors
        self.project_digest = project_digest
        self.models_not_validated = models_not_validated
        self.computation_time = computation_time
    }

}

public struct ProjectValidationCache: SDKModel {
    /**
     * A list of project errors (read-only)
     */
    public var errors: [ProjectError]?
    /**
     * A hash value computed from the project's current state (read-only)
     */
    public var project_digest: String?
    /**
     * A list of models which were not fully validated (read-only)
     */
    public var models_not_validated: [ModelsNotValidated]?
    /**
     * Duration of project validation in seconds (read-only)
     */
    public var computation_time: Float?
    /**
     * If true, the cached project validation results are no longer accurate because the project has changed since the cached results were calculated (read-only)
     */
    public var stale: Bool?

    public init(errors: [ProjectError]? = nil, project_digest: String? = nil, models_not_validated: [ModelsNotValidated]? = nil, computation_time: Float? = nil, stale: Bool? = nil) {
        self.errors = errors
        self.project_digest = project_digest
        self.models_not_validated = models_not_validated
        self.computation_time = computation_time
        self.stale = stale
    }

}

public struct ProjectWorkspace: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * The id of the project (read-only)
     */
    public var project_id: String?
    /**
     * The id of the local workspace containing the project files (read-only)
     */
    public var workspace_id: String?
    /**
     * The status of the local git directory (read-only)
     */
    public var git_status: String?
    /**
     * Git head revision name (read-only)
     */
    public var git_head: String?
    /**
     * Status of the dependencies in your project. Valid values are: "lock_optional", "lock_required", "lock_error", "install_none". (read-only)
     */
    public var dependency_status: DependencyStatus?
    public var git_branch: GitBranch?
    /**
     * The lookml syntax used by all files in this project (read-only)
     */
    public var lookml_type: String?

    public init(can: StringDictionary<Bool>? = nil, project_id: String? = nil, workspace_id: String? = nil, git_status: String? = nil, git_head: String? = nil, dependency_status: DependencyStatus? = nil, git_branch: GitBranch? = nil, lookml_type: String? = nil) {
        self.can = can
        self.project_id = project_id
        self.workspace_id = workspace_id
        self.git_status = git_status
        self.git_head = git_head
        self.dependency_status = dependency_status
        self.git_branch = git_branch
        self.lookml_type = lookml_type
    }

}

/**
 * The git pull request policy for this project. Valid values are: "off", "links", "recommended", "required".
 */
public enum PullRequestMode: String, Codable {
    case off = "off"
    case links = "links"
    case recommended = "recommended"
    case required = "required"
}

public struct Query: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Model
     */
    public var model: String
    /**
     * Explore Name
     */
    public var view: String
    /**
     * Fields
     */
    public var fields: [String]?
    /**
     * Pivots
     */
    public var pivots: [String]?
    /**
     * Fill Fields
     */
    public var fill_fields: [String]?
    /**
     * Filters
     */
    public var filters: StringDictionary<AnyCodable>?
    /**
     * Filter Expression
     */
    public var filter_expression: String?
    /**
     * Sorting for the query results. Use the format `["view.field", ...]` to sort on fields in ascending order. Use the format `["view.field desc", ...]` to sort on fields in descending order. Use `["__UNSORTED__"]` (2 underscores before and after) to disable sorting entirely. Empty sorts `[]` will trigger a default sort.
     */
    public var sorts: [String]?
    /**
     * Limit
     */
    public var limit: String?
    /**
     * Column Limit
     */
    public var column_limit: String?
    /**
     * Total
     */
    public var total: Bool?
    /**
     * Raw Total
     */
    public var row_total: String?
    /**
     * Fields on which to run subtotals
     */
    public var subtotals: [String]?
    /**
     * Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
     */
    public var vis_config: StringDictionary<AnyCodable>?
    /**
     * The filter_config represents the state of the filter UI on the explore page for a given query. When running a query via the Looker UI, this parameter takes precedence over "filters". When creating a query or modifying an existing query, "filter_config" should be set to null. Setting it to any other value could cause unexpected filtering behavior. The format should be considered opaque.
     */
    public var filter_config: StringDictionary<AnyCodable>?
    /**
     * Visible UI Sections
     */
    public var visible_ui_sections: String?
    /**
     * Slug (read-only)
     */
    public var slug: String?
    /**
     * Dynamic Fields
     */
    public var dynamic_fields: String?
    /**
     * Client Id: used to generate shortened explore URLs. If set by client, must be a unique 22 character alphanumeric string. Otherwise one will be generated.
     */
    public var client_id: String?
    /**
     * Share Url (read-only)
     */
    public var share_url: String?
    /**
     * Expanded Share Url (read-only)
     */
    public var expanded_share_url: String?
    /**
     * Expanded Url (read-only)
     */
    public var url: String?
    /**
     * Query Timezone
     */
    public var query_timezone: String?
    /**
     * Has Table Calculations (read-only)
     */
    public var has_table_calculations: Bool?

    public init(can: StringDictionary<Bool>? = nil, id: Int64? = nil, model: String, view: String, fields: [String]? = nil, pivots: [String]? = nil, fill_fields: [String]? = nil, filters: StringDictionary<AnyCodable>? = nil, filter_expression: String? = nil, sorts: [String]? = nil, limit: String? = nil, column_limit: String? = nil, total: Bool? = nil, row_total: String? = nil, subtotals: [String]? = nil, vis_config: StringDictionary<AnyCodable>? = nil, filter_config: StringDictionary<AnyCodable>? = nil, visible_ui_sections: String? = nil, slug: String? = nil, dynamic_fields: String? = nil, client_id: String? = nil, share_url: String? = nil, expanded_share_url: String? = nil, url: String? = nil, query_timezone: String? = nil, has_table_calculations: Bool? = nil) {
        self.can = can
        self.id = id
        self.model = model
        self.view = view
        self.fields = fields
        self.pivots = pivots
        self.fill_fields = fill_fields
        self.filters = filters
        self.filter_expression = filter_expression
        self.sorts = sorts
        self.limit = limit
        self.column_limit = column_limit
        self.total = total
        self.row_total = row_total
        self.subtotals = subtotals
        self.vis_config = vis_config
        self.filter_config = filter_config
        self.visible_ui_sections = visible_ui_sections
        self.slug = slug
        self.dynamic_fields = dynamic_fields
        self.client_id = client_id
        self.share_url = share_url
        self.expanded_share_url = expanded_share_url
        self.url = url
        self.query_timezone = query_timezone
        self.has_table_calculations = has_table_calculations
    }

    public init(can: StringDictionary<Bool>? = nil, id: Int64? = nil, _ model: String, _ view: String, fields: [String]? = nil, pivots: [String]? = nil, fill_fields: [String]? = nil, filters: StringDictionary<AnyCodable>? = nil, filter_expression: String? = nil, sorts: [String]? = nil, limit: String? = nil, column_limit: String? = nil, total: Bool? = nil, row_total: String? = nil, subtotals: [String]? = nil, vis_config: StringDictionary<AnyCodable>? = nil, filter_config: StringDictionary<AnyCodable>? = nil, visible_ui_sections: String? = nil, slug: String? = nil, dynamic_fields: String? = nil, client_id: String? = nil, share_url: String? = nil, expanded_share_url: String? = nil, url: String? = nil, query_timezone: String? = nil, has_table_calculations: Bool? = nil) {
        self.init(can: can, id: id, model: model, view: view, fields: fields, pivots: pivots, fill_fields: fill_fields, filters: filters, filter_expression: filter_expression, sorts: sorts, limit: limit, column_limit: column_limit, total: total, row_total: row_total, subtotals: subtotals, vis_config: vis_config, filter_config: filter_config, visible_ui_sections: visible_ui_sections, slug: slug, dynamic_fields: dynamic_fields, client_id: client_id, share_url: share_url, expanded_share_url: expanded_share_url, url: url, query_timezone: query_timezone, has_table_calculations: has_table_calculations)
    }

}

public struct QueryTask: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Unique Id (read-only)
     */
    public var id: String?
    /**
     * Id of query
     */
    public var query_id: Int64?
    public var query: Query?
    /**
     * whether or not to generate links in the query response.
     */
    public var generate_links: Bool?
    /**
     * Use production models to run query (even is user is in dev mode).
     */
    public var force_production: Bool?
    /**
     * Prefix to use for drill links.
     */
    public var path_prefix: String?
    /**
     * Whether or not to use the cache
     */
    public var cache: Bool?
    /**
     * Whether or not to run table calculations on the server
     */
    public var server_table_calcs: Bool?
    /**
     * Retrieve any results from cache even if the results have expired.
     */
    public var cache_only: Bool?
    /**
     * cache key used to cache query. (read-only)
     */
    public var cache_key: String?
    /**
     * Status of query task.
     */
    public var status: String?
    /**
     * Source of query task.
     */
    public var source: String?
    /**
     * Runtime of prior queries. (read-only)
     */
    public var runtime: Float?
    /**
     * Rebuild PDTS used in query.
     */
    public var rebuild_pdts: Bool?
    /**
     * Source of the results of the query. (read-only)
     */
    public var result_source: String?
    /**
     * Id of look associated with query.
     */
    public var look_id: Int64?
    /**
     * Id of dashboard associated with query.
     */
    public var dashboard_id: String?
    /**
     * The data format of the query results. (read-only)
     */
    public var result_format: String?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, query_id: Int64? = nil, query: Query? = nil, generate_links: Bool? = nil, force_production: Bool? = nil, path_prefix: String? = nil, cache: Bool? = nil, server_table_calcs: Bool? = nil, cache_only: Bool? = nil, cache_key: String? = nil, status: String? = nil, source: String? = nil, runtime: Float? = nil, rebuild_pdts: Bool? = nil, result_source: String? = nil, look_id: Int64? = nil, dashboard_id: String? = nil, result_format: String? = nil) {
        self.can = can
        self.id = id
        self.query_id = query_id
        self.query = query
        self.generate_links = generate_links
        self.force_production = force_production
        self.path_prefix = path_prefix
        self.cache = cache
        self.server_table_calcs = server_table_calcs
        self.cache_only = cache_only
        self.cache_key = cache_key
        self.status = status
        self.source = source
        self.runtime = runtime
        self.rebuild_pdts = rebuild_pdts
        self.result_source = result_source
        self.look_id = look_id
        self.dashboard_id = dashboard_id
        self.result_format = result_format
    }

}

public struct RenderTask: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Date/Time render task was created (read-only)
     */
    public var created_at: String?
    /**
     * Filter values to apply to the dashboard queries, in URL query format (read-only)
     */
    public var dashboard_filters: String?
    /**
     * Id of dashboard to render (read-only)
     */
    public var dashboard_id: Int64?
    /**
     * Dashboard layout style: single_column or tiled (read-only)
     */
    public var dashboard_style: String?
    /**
     * Date/Time render task was completed (read-only)
     */
    public var finalized_at: String?
    /**
     * Output height in pixels. Flowed layouts may ignore this value. (read-only)
     */
    public var height: Int64?
    /**
     * Id of this render task (read-only)
     */
    public var id: String?
    /**
     * Id of look to render (read-only)
     */
    public var look_id: Int64?
    /**
     * Id of lookml dashboard to render (read-only)
     */
    public var lookml_dashboard_id: String?
    /**
     * Id of query to render (read-only)
     */
    public var query_id: Int64?
    /**
     * Number of seconds elapsed running queries (read-only)
     */
    public var query_runtime: Double?
    /**
     * Number of seconds elapsed rendering data (read-only)
     */
    public var render_runtime: Double?
    /**
     * Output format: pdf, png, or jpg (read-only)
     */
    public var result_format: String?
    /**
     * Total seconds elapsed for render task (read-only)
     */
    public var runtime: Double?
    /**
     * Render task status: enqueued_for_query, querying, enqueued_for_render, rendering, success, failure (read-only)
     */
    public var status: String?
    /**
     * Additional information about the current status (read-only)
     */
    public var status_detail: String?
    /**
     * The user account permissions in which the render task will execute (read-only)
     */
    public var user_id: Int64?
    /**
     * Output width in pixels (read-only)
     */
    public var width: Int64?

    public init(can: StringDictionary<Bool>? = nil, created_at: String? = nil, dashboard_filters: String? = nil, dashboard_id: Int64? = nil, dashboard_style: String? = nil, finalized_at: String? = nil, height: Int64? = nil, id: String? = nil, look_id: Int64? = nil, lookml_dashboard_id: String? = nil, query_id: Int64? = nil, query_runtime: Double? = nil, render_runtime: Double? = nil, result_format: String? = nil, runtime: Double? = nil, status: String? = nil, status_detail: String? = nil, user_id: Int64? = nil, width: Int64? = nil) {
        self.can = can
        self.created_at = created_at
        self.dashboard_filters = dashboard_filters
        self.dashboard_id = dashboard_id
        self.dashboard_style = dashboard_style
        self.finalized_at = finalized_at
        self.height = height
        self.id = id
        self.look_id = look_id
        self.lookml_dashboard_id = lookml_dashboard_id
        self.query_id = query_id
        self.query_runtime = query_runtime
        self.render_runtime = render_runtime
        self.result_format = result_format
        self.runtime = runtime
        self.status = status
        self.status_detail = status_detail
        self.user_id = user_id
        self.width = width
    }

}

public struct RepositoryCredential: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Unique Id (read-only)
     */
    public var id: String?
    /**
     * Root project Id (read-only)
     */
    public var root_project_id: String?
    /**
     * Git remote repository url (read-only)
     */
    public var remote_url: String?
    /**
     * Git username for HTTPS authentication.
     */
    public var git_username: String?
    /**
     * (Write-Only) Git password for HTTPS authentication.
     */
    public var git_password: String?
    /**
     * Public deploy key for SSH authentication.
     */
    public var ssh_public_key: String?
    /**
     * Whether the credentials have been configured for the Git Repository. (read-only)
     */
    public var is_configured: Bool?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, root_project_id: String? = nil, remote_url: String? = nil, git_username: String? = nil, git_password: String? = nil, ssh_public_key: String? = nil, is_configured: Bool? = nil) {
        self.can = can
        self.id = id
        self.root_project_id = root_project_id
        self.remote_url = remote_url
        self.git_username = git_username
        self.git_password = git_password
        self.ssh_public_key = ssh_public_key
        self.is_configured = is_configured
    }

}

/**
 * Desired async query result format. Valid values are: "inline_json", "json", "json_detail", "json_fe", "csv", "html", "md", "txt", "xlsx", "gsxml".
 */
public enum ResultFormat: String, Codable {
    case inline_json = "inline_json"
    case json = "json"
    case json_detail = "json_detail"
    case json_fe = "json_fe"
    case csv = "csv"
    case html = "html"
    case md = "md"
    case txt = "txt"
    case xlsx = "xlsx"
    case gsxml = "gsxml"
}

public struct ResultMakerFilterables: SDKModel {
    /**
     * The model this filterable comes from (used for field suggestions). (read-only)
     */
    public var model: String?
    /**
     * The view this filterable comes from (used for field suggestions). (read-only)
     */
    public var view: String?
    /**
     * The name of the filterable thing (Query or Merged Results). (read-only)
     */
    public var name: String?
    /**
     * array of dashboard_filter_name: and field: objects. (read-only)
     */
    public var listen: [ResultMakerFilterablesListen]?

    public init(model: String? = nil, view: String? = nil, name: String? = nil, listen: [ResultMakerFilterablesListen]? = nil) {
        self.model = model
        self.view = view
        self.name = name
        self.listen = listen
    }

}

public struct ResultMakerFilterablesListen: SDKModel {
    /**
     * The name of a dashboard filter to listen to.
     */
    public var dashboard_filter_name: String?
    /**
     * The name of the field in the filterable to filter with the value of the dashboard filter.
     */
    public var field: String?

    public init(dashboard_filter_name: String? = nil, field: String? = nil) {
        self.dashboard_filter_name = dashboard_filter_name
        self.field = field
    }

}

public struct ResultMakerWithIdVisConfigAndDynamicFields: SDKModel {
    /**
     * Unique Id. (read-only)
     */
    public var id: Int64?
    /**
     * JSON string of dynamic field information. (read-only)
     */
    public var dynamic_fields: String?
    /**
     * array of items that can be filtered and information about them. (read-only)
     */
    public var filterables: [ResultMakerFilterables]?
    /**
     * Sorts of the constituent Look, Query, or Merge Query (read-only)
     */
    public var sorts: [String]?
    /**
     * ID of merge result if this is a merge_result. (read-only)
     */
    public var merge_result_id: String?
    /**
     * Total of the constituent Look, Query, or Merge Query (read-only)
     */
    public var total: Bool?
    /**
     * ID of query if this is a query. (read-only)
     */
    public var query_id: Int64?
    /**
     * ID of SQL Query if this is a SQL Runner Query (read-only)
     */
    public var sql_query_id: String?
    public var query: Query?
    /**
     * Vis config of the constituent Query, or Merge Query. (read-only)
     */
    public var vis_config: StringDictionary<AnyCodable>?

    public init(id: Int64? = nil, dynamic_fields: String? = nil, filterables: [ResultMakerFilterables]? = nil, sorts: [String]? = nil, merge_result_id: String? = nil, total: Bool? = nil, query_id: Int64? = nil, sql_query_id: String? = nil, query: Query? = nil, vis_config: StringDictionary<AnyCodable>? = nil) {
        self.id = id
        self.dynamic_fields = dynamic_fields
        self.filterables = filterables
        self.sorts = sorts
        self.merge_result_id = merge_result_id
        self.total = total
        self.query_id = query_id
        self.sql_query_id = sql_query_id
        self.query = query
        self.vis_config = vis_config
    }

}

public struct Role: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Name of Role
     */
    public var name: String?
    public var permission_set: PermissionSet?
    /**
     * (Write-Only) Id of permission set
     */
    public var permission_set_id: Int64?
    public var model_set: ModelSet?
    /**
     * (Write-Only) Id of model set
     */
    public var model_set_id: Int64?
    /**
     * Link to get this item (read-only)
     */
    public var url: URI?
    /**
     * Link to get list of users with this role (read-only)
     */
    public var users_url: URI?

    public init(can: StringDictionary<Bool>? = nil, id: Int64? = nil, name: String? = nil, permission_set: PermissionSet? = nil, permission_set_id: Int64? = nil, model_set: ModelSet? = nil, model_set_id: Int64? = nil, url: URI? = nil, users_url: URI? = nil) {
        self.can = can
        self.id = id
        self.name = name
        self.permission_set = permission_set
        self.permission_set_id = permission_set_id
        self.model_set = model_set
        self.model_set_id = model_set_id
        self.url = url
        self.users_url = users_url
    }

}

public struct RunningQueries: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    public var user: UserPublic?
    public var query: Query?
    public var sql_query: SqlQuery?
    public var look: LookBasic?
    /**
     * Date/Time Query was initiated (read-only)
     */
    public var created_at: String?
    /**
     * Date/Time Query was completed (read-only)
     */
    public var completed_at: String?
    /**
     * Query Id (read-only)
     */
    public var query_id: String?
    /**
     * Source (look, dashboard, queryrunner, explore, etc.) (read-only)
     */
    public var source: String?
    /**
     * Node Id (read-only)
     */
    public var node_id: String?
    /**
     * Slug (read-only)
     */
    public var slug: String?
    /**
     * ID of a Query Task (read-only)
     */
    public var query_task_id: String?
    /**
     * Cache Key (read-only)
     */
    public var cache_key: String?
    /**
     * Connection (read-only)
     */
    public var connection_name: String?
    /**
     * Dialect (read-only)
     */
    public var dialect: String?
    /**
     * Connection ID (read-only)
     */
    public var connection_id: String?
    /**
     * Additional Information(Error message or verbose status) (read-only)
     */
    public var message: String?
    /**
     * Status description (read-only)
     */
    public var status: String?
    /**
     * Number of seconds elapsed running the Query (read-only)
     */
    public var runtime: Double?
    /**
     * SQL text of the query as run (read-only)
     */
    public var sql: String?

    public init(can: StringDictionary<Bool>? = nil, id: Int64? = nil, user: UserPublic? = nil, query: Query? = nil, sql_query: SqlQuery? = nil, look: LookBasic? = nil, created_at: String? = nil, completed_at: String? = nil, query_id: String? = nil, source: String? = nil, node_id: String? = nil, slug: String? = nil, query_task_id: String? = nil, cache_key: String? = nil, connection_name: String? = nil, dialect: String? = nil, connection_id: String? = nil, message: String? = nil, status: String? = nil, runtime: Double? = nil, sql: String? = nil) {
        self.can = can
        self.id = id
        self.user = user
        self.query = query
        self.sql_query = sql_query
        self.look = look
        self.created_at = created_at
        self.completed_at = completed_at
        self.query_id = query_id
        self.source = source
        self.node_id = node_id
        self.slug = slug
        self.query_task_id = query_task_id
        self.cache_key = cache_key
        self.connection_name = connection_name
        self.dialect = dialect
        self.connection_id = connection_id
        self.message = message
        self.status = status
        self.runtime = runtime
        self.sql = sql
    }

}

public struct SamlConfig: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Enable/Disable Saml authentication for the server
     */
    public var enabled: Bool?
    /**
     * Identity Provider Certificate (provided by IdP)
     */
    public var idp_cert: String?
    /**
     * Identity Provider Url (provided by IdP)
     */
    public var idp_url: String?
    /**
     * Identity Provider Issuer (provided by IdP)
     */
    public var idp_issuer: String?
    /**
     * Identity Provider Audience (set in IdP config). Optional in Looker. Set this only if you want Looker to validate the audience value returned by the IdP.
     */
    public var idp_audience: String?
    /**
     * Count of seconds of clock drift to allow when validating timestamps of assertions.
     */
    public var allowed_clock_drift: Int64?
    /**
     * Name of user record attributes used to indicate email address field
     */
    public var user_attribute_map_email: String?
    /**
     * Name of user record attributes used to indicate first name
     */
    public var user_attribute_map_first_name: String?
    /**
     * Name of user record attributes used to indicate last name
     */
    public var user_attribute_map_last_name: String?
    /**
     * Merge first-time saml login to existing user account by email addresses. When a user logs in for the first time via saml this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
     */
    public var new_user_migration_types: String?
    /**
     * Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
     */
    public var alternate_email_login_allowed: Bool?
    /**
     * Slug to identify configurations that are created in order to run a Saml config test (read-only)
     */
    public var test_slug: String?
    /**
     * When this config was last modified (read-only)
     */
    public var modified_at: String?
    /**
     * User id of user who last modified this config (read-only)
     */
    public var modified_by: String?
    /**
     * (Read-only) Roles that will be applied to new users the first time they login via Saml (read-only)
     */
    public var default_new_user_roles: [Role]?
    /**
     * (Read-only) Groups that will be applied to new users the first time they login via Saml (read-only)
     */
    public var default_new_user_groups: [LkGroup]?
    /**
     * (Write-Only) Array of ids of roles that will be applied to new users the first time they login via Saml
     */
    public var default_new_user_role_ids: [Int64]?
    /**
     * (Write-Only) Array of ids of groups that will be applied to new users the first time they login via Saml
     */
    public var default_new_user_group_ids: [Int64]?
    /**
     * Set user roles in Looker based on groups from Saml
     */
    public var set_roles_from_groups: Bool?
    /**
     * Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
     */
    public var groups_attribute: String?
    /**
     * (Read-only) Array of mappings between Saml Groups and Looker Roles (read-only)
     */
    public var groups: [SamlGroupRead]?
    /**
     * (Read/Write) Array of mappings between Saml Groups and arrays of Looker Role ids
     */
    public var groups_with_role_ids: [SamlGroupWrite]?
    /**
     * Users will not be allowed to login at all unless a role for them is found in Saml if set to true
     */
    public var auth_requires_role: Bool?
    /**
     * (Read-only) Array of mappings between Saml User Attributes and Looker User Attributes (read-only)
     */
    public var user_attributes: [SamlUserAttributeRead]?
    /**
     * (Read/Write) Array of mappings between Saml User Attributes and arrays of Looker User Attribute ids
     */
    public var user_attributes_with_ids: [SamlUserAttributeWrite]?
    /**
     * Identifier for a strategy for how Looker will find groups in the SAML response. One of ['grouped_attribute_values', 'individual_attributes']
     */
    public var groups_finder_type: String?
    /**
     * Value for group attribute used to indicate membership. Used when 'groups_finder_type' is set to 'individual_attributes'
     */
    public var groups_member_value: String?
    /**
     * Bypass the login page when user authentication is required. Redirect to IdP immediately instead.
     */
    public var bypass_login_page: Bool?
    /**
     * Allow SAML auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.
     */
    public var allow_normal_group_membership: Bool?
    /**
     * SAML auth'd users will inherit roles from non-reflected Looker groups.
     */
    public var allow_roles_from_normal_groups: Bool?
    /**
     * Allows roles to be directly assigned to SAML auth'd users.
     */
    public var allow_direct_roles: Bool?
    /**
     * Link to get this item (read-only)
     */
    public var url: URI?

    public init(can: StringDictionary<Bool>? = nil, enabled: Bool? = nil, idp_cert: String? = nil, idp_url: String? = nil, idp_issuer: String? = nil, idp_audience: String? = nil, allowed_clock_drift: Int64? = nil, user_attribute_map_email: String? = nil, user_attribute_map_first_name: String? = nil, user_attribute_map_last_name: String? = nil, new_user_migration_types: String? = nil, alternate_email_login_allowed: Bool? = nil, test_slug: String? = nil, modified_at: String? = nil, modified_by: String? = nil, default_new_user_roles: [Role]? = nil, default_new_user_groups: [LkGroup]? = nil, default_new_user_role_ids: [Int64]? = nil, default_new_user_group_ids: [Int64]? = nil, set_roles_from_groups: Bool? = nil, groups_attribute: String? = nil, groups: [SamlGroupRead]? = nil, groups_with_role_ids: [SamlGroupWrite]? = nil, auth_requires_role: Bool? = nil, user_attributes: [SamlUserAttributeRead]? = nil, user_attributes_with_ids: [SamlUserAttributeWrite]? = nil, groups_finder_type: String? = nil, groups_member_value: String? = nil, bypass_login_page: Bool? = nil, allow_normal_group_membership: Bool? = nil, allow_roles_from_normal_groups: Bool? = nil, allow_direct_roles: Bool? = nil, url: URI? = nil) {
        self.can = can
        self.enabled = enabled
        self.idp_cert = idp_cert
        self.idp_url = idp_url
        self.idp_issuer = idp_issuer
        self.idp_audience = idp_audience
        self.allowed_clock_drift = allowed_clock_drift
        self.user_attribute_map_email = user_attribute_map_email
        self.user_attribute_map_first_name = user_attribute_map_first_name
        self.user_attribute_map_last_name = user_attribute_map_last_name
        self.new_user_migration_types = new_user_migration_types
        self.alternate_email_login_allowed = alternate_email_login_allowed
        self.test_slug = test_slug
        self.modified_at = modified_at
        self.modified_by = modified_by
        self.default_new_user_roles = default_new_user_roles
        self.default_new_user_groups = default_new_user_groups
        self.default_new_user_role_ids = default_new_user_role_ids
        self.default_new_user_group_ids = default_new_user_group_ids
        self.set_roles_from_groups = set_roles_from_groups
        self.groups_attribute = groups_attribute
        self.groups = groups
        self.groups_with_role_ids = groups_with_role_ids
        self.auth_requires_role = auth_requires_role
        self.user_attributes = user_attributes
        self.user_attributes_with_ids = user_attributes_with_ids
        self.groups_finder_type = groups_finder_type
        self.groups_member_value = groups_member_value
        self.bypass_login_page = bypass_login_page
        self.allow_normal_group_membership = allow_normal_group_membership
        self.allow_roles_from_normal_groups = allow_roles_from_normal_groups
        self.allow_direct_roles = allow_direct_roles
        self.url = url
    }

}

public struct SamlGroupRead: SDKModel {
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Unique Id of group in Looker (read-only)
     */
    public var looker_group_id: Int64?
    /**
     * Name of group in Looker (read-only)
     */
    public var looker_group_name: String?
    /**
     * Name of group in Saml (read-only)
     */
    public var name: String?
    /**
     * Looker Roles (read-only)
     */
    public var roles: [Role]?
    /**
     * Link to saml config (read-only)
     */
    public var url: URI?

    public init(id: Int64? = nil, looker_group_id: Int64? = nil, looker_group_name: String? = nil, name: String? = nil, roles: [Role]? = nil, url: URI? = nil) {
        self.id = id
        self.looker_group_id = looker_group_id
        self.looker_group_name = looker_group_name
        self.name = name
        self.roles = roles
        self.url = url
    }

}

public struct SamlGroupWrite: SDKModel {
    /**
     * Unique Id
     */
    public var id: Int64?
    /**
     * Unique Id of group in Looker (read-only)
     */
    public var looker_group_id: Int64?
    /**
     * Name of group in Looker
     */
    public var looker_group_name: String?
    /**
     * Name of group in Saml
     */
    public var name: String?
    /**
     * Looker Role Ids
     */
    public var role_ids: [Int64]?
    /**
     * Link to saml config (read-only)
     */
    public var url: URI?

    public init(id: Int64? = nil, looker_group_id: Int64? = nil, looker_group_name: String? = nil, name: String? = nil, role_ids: [Int64]? = nil, url: URI? = nil) {
        self.id = id
        self.looker_group_id = looker_group_id
        self.looker_group_name = looker_group_name
        self.name = name
        self.role_ids = role_ids
        self.url = url
    }

}

public struct SamlMetadataParseResult: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Identify Provider Issuer (read-only)
     */
    public var idp_issuer: String?
    /**
     * Identify Provider Url (read-only)
     */
    public var idp_url: String?
    /**
     * Identify Provider Certificate (read-only)
     */
    public var idp_cert: String?

    public init(can: StringDictionary<Bool>? = nil, idp_issuer: String? = nil, idp_url: String? = nil, idp_cert: String? = nil) {
        self.can = can
        self.idp_issuer = idp_issuer
        self.idp_url = idp_url
        self.idp_cert = idp_cert
    }

}

public struct SamlUserAttributeRead: SDKModel {
    /**
     * Name of User Attribute in Saml (read-only)
     */
    public var name: String?
    /**
     * Required to be in Saml assertion for login to be allowed to succeed (read-only)
     */
    public var required: Bool?
    /**
     * Looker User Attributes (read-only)
     */
    public var user_attributes: [UserAttribute]?
    /**
     * Link to saml config (read-only)
     */
    public var url: URI?

    public init(name: String? = nil, required: Bool? = nil, user_attributes: [UserAttribute]? = nil, url: URI? = nil) {
        self.name = name
        self.required = required
        self.user_attributes = user_attributes
        self.url = url
    }

}

public struct SamlUserAttributeWrite: SDKModel {
    /**
     * Name of User Attribute in Saml
     */
    public var name: String?
    /**
     * Required to be in Saml assertion for login to be allowed to succeed
     */
    public var required: Bool?
    /**
     * Looker User Attribute Ids
     */
    public var user_attribute_ids: [Int64]?
    /**
     * Link to saml config (read-only)
     */
    public var url: URI?

    public init(name: String? = nil, required: Bool? = nil, user_attribute_ids: [Int64]? = nil, url: URI? = nil) {
        self.name = name
        self.required = required
        self.user_attribute_ids = user_attribute_ids
        self.url = url
    }

}

public struct ScheduledPlan: SDKModel {
    /**
     * Name of this scheduled plan
     */
    public var name: String?
    /**
     * User Id which owns this scheduled plan
     */
    public var user_id: Int64?
    /**
     * Whether schedule is run as recipient (only applicable for email recipients)
     */
    public var run_as_recipient: Bool?
    /**
     * Whether the ScheduledPlan is enabled
     */
    public var enabled: Bool?
    /**
     * Id of a look
     */
    public var look_id: Int64?
    /**
     * Id of a dashboard
     */
    public var dashboard_id: Int64?
    /**
     * Id of a LookML dashboard
     */
    public var lookml_dashboard_id: String?
    /**
     * Query string to run look or dashboard with
     */
    public var filters_string: String?
    /**
     * (DEPRECATED) Alias for filters_string field
     */
    public var dashboard_filters: String?
    /**
     * Delivery should occur if running the dashboard or look returns results
     */
    public var require_results: Bool?
    /**
     * Delivery should occur if the dashboard look does not return results
     */
    public var require_no_results: Bool?
    /**
     * Delivery should occur if data have changed since the last run
     */
    public var require_change: Bool?
    /**
     * Will run an unlimited query and send all results.
     */
    public var send_all_results: Bool?
    /**
     * Vixie-Style crontab specification when to run
     */
    public var crontab: String?
    /**
     * Name of a datagroup; if specified will run when datagroup triggered (can't be used with cron string)
     */
    public var datagroup: String?
    /**
     * Timezone for interpreting the specified crontab (default is Looker instance timezone)
     */
    public var timezone: String?
    /**
     * Query id
     */
    public var query_id: String?
    /**
     * Scheduled plan destinations
     */
    public var scheduled_plan_destination: [ScheduledPlanDestination]?
    /**
     * Whether the plan in question should only be run once (usually for testing)
     */
    public var run_once: Bool?
    /**
     * Whether links back to Looker should be included in this ScheduledPlan
     */
    public var include_links: Bool?
    /**
     * The size of paper the PDF should be formatted to fit. Valid values are: "letter", "legal", "tabloid", "a0", "a1", "a2", "a3", "a4", "a5".
     */
    public var pdf_paper_size: String?
    /**
     * Whether the PDF should be formatted for landscape orientation
     */
    public var pdf_landscape: Bool?
    /**
     * Whether this schedule is in an embed context or not
     */
    public var embed: Bool?
    /**
     * Color scheme of the dashboard if applicable
     */
    public var color_theme: String?
    /**
     * Whether or not to expand table vis to full length
     */
    public var long_tables: Bool?
    /**
     * The pixel width at which we render the inline table visualizations
     */
    public var inline_table_width: Int64?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Date and time when ScheduledPlan was created (read-only)
     */
    public var created_at: Date?
    /**
     * Date and time when ScheduledPlan was last updated (read-only)
     */
    public var updated_at: Date?
    /**
     * Title (read-only)
     */
    public var title: String?
    public var user: UserPublic?
    /**
     * When the ScheduledPlan will next run (null if running once) (read-only)
     */
    public var next_run_at: Date?
    /**
     * When the ScheduledPlan was last run (read-only)
     */
    public var last_run_at: Date?
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?

    public init(name: String? = nil, user_id: Int64? = nil, run_as_recipient: Bool? = nil, enabled: Bool? = nil, look_id: Int64? = nil, dashboard_id: Int64? = nil, lookml_dashboard_id: String? = nil, filters_string: String? = nil, dashboard_filters: String? = nil, require_results: Bool? = nil, require_no_results: Bool? = nil, require_change: Bool? = nil, send_all_results: Bool? = nil, crontab: String? = nil, datagroup: String? = nil, timezone: String? = nil, query_id: String? = nil, scheduled_plan_destination: [ScheduledPlanDestination]? = nil, run_once: Bool? = nil, include_links: Bool? = nil, pdf_paper_size: String? = nil, pdf_landscape: Bool? = nil, embed: Bool? = nil, color_theme: String? = nil, long_tables: Bool? = nil, inline_table_width: Int64? = nil, id: Int64? = nil, created_at: Date? = nil, updated_at: Date? = nil, title: String? = nil, user: UserPublic? = nil, next_run_at: Date? = nil, last_run_at: Date? = nil, can: StringDictionary<Bool>? = nil) {
        self.name = name
        self.user_id = user_id
        self.run_as_recipient = run_as_recipient
        self.enabled = enabled
        self.look_id = look_id
        self.dashboard_id = dashboard_id
        self.lookml_dashboard_id = lookml_dashboard_id
        self.filters_string = filters_string
        self.dashboard_filters = dashboard_filters
        self.require_results = require_results
        self.require_no_results = require_no_results
        self.require_change = require_change
        self.send_all_results = send_all_results
        self.crontab = crontab
        self.datagroup = datagroup
        self.timezone = timezone
        self.query_id = query_id
        self.scheduled_plan_destination = scheduled_plan_destination
        self.run_once = run_once
        self.include_links = include_links
        self.pdf_paper_size = pdf_paper_size
        self.pdf_landscape = pdf_landscape
        self.embed = embed
        self.color_theme = color_theme
        self.long_tables = long_tables
        self.inline_table_width = inline_table_width
        self.id = id
        self.created_at = created_at
        self.updated_at = updated_at
        self.title = title
        self.user = user
        self.next_run_at = next_run_at
        self.last_run_at = last_run_at
        self.can = can
    }

}

public struct ScheduledPlanDestination: SDKModel {
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Id of a scheduled plan you own
     */
    public var scheduled_plan_id: Int64?
    /**
     * The data format to send to the given destination. Supported formats vary by destination, but include: "txt", "csv", "inline_json", "json", "json_detail", "xlsx", "html", "wysiwyg_pdf", "assembled_pdf", "wysiwyg_png"
     */
    public var format: String?
    /**
     * Are values formatted? (containing currency symbols, digit separators, etc.
     */
    public var apply_formatting: Bool?
    /**
     * Whether visualization options are applied to the results.
     */
    public var apply_vis: Bool?
    /**
     * Address for recipient. For email e.g. 'user@example.com'. For webhooks e.g. 'https://domain/path'. For Amazon S3 e.g. 's3://bucket-name/path/'. For SFTP e.g. 'sftp://host-name/path/'.
     */
    public var address: String?
    /**
     * Whether the recipient is a Looker user on the current instance (only applicable for email recipients) (read-only)
     */
    public var looker_recipient: Bool?
    /**
     * Type of the address ('email', 'webhook', 's3', or 'sftp')
     */
    public var type: String?
    /**
     * JSON object containing parameters for external scheduling. For Amazon S3, this requires keys and values for access_key_id and region. For SFTP, this requires a key and value for username.
     */
    public var parameters: String?
    /**
     * (Write-Only) JSON object containing secret parameters for external scheduling. For Amazon S3, this requires a key and value for secret_access_key. For SFTP, this requires a key and value for password.
     */
    public var secret_parameters: String?
    /**
     * Optional message to be included in scheduled emails
     */
    public var message: String?

    public init(id: Int64? = nil, scheduled_plan_id: Int64? = nil, format: String? = nil, apply_formatting: Bool? = nil, apply_vis: Bool? = nil, address: String? = nil, looker_recipient: Bool? = nil, type: String? = nil, parameters: String? = nil, secret_parameters: String? = nil, message: String? = nil) {
        self.id = id
        self.scheduled_plan_id = scheduled_plan_id
        self.format = format
        self.apply_formatting = apply_formatting
        self.apply_vis = apply_vis
        self.address = address
        self.looker_recipient = looker_recipient
        self.type = type
        self.parameters = parameters
        self.secret_parameters = secret_parameters
        self.message = message
    }

}

public struct Schema: SDKModel {
    /**
     * Schema name (read-only)
     */
    public var name: String?
    /**
     * True if this is the default schema (read-only)
     */
    public var is_default: Bool?

    public init(name: String? = nil, is_default: Bool? = nil) {
        self.name = name
        self.is_default = is_default
    }

}

public struct SchemaColumn: SDKModel {
    /**
     * Schema item name (read-only)
     */
    public var name: String?
    /**
     * Full name of item (read-only)
     */
    public var sql_escaped_name: String?
    /**
     * Name of schema (read-only)
     */
    public var schema_name: String?
    /**
     * SQL dialect data type (read-only)
     */
    public var data_type_database: String?
    /**
     * Data type (read-only)
     */
    public var data_type: String?
    /**
     * Looker data type (read-only)
     */
    public var data_type_looker: String?
    /**
     * SQL data type (read-only)
     */
    public var description: String?
    /**
     * Column data size (read-only)
     */
    public var column_size: Int64?
    /**
     * SQL Runner snippets for this connection (read-only)
     */
    public var snippets: [Snippet]?

    public init(name: String? = nil, sql_escaped_name: String? = nil, schema_name: String? = nil, data_type_database: String? = nil, data_type: String? = nil, data_type_looker: String? = nil, description: String? = nil, column_size: Int64? = nil, snippets: [Snippet]? = nil) {
        self.name = name
        self.sql_escaped_name = sql_escaped_name
        self.schema_name = schema_name
        self.data_type_database = data_type_database
        self.data_type = data_type
        self.data_type_looker = data_type_looker
        self.description = description
        self.column_size = column_size
        self.snippets = snippets
    }

}

public struct SchemaColumns: SDKModel {
    /**
     * Schema item name (read-only)
     */
    public var name: String?
    /**
     * Full name of item (read-only)
     */
    public var sql_escaped_name: String?
    /**
     * Name of schema (read-only)
     */
    public var schema_name: String?
    /**
     * Columns for this schema (read-only)
     */
    public var columns: [SchemaColumn]?

    public init(name: String? = nil, sql_escaped_name: String? = nil, schema_name: String? = nil, columns: [SchemaColumn]? = nil) {
        self.name = name
        self.sql_escaped_name = sql_escaped_name
        self.schema_name = schema_name
        self.columns = columns
    }

}

public struct SchemaTable: SDKModel {
    /**
     * Schema item name (read-only)
     */
    public var name: String?
    /**
     * Full name of item (read-only)
     */
    public var sql_escaped_name: String?
    /**
     * Name of schema (read-only)
     */
    public var schema_name: String?
    /**
     * Number of data rows (read-only)
     */
    public var rows: Int64?
    /**
     * External reference??? (read-only)
     */
    public var external: String?
    /**
     * SQL Runner snippets for connection (read-only)
     */
    public var snippets: [Snippet]?

    public init(name: String? = nil, sql_escaped_name: String? = nil, schema_name: String? = nil, rows: Int64? = nil, external: String? = nil, snippets: [Snippet]? = nil) {
        self.name = name
        self.sql_escaped_name = sql_escaped_name
        self.schema_name = schema_name
        self.rows = rows
        self.external = external
        self.snippets = snippets
    }

}

public struct SchemaTables: SDKModel {
    /**
     * Schema name (read-only)
     */
    public var name: String?
    /**
     * True if this is the default schema (read-only)
     */
    public var is_default: Bool?
    /**
     * Tables for this schema (read-only)
     */
    public var tables: [SchemaTable]?

    public init(name: String? = nil, is_default: Bool? = nil, tables: [SchemaTable]? = nil) {
        self.name = name
        self.is_default = is_default
        self.tables = tables
    }

}

public struct Session: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * IP address of user when this session was initiated (read-only)
     */
    public var ip_address: String?
    /**
     * User's browser type (read-only)
     */
    public var browser: String?
    /**
     * User's Operating System (read-only)
     */
    public var operating_system: String?
    /**
     * City component of user location (derived from IP address) (read-only)
     */
    public var city: String?
    /**
     * State component of user location (derived from IP address) (read-only)
     */
    public var state: String?
    /**
     * Country component of user location (derived from IP address) (read-only)
     */
    public var country: String?
    /**
     * Type of credentials used for logging in this session (read-only)
     */
    public var credentials_type: String?
    /**
     * Time when this session was last extended by the user (read-only)
     */
    public var extended_at: String?
    /**
     * Number of times this session was extended (read-only)
     */
    public var extended_count: Int64?
    /**
     * Actual user in the case when this session represents one user sudo'ing as another (read-only)
     */
    public var sudo_user_id: Int64?
    /**
     * Time when this session was initiated (read-only)
     */
    public var created_at: String?
    /**
     * Time when this session will expire (read-only)
     */
    public var expires_at: String?
    /**
     * Link to get this item (read-only)
     */
    public var url: URI?

    public init(can: StringDictionary<Bool>? = nil, id: Int64? = nil, ip_address: String? = nil, browser: String? = nil, operating_system: String? = nil, city: String? = nil, state: String? = nil, country: String? = nil, credentials_type: String? = nil, extended_at: String? = nil, extended_count: Int64? = nil, sudo_user_id: Int64? = nil, created_at: String? = nil, expires_at: String? = nil, url: URI? = nil) {
        self.can = can
        self.id = id
        self.ip_address = ip_address
        self.browser = browser
        self.operating_system = operating_system
        self.city = city
        self.state = state
        self.country = country
        self.credentials_type = credentials_type
        self.extended_at = extended_at
        self.extended_count = extended_count
        self.sudo_user_id = sudo_user_id
        self.created_at = created_at
        self.expires_at = expires_at
        self.url = url
    }

}

public struct SessionConfig: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Allow users to have persistent sessions when they login
     */
    public var allow_persistent_sessions: Bool?
    /**
     * Number of minutes for user sessions.  Must be between 5 and 43200
     */
    public var session_minutes: Int64?
    /**
     * Allow users to have an unbounded number of concurrent sessions (otherwise, users will be limited to only one session at a time).
     */
    public var unlimited_sessions_per_user: Bool?
    /**
     * Enforce session logout for sessions that are inactive for 15 minutes.
     */
    public var use_inactivity_based_logout: Bool?
    /**
     * Track location of session when user logs in.
     */
    public var track_session_location: Bool?

    public init(can: StringDictionary<Bool>? = nil, allow_persistent_sessions: Bool? = nil, session_minutes: Int64? = nil, unlimited_sessions_per_user: Bool? = nil, use_inactivity_based_logout: Bool? = nil, track_session_location: Bool? = nil) {
        self.can = can
        self.allow_persistent_sessions = allow_persistent_sessions
        self.session_minutes = session_minutes
        self.unlimited_sessions_per_user = unlimited_sessions_per_user
        self.use_inactivity_based_logout = use_inactivity_based_logout
        self.track_session_location = track_session_location
    }

}

public struct Snippet: SDKModel {
    /**
     * Name of the snippet (read-only)
     */
    public var name: String?
    /**
     * Label of the snippet (read-only)
     */
    public var label: String?
    /**
     * SQL text of the snippet (read-only)
     */
    public var sql: String?

    public init(name: String? = nil, label: String? = nil, sql: String? = nil) {
        self.name = name
        self.label = label
        self.sql = sql
    }

}

public struct SqlQuery: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * The identifier of the SQL query (read-only)
     */
    public var slug: String?
    /**
     * Number of seconds this query took to run the most recent time it was run (read-only)
     */
    public var last_runtime: Float?
    /**
     * Number of times this query has been run (read-only)
     */
    public var run_count: Int64?
    /**
     * Maximum number of rows this query will display on the SQL Runner page (read-only)
     */
    public var browser_limit: Int64?
    /**
     * SQL query text (read-only)
     */
    public var sql: String?
    /**
     * The most recent time this query was run (read-only)
     */
    public var last_run_at: String?
    public var connection: DBConnectionBase?
    /**
     * Model name this query uses (read-only)
     */
    public var model_name: String?
    public var creator: UserPublic?
    /**
     * Explore page URL for this SQL query (read-only)
     */
    public var explore_url: String?
    /**
     * Should this query be rendered as plain text (read-only)
     */
    public var plaintext: Bool?
    /**
     * Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
     */
    public var vis_config: StringDictionary<AnyCodable>?
    /**
     * ID of the ResultMakerLookup entry.
     */
    public var result_maker_id: Int64?

    public init(can: StringDictionary<Bool>? = nil, slug: String? = nil, last_runtime: Float? = nil, run_count: Int64? = nil, browser_limit: Int64? = nil, sql: String? = nil, last_run_at: String? = nil, connection: DBConnectionBase? = nil, model_name: String? = nil, creator: UserPublic? = nil, explore_url: String? = nil, plaintext: Bool? = nil, vis_config: StringDictionary<AnyCodable>? = nil, result_maker_id: Int64? = nil) {
        self.can = can
        self.slug = slug
        self.last_runtime = last_runtime
        self.run_count = run_count
        self.browser_limit = browser_limit
        self.sql = sql
        self.last_run_at = last_run_at
        self.connection = connection
        self.model_name = model_name
        self.creator = creator
        self.explore_url = explore_url
        self.plaintext = plaintext
        self.vis_config = vis_config
        self.result_maker_id = result_maker_id
    }

}

public struct SqlQueryCreate: SDKModel {
    /**
     * Name of the db connection on which to run this query
     */
    public var connection_name: String?
    /**
     * (DEPRECATED) Use `connection_name` instead
     */
    public var connection_id: String?
    /**
     * Name of LookML Model (this or `connection_id` required)
     */
    public var model_name: String?
    /**
     * SQL query
     */
    public var sql: String?
    /**
     * Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
     */
    public var vis_config: StringDictionary<AnyCodable>?

    public init(connection_name: String? = nil, connection_id: String? = nil, model_name: String? = nil, sql: String? = nil, vis_config: StringDictionary<AnyCodable>? = nil) {
        self.connection_name = connection_name
        self.connection_id = connection_id
        self.model_name = model_name
        self.sql = sql
        self.vis_config = vis_config
    }

}

public struct SshPublicKey: SDKModel {
    /**
     * The SSH public key created for this instance (read-only)
     */
    public var public_key: String?

    public init(public_key: String? = nil) {
        self.public_key = public_key
    }

}

public struct SshServer: SDKModel {
    /**
     * A unique id used to identify this SSH Server (read-only)
     */
    public var ssh_server_id: String?
    /**
     * The name to identify this SSH Server
     */
    public var ssh_server_name: String?
    /**
     * The hostname or ip address of the SSH Server
     */
    public var ssh_server_host: String?
    /**
     * The port to connect to on the SSH Server
     */
    public var ssh_server_port: Int64?
    /**
     * The username used to connect to the SSH Server
     */
    public var ssh_server_user: String?
    /**
     * The md5 fingerprint used to identify the SSH Server (read-only)
     */
    public var finger_print: String?
    /**
     * The SHA fingerprint used to identify the SSH Server (read-only)
     */
    public var sha_finger_print: String?
    /**
     * The SSH public key created for this instance (read-only)
     */
    public var public_key: String?
    /**
     * The current connection status to this SSH Server (read-only)
     */
    public var status: String?

    public init(ssh_server_id: String? = nil, ssh_server_name: String? = nil, ssh_server_host: String? = nil, ssh_server_port: Int64? = nil, ssh_server_user: String? = nil, finger_print: String? = nil, sha_finger_print: String? = nil, public_key: String? = nil, status: String? = nil) {
        self.ssh_server_id = ssh_server_id
        self.ssh_server_name = ssh_server_name
        self.ssh_server_host = ssh_server_host
        self.ssh_server_port = ssh_server_port
        self.ssh_server_user = ssh_server_user
        self.finger_print = finger_print
        self.sha_finger_print = sha_finger_print
        self.public_key = public_key
        self.status = status
    }

}

public struct SshTunnel: SDKModel {
    /**
     * Unique ID for the tunnel (read-only)
     */
    public var tunnel_id: String?
    /**
     * SSH Server ID
     */
    public var ssh_server_id: String?
    /**
     * SSH Server name (read-only)
     */
    public var ssh_server_name: String?
    /**
     * SSH Server Hostname or IP Address (read-only)
     */
    public var ssh_server_host: String?
    /**
     * SSH Server port (read-only)
     */
    public var ssh_server_port: Int64?
    /**
     * Username used to connect to the SSH Server (read-only)
     */
    public var ssh_server_user: String?
    /**
     * Time of last connect attempt (read-only)
     */
    public var last_attempt: String?
    /**
     * Localhost Port used by the Looker instance to connect to the remote DB (read-only)
     */
    public var local_host_port: Int64?
    /**
     * Hostname or IP Address of the Database Server
     */
    public var database_host: String?
    /**
     * Port that the Database Server is listening on
     */
    public var database_port: Int64?
    /**
     * Current connection status for this Tunnel (read-only)
     */
    public var status: String?

    public init(tunnel_id: String? = nil, ssh_server_id: String? = nil, ssh_server_name: String? = nil, ssh_server_host: String? = nil, ssh_server_port: Int64? = nil, ssh_server_user: String? = nil, last_attempt: String? = nil, local_host_port: Int64? = nil, database_host: String? = nil, database_port: Int64? = nil, status: String? = nil) {
        self.tunnel_id = tunnel_id
        self.ssh_server_id = ssh_server_id
        self.ssh_server_name = ssh_server_name
        self.ssh_server_host = ssh_server_host
        self.ssh_server_port = ssh_server_port
        self.ssh_server_user = ssh_server_user
        self.last_attempt = last_attempt
        self.local_host_port = local_host_port
        self.database_host = database_host
        self.database_port = database_port
        self.status = status
    }

}

/**
 * A list of action types the integration supports. Valid values are: "cell", "query", "dashboard".
 */
public enum SupportedActionTypes: String, Codable {
    case cell = "cell"
    case query = "query"
    case dashboard = "dashboard"
}

/**
 * A list of all the download mechanisms the integration supports. The order of values is not significant: Looker will select the most appropriate supported download mechanism for a given query. The integration must ensure it can handle any of the mechanisms it claims to support. If unspecified, this defaults to all download setting values. Valid values are: "push", "url".
 */
public enum SupportedDownloadSettings: String, Codable {
    case push = "push"
    case url = "url"
}

/**
 * A list of data formats the integration supports. If unspecified, the default is all data formats. Valid values are: "txt", "csv", "inline_json", "json", "json_label", "json_detail", "json_detail_lite_stream", "xlsx", "html", "wysiwyg_pdf", "assembled_pdf", "wysiwyg_png", "csv_zip".
 */
public enum SupportedFormats: String, Codable {
    case txt = "txt"
    case csv = "csv"
    case inline_json = "inline_json"
    case json = "json"
    case json_label = "json_label"
    case json_detail = "json_detail"
    case json_detail_lite_stream = "json_detail_lite_stream"
    case xlsx = "xlsx"
    case html = "html"
    case wysiwyg_pdf = "wysiwyg_pdf"
    case assembled_pdf = "assembled_pdf"
    case wysiwyg_png = "wysiwyg_png"
    case csv_zip = "csv_zip"
}

/**
 * A list of formatting options the integration supports. If unspecified, defaults to all formats. Valid values are: "formatted", "unformatted".
 */
public enum SupportedFormattings: String, Codable {
    case formatted = "formatted"
    case unformatted = "unformatted"
}

/**
 * A list of visualization formatting options the integration supports. If unspecified, defaults to all formats. Valid values are: "apply", "noapply".
 */
public enum SupportedVisualizationFormattings: String, Codable {
    case apply = "apply"
    case noapply = "noapply"
}

public struct Theme: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Timestamp for when this theme becomes active. Null=always
     */
    public var begin_at: Date?
    /**
     * Timestamp for when this theme expires. Null=never
     */
    public var end_at: Date?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Name of theme. Can only be alphanumeric and underscores.
     */
    public var name: String?
    public var settings: ThemeSettings?

    public init(can: StringDictionary<Bool>? = nil, begin_at: Date? = nil, end_at: Date? = nil, id: Int64? = nil, name: String? = nil, settings: ThemeSettings? = nil) {
        self.can = can
        self.begin_at = begin_at
        self.end_at = end_at
        self.id = id
        self.name = name
        self.settings = settings
    }

}

public struct ThemeSettings: SDKModel {
    /**
     * Default background color
     */
    public var background_color: String?
    /**
     * Base font size for scaling fonts
     */
    public var base_font_size: String?
    /**
     * Optional. ID of color collection to use with the theme. Use an empty string for none.
     */
    public var color_collection_id: String?
    /**
     * Default font color
     */
    public var font_color: String?
    /**
     * Primary font family
     */
    public var font_family: String?
    /**
     * Source specification for font
     */
    public var font_source: String?
    /**
     * Info button color
     */
    public var info_button_color: String?
    /**
     * Primary button color
     */
    public var primary_button_color: String?
    /**
     * Toggle to show filters. Defaults to true.
     */
    public var show_filters_bar: Bool?
    /**
     * Toggle to show the title. Defaults to true.
     */
    public var show_title: Bool?
    /**
     * Text color for text tiles
     */
    public var text_tile_text_color: String?
    /**
     * Background color for tiles
     */
    public var tile_background_color: String?
    /**
     * Text color for tiles
     */
    public var tile_text_color: String?
    /**
     * Color for titles
     */
    public var title_color: String?
    /**
     * Warning button color
     */
    public var warn_button_color: String?
    /**
     * The text alignment of tile titles (New Dashboards)
     */
    public var tile_title_alignment: String?
    /**
     * Toggles the tile shadow (New Dashboards)
     */
    public var tile_shadow: Bool?

    public init(background_color: String? = nil, base_font_size: String? = nil, color_collection_id: String? = nil, font_color: String? = nil, font_family: String? = nil, font_source: String? = nil, info_button_color: String? = nil, primary_button_color: String? = nil, show_filters_bar: Bool? = nil, show_title: Bool? = nil, text_tile_text_color: String? = nil, tile_background_color: String? = nil, tile_text_color: String? = nil, title_color: String? = nil, warn_button_color: String? = nil, tile_title_alignment: String? = nil, tile_shadow: Bool? = nil) {
        self.background_color = background_color
        self.base_font_size = base_font_size
        self.color_collection_id = color_collection_id
        self.font_color = font_color
        self.font_family = font_family
        self.font_source = font_source
        self.info_button_color = info_button_color
        self.primary_button_color = primary_button_color
        self.show_filters_bar = show_filters_bar
        self.show_title = show_title
        self.text_tile_text_color = text_tile_text_color
        self.tile_background_color = tile_background_color
        self.tile_text_color = tile_text_color
        self.title_color = title_color
        self.warn_button_color = warn_button_color
        self.tile_title_alignment = tile_title_alignment
        self.tile_shadow = tile_shadow
    }

}

public struct Timezone: SDKModel {
    /**
     * Timezone (read-only)
     */
    public var value: String?
    /**
     * Description of timezone (read-only)
     */
    public var label: String?
    /**
     * Timezone group (e.g Common, Other, etc.) (read-only)
     */
    public var group: String?

    public init(value: String? = nil, label: String? = nil, group: String? = nil) {
        self.value = value
        self.label = label
        self.group = group
    }

}

public struct UpdateCommand: SDKModel {
    /**
     * Name of the command
     */
    public var name: String?
    /**
     * Description of the command
     */
    public var description: String?

    public init(name: String? = nil, description: String? = nil) {
        self.name = name
        self.description = description
    }

}

public struct UpdateFolder: SDKModel {
    /**
     * Unique Name
     */
    public var name: String?
    /**
     * Id of Parent. If the parent id is null, this is a root-level entry
     */
    public var parent_id: String?

    public init(name: String? = nil, parent_id: String? = nil) {
        self.name = name
        self.parent_id = parent_id
    }

}

public struct User: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * URL for the avatar image (may be generic) (read-only)
     */
    public var avatar_url: URI?
    /**
     * URL for the avatar image (may be generic), does not specify size (read-only)
     */
    public var avatar_url_without_sizing: URI?
    /**
     * API 3 credentials (read-only)
     */
    public var credentials_api3: [CredentialsApi3]?
    public var credentials_email: CredentialsEmail?
    /**
     * Embed credentials (read-only)
     */
    public var credentials_embed: [CredentialsEmbed]?
    public var credentials_google: CredentialsGoogle?
    public var credentials_ldap: CredentialsLDAP?
    public var credentials_looker_openid: CredentialsLookerOpenid?
    public var credentials_oidc: CredentialsOIDC?
    public var credentials_saml: CredentialsSaml?
    public var credentials_totp: CredentialsTotp?
    /**
     * Full name for display (available only if both first_name and last_name are set) (read-only)
     */
    public var display_name: String?
    /**
     * EMail address (read-only)
     */
    public var email: String?
    /**
     * (Embed only) ID of user's group space based on the external_group_id optionally specified during embed user login (read-only)
     */
    public var embed_group_space_id: Int64?
    /**
     * First name
     */
    public var first_name: String?
    /**
     * Array of ids of the groups for this user (read-only)
     */
    public var group_ids: [Int64]?
    /**
     * ID string for user's home folder
     */
    public var home_folder_id: String?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Account has been disabled
     */
    public var is_disabled: Bool?
    /**
     * Last name
     */
    public var last_name: String?
    /**
     * User's preferred locale. User locale takes precedence over Looker's system-wide default locale. Locale determines language of display strings and date and numeric formatting in API responses. Locale string must be a 2 letter language code or a combination of language code and region code: 'en' or 'en-US', for example.
     */
    public var locale: String?
    /**
     * Array of strings representing the Looker versions that this user has used (this only goes back as far as '3.54.0') (read-only)
     */
    public var looker_versions: [String]?
    /**
     * User's dev workspace has been checked for presence of applicable production projects
     */
    public var models_dir_validated: Bool?
    /**
     * ID of user's personal folder (read-only)
     */
    public var personal_folder_id: Int64?
    /**
     * User is identified as an employee of Looker (read-only)
     */
    public var presumed_looker_employee: Bool?
    /**
     * Array of ids of the roles for this user (read-only)
     */
    public var role_ids: [Int64]?
    /**
     * Active sessions (read-only)
     */
    public var sessions: [Session]?
    /**
     * Per user dictionary of undocumented state information owned by the Looker UI.
     */
    public var ui_state: StringDictionary<AnyCodable>?
    /**
     * User is identified as an employee of Looker who has been verified via Looker corporate authentication (read-only)
     */
    public var verified_looker_employee: Bool?
    /**
     * User's roles are managed by an external directory like SAML or LDAP and can not be changed directly. (read-only)
     */
    public var roles_externally_managed: Bool?
    /**
     * User can be directly assigned a role. (read-only)
     */
    public var allow_direct_roles: Bool?
    /**
     * User can be a direct member of a normal Looker group. (read-only)
     */
    public var allow_normal_group_membership: Bool?
    /**
     * User can inherit roles from a normal Looker group. (read-only)
     */
    public var allow_roles_from_normal_groups: Bool?
    /**
     * Link to get this item (read-only)
     */
    public var url: URI?

    public init(can: StringDictionary<Bool>? = nil, avatar_url: URI? = nil, avatar_url_without_sizing: URI? = nil, credentials_api3: [CredentialsApi3]? = nil, credentials_email: CredentialsEmail? = nil, credentials_embed: [CredentialsEmbed]? = nil, credentials_google: CredentialsGoogle? = nil, credentials_ldap: CredentialsLDAP? = nil, credentials_looker_openid: CredentialsLookerOpenid? = nil, credentials_oidc: CredentialsOIDC? = nil, credentials_saml: CredentialsSaml? = nil, credentials_totp: CredentialsTotp? = nil, display_name: String? = nil, email: String? = nil, embed_group_space_id: Int64? = nil, first_name: String? = nil, group_ids: [Int64]? = nil, home_folder_id: String? = nil, id: Int64? = nil, is_disabled: Bool? = nil, last_name: String? = nil, locale: String? = nil, looker_versions: [String]? = nil, models_dir_validated: Bool? = nil, personal_folder_id: Int64? = nil, presumed_looker_employee: Bool? = nil, role_ids: [Int64]? = nil, sessions: [Session]? = nil, ui_state: StringDictionary<AnyCodable>? = nil, verified_looker_employee: Bool? = nil, roles_externally_managed: Bool? = nil, allow_direct_roles: Bool? = nil, allow_normal_group_membership: Bool? = nil, allow_roles_from_normal_groups: Bool? = nil, url: URI? = nil) {
        self.can = can
        self.avatar_url = avatar_url
        self.avatar_url_without_sizing = avatar_url_without_sizing
        self.credentials_api3 = credentials_api3
        self.credentials_email = credentials_email
        self.credentials_embed = credentials_embed
        self.credentials_google = credentials_google
        self.credentials_ldap = credentials_ldap
        self.credentials_looker_openid = credentials_looker_openid
        self.credentials_oidc = credentials_oidc
        self.credentials_saml = credentials_saml
        self.credentials_totp = credentials_totp
        self.display_name = display_name
        self.email = email
        self.embed_group_space_id = embed_group_space_id
        self.first_name = first_name
        self.group_ids = group_ids
        self.home_folder_id = home_folder_id
        self.id = id
        self.is_disabled = is_disabled
        self.last_name = last_name
        self.locale = locale
        self.looker_versions = looker_versions
        self.models_dir_validated = models_dir_validated
        self.personal_folder_id = personal_folder_id
        self.presumed_looker_employee = presumed_looker_employee
        self.role_ids = role_ids
        self.sessions = sessions
        self.ui_state = ui_state
        self.verified_looker_employee = verified_looker_employee
        self.roles_externally_managed = roles_externally_managed
        self.allow_direct_roles = allow_direct_roles
        self.allow_normal_group_membership = allow_normal_group_membership
        self.allow_roles_from_normal_groups = allow_roles_from_normal_groups
        self.url = url
    }

}

public struct UserAttribute: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Name of user attribute
     */
    public var name: String?
    /**
     * Human-friendly label for user attribute
     */
    public var label: String?
    /**
     * Type of user attribute ("string", "number", "datetime", "yesno", "zipcode")
     */
    public var type: String?
    /**
     * Default value for when no value is set on the user
     */
    public var default_value: String?
    /**
     * Attribute is a system default (read-only)
     */
    public var is_system: Bool?
    /**
     * Attribute is permanent and cannot be deleted (read-only)
     */
    public var is_permanent: Bool?
    /**
     * If true, users will not be able to view values of this attribute
     */
    public var value_is_hidden: Bool?
    /**
     * Non-admin users can see the values of their attributes and use them in filters
     */
    public var user_can_view: Bool?
    /**
     * Users can change the value of this attribute for themselves
     */
    public var user_can_edit: Bool?
    /**
     * Destinations to which a hidden attribute may be sent. Once set, cannot be edited.
     */
    public var hidden_value_domain_whitelist: String?

    public init(can: StringDictionary<Bool>? = nil, id: Int64? = nil, name: String? = nil, label: String? = nil, type: String? = nil, default_value: String? = nil, is_system: Bool? = nil, is_permanent: Bool? = nil, value_is_hidden: Bool? = nil, user_can_view: Bool? = nil, user_can_edit: Bool? = nil, hidden_value_domain_whitelist: String? = nil) {
        self.can = can
        self.id = id
        self.name = name
        self.label = label
        self.type = type
        self.default_value = default_value
        self.is_system = is_system
        self.is_permanent = is_permanent
        self.value_is_hidden = value_is_hidden
        self.user_can_view = user_can_view
        self.user_can_edit = user_can_edit
        self.hidden_value_domain_whitelist = hidden_value_domain_whitelist
    }

}

/**
 * An array of user attribute types that are allowed to be used in filters on this field. Valid values are: "advanced_filter_string", "advanced_filter_number", "advanced_filter_datetime", "string", "number", "datetime", "relative_url", "yesno", "zipcode".
 */
public enum UserAttributeFilterTypes: String, Codable {
    case advanced_filter_string = "advanced_filter_string"
    case advanced_filter_number = "advanced_filter_number"
    case advanced_filter_datetime = "advanced_filter_datetime"
    case string = "string"
    case number = "number"
    case datetime = "datetime"
    case relative_url = "relative_url"
    case yesno = "yesno"
    case zipcode = "zipcode"
}

public struct UserAttributeGroupValue: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Unique Id of this group-attribute relation (read-only)
     */
    public var id: Int64?
    /**
     * Id of group (read-only)
     */
    public var group_id: Int64?
    /**
     * Id of user attribute (read-only)
     */
    public var user_attribute_id: Int64?
    /**
     * If true, the "value" field will be null, because the attribute settings block access to this value (read-only)
     */
    public var value_is_hidden: Bool?
    /**
     * Precedence for resolving value for user (read-only)
     */
    public var rank: Int64?
    /**
     * Value of user attribute for group (read-only)
     */
    public var value: String?

    public init(can: StringDictionary<Bool>? = nil, id: Int64? = nil, group_id: Int64? = nil, user_attribute_id: Int64? = nil, value_is_hidden: Bool? = nil, rank: Int64? = nil, value: String? = nil) {
        self.can = can
        self.id = id
        self.group_id = group_id
        self.user_attribute_id = user_attribute_id
        self.value_is_hidden = value_is_hidden
        self.rank = rank
        self.value = value
    }

}

public struct UserAttributeWithValue: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Name of user attribute (read-only)
     */
    public var name: String?
    /**
     * Human-friendly label for user attribute (read-only)
     */
    public var label: String?
    /**
     * Precedence for setting value on user (lowest wins) (read-only)
     */
    public var rank: Int64?
    /**
     * Value of attribute for user
     */
    public var value: String?
    /**
     * Id of User (read-only)
     */
    public var user_id: Int64?
    /**
     * Can the user set this value (read-only)
     */
    public var user_can_edit: Bool?
    /**
     * If true, the "value" field will be null, because the attribute settings block access to this value (read-only)
     */
    public var value_is_hidden: Bool?
    /**
     * Id of User Attribute (read-only)
     */
    public var user_attribute_id: Int64?
    /**
     * How user got this value for this attribute (read-only)
     */
    public var source: String?
    /**
     * If this user attribute is hidden, whitelist of destinations to which it may be sent. (read-only)
     */
    public var hidden_value_domain_whitelist: String?

    public init(can: StringDictionary<Bool>? = nil, name: String? = nil, label: String? = nil, rank: Int64? = nil, value: String? = nil, user_id: Int64? = nil, user_can_edit: Bool? = nil, value_is_hidden: Bool? = nil, user_attribute_id: Int64? = nil, source: String? = nil, hidden_value_domain_whitelist: String? = nil) {
        self.can = can
        self.name = name
        self.label = label
        self.rank = rank
        self.value = value
        self.user_id = user_id
        self.user_can_edit = user_can_edit
        self.value_is_hidden = value_is_hidden
        self.user_attribute_id = user_attribute_id
        self.source = source
        self.hidden_value_domain_whitelist = hidden_value_domain_whitelist
    }

}

public struct UserLoginLockout: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Hash of user's client id (read-only)
     */
    public var key: String?
    /**
     * Authentication method for login failures (read-only)
     */
    public var auth_type: String?
    /**
     * IP address of most recent failed attempt (read-only)
     */
    public var ip: String?
    /**
     * User ID (read-only)
     */
    public var user_id: Int64?
    /**
     * Remote ID of user if using LDAP (read-only)
     */
    public var remote_id: String?
    /**
     * User's name (read-only)
     */
    public var full_name: String?
    /**
     * Email address associated with the user's account (read-only)
     */
    public var email: String?
    /**
     * Number of failures that triggered the lockout (read-only)
     */
    public var fail_count: Int64?
    /**
     * Time when lockout was triggered (read-only)
     */
    public var lockout_at: Date?

    public init(can: StringDictionary<Bool>? = nil, key: String? = nil, auth_type: String? = nil, ip: String? = nil, user_id: Int64? = nil, remote_id: String? = nil, full_name: String? = nil, email: String? = nil, fail_count: Int64? = nil, lockout_at: Date? = nil) {
        self.can = can
        self.key = key
        self.auth_type = auth_type
        self.ip = ip
        self.user_id = user_id
        self.remote_id = remote_id
        self.full_name = full_name
        self.email = email
        self.fail_count = fail_count
        self.lockout_at = lockout_at
    }

}

public struct UserPublic: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * First Name (read-only)
     */
    public var first_name: String?
    /**
     * Last Name (read-only)
     */
    public var last_name: String?
    /**
     * Full name for display (available only if both first_name and last_name are set) (read-only)
     */
    public var display_name: String?
    /**
     * URL for the avatar image (may be generic) (read-only)
     */
    public var avatar_url: URI?
    /**
     * Link to get this item (read-only)
     */
    public var url: URI?

    public init(can: StringDictionary<Bool>? = nil, id: Int64? = nil, first_name: String? = nil, last_name: String? = nil, display_name: String? = nil, avatar_url: URI? = nil, url: URI? = nil) {
        self.can = can
        self.id = id
        self.first_name = first_name
        self.last_name = last_name
        self.display_name = display_name
        self.avatar_url = avatar_url
        self.url = url
    }

}

public struct ValidationError: SDKModel {
    /**
     * Error details (read-only)
     */
    public var message: String
    /**
     * Error detail array (read-only)
     */
    public var errors: [ValidationErrorDetail]?
    /**
     * Documentation link (read-only)
     */
    public var documentation_url: URI

    public init(message: String, errors: [ValidationErrorDetail]? = nil, documentation_url: URI) {
        self.message = message
        self.errors = errors
        self.documentation_url = documentation_url
    }

    public init(_ message: String, errors: [ValidationErrorDetail]? = nil, _ documentation_url: URI) {
        self.init(message: message, errors: errors, documentation_url: documentation_url)
    }

}

public struct ValidationErrorDetail: SDKModel {
    /**
     * Field with error (read-only)
     */
    public var field: String?
    /**
     * Error code (read-only)
     */
    public var code: String?
    /**
     * Error info message (read-only)
     */
    public var message: String?
    /**
     * Documentation link (read-only)
     */
    public var documentation_url: URI

    public init(field: String? = nil, code: String? = nil, message: String? = nil, documentation_url: URI) {
        self.field = field
        self.code = code
        self.message = message
        self.documentation_url = documentation_url
    }

    public init(field: String? = nil, code: String? = nil, message: String? = nil, _ documentation_url: URI) {
        self.init(field: field, code: code, message: message, documentation_url: documentation_url)
    }

}

/**
 * The name of the starting day of the week. Valid values are: "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday".
 */
public enum WeekStartDay: String, Codable {
    case monday = "monday"
    case tuesday = "tuesday"
    case wednesday = "wednesday"
    case thursday = "thursday"
    case friday = "friday"
    case saturday = "saturday"
    case sunday = "sunday"
}

public struct WelcomeEmailTest: SDKModel {
    /**
     * The content that would be sent in the body of a custom welcome email
     */
    public var content: String?
    /**
     * The subject that would be sent for the custom welcome email
     */
    public var subject: String?
    /**
     * The header that would be sent in the body of a custom welcome email
     */
    public var header: String?

    public init(content: String? = nil, subject: String? = nil, header: String? = nil) {
        self.content = content
        self.subject = subject
        self.header = header
    }

}

public struct WhitelabelConfiguration: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * Unique Id (read-only)
     */
    public var id: Int64?
    /**
     * Customer logo image. Expected base64 encoded data (write-only)
     */
    public var logo_file: String?
    /**
     * Logo image url (read-only) (read-only)
     */
    public var logo_url: String?
    /**
     * Custom favicon image. Expected base64 encoded data (write-only)
     */
    public var favicon_file: String?
    /**
     * Favicon image url (read-only) (read-only)
     */
    public var favicon_url: String?
    /**
     * Default page title
     */
    public var default_title: String?
    /**
     * Boolean to toggle showing help menus
     */
    public var show_help_menu: Bool?
    /**
     * Boolean to toggle showing docs
     */
    public var show_docs: Bool?
    /**
     * Boolean to toggle showing email subscription options.
     */
    public var show_email_sub_options: Bool?
    /**
     * Boolean to toggle mentions of Looker in emails
     */
    public var allow_looker_mentions: Bool?
    /**
     * Boolean to toggle links to Looker in emails
     */
    public var allow_looker_links: Bool?
    /**
     * Allow subject line and email heading customization in customized emails”
     */
    public var custom_welcome_email_advanced: Bool?
    /**
     * Remove the word Looker from appearing in the account setup page
     */
    public var setup_mentions: Bool?
    /**
     * Remove Looker logo from Alerts
     */
    public var alerts_logo: Bool?
    /**
     * Remove Looker links from Alerts
     */
    public var alerts_links: Bool?
    /**
     * Remove Looker mentions in home folder page when you don’t have any items saved
     */
    public var folders_mentions: Bool?

    public init(can: StringDictionary<Bool>? = nil, id: Int64? = nil, logo_file: String? = nil, logo_url: String? = nil, favicon_file: String? = nil, favicon_url: String? = nil, default_title: String? = nil, show_help_menu: Bool? = nil, show_docs: Bool? = nil, show_email_sub_options: Bool? = nil, allow_looker_mentions: Bool? = nil, allow_looker_links: Bool? = nil, custom_welcome_email_advanced: Bool? = nil, setup_mentions: Bool? = nil, alerts_logo: Bool? = nil, alerts_links: Bool? = nil, folders_mentions: Bool? = nil) {
        self.can = can
        self.id = id
        self.logo_file = logo_file
        self.logo_url = logo_url
        self.favicon_file = favicon_file
        self.favicon_url = favicon_url
        self.default_title = default_title
        self.show_help_menu = show_help_menu
        self.show_docs = show_docs
        self.show_email_sub_options = show_email_sub_options
        self.allow_looker_mentions = allow_looker_mentions
        self.allow_looker_links = allow_looker_links
        self.custom_welcome_email_advanced = custom_welcome_email_advanced
        self.setup_mentions = setup_mentions
        self.alerts_logo = alerts_logo
        self.alerts_links = alerts_links
        self.folders_mentions = folders_mentions
    }

}

public struct Workspace: SDKModel {
    /**
     * Operations the current user is able to perform on this object (read-only)
     */
    public var can: StringDictionary<Bool>?
    /**
     * The unique id of this user workspace. Predefined workspace ids include "production" and "dev" (read-only)
     */
    public var id: String?
    /**
     * The local state of each project in the workspace (read-only)
     */
    public var projects: [Project]?

    public init(can: StringDictionary<Bool>? = nil, id: String? = nil, projects: [Project]? = nil) {
        self.can = can
        self.id = id
        self.projects = projects
    }

}

/**
 * Dynamically generated writeable type for ApiSession removes properties:
 * can, sudo_user_id
 */
public struct WriteApiSession: SDKModel {
    /**
     * The id of active workspace for this session
     */
    public var workspace_id: String?

    public init(workspace_id: String? = nil) {
        self.workspace_id = workspace_id
    }

}

/**
 * Dynamically generated writeable type for BackupConfiguration removes properties:
 * can, url
 */
public struct WriteBackupConfiguration: SDKModel {
    /**
     * Type of backup: looker-s3 or custom-s3
     */
    public var type: String?
    /**
     * Name of bucket for custom-s3 backups
     */
    public var custom_s3_bucket: String?
    /**
     * Name of region where the bucket is located
     */
    public var custom_s3_bucket_region: String?
    /**
     * (Write-Only) AWS S3 key used for custom-s3 backups
     */
    public var custom_s3_key: String?
    /**
     * (Write-Only) AWS S3 secret used for custom-s3 backups
     */
    public var custom_s3_secret: String?

    public init(type: String? = nil, custom_s3_bucket: String? = nil, custom_s3_bucket_region: String? = nil, custom_s3_key: String? = nil, custom_s3_secret: String? = nil) {
        self.type = type
        self.custom_s3_bucket = custom_s3_bucket
        self.custom_s3_bucket_region = custom_s3_bucket_region
        self.custom_s3_key = custom_s3_key
        self.custom_s3_secret = custom_s3_secret
    }

}

/**
 * Dynamically generated writeable type for Board removes properties:
 * can, content_metadata_id, created_at, board_sections, id, updated_at, user_id, primary_homepage
 */
public struct WriteBoard: SDKModel {
    /**
     * Date of board deletion
     */
    public var deleted_at: Date?
    /**
     * Description of the board
     */
    public var description: String?
    /**
     * ids of the board sections in the order they should be displayed
     */
    public var section_order: [Int64]?
    /**
     * Title of the board
     */
    public var title: String?

    public init(deleted_at: Date? = nil, description: String? = nil, section_order: [Int64]? = nil, title: String? = nil) {
        self.deleted_at = deleted_at
        self.description = description
        self.section_order = section_order
        self.title = title
    }

}

/**
 * Dynamically generated writeable type for BoardItem removes properties:
 * can, content_created_by, content_favorite_id, content_metadata_id, content_updated_at, description, favorite_count, id, location, title, url, view_count
 */
public struct WriteBoardItem: SDKModel {
    /**
     * Dashboard to base this item on
     */
    public var dashboard_id: Int64?
    /**
     * Associated Board Section
     */
    public var board_section_id: Int64?
    /**
     * Look to base this item on
     */
    public var look_id: Int64?
    /**
     * LookML Dashboard to base this item on
     */
    public var lookml_dashboard_id: String?
    /**
     * An arbitrary integer representing the sort order within the section
     */
    public var order: Int64?

    public init(dashboard_id: Int64? = nil, board_section_id: Int64? = nil, look_id: Int64? = nil, lookml_dashboard_id: String? = nil, order: Int64? = nil) {
        self.dashboard_id = dashboard_id
        self.board_section_id = board_section_id
        self.look_id = look_id
        self.lookml_dashboard_id = lookml_dashboard_id
        self.order = order
    }

}

/**
 * Dynamically generated writeable type for BoardSection removes properties:
 * can, created_at, board_items, id, updated_at
 */
public struct WriteBoardSection: SDKModel {
    /**
     * Time at which this section was deleted.
     */
    public var deleted_at: Date?
    /**
     * Description of the content found in this section.
     */
    public var description: String?
    /**
     * Id reference to parent board
     */
    public var board_id: Int64?
    /**
     * ids of the board items in the order they should be displayed
     */
    public var item_order: [Int64]?
    /**
     * Name of row
     */
    public var title: String?

    public init(deleted_at: Date? = nil, description: String? = nil, board_id: Int64? = nil, item_order: [Int64]? = nil, title: String? = nil) {
        self.deleted_at = deleted_at
        self.description = description
        self.board_id = board_id
        self.item_order = item_order
        self.title = title
    }

}

/**
 * Dynamically generated writeable type for ColorCollection removes properties:
 * id
 */
public struct WriteColorCollection: SDKModel {
    /**
     * Label of color collection
     */
    public var label: String?
    /**
     * Array of categorical palette definitions
     */
    public var categoricalPalettes: [DiscretePalette]?
    /**
     * Array of discrete palette definitions
     */
    public var sequentialPalettes: [ContinuousPalette]?
    /**
     * Array of diverging palette definitions
     */
    public var divergingPalettes: [ContinuousPalette]?

    public init(label: String? = nil, categoricalPalettes: [DiscretePalette]? = nil, sequentialPalettes: [ContinuousPalette]? = nil, divergingPalettes: [ContinuousPalette]? = nil) {
        self.label = label
        self.categoricalPalettes = categoricalPalettes
        self.sequentialPalettes = sequentialPalettes
        self.divergingPalettes = divergingPalettes
    }

}

/**
 * Dynamically generated writeable type for Command removes properties:
 * id, author_id
 */
public struct WriteCommand: SDKModel {
    /**
     * Name of the command
     */
    public var name: String?
    /**
     * Description of the command
     */
    public var description: String?
    /**
     * Id of the content associated with the command
     */
    public var linked_content_id: String?
    /**
     * Name of the command Valid values are: "dashboard", "lookml_dashboard".
     */
    public var linked_content_type: LinkedContentType?

    public init(name: String? = nil, description: String? = nil, linked_content_id: String? = nil, linked_content_type: LinkedContentType? = nil) {
        self.name = name
        self.description = description
        self.linked_content_id = linked_content_id
        self.linked_content_type = linked_content_type
    }

}

/**
 * Dynamically generated writeable type for ContentFavorite removes properties:
 * id, look_id, dashboard_id, board_id
 */
public struct WriteContentFavorite: SDKModel {
    /**
     * User Id which owns this ContentFavorite
     */
    public var user_id: Int64?
    /**
     * Content Metadata Id associated with this ContentFavorite
     */
    public var content_metadata_id: Int64?
    public var look: WriteLookBasic?
    public var dashboard: WriteDashboardBase?

    public init(user_id: Int64? = nil, content_metadata_id: Int64? = nil, look: WriteLookBasic? = nil, dashboard: WriteDashboardBase? = nil) {
        self.user_id = user_id
        self.content_metadata_id = content_metadata_id
        self.look = look
        self.dashboard = dashboard
    }

}

/**
 * Dynamically generated writeable type for ContentMeta removes properties:
 * can, id, name, parent_id, dashboard_id, look_id, folder_id, content_type, inheriting_id, slug
 */
public struct WriteContentMeta: SDKModel {
    /**
     * Whether content inherits its access levels from parent
     */
    public var inherits: Bool?

    public init(inherits: Bool? = nil) {
        self.inherits = inherits
    }

}

/**
 * Dynamically generated writeable type for CreateDashboardFilter removes properties:
 * id, field
 */
public struct WriteCreateDashboardFilter: SDKModel {
    /**
     * Id of Dashboard
     */
    public var dashboard_id: String
    /**
     * Name of filter
     */
    public var name: String
    /**
     * Title of filter
     */
    public var title: String
    /**
     * Type of filter: one of date, number, string, or field
     */
    public var type: String
    /**
     * Default value of filter
     */
    public var default_value: String?
    /**
     * Model of filter (required if type = field)
     */
    public var model: String?
    /**
     * Explore of filter (required if type = field)
     */
    public var explore: String?
    /**
     * Dimension of filter (required if type = field)
     */
    public var dimension: String?
    /**
     * Display order of this filter relative to other filters
     */
    public var row: Int64?
    /**
     * Array of listeners for faceted filters
     */
    public var listens_to_filters: [String]?
    /**
     * Whether the filter allows multiple filter values
     */
    public var allow_multiple_values: Bool?
    /**
     * Whether the filter requires a value to run the dashboard
     */
    public var required: Bool?
    /**
     * The visual configuration for this filter. Used to set up how the UI for this filter should appear.
     */
    public var ui_config: StringDictionary<AnyCodable>?

    public init(dashboard_id: String, name: String, title: String, type: String, default_value: String? = nil, model: String? = nil, explore: String? = nil, dimension: String? = nil, row: Int64? = nil, listens_to_filters: [String]? = nil, allow_multiple_values: Bool? = nil, required: Bool? = nil, ui_config: StringDictionary<AnyCodable>? = nil) {
        self.dashboard_id = dashboard_id
        self.name = name
        self.title = title
        self.type = type
        self.default_value = default_value
        self.model = model
        self.explore = explore
        self.dimension = dimension
        self.row = row
        self.listens_to_filters = listens_to_filters
        self.allow_multiple_values = allow_multiple_values
        self.required = required
        self.ui_config = ui_config
    }

    public init(_ dashboard_id: String, _ name: String, _ title: String, _ type: String, default_value: String? = nil, model: String? = nil, explore: String? = nil, dimension: String? = nil, row: Int64? = nil, listens_to_filters: [String]? = nil, allow_multiple_values: Bool? = nil, required: Bool? = nil, ui_config: StringDictionary<AnyCodable>? = nil) {
        self.init(dashboard_id: dashboard_id, name: name, title: title, type: type, default_value: default_value, model: model, explore: explore, dimension: dimension, row: row, listens_to_filters: listens_to_filters, allow_multiple_values: allow_multiple_values, required: required, ui_config: ui_config)
    }

}

/**
 * Dynamically generated writeable type for CreateQueryTask removes properties:
 * can
 */
public struct WriteCreateQueryTask: SDKModel {
    /**
     * Id of query to run
     */
    public var query_id: Int64
    /**
     * Desired async query result format. Valid values are: "inline_json", "json", "json_detail", "json_fe", "csv", "html", "md", "txt", "xlsx", "gsxml".
     */
    public var result_format: ResultFormat
    /**
     * Source of query task
     */
    public var source: String?
    /**
     * Create the task but defer execution
     */
    public var deferred: Bool?
    /**
     * Id of look associated with query.
     */
    public var look_id: Int64?
    /**
     * Id of dashboard associated with query.
     */
    public var dashboard_id: String?

    public init(query_id: Int64, result_format: ResultFormat, source: String? = nil, deferred: Bool? = nil, look_id: Int64? = nil, dashboard_id: String? = nil) {
        self.query_id = query_id
        self.result_format = result_format
        self.source = source
        self.deferred = deferred
        self.look_id = look_id
        self.dashboard_id = dashboard_id
    }

    public init(_ query_id: Int64, _ result_format: ResultFormat, source: String? = nil, deferred: Bool? = nil, look_id: Int64? = nil, dashboard_id: String? = nil) {
        self.init(query_id: query_id, result_format: result_format, source: source, deferred: deferred, look_id: look_id, dashboard_id: dashboard_id)
    }

}

/**
 * Dynamically generated writeable type for CredentialsEmail removes properties:
 * can, created_at, is_disabled, logged_in_at, password_reset_url, type, url, user_url
 */
public struct WriteCredentialsEmail: SDKModel {
    /**
     * EMail address used for user login
     */
    public var email: String?
    /**
     * Force the user to change their password upon their next login
     */
    public var forced_password_reset_at_next_login: Bool?

    public init(email: String? = nil, forced_password_reset_at_next_login: Bool? = nil) {
        self.email = email
        self.forced_password_reset_at_next_login = forced_password_reset_at_next_login
    }

}

/**
 * Dynamically generated writeable type for CustomWelcomeEmail removes properties:
 * can
 */
public struct WriteCustomWelcomeEmail: SDKModel {
    /**
     * If true, custom email content will replace the default body of welcome emails
     */
    public var enabled: Bool?
    /**
     * The HTML to use as custom content for welcome emails. Script elements and other potentially dangerous markup will be removed.
     */
    public var content: String?
    /**
     * The text to appear in the email subject line.
     */
    public var subject: String?
    /**
     * The text to appear in the header line of the email body.
     */
    public var header: String?

    public init(enabled: Bool? = nil, content: String? = nil, subject: String? = nil, header: String? = nil) {
        self.enabled = enabled
        self.content = content
        self.subject = subject
        self.header = header
    }

}

/**
 * Dynamically generated writeable type for Dashboard removes properties:
 * can, content_favorite_id, content_metadata_id, id, model, readonly, refresh_interval_to_i, user_id, created_at, dashboard_elements, dashboard_filters, dashboard_layouts, deleted_at, deleter_id, edit_uri, favorite_count, last_accessed_at, last_viewed_at, view_count
 */
public struct WriteDashboard: SDKModel {
    /**
     * Description
     */
    public var description: String?
    /**
     * Is Hidden
     */
    public var hidden: Bool?
    /**
     * Timezone in which the Dashboard will run by default.
     */
    public var query_timezone: String?
    /**
     * Refresh Interval, as a time duration phrase like "2 hours 30 minutes". A number with no time units will be interpreted as whole seconds.
     */
    public var refresh_interval: String?
    public var folder: WriteFolderBase?
    /**
     * Dashboard Title
     */
    public var title: String?
    /**
     * Background color
     */
    public var background_color: String?
    /**
     * Enables crossfiltering in dashboards - only available in dashboards-next (beta)
     */
    public var crossfilter_enabled: Bool?
    /**
     * Whether or not a dashboard is 'soft' deleted.
     */
    public var deleted: Bool?
    /**
     * configuration option that governs how dashboard loading will happen.
     */
    public var load_configuration: String?
    /**
     * Links this dashboard to a particular LookML dashboard such that calling a **sync** operation on that LookML dashboard will update this dashboard to match.
     */
    public var lookml_link_id: String?
    /**
     * Show filters bar.  **Security Note:** This property only affects the *cosmetic* appearance of the dashboard, not a user's ability to access data. Hiding the filters bar does **NOT** prevent users from changing filters by other means. For information on how to set up secure data access control policies, see [Control User Access to Data](https://looker.com/docs/r/api/control-access)
     */
    public var show_filters_bar: Bool?
    /**
     * Show title
     */
    public var show_title: Bool?
    /**
     * Content Metadata Slug
     */
    public var slug: String?
    /**
     * Id of folder
     */
    public var folder_id: String?
    /**
     * Color of text on text tiles
     */
    public var text_tile_text_color: String?
    /**
     * Tile background color
     */
    public var tile_background_color: String?
    /**
     * Tile text color
     */
    public var tile_text_color: String?
    /**
     * Title color
     */
    public var title_color: String?
    public var appearance: DashboardAppearance?
    /**
     * The preferred route for viewing this dashboard (ie: dashboards or dashboards-next)
     */
    public var preferred_viewer: String?

    public init(description: String? = nil, hidden: Bool? = nil, query_timezone: String? = nil, refresh_interval: String? = nil, folder: WriteFolderBase? = nil, title: String? = nil, background_color: String? = nil, crossfilter_enabled: Bool? = nil, deleted: Bool? = nil, load_configuration: String? = nil, lookml_link_id: String? = nil, show_filters_bar: Bool? = nil, show_title: Bool? = nil, slug: String? = nil, folder_id: String? = nil, text_tile_text_color: String? = nil, tile_background_color: String? = nil, tile_text_color: String? = nil, title_color: String? = nil, appearance: DashboardAppearance? = nil, preferred_viewer: String? = nil) {
        self.description = description
        self.hidden = hidden
        self.query_timezone = query_timezone
        self.refresh_interval = refresh_interval
        self.folder = folder
        self.title = title
        self.background_color = background_color
        self.crossfilter_enabled = crossfilter_enabled
        self.deleted = deleted
        self.load_configuration = load_configuration
        self.lookml_link_id = lookml_link_id
        self.show_filters_bar = show_filters_bar
        self.show_title = show_title
        self.slug = slug
        self.folder_id = folder_id
        self.text_tile_text_color = text_tile_text_color
        self.tile_background_color = tile_background_color
        self.tile_text_color = tile_text_color
        self.title_color = title_color
        self.appearance = appearance
        self.preferred_viewer = preferred_viewer
    }

}

/**
 * Dynamically generated writeable type for DashboardBase removes properties:
 * can, content_favorite_id, content_metadata_id, description, hidden, id, model, query_timezone, readonly, refresh_interval, refresh_interval_to_i, title, user_id
 */
public struct WriteDashboardBase: SDKModel {
    public var folder: WriteFolderBase?

    public init(folder: WriteFolderBase? = nil) {
        self.folder = folder
    }

}

/**
 * Dynamically generated writeable type for DashboardElement removes properties:
 * can, body_text_as_html, edit_uri, id, lookml_link_id, note_text_as_html, refresh_interval_to_i, alert_count, title_text_as_html, subtitle_text_as_html
 */
public struct WriteDashboardElement: SDKModel {
    /**
     * Text tile body text
     */
    public var body_text: String?
    /**
     * Id of Dashboard
     */
    public var dashboard_id: String?
    public var look: WriteLookWithQuery?
    /**
     * Id Of Look
     */
    public var look_id: String?
    /**
     * ID of merge result
     */
    public var merge_result_id: String?
    /**
     * Note Display
     */
    public var note_display: String?
    /**
     * Note State
     */
    public var note_state: String?
    /**
     * Note Text
     */
    public var note_text: String?
    public var query: WriteQuery?
    /**
     * Id Of Query
     */
    public var query_id: Int64?
    /**
     * Refresh Interval
     */
    public var refresh_interval: String?
    public var result_maker: WriteResultMakerWithIdVisConfigAndDynamicFields?
    /**
     * ID of the ResultMakerLookup entry.
     */
    public var result_maker_id: Int64?
    /**
     * Text tile subtitle text
     */
    public var subtitle_text: String?
    /**
     * Title of dashboard element
     */
    public var title: String?
    /**
     * Whether title is hidden
     */
    public var title_hidden: Bool?
    /**
     * Text tile title
     */
    public var title_text: String?
    /**
     * Type
     */
    public var type: String?

    public init(body_text: String? = nil, dashboard_id: String? = nil, look: WriteLookWithQuery? = nil, look_id: String? = nil, merge_result_id: String? = nil, note_display: String? = nil, note_state: String? = nil, note_text: String? = nil, query: WriteQuery? = nil, query_id: Int64? = nil, refresh_interval: String? = nil, result_maker: WriteResultMakerWithIdVisConfigAndDynamicFields? = nil, result_maker_id: Int64? = nil, subtitle_text: String? = nil, title: String? = nil, title_hidden: Bool? = nil, title_text: String? = nil, type: String? = nil) {
        self.body_text = body_text
        self.dashboard_id = dashboard_id
        self.look = look
        self.look_id = look_id
        self.merge_result_id = merge_result_id
        self.note_display = note_display
        self.note_state = note_state
        self.note_text = note_text
        self.query = query
        self.query_id = query_id
        self.refresh_interval = refresh_interval
        self.result_maker = result_maker
        self.result_maker_id = result_maker_id
        self.subtitle_text = subtitle_text
        self.title = title
        self.title_hidden = title_hidden
        self.title_text = title_text
        self.type = type
    }

}

/**
 * Dynamically generated writeable type for DashboardFilter removes properties:
 * can, id, dashboard_id, field
 */
public struct WriteDashboardFilter: SDKModel {
    /**
     * Name of filter
     */
    public var name: String?
    /**
     * Title of filter
     */
    public var title: String?
    /**
     * Type of filter: one of date, number, string, or field
     */
    public var type: String?
    /**
     * Default value of filter
     */
    public var default_value: String?
    /**
     * Model of filter (required if type = field)
     */
    public var model: String?
    /**
     * Explore of filter (required if type = field)
     */
    public var explore: String?
    /**
     * Dimension of filter (required if type = field)
     */
    public var dimension: String?
    /**
     * Display order of this filter relative to other filters
     */
    public var row: Int64?
    /**
     * Array of listeners for faceted filters
     */
    public var listens_to_filters: [String]?
    /**
     * Whether the filter allows multiple filter values
     */
    public var allow_multiple_values: Bool?
    /**
     * Whether the filter requires a value to run the dashboard
     */
    public var required: Bool?
    /**
     * The visual configuration for this filter. Used to set up how the UI for this filter should appear.
     */
    public var ui_config: StringDictionary<AnyCodable>?

    public init(name: String? = nil, title: String? = nil, type: String? = nil, default_value: String? = nil, model: String? = nil, explore: String? = nil, dimension: String? = nil, row: Int64? = nil, listens_to_filters: [String]? = nil, allow_multiple_values: Bool? = nil, required: Bool? = nil, ui_config: StringDictionary<AnyCodable>? = nil) {
        self.name = name
        self.title = title
        self.type = type
        self.default_value = default_value
        self.model = model
        self.explore = explore
        self.dimension = dimension
        self.row = row
        self.listens_to_filters = listens_to_filters
        self.allow_multiple_values = allow_multiple_values
        self.required = required
        self.ui_config = ui_config
    }

}

/**
 * Dynamically generated writeable type for DashboardLayout removes properties:
 * can, id, deleted, dashboard_title, dashboard_layout_components
 */
public struct WriteDashboardLayout: SDKModel {
    /**
     * Id of Dashboard
     */
    public var dashboard_id: String?
    /**
     * Type
     */
    public var type: String?
    /**
     * Is Active
     */
    public var active: Bool?
    /**
     * Column Width
     */
    public var column_width: Int64?
    /**
     * Width
     */
    public var width: Int64?

    public init(dashboard_id: String? = nil, type: String? = nil, active: Bool? = nil, column_width: Int64? = nil, width: Int64? = nil) {
        self.dashboard_id = dashboard_id
        self.type = type
        self.active = active
        self.column_width = column_width
        self.width = width
    }

}

/**
 * Dynamically generated writeable type for DashboardLayoutComponent removes properties:
 * can, id, deleted, element_title, element_title_hidden, vis_type
 */
public struct WriteDashboardLayoutComponent: SDKModel {
    /**
     * Id of Dashboard Layout
     */
    public var dashboard_layout_id: String?
    /**
     * Id Of Dashboard Element
     */
    public var dashboard_element_id: String?
    /**
     * Row
     */
    public var row: Int64?
    /**
     * Column
     */
    public var column: Int64?
    /**
     * Width
     */
    public var width: Int64?
    /**
     * Height
     */
    public var height: Int64?

    public init(dashboard_layout_id: String? = nil, dashboard_element_id: String? = nil, row: Int64? = nil, column: Int64? = nil, width: Int64? = nil, height: Int64? = nil) {
        self.dashboard_layout_id = dashboard_layout_id
        self.dashboard_element_id = dashboard_element_id
        self.row = row
        self.column = column
        self.width = width
        self.height = height
    }

}

/**
 * Dynamically generated writeable type for Datagroup removes properties:
 * can, created_at, id, model_name, name, trigger_check_at, trigger_error, trigger_value
 */
public struct WriteDatagroup: SDKModel {
    /**
     * UNIX timestamp before which cache entries are considered stale. Cannot be in the future.
     */
    public var stale_before: Int64?
    /**
     * UNIX timestamp at which this entry became triggered. Cannot be in the future.
     */
    public var triggered_at: Int64?

    public init(stale_before: Int64? = nil, triggered_at: Int64? = nil) {
        self.stale_before = stale_before
        self.triggered_at = triggered_at
    }

}

/**
 * Dynamically generated writeable type for DBConnection removes properties:
 * can, dialect, snippets, pdts_enabled, uses_oauth, created_at, user_id, example, last_regen_at, last_reap_at, managed
 */
public struct WriteDBConnection: SDKModel {
    /**
     * Name of the connection. Also used as the unique identifier
     */
    public var name: String?
    /**
     * Host name/address of server
     */
    public var host: String?
    /**
     * Port number on server
     */
    public var port: Int64?
    /**
     * Username for server authentication
     */
    public var username: String?
    /**
     * (Write-Only) Password for server authentication
     */
    public var password: String?
    /**
     * (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
     */
    public var certificate: String?
    /**
     * (Write-Only) Certificate keyfile type - .json or .p12
     */
    public var file_type: String?
    /**
     * Database name
     */
    public var database: String?
    /**
     * Time zone of database
     */
    public var db_timezone: String?
    /**
     * Timezone to use in queries
     */
    public var query_timezone: String?
    /**
     * Scheme name
     */
    public var schema: String?
    /**
     * Maximum number of concurrent connection to use
     */
    public var max_connections: Int64?
    /**
     * Maximum size of query in GBs (BigQuery only, can be a user_attribute name)
     */
    public var max_billing_gigabytes: String?
    /**
     * Use SSL/TLS when connecting to server
     */
    public var ssl: Bool?
    /**
     * Verify the SSL
     */
    public var verify_ssl: Bool?
    /**
     * Name of temporary database (if used)
     */
    public var tmp_db_name: String?
    /**
     * Additional params to add to JDBC connection string
     */
    public var jdbc_additional_params: String?
    /**
     * Connection Pool Timeout, in seconds
     */
    public var pool_timeout: Int64?
    /**
     * (Read/Write) SQL Dialect name
     */
    public var dialect_name: String?
    /**
     * (Limited access feature) Are per user db credentials enabled. Enabling will remove previously set username and password
     */
    public var user_db_credentials: Bool?
    /**
     * Fields whose values map to user attribute names
     */
    public var user_attribute_fields: [String]?
    /**
     * Cron string specifying when maintenance such as PDT trigger checks and drops should be performed
     */
    public var maintenance_cron: String?
    /**
     * Precache tables in the SQL Runner
     */
    public var sql_runner_precache_tables: Bool?
    /**
     * SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
     */
    public var after_connect_statements: String?
    public var pdt_context_override: WriteDBConnectionOverride?
    /**
     * The Id of the ssh tunnel this connection uses
     */
    public var tunnel_id: String?
    /**
     * Maximum number of threads to use to build PDTs in parallel
     */
    public var pdt_concurrency: Int64?
    /**
     * When disable_context_comment is true comment will not be added to SQL
     */
    public var disable_context_comment: Bool?

    public init(name: String? = nil, host: String? = nil, port: Int64? = nil, username: String? = nil, password: String? = nil, certificate: String? = nil, file_type: String? = nil, database: String? = nil, db_timezone: String? = nil, query_timezone: String? = nil, schema: String? = nil, max_connections: Int64? = nil, max_billing_gigabytes: String? = nil, ssl: Bool? = nil, verify_ssl: Bool? = nil, tmp_db_name: String? = nil, jdbc_additional_params: String? = nil, pool_timeout: Int64? = nil, dialect_name: String? = nil, user_db_credentials: Bool? = nil, user_attribute_fields: [String]? = nil, maintenance_cron: String? = nil, sql_runner_precache_tables: Bool? = nil, after_connect_statements: String? = nil, pdt_context_override: WriteDBConnectionOverride? = nil, tunnel_id: String? = nil, pdt_concurrency: Int64? = nil, disable_context_comment: Bool? = nil) {
        self.name = name
        self.host = host
        self.port = port
        self.username = username
        self.password = password
        self.certificate = certificate
        self.file_type = file_type
        self.database = database
        self.db_timezone = db_timezone
        self.query_timezone = query_timezone
        self.schema = schema
        self.max_connections = max_connections
        self.max_billing_gigabytes = max_billing_gigabytes
        self.ssl = ssl
        self.verify_ssl = verify_ssl
        self.tmp_db_name = tmp_db_name
        self.jdbc_additional_params = jdbc_additional_params
        self.pool_timeout = pool_timeout
        self.dialect_name = dialect_name
        self.user_db_credentials = user_db_credentials
        self.user_attribute_fields = user_attribute_fields
        self.maintenance_cron = maintenance_cron
        self.sql_runner_precache_tables = sql_runner_precache_tables
        self.after_connect_statements = after_connect_statements
        self.pdt_context_override = pdt_context_override
        self.tunnel_id = tunnel_id
        self.pdt_concurrency = pdt_concurrency
        self.disable_context_comment = disable_context_comment
    }

}

/**
 * Dynamically generated writeable type for DBConnectionOverride removes properties:
 * has_password
 */
public struct WriteDBConnectionOverride: SDKModel {
    /**
     * Context in which to override (`pdt` is the only allowed value)
     */
    public var context: String?
    /**
     * Host name/address of server
     */
    public var host: String?
    /**
     * Port number on server
     */
    public var port: String?
    /**
     * Username for server authentication
     */
    public var username: String?
    /**
     * (Write-Only) Password for server authentication
     */
    public var password: String?
    /**
     * (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
     */
    public var certificate: String?
    /**
     * (Write-Only) Certificate keyfile type - .json or .p12
     */
    public var file_type: String?
    /**
     * Database name
     */
    public var database: String?
    /**
     * Scheme name
     */
    public var schema: String?
    /**
     * Additional params to add to JDBC connection string
     */
    public var jdbc_additional_params: String?
    /**
     * SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature
     */
    public var after_connect_statements: String?

    public init(context: String? = nil, host: String? = nil, port: String? = nil, username: String? = nil, password: String? = nil, certificate: String? = nil, file_type: String? = nil, database: String? = nil, schema: String? = nil, jdbc_additional_params: String? = nil, after_connect_statements: String? = nil) {
        self.context = context
        self.host = host
        self.port = port
        self.username = username
        self.password = password
        self.certificate = certificate
        self.file_type = file_type
        self.database = database
        self.schema = schema
        self.jdbc_additional_params = jdbc_additional_params
        self.after_connect_statements = after_connect_statements
    }

}

/**
 * Dynamically generated writeable type for FolderBase removes properties:
 * id, content_metadata_id, created_at, creator_id, child_count, external_id, is_embed, is_embed_shared_root, is_embed_users_root, is_personal, is_personal_descendant, is_shared_root, is_users_root, can
 */
public struct WriteFolderBase: SDKModel {
    /**
     * Unique Name
     */
    public var name: String
    /**
     * Id of Parent. If the parent id is null, this is a root-level entry
     */
    public var parent_id: String?

    public init(name: String, parent_id: String? = nil) {
        self.name = name
        self.parent_id = parent_id
    }

    public init(_ name: String, parent_id: String? = nil) {
        self.init(name: name, parent_id: parent_id)
    }

}

/**
 * Dynamically generated writeable type for GitBranch removes properties:
 * can, remote, remote_name, error, message, owner_name, readonly, personal, is_local, is_remote, is_production, ahead_count, behind_count, commit_at, remote_ref
 */
public struct WriteGitBranch: SDKModel {
    /**
     * The short name on the local. Updating `name` results in `git checkout <new_name>`
     */
    public var name: String?
    /**
     * The resolved ref of this branch. Updating `ref` results in `git reset --hard <new_ref>``.
     */
    public var ref: String?

    public init(name: String? = nil, ref: String? = nil) {
        self.name = name
        self.ref = ref
    }

}

/**
 * Dynamically generated writeable type for Group removes properties:
 * can, contains_current_user, external_group_id, externally_managed, id, include_by_default, user_count
 */
public struct WriteGroup: SDKModel {
    /**
     * Group can be used in content access controls
     */
    public var can_add_to_content_metadata: Bool?
    /**
     * Name of group
     */
    public var name: String?

    public init(can_add_to_content_metadata: Bool? = nil, name: String? = nil) {
        self.can_add_to_content_metadata = can_add_to_content_metadata
        self.name = name
    }

}

/**
 * Dynamically generated writeable type for Integration removes properties:
 * can, id, integration_hub_id, label, description, supported_formats, supported_action_types, supported_formattings, supported_visualization_formattings, supported_download_settings, icon_url, uses_oauth, required_fields, delegate_oauth
 */
public struct WriteIntegration: SDKModel {
    /**
     * Whether the integration is available to users.
     */
    public var enabled: Bool?
    /**
     * Array of params for the integration.
     */
    public var params: [IntegrationParam]?
    /**
     * Whether the integration is available to users.
     */
    public var installed_delegate_oauth_targets: [Int64]?

    public init(enabled: Bool? = nil, params: [IntegrationParam]? = nil, installed_delegate_oauth_targets: [Int64]? = nil) {
        self.enabled = enabled
        self.params = params
        self.installed_delegate_oauth_targets = installed_delegate_oauth_targets
    }

}

/**
 * Dynamically generated writeable type for IntegrationHub removes properties:
 * can, id, label, official, fetch_error_message, has_authorization_token, legal_agreement_signed, legal_agreement_required, legal_agreement_text
 */
public struct WriteIntegrationHub: SDKModel {
    /**
     * URL of the hub.
     */
    public var url: String?
    /**
     * (Write-Only) An authorization key that will be sent to the integration hub on every request.
     */
    public var authorization_token: String?

    public init(url: String? = nil, authorization_token: String? = nil) {
        self.url = url
        self.authorization_token = authorization_token
    }

}

/**
 * Dynamically generated writeable type for InternalHelpResources removes properties:
 * can
 */
public struct WriteInternalHelpResources: SDKModel {
    /**
     * If true and internal help resources content is not blank then the link for internal help resources will be shown in the help menu and the content displayed within Looker
     */
    public var enabled: Bool?

    public init(enabled: Bool? = nil) {
        self.enabled = enabled
    }

}

/**
 * Dynamically generated writeable type for InternalHelpResourcesContent removes properties:
 * can
 */
public struct WriteInternalHelpResourcesContent: SDKModel {
    /**
     * Text to display in the help menu item which will display the internal help resources
     */
    public var organization_name: String?
    /**
     * Content to be displayed in the internal help resources page/modal
     */
    public var markdown_content: String?

    public init(organization_name: String? = nil, markdown_content: String? = nil) {
        self.organization_name = organization_name
        self.markdown_content = markdown_content
    }

}

/**
 * Dynamically generated writeable type for LDAPConfig removes properties:
 * can, default_new_user_groups, default_new_user_roles, groups, has_auth_password, modified_at, modified_by, user_attributes, url
 */
public struct WriteLDAPConfig: SDKModel {
    /**
     * Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
     */
    public var alternate_email_login_allowed: Bool?
    /**
     * (Write-Only)  Password for the LDAP account used to access the LDAP server
     */
    public var auth_password: String?
    /**
     * Users will not be allowed to login at all unless a role for them is found in LDAP if set to true
     */
    public var auth_requires_role: Bool?
    /**
     * Distinguished name of LDAP account used to access the LDAP server
     */
    public var auth_username: String?
    /**
     * LDAP server hostname
     */
    public var connection_host: String?
    /**
     * LDAP host port
     */
    public var connection_port: String?
    /**
     * Use Transport Layer Security
     */
    public var connection_tls: Bool?
    /**
     * Do not verify peer when using TLS
     */
    public var connection_tls_no_verify: Bool?
    /**
     * (Write-Only)  Array of ids of groups that will be applied to new users the first time they login via LDAP
     */
    public var default_new_user_group_ids: [Int64]?
    /**
     * (Write-Only)  Array of ids of roles that will be applied to new users the first time they login via LDAP
     */
    public var default_new_user_role_ids: [Int64]?
    /**
     * Enable/Disable LDAP authentication for the server
     */
    public var enabled: Bool?
    /**
     * Don't attempt to do LDAP search result paging (RFC 2696) even if the LDAP server claims to support it.
     */
    public var force_no_page: Bool?
    /**
     * Base dn for finding groups in LDAP searches
     */
    public var groups_base_dn: String?
    /**
     * Identifier for a strategy for how Looker will search for groups in the LDAP server
     */
    public var groups_finder_type: String?
    /**
     * LDAP Group attribute that signifies the members of the groups. Most commonly 'member'
     */
    public var groups_member_attribute: String?
    /**
     * Optional comma-separated list of supported LDAP objectclass for groups when doing groups searches
     */
    public var groups_objectclasses: String?
    /**
     * LDAP Group attribute that signifies the user in a group. Most commonly 'dn'
     */
    public var groups_user_attribute: String?
    /**
     * (Read/Write) Array of mappings between LDAP Groups and arrays of Looker Role ids
     */
    public var groups_with_role_ids: [LDAPGroupWrite]?
    /**
     * Merge first-time ldap login to existing user account by email addresses. When a user logs in for the first time via ldap this option will connect this user into their existing account by finding the account with a matching email address. Otherwise a new user account will be created for the user.
     */
    public var merge_new_users_by_email: Bool?
    /**
     * Set user roles in Looker based on groups from LDAP
     */
    public var set_roles_from_groups: Bool?
    /**
     * (Write-Only)  Test LDAP user password. For ldap tests only.
     */
    public var test_ldap_password: String?
    /**
     * (Write-Only)  Test LDAP user login id. For ldap tests only.
     */
    public var test_ldap_user: String?
    /**
     * Name of user record attributes used to indicate email address field
     */
    public var user_attribute_map_email: String?
    /**
     * Name of user record attributes used to indicate first name
     */
    public var user_attribute_map_first_name: String?
    /**
     * Name of user record attributes used to indicate last name
     */
    public var user_attribute_map_last_name: String?
    /**
     * Name of user record attributes used to indicate unique record id
     */
    public var user_attribute_map_ldap_id: String?
    /**
     * (Read/Write) Array of mappings between LDAP User Attributes and arrays of Looker User Attribute ids
     */
    public var user_attributes_with_ids: [LDAPUserAttributeWrite]?
    /**
     * Distinguished name of LDAP node used as the base for user searches
     */
    public var user_bind_base_dn: String?
    /**
     * (Optional) Custom RFC-2254 filter clause for use in finding user during login. Combined via 'and' with the other generated filter clauses.
     */
    public var user_custom_filter: String?
    /**
     * Name(s) of user record attributes used for matching user login id (comma separated list)
     */
    public var user_id_attribute_names: String?
    /**
     * (Optional) Name of user record objectclass used for finding user during login id
     */
    public var user_objectclass: String?
    /**
     * Allow LDAP auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.
     */
    public var allow_normal_group_membership: Bool?
    /**
     * LDAP auth'd users will be able to inherit roles from non-reflected Looker groups.
     */
    public var allow_roles_from_normal_groups: Bool?
    /**
     * Allows roles to be directly assigned to LDAP auth'd users.
     */
    public var allow_direct_roles: Bool?

    public init(alternate_email_login_allowed: Bool? = nil, auth_password: String? = nil, auth_requires_role: Bool? = nil, auth_username: String? = nil, connection_host: String? = nil, connection_port: String? = nil, connection_tls: Bool? = nil, connection_tls_no_verify: Bool? = nil, default_new_user_group_ids: [Int64]? = nil, default_new_user_role_ids: [Int64]? = nil, enabled: Bool? = nil, force_no_page: Bool? = nil, groups_base_dn: String? = nil, groups_finder_type: String? = nil, groups_member_attribute: String? = nil, groups_objectclasses: String? = nil, groups_user_attribute: String? = nil, groups_with_role_ids: [LDAPGroupWrite]? = nil, merge_new_users_by_email: Bool? = nil, set_roles_from_groups: Bool? = nil, test_ldap_password: String? = nil, test_ldap_user: String? = nil, user_attribute_map_email: String? = nil, user_attribute_map_first_name: String? = nil, user_attribute_map_last_name: String? = nil, user_attribute_map_ldap_id: String? = nil, user_attributes_with_ids: [LDAPUserAttributeWrite]? = nil, user_bind_base_dn: String? = nil, user_custom_filter: String? = nil, user_id_attribute_names: String? = nil, user_objectclass: String? = nil, allow_normal_group_membership: Bool? = nil, allow_roles_from_normal_groups: Bool? = nil, allow_direct_roles: Bool? = nil) {
        self.alternate_email_login_allowed = alternate_email_login_allowed
        self.auth_password = auth_password
        self.auth_requires_role = auth_requires_role
        self.auth_username = auth_username
        self.connection_host = connection_host
        self.connection_port = connection_port
        self.connection_tls = connection_tls
        self.connection_tls_no_verify = connection_tls_no_verify
        self.default_new_user_group_ids = default_new_user_group_ids
        self.default_new_user_role_ids = default_new_user_role_ids
        self.enabled = enabled
        self.force_no_page = force_no_page
        self.groups_base_dn = groups_base_dn
        self.groups_finder_type = groups_finder_type
        self.groups_member_attribute = groups_member_attribute
        self.groups_objectclasses = groups_objectclasses
        self.groups_user_attribute = groups_user_attribute
        self.groups_with_role_ids = groups_with_role_ids
        self.merge_new_users_by_email = merge_new_users_by_email
        self.set_roles_from_groups = set_roles_from_groups
        self.test_ldap_password = test_ldap_password
        self.test_ldap_user = test_ldap_user
        self.user_attribute_map_email = user_attribute_map_email
        self.user_attribute_map_first_name = user_attribute_map_first_name
        self.user_attribute_map_last_name = user_attribute_map_last_name
        self.user_attribute_map_ldap_id = user_attribute_map_ldap_id
        self.user_attributes_with_ids = user_attributes_with_ids
        self.user_bind_base_dn = user_bind_base_dn
        self.user_custom_filter = user_custom_filter
        self.user_id_attribute_names = user_id_attribute_names
        self.user_objectclass = user_objectclass
        self.allow_normal_group_membership = allow_normal_group_membership
        self.allow_roles_from_normal_groups = allow_roles_from_normal_groups
        self.allow_direct_roles = allow_direct_roles
    }

}

/**
 * Dynamically generated writeable type for LegacyFeature removes properties:
 * can, id, name, description, enabled, disallowed_as_of_version, disable_on_upgrade_to_version, end_of_life_version, documentation_url, approximate_disable_date, approximate_end_of_life_date, has_disabled_on_upgrade
 */
public struct WriteLegacyFeature: SDKModel {
    /**
     * Whether this feature has been enabled by a user
     */
    public var enabled_locally: Bool?

    public init(enabled_locally: Bool? = nil) {
        self.enabled_locally = enabled_locally
    }

}

/**
 * Dynamically generated writeable type for LookBasic removes properties:
 * can, content_metadata_id, id, title
 */
public struct WriteLookBasic: SDKModel {
    /**
     * User Id
     */
    public var user_id: Int64?

    public init(user_id: Int64? = nil) {
        self.user_id = user_id
    }

}

/**
 * Dynamically generated writeable type for LookmlModel removes properties:
 * can, explores, has_content, label
 */
public struct WriteLookmlModel: SDKModel {
    /**
     * Array of names of connections this model is allowed to use
     */
    public var allowed_db_connection_names: [String]?
    /**
     * Name of the model. Also used as the unique identifier
     */
    public var name: String?
    /**
     * Name of project containing the model
     */
    public var project_name: String?
    /**
     * Is this model allowed to use all current and future connections
     */
    public var unlimited_db_connections: Bool?

    public init(allowed_db_connection_names: [String]? = nil, name: String? = nil, project_name: String? = nil, unlimited_db_connections: Bool? = nil) {
        self.allowed_db_connection_names = allowed_db_connection_names
        self.name = name
        self.project_name = project_name
        self.unlimited_db_connections = unlimited_db_connections
    }

}

/**
 * Dynamically generated writeable type for LookWithQuery removes properties:
 * can, content_metadata_id, id, content_favorite_id, created_at, deleted_at, deleter_id, embed_url, excel_file_url, favorite_count, google_spreadsheet_formula, image_embed_url, last_accessed_at, last_updater_id, last_viewed_at, model, public_slug, public_url, short_url, updated_at, view_count, url
 */
public struct WriteLookWithQuery: SDKModel {
    /**
     * Look Title
     */
    public var title: String?
    /**
     * User Id
     */
    public var user_id: Int64?
    /**
     * Whether or not a look is 'soft' deleted.
     */
    public var deleted: Bool?
    /**
     * Description
     */
    public var description: String?
    /**
     * auto-run query when Look viewed
     */
    public var is_run_on_load: Bool?
    /**
     * Is Public
     */
    public var `public`: Bool?
    /**
     * Query Id
     */
    public var query_id: Int64?
    public var folder: WriteFolderBase?
    /**
     * Folder Id
     */
    public var folder_id: String?
    public var query: WriteQuery?

    public init(title: String? = nil, user_id: Int64? = nil, deleted: Bool? = nil, description: String? = nil, is_run_on_load: Bool? = nil, `public`: Bool? = nil, query_id: Int64? = nil, folder: WriteFolderBase? = nil, folder_id: String? = nil, query: WriteQuery? = nil) {
        self.title = title
        self.user_id = user_id
        self.deleted = deleted
        self.description = description
        self.is_run_on_load = is_run_on_load
        self.`public` = `public`
        self.query_id = query_id
        self.folder = folder
        self.folder_id = folder_id
        self.query = query
    }

}

/**
 * Dynamically generated writeable type for MergeQuery removes properties:
 * can, id, result_maker_id
 */
public struct WriteMergeQuery: SDKModel {
    /**
     * Column Limit
     */
    public var column_limit: String?
    /**
     * Dynamic Fields
     */
    public var dynamic_fields: String?
    /**
     * Pivots
     */
    public var pivots: [String]?
    /**
     * Sorts
     */
    public var sorts: [String]?
    /**
     * Source Queries defining the results to be merged.
     */
    public var source_queries: [MergeQuerySourceQuery]?
    /**
     * Total
     */
    public var total: Bool?
    /**
     * Visualization Config
     */
    public var vis_config: StringDictionary<AnyCodable>?

    public init(column_limit: String? = nil, dynamic_fields: String? = nil, pivots: [String]? = nil, sorts: [String]? = nil, source_queries: [MergeQuerySourceQuery]? = nil, total: Bool? = nil, vis_config: StringDictionary<AnyCodable>? = nil) {
        self.column_limit = column_limit
        self.dynamic_fields = dynamic_fields
        self.pivots = pivots
        self.sorts = sorts
        self.source_queries = source_queries
        self.total = total
        self.vis_config = vis_config
    }

}

/**
 * Dynamically generated writeable type for ModelSet removes properties:
 * can, all_access, built_in, id, url
 */
public struct WriteModelSet: SDKModel {
    public var models: [String]?
    /**
     * Name of ModelSet
     */
    public var name: String?

    public init(models: [String]? = nil, name: String? = nil) {
        self.models = models
        self.name = name
    }

}

/**
 * Dynamically generated writeable type for OauthClientApp removes properties:
 * can, client_guid, tokens_invalid_before, activated_users
 */
public struct WriteOauthClientApp: SDKModel {
    /**
     * The uri with which this application will receive an auth code by browser redirect.
     */
    public var redirect_uri: String?
    /**
     * The application's display name
     */
    public var display_name: String?
    /**
     * A description of the application that will be displayed to users
     */
    public var description: String?
    /**
     * When enabled is true, OAuth2 and API requests will be accepted from this app. When false, all requests from this app will be refused.
     */
    public var enabled: Bool?
    /**
     * If set, only Looker users who are members of this group can use this web app with Looker. If group_id is not set, any Looker user may use this app to access this Looker instance
     */
    public var group_id: Int64?

    public init(redirect_uri: String? = nil, display_name: String? = nil, description: String? = nil, enabled: Bool? = nil, group_id: Int64? = nil) {
        self.redirect_uri = redirect_uri
        self.display_name = display_name
        self.description = description
        self.enabled = enabled
        self.group_id = group_id
    }

}

/**
 * Dynamically generated writeable type for OIDCConfig removes properties:
 * can, default_new_user_groups, default_new_user_roles, groups, modified_at, modified_by, test_slug, user_attributes, url
 */
public struct WriteOIDCConfig: SDKModel {
    /**
     * Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
     */
    public var alternate_email_login_allowed: Bool?
    /**
     * OpenID Provider Audience
     */
    public var audience: String?
    /**
     * Users will not be allowed to login at all unless a role for them is found in OIDC if set to true
     */
    public var auth_requires_role: Bool?
    /**
     * OpenID Provider Authorization Url
     */
    public var authorization_endpoint: URI?
    /**
     * (Write-Only) Array of ids of groups that will be applied to new users the first time they login via OIDC
     */
    public var default_new_user_group_ids: [Int64]?
    /**
     * (Write-Only) Array of ids of roles that will be applied to new users the first time they login via OIDC
     */
    public var default_new_user_role_ids: [Int64]?
    /**
     * Enable/Disable OIDC authentication for the server
     */
    public var enabled: Bool?
    /**
     * Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
     */
    public var groups_attribute: String?
    /**
     * (Read/Write) Array of mappings between OIDC Groups and arrays of Looker Role ids
     */
    public var groups_with_role_ids: [OIDCGroupWrite]?
    /**
     * Relying Party Identifier (provided by OpenID Provider)
     */
    public var identifier: String?
    /**
     * OpenID Provider Issuer
     */
    public var issuer: String?
    /**
     * Merge first-time oidc login to existing user account by email addresses. When a user logs in for the first time via oidc this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
     */
    public var new_user_migration_types: String?
    /**
     * Array of scopes to request.
     */
    public var scopes: [String]?
    /**
     * (Write-Only) Relying Party Secret (provided by OpenID Provider)
     */
    public var secret: String?
    /**
     * Set user roles in Looker based on groups from OIDC
     */
    public var set_roles_from_groups: Bool?
    /**
     * OpenID Provider Token Url
     */
    public var token_endpoint: String?
    /**
     * Name of user record attributes used to indicate email address field
     */
    public var user_attribute_map_email: String?
    /**
     * Name of user record attributes used to indicate first name
     */
    public var user_attribute_map_first_name: String?
    /**
     * Name of user record attributes used to indicate last name
     */
    public var user_attribute_map_last_name: String?
    /**
     * (Read/Write) Array of mappings between OIDC User Attributes and arrays of Looker User Attribute ids
     */
    public var user_attributes_with_ids: [OIDCUserAttributeWrite]?
    /**
     * OpenID Provider User Information Url
     */
    public var userinfo_endpoint: URI?
    /**
     * Allow OIDC auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.
     */
    public var allow_normal_group_membership: Bool?
    /**
     * OIDC auth'd users will inherit roles from non-reflected Looker groups.
     */
    public var allow_roles_from_normal_groups: Bool?
    /**
     * Allows roles to be directly assigned to OIDC auth'd users.
     */
    public var allow_direct_roles: Bool?

    public init(alternate_email_login_allowed: Bool? = nil, audience: String? = nil, auth_requires_role: Bool? = nil, authorization_endpoint: URI? = nil, default_new_user_group_ids: [Int64]? = nil, default_new_user_role_ids: [Int64]? = nil, enabled: Bool? = nil, groups_attribute: String? = nil, groups_with_role_ids: [OIDCGroupWrite]? = nil, identifier: String? = nil, issuer: String? = nil, new_user_migration_types: String? = nil, scopes: [String]? = nil, secret: String? = nil, set_roles_from_groups: Bool? = nil, token_endpoint: String? = nil, user_attribute_map_email: String? = nil, user_attribute_map_first_name: String? = nil, user_attribute_map_last_name: String? = nil, user_attributes_with_ids: [OIDCUserAttributeWrite]? = nil, userinfo_endpoint: URI? = nil, allow_normal_group_membership: Bool? = nil, allow_roles_from_normal_groups: Bool? = nil, allow_direct_roles: Bool? = nil) {
        self.alternate_email_login_allowed = alternate_email_login_allowed
        self.audience = audience
        self.auth_requires_role = auth_requires_role
        self.authorization_endpoint = authorization_endpoint
        self.default_new_user_group_ids = default_new_user_group_ids
        self.default_new_user_role_ids = default_new_user_role_ids
        self.enabled = enabled
        self.groups_attribute = groups_attribute
        self.groups_with_role_ids = groups_with_role_ids
        self.identifier = identifier
        self.issuer = issuer
        self.new_user_migration_types = new_user_migration_types
        self.scopes = scopes
        self.secret = secret
        self.set_roles_from_groups = set_roles_from_groups
        self.token_endpoint = token_endpoint
        self.user_attribute_map_email = user_attribute_map_email
        self.user_attribute_map_first_name = user_attribute_map_first_name
        self.user_attribute_map_last_name = user_attribute_map_last_name
        self.user_attributes_with_ids = user_attributes_with_ids
        self.userinfo_endpoint = userinfo_endpoint
        self.allow_normal_group_membership = allow_normal_group_membership
        self.allow_roles_from_normal_groups = allow_roles_from_normal_groups
        self.allow_direct_roles = allow_direct_roles
    }

}

/**
 * Dynamically generated writeable type for PasswordConfig removes properties:
 * can
 */
public struct WritePasswordConfig: SDKModel {
    /**
     * Minimum number of characters required for a new password.  Must be between 7 and 100
     */
    public var min_length: Int64?
    /**
     * Require at least one numeric character
     */
    public var require_numeric: Bool?
    /**
     * Require at least one uppercase and one lowercase letter
     */
    public var require_upperlower: Bool?
    /**
     * Require at least one special character
     */
    public var require_special: Bool?

    public init(min_length: Int64? = nil, require_numeric: Bool? = nil, require_upperlower: Bool? = nil, require_special: Bool? = nil) {
        self.min_length = min_length
        self.require_numeric = require_numeric
        self.require_upperlower = require_upperlower
        self.require_special = require_special
    }

}

/**
 * Dynamically generated writeable type for PermissionSet removes properties:
 * can, all_access, built_in, id, url
 */
public struct WritePermissionSet: SDKModel {
    /**
     * Name of PermissionSet
     */
    public var name: String?
    public var permissions: [String]?

    public init(name: String? = nil, permissions: [String]? = nil) {
        self.name = name
        self.permissions = permissions
    }

}

/**
 * Dynamically generated writeable type for Project removes properties:
 * can, id, uses_git, is_example
 */
public struct WriteProject: SDKModel {
    /**
     * Project display name
     */
    public var name: String?
    /**
     * Git remote repository url
     */
    public var git_remote_url: String?
    /**
     * Git username for HTTPS authentication. (For production only, if using user attributes.)
     */
    public var git_username: String?
    /**
     * (Write-Only) Git password for HTTPS authentication. (For production only, if using user attributes.)
     */
    public var git_password: String?
    /**
     * User attribute name for username in per-user HTTPS authentication.
     */
    public var git_username_user_attribute: String?
    /**
     * User attribute name for password in per-user HTTPS authentication.
     */
    public var git_password_user_attribute: String?
    /**
     * Name of the git service provider
     */
    public var git_service_name: String?
    /**
     * Port that HTTP(S) application server is running on (for PRs, file browsing, etc.)
     */
    public var git_application_server_http_port: Int64?
    /**
     * Scheme that is running on application server (for PRs, file browsing, etc.) Valid values are: "http", "https".
     */
    public var git_application_server_http_scheme: GitApplicationServerHttpScheme?
    /**
     * (Write-Only) Optional secret token with which to authenticate requests to the webhook deploy endpoint. If not set, endpoint is unauthenticated.
     */
    public var deploy_secret: String?
    /**
     * (Write-Only) When true, unsets the deploy secret to allow unauthenticated access to the webhook deploy endpoint.
     */
    public var unset_deploy_secret: Bool?
    /**
     * The git pull request policy for this project. Valid values are: "off", "links", "recommended", "required".
     */
    public var pull_request_mode: PullRequestMode?
    /**
     * Validation policy: If true, the project must pass validation checks before project changes can be committed to the git repository
     */
    public var validation_required: Bool?
    /**
     * If true, advanced git release management is enabled for this project
     */
    public var git_release_mgmt_enabled: Bool?
    /**
     * Validation policy: If true, the project can be committed with warnings when `validation_required` is true. (`allow_warnings` does nothing if `validation_required` is false).
     */
    public var allow_warnings: Bool?
    /**
     * Status of dependencies in your manifest & lockfile
     */
    public var dependency_status: String?

    public init(name: String? = nil, git_remote_url: String? = nil, git_username: String? = nil, git_password: String? = nil, git_username_user_attribute: String? = nil, git_password_user_attribute: String? = nil, git_service_name: String? = nil, git_application_server_http_port: Int64? = nil, git_application_server_http_scheme: GitApplicationServerHttpScheme? = nil, deploy_secret: String? = nil, unset_deploy_secret: Bool? = nil, pull_request_mode: PullRequestMode? = nil, validation_required: Bool? = nil, git_release_mgmt_enabled: Bool? = nil, allow_warnings: Bool? = nil, dependency_status: String? = nil) {
        self.name = name
        self.git_remote_url = git_remote_url
        self.git_username = git_username
        self.git_password = git_password
        self.git_username_user_attribute = git_username_user_attribute
        self.git_password_user_attribute = git_password_user_attribute
        self.git_service_name = git_service_name
        self.git_application_server_http_port = git_application_server_http_port
        self.git_application_server_http_scheme = git_application_server_http_scheme
        self.deploy_secret = deploy_secret
        self.unset_deploy_secret = unset_deploy_secret
        self.pull_request_mode = pull_request_mode
        self.validation_required = validation_required
        self.git_release_mgmt_enabled = git_release_mgmt_enabled
        self.allow_warnings = allow_warnings
        self.dependency_status = dependency_status
    }

}

/**
 * Dynamically generated writeable type for Query removes properties:
 * can, id, slug, share_url, expanded_share_url, url, has_table_calculations
 */
public struct WriteQuery: SDKModel {
    /**
     * Model
     */
    public var model: String
    /**
     * Explore Name
     */
    public var view: String
    /**
     * Fields
     */
    public var fields: [String]?
    /**
     * Pivots
     */
    public var pivots: [String]?
    /**
     * Fill Fields
     */
    public var fill_fields: [String]?
    /**
     * Filters
     */
    public var filters: StringDictionary<AnyCodable>?
    /**
     * Filter Expression
     */
    public var filter_expression: String?
    /**
     * Sorting for the query results. Use the format `["view.field", ...]` to sort on fields in ascending order. Use the format `["view.field desc", ...]` to sort on fields in descending order. Use `["__UNSORTED__"]` (2 underscores before and after) to disable sorting entirely. Empty sorts `[]` will trigger a default sort.
     */
    public var sorts: [String]?
    /**
     * Limit
     */
    public var limit: String?
    /**
     * Column Limit
     */
    public var column_limit: String?
    /**
     * Total
     */
    public var total: Bool?
    /**
     * Raw Total
     */
    public var row_total: String?
    /**
     * Fields on which to run subtotals
     */
    public var subtotals: [String]?
    /**
     * Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A "type" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
     */
    public var vis_config: StringDictionary<AnyCodable>?
    /**
     * The filter_config represents the state of the filter UI on the explore page for a given query. When running a query via the Looker UI, this parameter takes precedence over "filters". When creating a query or modifying an existing query, "filter_config" should be set to null. Setting it to any other value could cause unexpected filtering behavior. The format should be considered opaque.
     */
    public var filter_config: StringDictionary<AnyCodable>?
    /**
     * Visible UI Sections
     */
    public var visible_ui_sections: String?
    /**
     * Dynamic Fields
     */
    public var dynamic_fields: String?
    /**
     * Client Id: used to generate shortened explore URLs. If set by client, must be a unique 22 character alphanumeric string. Otherwise one will be generated.
     */
    public var client_id: String?
    /**
     * Query Timezone
     */
    public var query_timezone: String?

    public init(model: String, view: String, fields: [String]? = nil, pivots: [String]? = nil, fill_fields: [String]? = nil, filters: StringDictionary<AnyCodable>? = nil, filter_expression: String? = nil, sorts: [String]? = nil, limit: String? = nil, column_limit: String? = nil, total: Bool? = nil, row_total: String? = nil, subtotals: [String]? = nil, vis_config: StringDictionary<AnyCodable>? = nil, filter_config: StringDictionary<AnyCodable>? = nil, visible_ui_sections: String? = nil, dynamic_fields: String? = nil, client_id: String? = nil, query_timezone: String? = nil) {
        self.model = model
        self.view = view
        self.fields = fields
        self.pivots = pivots
        self.fill_fields = fill_fields
        self.filters = filters
        self.filter_expression = filter_expression
        self.sorts = sorts
        self.limit = limit
        self.column_limit = column_limit
        self.total = total
        self.row_total = row_total
        self.subtotals = subtotals
        self.vis_config = vis_config
        self.filter_config = filter_config
        self.visible_ui_sections = visible_ui_sections
        self.dynamic_fields = dynamic_fields
        self.client_id = client_id
        self.query_timezone = query_timezone
    }

    public init(_ model: String, _ view: String, fields: [String]? = nil, pivots: [String]? = nil, fill_fields: [String]? = nil, filters: StringDictionary<AnyCodable>? = nil, filter_expression: String? = nil, sorts: [String]? = nil, limit: String? = nil, column_limit: String? = nil, total: Bool? = nil, row_total: String? = nil, subtotals: [String]? = nil, vis_config: StringDictionary<AnyCodable>? = nil, filter_config: StringDictionary<AnyCodable>? = nil, visible_ui_sections: String? = nil, dynamic_fields: String? = nil, client_id: String? = nil, query_timezone: String? = nil) {
        self.init(model: model, view: view, fields: fields, pivots: pivots, fill_fields: fill_fields, filters: filters, filter_expression: filter_expression, sorts: sorts, limit: limit, column_limit: column_limit, total: total, row_total: row_total, subtotals: subtotals, vis_config: vis_config, filter_config: filter_config, visible_ui_sections: visible_ui_sections, dynamic_fields: dynamic_fields, client_id: client_id, query_timezone: query_timezone)
    }

}

/**
 * Dynamically generated writeable type for RepositoryCredential removes properties:
 * can, id, root_project_id, remote_url, is_configured
 */
public struct WriteRepositoryCredential: SDKModel {
    /**
     * Git username for HTTPS authentication.
     */
    public var git_username: String?
    /**
     * (Write-Only) Git password for HTTPS authentication.
     */
    public var git_password: String?
    /**
     * Public deploy key for SSH authentication.
     */
    public var ssh_public_key: String?

    public init(git_username: String? = nil, git_password: String? = nil, ssh_public_key: String? = nil) {
        self.git_username = git_username
        self.git_password = git_password
        self.ssh_public_key = ssh_public_key
    }

}

/**
 * Dynamically generated writeable type for ResultMakerWithIdVisConfigAndDynamicFields removes properties:
 * id, dynamic_fields, filterables, sorts, merge_result_id, total, query_id, sql_query_id, vis_config
 */
public struct WriteResultMakerWithIdVisConfigAndDynamicFields: SDKModel {
    public var query: WriteQuery?

    public init(query: WriteQuery? = nil) {
        self.query = query
    }

}

/**
 * Dynamically generated writeable type for Role removes properties:
 * can, id, url, users_url
 */
public struct WriteRole: SDKModel {
    /**
     * Name of Role
     */
    public var name: String?
    public var permission_set: WritePermissionSet?
    /**
     * (Write-Only) Id of permission set
     */
    public var permission_set_id: Int64?
    public var model_set: WriteModelSet?
    /**
     * (Write-Only) Id of model set
     */
    public var model_set_id: Int64?

    public init(name: String? = nil, permission_set: WritePermissionSet? = nil, permission_set_id: Int64? = nil, model_set: WriteModelSet? = nil, model_set_id: Int64? = nil) {
        self.name = name
        self.permission_set = permission_set
        self.permission_set_id = permission_set_id
        self.model_set = model_set
        self.model_set_id = model_set_id
    }

}

/**
 * Dynamically generated writeable type for SamlConfig removes properties:
 * can, test_slug, modified_at, modified_by, default_new_user_roles, default_new_user_groups, groups, user_attributes, url
 */
public struct WriteSamlConfig: SDKModel {
    /**
     * Enable/Disable Saml authentication for the server
     */
    public var enabled: Bool?
    /**
     * Identity Provider Certificate (provided by IdP)
     */
    public var idp_cert: String?
    /**
     * Identity Provider Url (provided by IdP)
     */
    public var idp_url: String?
    /**
     * Identity Provider Issuer (provided by IdP)
     */
    public var idp_issuer: String?
    /**
     * Identity Provider Audience (set in IdP config). Optional in Looker. Set this only if you want Looker to validate the audience value returned by the IdP.
     */
    public var idp_audience: String?
    /**
     * Count of seconds of clock drift to allow when validating timestamps of assertions.
     */
    public var allowed_clock_drift: Int64?
    /**
     * Name of user record attributes used to indicate email address field
     */
    public var user_attribute_map_email: String?
    /**
     * Name of user record attributes used to indicate first name
     */
    public var user_attribute_map_first_name: String?
    /**
     * Name of user record attributes used to indicate last name
     */
    public var user_attribute_map_last_name: String?
    /**
     * Merge first-time saml login to existing user account by email addresses. When a user logs in for the first time via saml this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
     */
    public var new_user_migration_types: String?
    /**
     * Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
     */
    public var alternate_email_login_allowed: Bool?
    /**
     * (Write-Only) Array of ids of roles that will be applied to new users the first time they login via Saml
     */
    public var default_new_user_role_ids: [Int64]?
    /**
     * (Write-Only) Array of ids of groups that will be applied to new users the first time they login via Saml
     */
    public var default_new_user_group_ids: [Int64]?
    /**
     * Set user roles in Looker based on groups from Saml
     */
    public var set_roles_from_groups: Bool?
    /**
     * Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
     */
    public var groups_attribute: String?
    /**
     * (Read/Write) Array of mappings between Saml Groups and arrays of Looker Role ids
     */
    public var groups_with_role_ids: [SamlGroupWrite]?
    /**
     * Users will not be allowed to login at all unless a role for them is found in Saml if set to true
     */
    public var auth_requires_role: Bool?
    /**
     * (Read/Write) Array of mappings between Saml User Attributes and arrays of Looker User Attribute ids
     */
    public var user_attributes_with_ids: [SamlUserAttributeWrite]?
    /**
     * Identifier for a strategy for how Looker will find groups in the SAML response. One of ['grouped_attribute_values', 'individual_attributes']
     */
    public var groups_finder_type: String?
    /**
     * Value for group attribute used to indicate membership. Used when 'groups_finder_type' is set to 'individual_attributes'
     */
    public var groups_member_value: String?
    /**
     * Bypass the login page when user authentication is required. Redirect to IdP immediately instead.
     */
    public var bypass_login_page: Bool?
    /**
     * Allow SAML auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.
     */
    public var allow_normal_group_membership: Bool?
    /**
     * SAML auth'd users will inherit roles from non-reflected Looker groups.
     */
    public var allow_roles_from_normal_groups: Bool?
    /**
     * Allows roles to be directly assigned to SAML auth'd users.
     */
    public var allow_direct_roles: Bool?

    public init(enabled: Bool? = nil, idp_cert: String? = nil, idp_url: String? = nil, idp_issuer: String? = nil, idp_audience: String? = nil, allowed_clock_drift: Int64? = nil, user_attribute_map_email: String? = nil, user_attribute_map_first_name: String? = nil, user_attribute_map_last_name: String? = nil, new_user_migration_types: String? = nil, alternate_email_login_allowed: Bool? = nil, default_new_user_role_ids: [Int64]? = nil, default_new_user_group_ids: [Int64]? = nil, set_roles_from_groups: Bool? = nil, groups_attribute: String? = nil, groups_with_role_ids: [SamlGroupWrite]? = nil, auth_requires_role: Bool? = nil, user_attributes_with_ids: [SamlUserAttributeWrite]? = nil, groups_finder_type: String? = nil, groups_member_value: String? = nil, bypass_login_page: Bool? = nil, allow_normal_group_membership: Bool? = nil, allow_roles_from_normal_groups: Bool? = nil, allow_direct_roles: Bool? = nil) {
        self.enabled = enabled
        self.idp_cert = idp_cert
        self.idp_url = idp_url
        self.idp_issuer = idp_issuer
        self.idp_audience = idp_audience
        self.allowed_clock_drift = allowed_clock_drift
        self.user_attribute_map_email = user_attribute_map_email
        self.user_attribute_map_first_name = user_attribute_map_first_name
        self.user_attribute_map_last_name = user_attribute_map_last_name
        self.new_user_migration_types = new_user_migration_types
        self.alternate_email_login_allowed = alternate_email_login_allowed
        self.default_new_user_role_ids = default_new_user_role_ids
        self.default_new_user_group_ids = default_new_user_group_ids
        self.set_roles_from_groups = set_roles_from_groups
        self.groups_attribute = groups_attribute
        self.groups_with_role_ids = groups_with_role_ids
        self.auth_requires_role = auth_requires_role
        self.user_attributes_with_ids = user_attributes_with_ids
        self.groups_finder_type = groups_finder_type
        self.groups_member_value = groups_member_value
        self.bypass_login_page = bypass_login_page
        self.allow_normal_group_membership = allow_normal_group_membership
        self.allow_roles_from_normal_groups = allow_roles_from_normal_groups
        self.allow_direct_roles = allow_direct_roles
    }

}

/**
 * Dynamically generated writeable type for ScheduledPlan removes properties:
 * id, created_at, updated_at, title, user, next_run_at, last_run_at, can
 */
public struct WriteScheduledPlan: SDKModel {
    /**
     * Name of this scheduled plan
     */
    public var name: String?
    /**
     * User Id which owns this scheduled plan
     */
    public var user_id: Int64?
    /**
     * Whether schedule is run as recipient (only applicable for email recipients)
     */
    public var run_as_recipient: Bool?
    /**
     * Whether the ScheduledPlan is enabled
     */
    public var enabled: Bool?
    /**
     * Id of a look
     */
    public var look_id: Int64?
    /**
     * Id of a dashboard
     */
    public var dashboard_id: Int64?
    /**
     * Id of a LookML dashboard
     */
    public var lookml_dashboard_id: String?
    /**
     * Query string to run look or dashboard with
     */
    public var filters_string: String?
    /**
     * (DEPRECATED) Alias for filters_string field
     */
    public var dashboard_filters: String?
    /**
     * Delivery should occur if running the dashboard or look returns results
     */
    public var require_results: Bool?
    /**
     * Delivery should occur if the dashboard look does not return results
     */
    public var require_no_results: Bool?
    /**
     * Delivery should occur if data have changed since the last run
     */
    public var require_change: Bool?
    /**
     * Will run an unlimited query and send all results.
     */
    public var send_all_results: Bool?
    /**
     * Vixie-Style crontab specification when to run
     */
    public var crontab: String?
    /**
     * Name of a datagroup; if specified will run when datagroup triggered (can't be used with cron string)
     */
    public var datagroup: String?
    /**
     * Timezone for interpreting the specified crontab (default is Looker instance timezone)
     */
    public var timezone: String?
    /**
     * Query id
     */
    public var query_id: String?
    /**
     * Scheduled plan destinations
     */
    public var scheduled_plan_destination: [ScheduledPlanDestination]?
    /**
     * Whether the plan in question should only be run once (usually for testing)
     */
    public var run_once: Bool?
    /**
     * Whether links back to Looker should be included in this ScheduledPlan
     */
    public var include_links: Bool?
    /**
     * The size of paper the PDF should be formatted to fit. Valid values are: "letter", "legal", "tabloid", "a0", "a1", "a2", "a3", "a4", "a5".
     */
    public var pdf_paper_size: String?
    /**
     * Whether the PDF should be formatted for landscape orientation
     */
    public var pdf_landscape: Bool?
    /**
     * Whether this schedule is in an embed context or not
     */
    public var embed: Bool?
    /**
     * Color scheme of the dashboard if applicable
     */
    public var color_theme: String?
    /**
     * Whether or not to expand table vis to full length
     */
    public var long_tables: Bool?
    /**
     * The pixel width at which we render the inline table visualizations
     */
    public var inline_table_width: Int64?

    public init(name: String? = nil, user_id: Int64? = nil, run_as_recipient: Bool? = nil, enabled: Bool? = nil, look_id: Int64? = nil, dashboard_id: Int64? = nil, lookml_dashboard_id: String? = nil, filters_string: String? = nil, dashboard_filters: String? = nil, require_results: Bool? = nil, require_no_results: Bool? = nil, require_change: Bool? = nil, send_all_results: Bool? = nil, crontab: String? = nil, datagroup: String? = nil, timezone: String? = nil, query_id: String? = nil, scheduled_plan_destination: [ScheduledPlanDestination]? = nil, run_once: Bool? = nil, include_links: Bool? = nil, pdf_paper_size: String? = nil, pdf_landscape: Bool? = nil, embed: Bool? = nil, color_theme: String? = nil, long_tables: Bool? = nil, inline_table_width: Int64? = nil) {
        self.name = name
        self.user_id = user_id
        self.run_as_recipient = run_as_recipient
        self.enabled = enabled
        self.look_id = look_id
        self.dashboard_id = dashboard_id
        self.lookml_dashboard_id = lookml_dashboard_id
        self.filters_string = filters_string
        self.dashboard_filters = dashboard_filters
        self.require_results = require_results
        self.require_no_results = require_no_results
        self.require_change = require_change
        self.send_all_results = send_all_results
        self.crontab = crontab
        self.datagroup = datagroup
        self.timezone = timezone
        self.query_id = query_id
        self.scheduled_plan_destination = scheduled_plan_destination
        self.run_once = run_once
        self.include_links = include_links
        self.pdf_paper_size = pdf_paper_size
        self.pdf_landscape = pdf_landscape
        self.embed = embed
        self.color_theme = color_theme
        self.long_tables = long_tables
        self.inline_table_width = inline_table_width
    }

}

/**
 * Dynamically generated writeable type for SessionConfig removes properties:
 * can
 */
public struct WriteSessionConfig: SDKModel {
    /**
     * Allow users to have persistent sessions when they login
     */
    public var allow_persistent_sessions: Bool?
    /**
     * Number of minutes for user sessions.  Must be between 5 and 43200
     */
    public var session_minutes: Int64?
    /**
     * Allow users to have an unbounded number of concurrent sessions (otherwise, users will be limited to only one session at a time).
     */
    public var unlimited_sessions_per_user: Bool?
    /**
     * Enforce session logout for sessions that are inactive for 15 minutes.
     */
    public var use_inactivity_based_logout: Bool?
    /**
     * Track location of session when user logs in.
     */
    public var track_session_location: Bool?

    public init(allow_persistent_sessions: Bool? = nil, session_minutes: Int64? = nil, unlimited_sessions_per_user: Bool? = nil, use_inactivity_based_logout: Bool? = nil, track_session_location: Bool? = nil) {
        self.allow_persistent_sessions = allow_persistent_sessions
        self.session_minutes = session_minutes
        self.unlimited_sessions_per_user = unlimited_sessions_per_user
        self.use_inactivity_based_logout = use_inactivity_based_logout
        self.track_session_location = track_session_location
    }

}

/**
 * Dynamically generated writeable type for SshServer removes properties:
 * ssh_server_id, finger_print, sha_finger_print, public_key, status
 */
public struct WriteSshServer: SDKModel {
    /**
     * The name to identify this SSH Server
     */
    public var ssh_server_name: String?
    /**
     * The hostname or ip address of the SSH Server
     */
    public var ssh_server_host: String?
    /**
     * The port to connect to on the SSH Server
     */
    public var ssh_server_port: Int64?
    /**
     * The username used to connect to the SSH Server
     */
    public var ssh_server_user: String?

    public init(ssh_server_name: String? = nil, ssh_server_host: String? = nil, ssh_server_port: Int64? = nil, ssh_server_user: String? = nil) {
        self.ssh_server_name = ssh_server_name
        self.ssh_server_host = ssh_server_host
        self.ssh_server_port = ssh_server_port
        self.ssh_server_user = ssh_server_user
    }

}

/**
 * Dynamically generated writeable type for SshTunnel removes properties:
 * tunnel_id, ssh_server_name, ssh_server_host, ssh_server_port, ssh_server_user, last_attempt, local_host_port, status
 */
public struct WriteSshTunnel: SDKModel {
    /**
     * SSH Server ID
     */
    public var ssh_server_id: String?
    /**
     * Hostname or IP Address of the Database Server
     */
    public var database_host: String?
    /**
     * Port that the Database Server is listening on
     */
    public var database_port: Int64?

    public init(ssh_server_id: String? = nil, database_host: String? = nil, database_port: Int64? = nil) {
        self.ssh_server_id = ssh_server_id
        self.database_host = database_host
        self.database_port = database_port
    }

}

/**
 * Dynamically generated writeable type for Theme removes properties:
 * can, id
 */
public struct WriteTheme: SDKModel {
    /**
     * Timestamp for when this theme becomes active. Null=always
     */
    public var begin_at: Date?
    /**
     * Timestamp for when this theme expires. Null=never
     */
    public var end_at: Date?
    /**
     * Name of theme. Can only be alphanumeric and underscores.
     */
    public var name: String?
    public var settings: ThemeSettings?

    public init(begin_at: Date? = nil, end_at: Date? = nil, name: String? = nil, settings: ThemeSettings? = nil) {
        self.begin_at = begin_at
        self.end_at = end_at
        self.name = name
        self.settings = settings
    }

}

/**
 * Dynamically generated writeable type for User removes properties:
 * can, avatar_url, avatar_url_without_sizing, credentials_api3, credentials_embed, credentials_google, credentials_ldap, credentials_looker_openid, credentials_oidc, credentials_saml, credentials_totp, display_name, email, embed_group_space_id, group_ids, id, looker_versions, personal_folder_id, presumed_looker_employee, role_ids, sessions, verified_looker_employee, roles_externally_managed, allow_direct_roles, allow_normal_group_membership, allow_roles_from_normal_groups, url
 */
public struct WriteUser: SDKModel {
    public var credentials_email: WriteCredentialsEmail?
    /**
     * First name
     */
    public var first_name: String?
    /**
     * ID string for user's home folder
     */
    public var home_folder_id: String?
    /**
     * Account has been disabled
     */
    public var is_disabled: Bool?
    /**
     * Last name
     */
    public var last_name: String?
    /**
     * User's preferred locale. User locale takes precedence over Looker's system-wide default locale. Locale determines language of display strings and date and numeric formatting in API responses. Locale string must be a 2 letter language code or a combination of language code and region code: 'en' or 'en-US', for example.
     */
    public var locale: String?
    /**
     * User's dev workspace has been checked for presence of applicable production projects
     */
    public var models_dir_validated: Bool?
    /**
     * Per user dictionary of undocumented state information owned by the Looker UI.
     */
    public var ui_state: StringDictionary<AnyCodable>?

    public init(credentials_email: WriteCredentialsEmail? = nil, first_name: String? = nil, home_folder_id: String? = nil, is_disabled: Bool? = nil, last_name: String? = nil, locale: String? = nil, models_dir_validated: Bool? = nil, ui_state: StringDictionary<AnyCodable>? = nil) {
        self.credentials_email = credentials_email
        self.first_name = first_name
        self.home_folder_id = home_folder_id
        self.is_disabled = is_disabled
        self.last_name = last_name
        self.locale = locale
        self.models_dir_validated = models_dir_validated
        self.ui_state = ui_state
    }

}

/**
 * Dynamically generated writeable type for UserAttribute removes properties:
 * can, id, is_system, is_permanent
 */
public struct WriteUserAttribute: SDKModel {
    /**
     * Name of user attribute
     */
    public var name: String?
    /**
     * Human-friendly label for user attribute
     */
    public var label: String?
    /**
     * Type of user attribute ("string", "number", "datetime", "yesno", "zipcode")
     */
    public var type: String?
    /**
     * Default value for when no value is set on the user
     */
    public var default_value: String?
    /**
     * If true, users will not be able to view values of this attribute
     */
    public var value_is_hidden: Bool?
    /**
     * Non-admin users can see the values of their attributes and use them in filters
     */
    public var user_can_view: Bool?
    /**
     * Users can change the value of this attribute for themselves
     */
    public var user_can_edit: Bool?
    /**
     * Destinations to which a hidden attribute may be sent. Once set, cannot be edited.
     */
    public var hidden_value_domain_whitelist: String?

    public init(name: String? = nil, label: String? = nil, type: String? = nil, default_value: String? = nil, value_is_hidden: Bool? = nil, user_can_view: Bool? = nil, user_can_edit: Bool? = nil, hidden_value_domain_whitelist: String? = nil) {
        self.name = name
        self.label = label
        self.type = type
        self.default_value = default_value
        self.value_is_hidden = value_is_hidden
        self.user_can_view = user_can_view
        self.user_can_edit = user_can_edit
        self.hidden_value_domain_whitelist = hidden_value_domain_whitelist
    }

}

/**
 * Dynamically generated writeable type for UserAttributeWithValue removes properties:
 * can, name, label, rank, user_id, user_can_edit, value_is_hidden, user_attribute_id, source, hidden_value_domain_whitelist
 */
public struct WriteUserAttributeWithValue: SDKModel {
    /**
     * Value of attribute for user
     */
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

}

/**
 * Dynamically generated writeable type for WhitelabelConfiguration removes properties:
 * can, id, logo_url, favicon_url
 */
public struct WriteWhitelabelConfiguration: SDKModel {
    /**
     * Customer logo image. Expected base64 encoded data (write-only)
     */
    public var logo_file: String?
    /**
     * Custom favicon image. Expected base64 encoded data (write-only)
     */
    public var favicon_file: String?
    /**
     * Default page title
     */
    public var default_title: String?
    /**
     * Boolean to toggle showing help menus
     */
    public var show_help_menu: Bool?
    /**
     * Boolean to toggle showing docs
     */
    public var show_docs: Bool?
    /**
     * Boolean to toggle showing email subscription options.
     */
    public var show_email_sub_options: Bool?
    /**
     * Boolean to toggle mentions of Looker in emails
     */
    public var allow_looker_mentions: Bool?
    /**
     * Boolean to toggle links to Looker in emails
     */
    public var allow_looker_links: Bool?
    /**
     * Allow subject line and email heading customization in customized emails”
     */
    public var custom_welcome_email_advanced: Bool?
    /**
     * Remove the word Looker from appearing in the account setup page
     */
    public var setup_mentions: Bool?
    /**
     * Remove Looker logo from Alerts
     */
    public var alerts_logo: Bool?
    /**
     * Remove Looker links from Alerts
     */
    public var alerts_links: Bool?
    /**
     * Remove Looker mentions in home folder page when you don’t have any items saved
     */
    public var folders_mentions: Bool?

    public init(logo_file: String? = nil, favicon_file: String? = nil, default_title: String? = nil, show_help_menu: Bool? = nil, show_docs: Bool? = nil, show_email_sub_options: Bool? = nil, allow_looker_mentions: Bool? = nil, allow_looker_links: Bool? = nil, custom_welcome_email_advanced: Bool? = nil, setup_mentions: Bool? = nil, alerts_logo: Bool? = nil, alerts_links: Bool? = nil, folders_mentions: Bool? = nil) {
        self.logo_file = logo_file
        self.favicon_file = favicon_file
        self.default_title = default_title
        self.show_help_menu = show_help_menu
        self.show_docs = show_docs
        self.show_email_sub_options = show_email_sub_options
        self.allow_looker_mentions = allow_looker_mentions
        self.allow_looker_links = allow_looker_links
        self.custom_welcome_email_advanced = custom_welcome_email_advanced
        self.setup_mentions = setup_mentions
        self.alerts_logo = alerts_logo
        self.alerts_links = alerts_links
        self.folders_mentions = folders_mentions
    }

}

